export const propertiesForNewPages = [{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#game #ea #embark作为EA的CDO（首席设计官，Chief design officer）在DICE/EA为游戏奉献了十八个年头，现在创建了新公司Embark，打算尝试点新东西。Embark宣布将用Rust构建他们的技术。相关新闻https://www.theverge.com/2018/11/8/18073992/patrick-soderlund-new-studio-embark-nexon推文https://twitter.com/repi/status/1060469377500274689"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-10 13:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"前EA首席设计官成立的新独立游戏工作室Embark宣布使用Rust为主要语言"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#conduitBuoyant的软件工程师Carl分享了在Conduit开发过程中利用Rust零成本抽象开发下一代网络基础平台。infoq 视频https://www.infoq.com/presentations/rust-infrastructure"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-10 13:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「演讲」使用Rust构建下一代网络基础设施"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#game #rougelikeRoguelike是电子角色扮演游戏（RPG游戏）的一个子类。标志性特征有：在随机生成的地牢中探索、回合制、基于图块的图像（tile-based graphics）以及角色的永久死亡。rusted-ruinshttps://github.com/garkimasera/rusted-ruins"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-10 13:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust + SDL实现的rougelike沙盒游戏"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#cargo #sweepcargo-sweephttps://github.com/holmgr/cargo-sweep"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-10 13:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」清理cargo或rustc产生的构建垃圾"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#activitypub #blog_engine #blog #plume #rocket #diesel #Aardwolf #federatedplume是基于rocket和diesel实现。Plumehttps://github.com/Plume-org/PlumeDemohttps://baptiste.gelez.xyz/相似的项目有: Aardwolfhttps://github.com/Aardwolf-Social/aardwolf"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-10 13:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Plume:又一个基于ActivityPub协议开发的社区联盟博客系统"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#ttv #cli #train #ml #rust2018ttv是一个命令行工具，用于将大型文件拆分为适合于机器学习的训练/测试/验证拆分的块。基于Rust 2018版本。ttvhttps://github.com/sd2k/ttv每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-10 13:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「机器学习」使用Rust在命令行构建训练数据"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"修补了一些bugRead Morehttps://blog.rust-lang.org/2018/11/08/Rust-1.30.1.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-09 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 1.30.1 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"秘猿计划每个月的Dev Meetup第一场都会开设Rust专题B站视频前面几分钟无声音，后面有了 B站 https://www.bilibili.com/video/av35546990/ 油管视频声音比较完整 https://www.youtube.com/watch?reload=9&v=s7gFNTb3rWU&feature=youtu.be"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-09 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「录播视频」11-07晚上杭州秘猿Rust开发分享会"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tide #middlewareTide 初始版本已经开始动工，大约1000行代码实现了一个基本的框架雏形。目前还存在很多问题，不过「骨架」已经到位了，剩下的就是社区的努力一起为其填充「血肉」。在这个初始版本里，加入了一个简单的中间件设计和计算值。一、中间件中间件的设计直接来自于actix-web ：当然，具体的trait方法和actix-web略有不同（tide里用request替代了actix-web的start），但基本的思想是一致的。 详细可参考actix-web中间件的文档.在未来FutureObj将会换成Box，这样可以避免复杂的类型跟踪，虽然可能有性能开销，但预计成本会极低，这个已经在actix-web中得到了证明。虽然受actix-web极大的启发，但目前没有加入finish方法，原因是目前基于hyper当前的API很难实现finish（在响应结束后调用该方法）。目前团队还在想办法。中间件写好以后，可以通过以下方式方便加到应用中：之后还会支持更细粒度的中间件应用，比如，仅将其应用于特定的子路由。二、计算值计算值（Computed values） 就像一个算术公式一样去从现有的状态或其他值去计算出需要的值。虽然中间件很灵活，但对于某些情况来说，比较重。Tide的一个新的概念就是计算值。这些值是可以根据请求生成的值。例如，经常要根据URL的query部分生成组件，在endpoint或其他中间件中可能使用该组件。可以通过计算值来处理这种解析，而非实现中间件。简单的示例：tidehttps://github.com/rust-net-web/tideactix-web中间件https://rustlang-cn.github.io/server/actix-web/middleare.htmlRead Morehttps://rust-lang-nursery.github.io/wg-net/2018/11/07/tide-middleware.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-09 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Tide 中间件"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#optional_args本文记录了作者使用Rust实现可选参数的一步步思路，也是对Rust设计API的思考。P.S 这还是一个PingCAP隐藏的招聘贴呢。Read Morehttps://hoverbear.org/2018/11/04/optional-arguments/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-09 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust实现可选参数"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#job #remote丹麦的一家正规公司：impero，目前正在招募Rust全栈工程师。可远程。Read Morehttps://www.reddit.com/r/rust/comments/9v7qpx/rust_fullstack_developer_denmark_or_remote/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-09 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Job」来自丹麦的召唤：Rust全栈工程师"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#Vulkanvulkano是对Vulkan API的安全包装vulkanohttps://github.com/vulkano-rs/vulkanoRead Morehttps://www.patreon.com/posts/22587417"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-09 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"vulkano 0.11 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者在移植一个高性能C++库，用于在字符串和数字之间进行转换。发现Rust解析浮点数的性能很慢。解析32位浮点数比解析64位整数慢约100倍，比解析32位整数慢约150倍。更为明显的是，解析64位浮点数比解析64位整数慢约450倍，比解析32位整数慢约650倍。感兴趣可以看看讨论。Read Morehttps://www.reddit.com/r/rust/comments/9vdsyl/rust_float_parsing_is_atypically_slow/每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-09 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「讨论」Rust解析浮点数很慢"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者来自于Python社区，通常他学习一门新的语言只需要一周左右的时间，毕竟都是一些常规的概念：赋值、数据结构、循环、分支、OOP等，没有什么特殊的。直到他遇到Rust，一下学了两个月还在懵逼中。他现在开始刷exercism里的题，并列出了其中值得注意的练习。Read more https://cslai.coolsilon.com/2018/11/06/learning-a-new-language-for-more-than-2-months-feat-exercism/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-08 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」花费了两个多月去学习一门新语言"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#monotron #microcontrollerMonotron是基于TM4C123单片机和ARM Cortex-M4内核的一款DIY 8位家用小电脑，作者在RustBelt大会上展示了让它来跑snake小游戏。 并且可以使用C和Rust来为其编写应用。Monotronhttps://github.com/thejpster/monotronRead Morehttps://railwayelectronics.blogspot.com/2018/11/monotron-at-rust-belt-rust.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-08 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「嵌入式」Monotron在Rust Belt上的展示"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#mundane #google #boringssl #cryptoBoringSSL 是由谷歌从 OpenSSL 中抽出来后独立发展的作品。mundanehttps://github.com/google/mundane"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-08 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Mundane : 基于BoringSSL的Rust加密库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#pinissues-55766https://github.com/rust-lang/rust/issues/55766每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-08 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」Pin API即将在1.32版本中稳定"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#network #driverPDFhttps://www.net.in.tum.de/fileadmin/bibtex/publications/theses/2018-ixy-rust.pdf"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-07 12:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用Rust编写网络驱动程序"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#suricata #IPS #IDS #NSMSuricata是一个网络实时入侵检测(IDS)、嵌入式入侵防御(IPS)和网络安全监控(NSM)的引擎。本来是C语言实现的，现在4.1版本中引入的新协议支持是基于Rust构建。也就是说:Suricata 4.1 is not really 4.1 if you don’t have Rust.Read Morehttps://suricata-ids.org/2018/11/06/suricata-4-1-released/suricatahttps://github.com/OISF/suricata"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-07 12:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Suricata 4.1 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"rustdoc-katex-demohttps://github.com/paulkernfeld/rustdoc-katex-demo"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-07 12:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」让rust doc可以渲染KaTeX"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"remyhttps://github.com/mcandre/remy"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-07 12:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」remy： 配合docker快速为多target环境匹配不同的工具链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#parity #zcash新的Zcash节点将使用Rust编写，并成为Zcash公司自zcashed之后的第一个可选客户端。zcashed是Zcash唯一可用的完整节点。Read Morehttps://www.parity.io/parity-teams-up-with-zcash-foundation-for-parity-zcash-client/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-07 12:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Parity与Zcash 基金会合作"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#config此次版本更接近于生产环境，不仅仅是实验性configure_mehttps://github.com/Kixunil/configure_meRead Morehttps://www.reddit.com/r/rust/comments/9umfln/announcing_release_of_version_03_of_configure_me/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-07 12:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「库」configure_me 0.3发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#hex #colorful #cli彩色输出不同类别的字节hexylhttps://github.com/sharkdp/hexyl"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-07 12:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」hexyl 命令行16进制查看器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#du  #diskusdiskushttps://github.com/sharkdp/diskus"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-07 12:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」Linux du -sh命令替代工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#postgis #martin #vector_tiles #mapboxmartin是基于rust和actix-web实现的PostGIS矢量切片服务器。主要是基于mapbox格式做矢量切片，一般用于地图服务。PostGIS 是 PostgreSQL 的空间数据库扩展。考察了一下该库背后的公司Urbica，是一家来自莫斯科的数据分析及可视化公司。他们最新开发的产品AReal，是一款 iOS 平台上的增强现实 App，通过 3D 的方式展示了圣彼得堡的地图和地标建筑，包括了七座杰出建筑在地图上用星标标记。但是展示方式可能与大家想象的有所不同——不再是低下头在屏幕上看，而是举起手机把建筑“搭建”到你眼前！只要点击任何一座建筑，你就可以通过 AR 模块将建筑融入你所处的环境，并通过缩放、旋转等操作来探索。一句话描述： Urbica公司是做AR地图的。据说苹果公司也正在筹备做AR地图产品。Urbica介绍来源https://zhuanlan.zhihu.com/p/43656372martinhttps://github.com/urbica/martin"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-07 12:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」martin： PostGIS矢量切片（ vector tiles）服务器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#xray #atomxray是Atom团队使用Rust和Electron实现的下一代文本编辑器。今天看了下其代码仓库，发现还是在持续地更新。在2018第三个季度，团队主要聚焦于memo子项目。memo是xray的基础，它是一个版本控制系统，也可以作为独立库使用。memo是想作为Git的扩展，使用无冲突的复制数据类型（CRDT）记录工作副本，用于增强Git的实时协作功能。其技术栈也用到了WebAssembly，用于公开虚拟文件系统的API。在memo稳定以后，会将其从xray独立出来，然后会继续进行xray的开发。将xray作为一个以memo为基础的一流的可实时协作的编辑器。牛逼了memohttps://github.com/atom/xray/tree/master/memo_corexrayhttps://github.com/atom/xray###「项目」rust-analyzer：给IDE使用的Rust实验性模块化编译器前端#rust_analyzer #compiler_frontend旨在为优秀的IDE支持奠定基础rust-analyzerhttps://github.com/rust-analyzer/rust-analyzer"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-07 12:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"xray有什么进展？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#liveusb #alma #archlinux该工具可以帮助定制Arch Linux的USB启动驱动器，通过UEFI来引导系统启动。almahttps://github.com/r-darwish/alma每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-07 12:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」alma：帮助创建基于USB启动的Arch Linux"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#nll本篇文章是对Niko之前博文的增补。其中按时间线罗列了针对NLL性能提升的各个PR。这些PR主要是提升了编译器基于NLL做静态借用检查的性能。Read Morehttps://blog.mozilla.org/nnethercote/2018/11/06/how-to-speed-up-the-rust-compiler-in-2018-nll-edition/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-06 14:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」如何在2018年加速Rust编译器：NLL edition"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#api_design该文作者在2017年的Rust Fest大会做了分享，直到昨天，他才把演讲内容更新成了文稿。演讲视频https://www.youtube.com/watch?v=3Q2hQfYW-XM&index=9&list=PL85XCvVPmGQj9mqbJizw-zi-EhcpS5jTP（ 我在《Rust编程之道》一书的设计模式 - RAII模式 里也借鉴了他的这次演讲内容 ）Read Morehttps://blog.systems.ethz.ch/blog/2018/a-hammer-you-can-only-hold-by-the-handle.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-06 14:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」利用Rust所有权语义来构造有约束的API"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#fp #higher_order_function该文使用一个二维数组的示例，探究了Rust中纯函数式编程，主要是高阶函数的应用。Playgroundhttps://play.integer32.com/?version=stable&mode=debug&edition=2015&gist=8639706958a3b51389474b328331d9d8Read Morehttps://dev.to/deciduously/higher-order-functions-in-rust-287h"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-06 14:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」Rust中的高阶函数"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#pythoner一个Pythoner写的文章，他在学习Rust的时候，所有权move语义和作用域的概念给他带来了新的思考。Read Morehttps://boakye.yiadom.org/rust/new/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-06 14:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」Rust：一种新的思维方式"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#proc_macro_attribute #proc_macro #no_panicserde/syn 作者dtolnay的新库：no-panic。 提供了一个属性宏，通过编译器来保证函数不会发生panic。比如：如果该demo函数发生panic（或编译器无法检验函数不能panic），则该函数会编译失败，并且错误信息中会携带包含该函数名称标识的链接器错误信息。注意：通过看该库的源码发现：\nRust的proc_macro_attribute功能也移出了#![feature(custom_attribute)]特性，意味着，也要准备稳定了\n现在稳定的proc_macro功能，不能用作表达式，除非使用#![feature(proc_macro_hygiene)]特性。相关issues \nno-panichttps://github.com/dtolnay/no-panic每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-06 14:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「库」no-panic ：通过一个属性宏让编译器检验函数不会发生panic"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://phaazon.net/blog/on-owning-borrowing-pub-interface假如你有一个结构体：然后为其实现一个new方法：这个new方法，接收的参数是具有移动语义的String字符串。这个API是让客户端（调用方）来分配字符串，或者是move别人分配的字符串。当传入字符串字面量的时候，会编译错误。这里 \"Patrick Bateman\"是 &'static str 类型的字符串字面量，而不是String类型。如何修复上面代码？但这样并不理想。尝试以下方案：这样实现，下面的调用是可以编译了：但是，又不能使用String的字符串了。为此，只能传入x的引用才行：上面可以编译是因为String实现了Deref<Target = str>。还有另外一个比较好的技巧就是使用AsRef trait。&str和String都实现了AsRef<str>。然而这里依旧存在问题，如果在调用Person::new之后还需要使用x，这代码是没问题的。但是在调用之后不再使用x，那这里就是浪费了一次move，而又重新分配一次（to_owned）。一个完美的API，最好是在需要clone的时候就clone，需要move的时候move。另外一个解决方案是ToOwned + Cow看得出来Cow可以持有借用或者所有权，并且提供了into_owned方法。所以我们的代码可以修改为：所以，当为new方法传递String的时候，就会move。传递&str的时候，则是clone。就像这样：对于此API，调用者可以选择使用独占类型还是借用。但是Cow::into_owned因为使用了match匹配，所以会存在一点点运行时开销。当然，也可以直接使用Into来简化此方案：显然，这里有一些缺点：\nInto<String>无法表达任何生命周期。如果需要动态检查需要clone还是move，则使用Cow<str>。\n如果明确地知道此处不需要move，则继续使用Into<String>。\n有些类型可能没有实现Into<String>。\n结论：本文主要想强调&_, AsRef<_>, Cow<_>, Into<_> 都有不同的语义，在用它们编写公开API的时候，满足不同的契约。\n&T 意味着，不需要客户端（调用方）move或者clone。只进行只读计算。\n\n不需要客户端拥有T。\n客户端不必要担心会有内存分配。\n强迫使用引用，会传达更多的信息，比如切片类型，这就要求数据的连续性。\n\n\nQ: AsRef<T>，意味着，你打算执行只读计算（只读契约），或者，在需要独占类型的时候，也不需要客户端来提供。但记住，这里有个隐藏属性：因为你在只读契约上接受一个被move的值（比如前例中的String），所以你也要接受该值必然会被drop（之后无法使用）。\nCow<T>，使用它，表明客户端可以选择使用独占（拥有所有权）或借用。但它是在运行时来选择是否需要独占。\nQ: Into<T>，当你确定此处需要独占类型（拥有所有权）时候，可以使用它们。\nQ: IntoIterator<Item = T>， 使用该限定，可以直接使用Vec<_>这种类型，而不是使用迭代器。\n\n不需要客户端拥有T。\n客户端不必要担心会有内存分配。\n强迫使用引用，会传达更多的信息，比如切片类型，这就要求数据的连续性。\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-05 21:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"探讨所有权和借用语义对API接口设计的影响"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#ndarray #either #puzzlendarray-csv的作者第三次重构该库的时候碰到一个问题。他想实现一个函数：然后用于处理像下面这种迭代器中的Result作者经过三次失败的flatten_nested_results函数实现，首先找出的解决方案是使用trait object。但他还不喜欢这个方案，最终他使用了either库来解决此问题Read Morehttps://paulkernfeld.com/2018/11/03/flatten-nested-iterator-result.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-05 21:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust谜题：让内嵌于迭代中的Result扁平化"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#travis #ci #kcov #codecov本文讲述了如何使用Travis CI 的workspace测试Nightly项目，并且使用kcov和codecov收集测试覆盖率。Read Morehttps://baptiste.gelez.xyz/%7E/Rust/rust-nightly-travis-ci-and-code-coverage/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-05 21:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」Rust Nightly，Travis CI和代码覆盖率"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#orion  #cryptoorion 纯Rust加密的另一种尝试\n禁止 unsafe\n提供高级抽象，关注可用性\n不是要替代Ring或RustCrypto这样的库\n现在不适合用于生产\n新版本新增了 XChaCha20Poly1305等算法支持Read Morehttps://www.reddit.com/r/rust/comments/9u6d5w/orion_09_released_support_for_xchacha20poly1305/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-05 21:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」orion 0.9发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#wasm #snakerust-snake-wasmhttps://github.com/yiransheng/rust-snake-wasm"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-05 21:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小游戏」Rust和WASM实现的贪食蛇"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#passgen #passwordpassgen-rshttps://gitlab.com/NateDogg1232/passgen-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-05 21:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」Rust实现的密码生成工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#pest #serde #json5基于pest和serdejson5-rshttps://github.com/callum-oakley/json5-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-05 21:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」JSON5的序列化和反序列化工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#s3 #s3_concats3-concathttps://github.com/whitfin/s3-concatRead Morehttps://whitfin.io/quickly-concatenating-files-in-amazon-s3/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-05 21:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」s3-concat: 使用Rust快速合并S3文件"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#lazy_static #no_std该版本主要是让lazy_static可以在no_std下使用。Read Morehttps://www.reddit.com/r/rust/comments/9u8u6h/psa_lazy_static_120_requires_rustc_1241_or_higher/每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-05 21:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"lazy_static发布1.2.0版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字：[debian]本周新增的CPU架构为：\nmips\nmips64el\nmipsel\npowerpcspe\nRead Morehttps://lists.debian.org/debian-devel-announce/2018/11/msg00000.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-03 14:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」Rust编译器现在已支持14个debian架构"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#oj #kattis  #codewars  #leetcode #code_challenge顺便统计一下国内外支持Rust的OJ平台。\nCodewars （支持）\nCodinGame （支持）\nCodeSignal （支持）\ncodechef（支持）\nexercism.io （支持）\natcoder.jp（支持）\n—\nLeetCode（正在开发Rust支持）\nhackerrank （不支持）\ncoderbyte （目前不支持Rust）\ngeeksforgeeks （不支持）\n欢迎补充Read Morehttps://open.kattis.com/help/rust"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-03 14:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「oj平台」Kattis现在支持Rust了"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust2018 #uniform #anchor #use #path该文是官方团队成员withoutblogs所写。锚定（Anchored）和统一（Uniform）路径，是当前Rust 2018中还存在的两种模块路径引入变体支持。但是官方计划在12月正式发布Rust 2018的时候只保留一种变体。在Rust 2018版本中：\n可以直接使用crate:: 命名空间来访问当前crate中的模块，而不是在顶层根目录下use。\n使用第三方包的时候不需要使用 extern crate 语句\n你可以在代码的任意地方像使用crate::命名空间这样去访问第三方包，而不再需要“::”前缀。比如，不再需要impl ::std::fmt::Debug，而只需要写impl std::fmt::Debug\n锚定（Anchored）和统一（Uniform）路径区别：\n锚定路径： 如果从子模块中导入，则需要写  self::submodule::。\n统一路径：从子模块导入，可以直接 use submodule:: 。\n统一路径中，子模块如果和第三方依赖有相同的名称，则需要使用use ::foo 来消除歧义。\n统一路径的优势是可以避免混淆，更加符合直觉。\n锚定路径的优势： 可以消除模块来自于哪里的歧义。它们有专门的命名空间：crate、super和self。\n经过官方团队的内部会议之后，该文作者认为以后应该走统一路径的方向。\n统一路径优势很大，将为新用户消除self::这样的障碍。\n虽然名称冲突可能发生，但情况比较稀有。使用use :: 这种方式，比使用use self要好的多。\n官方会在未来3周内对此问题做出决定。即，withoutboats建议，在1.31版本中，只保留统一路径。Read Morehttps://boats.gitlab.io/blog/post/anchored-uniform/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-03 14:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Rust 2018」 Anchored and Uniform Paths"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#default_value #smart_defaultsmart-defaulthttps://github.com/idanarye/rust-smart-default"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-03 14:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」smart-default 0.3发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#dutree #filesystemdutreehttps://github.com/nachoparker/dutree"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-03 14:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 用Rust实现的分析文件系统的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#Ethereum #zkSNARKS当前为POC项目。zkSNARKS是一种零知识证明算法，以太坊据说要应用这种技术来提升以太坊的性能。Buterin 估计，ZK-SNARK 的整合和采用能够使以太坊每秒处理高达500笔交易，而目前的上限约为15笔。ZoKrateshttps://github.com/Zokrates/ZoKrates每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-03 14:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」ZoKrates: 以太坊的zkSNARKS工具箱"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [nll, niko]niko在思考Rust所有权未来进展，首先打算列出了当前所有权和借用系统的各种限制。本文着重于阐述第一个限制：函数间冲突。问题：经常会有一个包含很多字段的大结构体，并非所有字段都被所有方法使用到。假如有一个increment方法，用来在每次发生事件的时候计数，并且给listener发送消息。当我们同时使用MyStruct的某些其他字段时，尝试调用此方法就会出现问题。假设我们现在要检查widget，这个过程可能会产生计数事件。可惜，这段代码会产生编译错误：错误消息试图在告诉你：\n循环中正在借用self.widgets\n然后，访问self.signal_event，而signal_event有可能改变当前正在迭代的widget。\n虽然开发者知道这里不会修改到widget的widget字段，但是编译器不知道。如果解决？就是把signal_event方法再搬过来。但是现在已经违反了DRY（Don't repeat yourself）原则。如何改进？提取一个独立的结构体EventSignal，并为其实现signal_event方法。然后修改MyStruct：完整代码https://play.rust-lang.org/?version=beta&mode=debug&edition=2018&gist=6512551bf58cd66917895a588f3643dc将大的结构体分解为小结构体，有时候可能会使代码更加清晰。但也有问题。比如会使代码变得冗长，以及这种方法有时候也不那么凑效。比如MyStruct中有可能出现一个方法，既使用count又使用widget。另外一种解决方案是使用自由函数。比如将signal_event函数变为独立函数，而不是方法，就可以避免使用&mut self。但这种方法有点极端。也可以定义一种视图结构来解决问题，但同样是比较极端的方案：这里的魔法是，CheckWidgetsView已经把调用所需要的借用包含了。所以在check_widgets的时候，不会相互影响。实际上，经常出现此类问题的地方是闭包。因为闭包是要捕获变量。上面的闭包signal_event虽然指定了具体的字段，但依旧会捕获整个self。现在Rust已经接受了RFC 2229来解决这个问题。https://github.com/rust-lang/rfcs/pull/2229需要扩展语言本身来解决此问题，但当前还在讨论中。可以关注这个讨论贴：After NLL – what’s next for borrowing and lifetimes?https://users.rust-lang.org/t/blog-post-series-after-nll-whats-next-for-borrowing-and-lifetimes/21864Read Morehttp://smallcultfollowing.com/babysteps/blog/2018/11/01/after-nll-interprocedural-conflicts/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-02 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」NLL之后：函数间冲突"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [convinced, use rust]Rust核心团队成员Ashley Williams（@ag_bubs），同时也是crates.io、Rust社区的团队领导，WebAssembly工作组的成员分享了这篇主题。「视频地址：」How I Convinced the World's Largest Package Manager to Use Rust, and So Can You!https://www.youtube.com/watch?v=GCsxYAxw3JQPPThttps://ashleygwilliams.github.io/gotober-2018/#1"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-02 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Slides」禅与说服贵公司使用Rust的艺术"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [cita-cli, async, tokio, future]本文是来自 @driftluo 的投稿。他在使用全异步开发cita-cli过程遇到了自引用的问题，但他是在稳定版Rust下开发，使用的还是futures 0.1，为了解决这个问题，他给出了一个自己的思路。Read Morehttps://www.driftluo.com/article/19d035a0-f467-4f9d-a8d4-9c7096f7044d"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-02 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」Cita-cli工具开发中的异步经验谈"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [rustsim, alga, nalgebra, algebra]Rustsim组织是一个GitHub组织，聚焦于提供各种数值模拟的库。包括\nalga， 抽象代数库\nnalgebra， 线性代数库\nncollide， 2D和3D的碰撞检测库\nnphysics， 2D和3D的物理模拟库\nrustsim.orghttps://rustsim.org/今年最后的两个月，在改进ncollide和nalgebra，以便支持可变性物体的物理模拟。并且新增了两个crate：nalgebra-glm和nphysics-ecs。其中nphysics-ecs是打算让开发者方便将物理系统集成到ECS应用程序中。还将改进文档。Read Morehttps://www.rustsim.org/blog/2018/11/01/this-month-in-rustsim/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-02 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「rustsim」最后两月动态月刊#1"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [Shifgrethor, GC]本文阐述了Shifgrethor如何跟踪对象，识别该对象是否存活。定义Trace trait跟踪算法原理：从根（root）开始，访问它引用的每个GC对象，并标记该对象为活跃对象，这样垃圾收集器就不会回收它。该算法基于访问者模式。这是Rust社区普遍使用的模式，比如serde就是访问者模式。（插一句，《Rust编程之道》里也专门介绍了该模式）所以，GC如果想跟踪某些对象，这些对象就必须实现Trace。实现Trace问题不大，但是证明GC对象是否被正确的追踪才是问题。Proving rootedness将这种保证跟踪是否正确的验证称为Proving rootedness。Shifgrethor的解决方案是引入新的类型GcStore。GcStore是一种没有实现Deref的gc指针。上面代码会生成一个名为bar的方法，其函数签名为 Gc<'root, Foo<'_>> -> Gc<'root, Bar>，这是为了获得GC中某些内容的引用，必须始终证明是在该引用的生命周期内对其生根（rooted）Read Morehttps://boats.gitlab.io/blog/post/shifgrethor-iv/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-02 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「研究项目」「系列文章」 Shifgrethor IV： 跟踪"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [custom, error]custom_errorhttps://github.com/lovasoa/custom_error"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-02 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」custom_error: 提供了方便自定义Error的宏"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [trust-dns, dns]Read Morehttps://users.rust-lang.org/t/trust-dns-resolver-0-10-and-client-server-0-15-released/21851?u=bluejekyll"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-02 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Trust-DNS Resolver 0.10和Client / Server 0.15已发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [websocket, cli]websocat是一个命令行websocket客户端websocathttps://github.com/vi/websocat每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-02 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」websocat发布1.2.0版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Read Morehttps://zhuanlan.zhihu.com/p/48200804"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-01 12:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「杂谈」异常处理 vs 错误处理"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字：[nll, mir, borrowck, 2018]现在Rust 2018的crate已经默认是使用NLL了。在2018 测试版本稳定之后，官方也准备将NLL加到Rust 2015中。NLL的目的是提升Rust的使用体验。也就是说，开发者只需要按自己的直觉去写代码，而不需要做一些特殊的行为来取悦借用检查器。极大降低了Rust的学习曲线。Nll的诊断信息也得到了很大的提升，比之前的借用检查器更好，开发者可以看到更详细的错误提示信息。虽然NLL现在还有一些轻微的开销，但是性能基本已经不再成为实践的阻碍了。当前NLL运行在迁移模式下，也就是说，对于一些不遵循NLL的老代码，会报出警告信息。这只是一个过渡，假以时日，这些警告会变成硬性的错误。Rust所有权和借用检查的未来如何？还有一些小问题需要修复，以及应对未来人们开发过程中的新问题，并且还要加紧发布相关的文档。继续改进Polonius。等等Read Morehttp://smallcultfollowing.com/babysteps/blog/2018/10/31/mir-based-borrowck-is-almost-here/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-01 12:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」基于MIR的借用检查NLL已登陆Rust 2018"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [onefetch, cli, info]可展示language, author, license 等等onefetchhttps://github.com/o2sh/onefetch"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-01 12:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」onefetch: 可以在终端展示项目的信息"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字：[xorc, kafka, apns, fcm,push]该项目是来自于生产环境实践的开源项目，从kafka topic读取protocol buffer的数据并将推送通知发送到apns2，fcm和web-push三个平台，也可以用来发送普通的http请求。xorc-notificationshttps://github.com/xray-tech/xorc-notifications"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-01 12:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」xorc-notifications：用于发送推送通知的Kafka Consumer"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [amethyst, rfc]rfcshttps://github.com/amethyst/rfcs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-01 12:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」amethyst开源游戏引擎创建了RFC仓库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [rocket, web]正式版将于11月9号发布，到时候作者会写一篇完整介绍V0.4最大特色和变化的文章。Read Morehttps://rocket.rs/v0.4/news/2018-10-31-version-0.4-rc/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-01 12:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Web框架」Rocket v0.4 发布了候选版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [salsa, incrementalized-computation]Rust团队核心成员Niko又开了新坑，莎莎（salsa），是一个通用的增量计算框架。然后我又看到Cargo的贡献者Yehuda创建了一个新库：salsa-examples，我在猜测，Yehuda是不是想在salsa的基础上实现一个新的ORM框架呢？https://github.com/wycats/salsa-examplessalsahttps://github.com/salsa-rs/salsa每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-01 12:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」salsa：通用增量计算框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字:  [php, FFI, beyond]Read Morehttps://mnt.io/2018/10/29/from-rust-to-beyond-the-php-galaxy/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-31 12:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「From Rust to beyond系列」 Rust与PHP交互"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [pyro, ecs, specs]Pyro是一个快速的、小型的、带文档的ECS。特点：\n完全线性的迭代\n组件中的组合始终存在于同一存储中\n目前还仅支持单线程（作者说未来会加多线程支持）\n不要用于生产环境，该库主要是用于教育的目的\npyrohttps://github.com/MaikKlein/pyroRead More https://www.reddit.com/r/rust/comments/9srhuc/pyro_a_fast_small_and_documented_entity_component/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-31 12:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Pyro: 一个轻巧的ECS"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"$ rustup install betaRead More https://blog.rust-lang.org/2018/10/30/help-test-rust-2018.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-31 12:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」来帮助测试Rust 2018"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [aws, lambda, events]aws_lambda_events 提供了AWS Lambda事件类型，以便与AWS Lambda事件源一起使用。aws_lambda_eventshttps://github.com/srijs/rust-aws-lambda/tree/master/aws_lambda_events"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-31 12:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」aws_lambda_events 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [acct, unix]accthttps://github.com/jabedude/acct"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-31 12:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」acct：Unix中acct函数的Rust实现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [pbrt, render, raytracing]rs_pbrt是对《Physically Based Rendering,PBRT(光线跟踪：基于物理的渲染) 》这本书中代码的Rust实现。Read Morehttps://users.rust-lang.org/t/rs-pbrt-v0-4-4-adds-support-for-nurbs-and-subdivision-surfaces/21801rs_pbrthttps://github.com/wahn/rs_pbrtwww.pbrt.orghttps://www.pbrt.org/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-31 12:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」rs_pbrt发布0.4版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [ Embedded ]简要：一、 好消息：终于可以用Rust Stable开发嵌入式程序了。因为#[panic_handler]登录了Rust 1.30稳定版，这就意味着可以用Stable Rust写Cortex-M的裸机程序了。cortex-m, cortex-m-rt 和 embedded-hal这几个库都可以用于Stable了。但要注意在Discovery 和 The Embedded Rust Book这两本书中的代码还必须在1.30 beta或1.31 beta或最新Nightly版本中使用，因为它们用了2018 Edition版本。\nDiscovery\n嵌入式之书（The Embedded Rust Book）\n二、嵌入式工作组已经启动了一个Cortex-A团队，专注于为ARM-Cortex-A系列微处理器的裸机程序开发提供支持。三、为了解决多个设备连接到同一个外设的问题，@Rahix开发了shared-bushttps://github.com/Rahix/shared-bus四、嵌入式社区有了蓬勃的发展。工作组也从最初的8个人，增加到了现在的27名开发人员（分散在11个团队中，每个团队都在嵌入式开发中有自己的擅长领域）现在是开始用Rust进行嵌入式开发的最好时机。Read Morehttps://rust-embedded.github.io/blog/2018-10-28-newsletter-14/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-31 12:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」嵌入式工作组报告 14"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [hashbrown, swisstable, hashmap, hashset, map]该库是parking_lot作者开发的新库， 基于SwissTable算法实现了HashMap和HashSet。Rust标准库的HashMap和HashSet基于RobinHood散列，hashbrown基于SwissTable散列。SwissTable整体性能要优于Robinhood，尤其是在搜索上面：hashbrownhttps://github.com/Amanieu/hashbrownreddit讨论贴https://www.reddit.com/r/rust/comments/9sn4ze/github_amanieuhashbrown_a_faster_hashmap_for_rust/算法原理讲解视频: 《CppCon 2017: Matt Kulukundis “Designing a Fast, Efficient, Cache-friendly Hash Table, Step by Step”》https://www.youtube.com/watch?v=ncHmEUmJZf4每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-31 12:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「算法库」hashbrown：基于Google SwissTable哈希算法实现的Map"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者对其应用的下一个版本进行负载测试，使用wrk工具发送请求几秒之后，后端内存占用了1.3GB，内存占用的增长速度大约每秒50MB。初步调试：开始使用heaptrack工具，发现内存只分配了8KB，问题出在了heaptrack工具和jemalloc并不搭，所以换用Rust的system分配器。这样就可以用heaptrack来检测到内存泄漏了。然而还是没有得到什么有用的信息。改变策略：有一个办法，可以通过逐步删除部分程序来确定内存泄漏的位置。那么有没有这样一个工具来代替开发者手工完成？C-Reduce行不行？可惜的是，他们发现C-Reduce无法支持Rust。所以只能想办法徒手实现了一个最小版本的应用示例。https://embed.cs.utah.edu/creduce/最终发现，是在转换错误类型的时候调用into_future()的时候发生了泄漏。然后他们使用cargo-geiger工具，去发现导致这次泄漏的unsafe代码。https://github.com/anderejd/cargo-geiger最终他们定位到了问题所在：是failure库里的downcast方法使用了mem::forget。这就导致了Error::downcast并没有把Box<Inner<Fail>>给drop掉，而仅仅是drop了backtrace。之前有一个PR补丁修复了此泄漏漏洞 failure-pr-262，https://github.com/rust-lang-nursery/failure/pull/262但是在Rust 1.18之前的版本还存在泄漏问题，可见作者用的还是老版本。因此，他的同事给Failure提交了一个PR，修复此问题，现在已经被合并到failure中。 Read  More https://blog.1aim.com/2018/10/finding-and-fixing-memory-leaks-in-a-hyper-application-or-how-i-learned-to-stop-worrying-and-love-the-allocator/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-30 11:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」查找并修复Hyper应用中的内存泄漏"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字：[embedded, database, concurrent, b-tree, zero-copy]sled是一款Rust实现的现代化嵌入式数据库新的版本更加可靠，且实现了零Copy读取，Rust的所有权模型让引用安全地返回给缓存而无需防御性的拷贝。sledhttps://github.com/spacejam/sled"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-30 11:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」sled 发布 0.16版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [azul, gui, imgui, webrender, mvvm]支持用Rust编写桌面软件，基于Mozilla WebRender渲染引擎。目前还在完善中，期望特点（也就是说，当前这些功能并非全部支持）：\n跨平台\nIMGUI （Immediate Mode GUI ）/ MVVM 编程模型\n基于Dom的无状态组件\nCSS风格的样式引擎，支持多种通用CSS属性\n基于Flexbox的布局\n内置标准控件\n自定义widgets\nSVG渲染引擎，2D绘图助手 (lines, circles, rects, etc.)\nOpenGL集成\nAsync I/O\n可选的集成日志和错误报告辅助\n独立二进制部署，最小二进制大小（5MB）\nCPU使用率（0-4%），内存使用率（总共约50MB）\n快速重绘时间（0.5~4ms），包括了高效的状态缓存\nazul.rshttps://azul.rs/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-30 11:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「GUI框架」Azul：面向IMGUI的免费功能性GUI框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [Gotham, async, web-framwork, tokio, hyper]特点：\n基于新的tokio库\n采用hyper 0.12和新的http库\n内部路由算法改进\n自定义Gotham使用tokio运行时\n通过tokio-fs提供异步静态文件\n更多性能和可用性改进\nRead Morehttps://gotham.rs/blog/release/2018/10/29/gotham-0.3.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-30 11:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「异步Web框架」Gotham 0.3发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [RESSA, ECMAScript, JavaScript, parse]该项目是用于把js文本解析为基于ESTREE的ASTRESSAhttps://github.com/FreeMasen/RESSA"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-30 11:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」RESSA：Rusty ECMAScript语法分析器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [actix-web, microservice, diesel, auth]前文索引https://hgill.io/posts/auth-microservice-rust-actix-web-diesel-complete-tutorial-part-1/Read Morehttps://hgill.io/posts/auth-microservice-rust-actix-web-diesel-complete-tutorial-part-2/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-30 11:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Web框架」使用actix-web制作一个验证用户身份的微服务 Part 2"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [Qt, cargo]目的是想让Qt的安装和运行更加简单Read Morehttps://www.vandenoever.info/blog/2018/10/30/building_qt_apps_with_cargo.html每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-30 11:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」如何使用Cargo构建Qt应用"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [volkswagen, ci, auto pass]比如这个测试，会失败。但是volkswagen会根据失败的结果，生成一个新的测试，让其通过。目测，用这个工具的时候最好确定你真的需要它来自动生成测试，否则可能引起问题volkswagenhttps://github.com/lukaslueg/volkswagen「附带八卦」该作者起volkswagen这个名字，可能另有深意啊。大众汽车「排放门」，2015年9月18日，美国环境保护署指控大众汽车所售部分柴油车安装了专门应对尾气排放检测的软件，可以识别汽车是否处于被检测状态，继而在车检时秘密启动，从而使汽车能够在车检时以“高环保标准”过关，而在平时行驶时，这些汽车却大量排放污染物，最大可达美国法定标准的40倍。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-29 13:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」volkswagen: 检测测试何时在CI中执行并且让其通过"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [fd, release, checklist]该文是fd库的作者总结出来的release清单，可以给社区提供一个借鉴。按以下顺序做发布检查，非常重要：一、  检查和更新依赖。\n检查deps.rs是否有过期的依赖\n运行cargo update去更新最新的兼容（minor）版本的依赖性\n如果需要，可以手动更新到最新的主（major）版本\n对于主版本更新还需要查看上游更改，仔细评估是否真的需要更新为新版本。二、获取自上次发布以来的更新列表通过 GitHub -> Release -> \"XX commits to master since this release\"   就能获取此更新列表。示例https://github.com/sharkdp/fd/compare/v7.1.0...master三、更新文档\n检查并更新 -h和—help文本\n更新Readme（程序的用法、新功能介绍、最低要求的Rust版本）\n更新man页面\n四、在本地安装主分支并且测试新功能\n使用cargo install -f来安装\n手动测试新功能\n运行基准测试避免性能回退\n理想情况下，为新的功能编写了测试，并且也使用了CI，是没有什么可担心的了。但实际上，总有一些事需要手工审查。尤其是对终端环境依赖的CLI项目更是需要如此。五、清理代码库。\n运行 cargo clippy  并查看修改建议 [可选]\n运行 cargo fmt自动格式化代码\n运行 cargo text 确保所有测试通过\n最后两步通常包含在CI中。六、更新版本信息\n在Cargo.toml中更新项目版本\n运行cargo build更新Cargo.lock\n在项目仓库中搜索旧的版本号将其更新为新版本（比如在Readme、安装说明、构建脚本中等等）\n七、使用Dry run模拟发布cargo publish --dry-run --allow-dirty通过这次模拟来发现上传包到crates.io中的问题，提前检查修改八、Commit、Push并等待CI成功九、写release notes。十、 为最新的提交打上tag，并且开始部署。git tag vX.Y.Z; git push --tags十一、在GitHub上创建实际的发布版本。十二、验证部署。确保已经上传了所有的二进制文件。十三、发布到crates.io。cargo publish十四、通知软件包维护者有关的更新信息。Read Morehttps://dev.to/sharkdp/my-release-checklist-for-rust-programs-1m33"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-29 13:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」我的Rust程序发布checklist"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [2D, GPU, gfx]该篇文章在gfx-hal基础上构思了一个2D图形库的一些底层实现细节。他讨论的这些内容并非2D图形API，而是基础的组件，在此组件上面可以实现各种渲染技术，并且该组件将独立于这些渲染技术。 Read More https://nical.github.io/posts/rust-2d-graphics-02.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-29 13:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」 2D图形Rust开发：了解GPU内存管理"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [xcp, cp]提供进度条和.gitignore支持xcphttps://crates.io/crates/xcp"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-29 13:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」xcp：扩展cp命令"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [ci, template, travis, cargo]cargo-template-cihttps://github.com/antifuchs/cargo-template-ci"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-29 13:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」cargo-template-ci：自动生成travis.yml"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [roughtime, time-sync]该工具是基于Google的Roughtime协议的Rust实现，包含了客户端和服务端。可以用来做时间同步验证。比如区块链矿工可以用它来验证自己的时间早于其他矿工。新版本中支持KMS、HTTP运行状况检查和服务器模糊测试Read Morehttps://www.reddit.com/r/rust/comments/9s51tp/roughenough_110_released_with_kms_support_an_http/roughenoughhttps://github.com/int08h/roughenough"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-29 13:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」Roughenough 1.1.0 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字： [slotmap, Generational, Index ]该库是在Rust 2018 Conf闭幕演讲中介绍的，基于 Generational Index模式实现的库。https://kyren.github.io/2018/09/14/rustconf-talk.html新功能：\n可以自定义Key的类型\nSecondaryMap，运行slotmap中的key和任意数据关联\nRead Morehttps://www.reddit.com/r/rust/comments/9s0hbk/slotmap_03_released_support_for_custom_key_types/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-29 13:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「库」slotmap 0.3 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关键字: [bytecount, stdsimd, simd, byte, count]该库可以快速计算内存中给定字节或UTF8字符串出现的次数新版本中支持了新的更快的算法，基于stdsimd。bytecounthttps://github.com/llogiq/bytecount每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-29 13:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「库」bytecount 0.4 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"还没有提交问卷的小伙伴，来填写一下问卷。回头会把统计结果给大家分享，目前的统计结果很有意思，但是样本有点少，需要大家的配合。到时候把结果放出来，大家也可以对国内的Rust社区有一个了解。 来填问卷喽 https://wj.qq.com/s/2801182/f890"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-27 12:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Rust每日新闻」调查问卷"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"—  使用Rust将解析日志的速度提高了230倍该文章是《The Ruby Way》的作者André Arko写的，同时他也是Ruby包管理器Bunlder的No.1贡献者，以及Rubygems.org的维护者。https://github.com/indirect所以，他在维护Rubygems.org的过程中，遇到最让他头疼的事情就是对日志的处理。Rubygems每秒有4000到25000个请求，磁盘每天可以产生500GiB的日志。他们尝试了一些日志的托管产品，但是这些产品也只能为他们保留1个小时以内的日志数据。大概一年前，他把完整的日志进行了压缩，放到了s3上面，存储成本大概是每个月3.5美刀。但是有很多他感兴趣的统计数据被「埋葬」在了S3上面。因为S3的gzipped JSON流很难查询数据。这些统计数据有利于提供Ruby生态系统状态的重要信息。后来利用aws的Glue功能，可以运行基于spark脚本的hadoop集群，他写了一个统计脚本，但是费用上升到了每月1000刀。后来，也不知道是什么原因，让他想到了Rust。事实证明，Rust满足了他的需求。 Serde Json库，让他可以在2秒内将1GB的JSON反序列化为Rust数据类型。并且使用nom来解析日志，可以在3分钟内解析1GB的日志文件，作者说，用Python和Glue在30分钟内解析完日志，他就觉得了不起了。但是作者又仔细阅读了nom的文档，发现了一句「有时候，nom几乎和regex一样快」，这句话给了他灵感，他又用regex重写了解析代码，性能又提高了3倍。至少比spark中使用python解析快30倍。但是他把这个Rust程序的性能又多牛逼的事情告诉 @ReinH （他的朋友，Rust的贡献者之一，比他更了解Rust）的时候，ReinH说，怎么这么慢？你这个程序必须得优化。他不清楚他的朋友是不是跟他开玩笑，但是他继续对Rust进行研究，然后他发现了—release模式，在使用release模式编译代码之后，突然发现：他可以在8秒内把1GB的文件解析完。以下是处理速度的一个对比记录：~525 records/second/cpu in Python on AWS Glue50,534 records/second/cpu in Rust with nom121,153 records/second/cpu in Rust with regex + release但他没满足，继续使用rayon对程序并行化处理日志，最终的程序，在8核机器上快了100倍，在单核上跑，快230倍。现在的1GB的日志文件处理需要6.4s。151,441 records/second/cpu in Rust with regex + release+ rayon最后如何部署是个问题。他尝试了一些方案之后，最后发现了aws Lambda，它有一个免费策略：每个月400,000s。而作者处理500GB日志，只需要3000多s。于是他就快乐地使用了aws Lambda功能。源码 : kirbyhttps://github.com/rubytogether/kirbyRead Morehttps://andre.arko.net/2018/10/25/parsing-logs-230x-faster-with-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-27 12:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」一个使用Rust节约成本的故事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"灵感来自于React和Elm。使用了虚拟Dom。dracohttps://github.com/utkarshkukreti/draco"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-27 12:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Rust前端框架」Draco：利用Rust和Wasm编写前端代码"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Emacs 党可以看看Read Morehttps://boinkor.net/2018/10/editing-rustdoc-comments-in-emacs/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-27 12:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一个在emacs中编辑rustdoc注释的好方法"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Read Morehttps://www.reddit.com/r/rust/comments/9rp856/pfmt_a_string_formatting_library_goes_040/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-27 12:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」字符串格式化库pfmt 发布0.4版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Playgroundhttps://play.rust-lang.org/?version=nightly&mode=debug&edition=2015&gist=69e4701b5ea779a294609e13c40c1a70Read Morehttps://www.reddit.com/r/rust/comments/9rotq7/proof_of_concept_monadic_io_in_rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-27 12:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Mondadic IO的Rust证明"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是想Java化吗？（逃Read Morehttps://internals.rust-lang.org/t/pre-rfc-domains-as-namespaces/8688"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-27 12:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「pre-RFC」域名作为命名空间"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"更具体来说，该文涉及：\nwasm\nazure Functions\n遗传算法\n快速解决复杂的优化问题\n前文「使用 rust+wasm提升Azure’s FaaS 性能的可能性」链接https://t.me/rust_daily_news/640Read More https://blog.x5ff.xyz/blog/azure-functions-wasm-rust-ai/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-27 12:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「系列文章 Rust on Azure Functions Part 4」使用Rust和Wasm提升JavaScript 10倍速"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该会议主要是讨论接下来Rust编译器的发展方向，制定public roadmap、编译器文档、社区如何参与等问题。Read Morehttps://internals.rust-lang.org/t/compiler-steering-committee-meeting/8588/16?u=nikomatsakis每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-27 12:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」举办了第一次编译器「 筹划指导委员会」会议"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"还没有提交问卷的小伙伴，来填写一下问卷。回头会把统计结果给大家分享，目前的统计结果很有意思，但是样本有点少，需要大家的配合。到时候把结果放出来，大家也可以对国内的Rust社区有一个了解。 来填问卷喽 https://wj.qq.com/s/2801182/f890"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-26 22:20"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Rust每日新闻」调查问卷"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一大片Rust 2018 edtion功能登陆了stable。简要：\nProcedural Macros 新的过程宏功能发布。之前的过程宏只能写派生属性，在1.30稳定版里，过程宏也可以写像函数一样可以调用的宏了，也可以把它叫Bang（因为感叹号）宏（Rust源码里也用Bang来区分）。\n从第三方导入宏，无需使用#[macro_use]属性了，而是直接使用use\n模块系统改进：引入第三方库的现在不需要使用\"::\"前缀了，库名可以直接作为前缀。而\"::\"则代表模块相对路径的外层路径。同时，增加了crate关键字，代表当前包的根路径。\nr#原生标识符， 可以使用r#前缀，将关键字作为函数名来使用。这个语法的意义在于，使用FFI的时候，可以使用和Rust关键字、保留字重名的函数。\n可以使用no_std来构建应用程序了。之前只能构建库，因为#[panic_handler]属性已经稳定，可以用它来处理运行时panic了。\n＃[used]属性稳定，用来阻止编译器优化静态变量。\n更多详细Read Morehttps://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-26 22:20"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」Rust 1.30 稳定版发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Atom 1.32发布，携带了新的Tree-sitter解析系统，用来改进语法的高亮显示和代码折叠功能。并且Atom 1.33 Beta版将内置对Rust编程语言的支持。 Read More http://blog.atom.io/2018/10/23/atom-1-32.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-26 22:20"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」大家还记得Atom吗？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"cargo的子命令，可以方便开发者使用cargo配合其他工具，比如gbd、rr等执行buildcargo-withhttps://github.com/cbourjau/cargo-with"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-26 22:20"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」cargo-with"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"85000行代码，一共分了48个crate，而且大多数crate还是包含了测试的可执行文件。现在这些可执行文件的总大小正以平方递增，目前有4.2G可执行文件。现在这些可执行文件严重拖累了Gitlab CI，因为它们必须在构建和测试阶段通过网络进行复制。作者现在不知道该如何处理这个问题？可以关注下reddit讨论贴，看看后续。reddit讨论贴https://www.reddit.com/r/rust/comments/9rb4fq/problems_scaling_a_large_multicrate_rust_project/e8fngcd/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-26 22:20"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「讨论」大型Rust项目的可扩展问题"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者在Docker上使用Rust，但是他的Dockerfile文件是这样配置的：所以当他每次修改代码以后，重新构建docker，都需要重新下载依赖包，时间会占用很久。所以他想找一个办法解决这个问题。他考察了Docker的构建原理，这里使用COPY，是告诉docker，整个my_build_dir如果有任何变化，请复制数据。Docker是分层缓存，COPY以后已经算是新的目录了，之前缓存的已经无效。所以build的时候必须重新下载一遍依赖。但是作者需要的只是在Cargo.toml文件修改之后再重新构建。所以他对Dockerfile文件做了一些更改：然后在crate根目录创建一个dummy.rs文件，里面只包含下面代码：仅此而已，它只是为了让Docker构建一遍，得到第三方crate依赖的缓存，而不是构建正式代码。魔法主要是由sed命令来激活的，该命令先用dummy.rs替换main.rs掉，把依赖编译完，在继续用此命令，把正式的main.rs或lib.rs替换回来，然后再复制src中的其他文件。通过这样的构建，就可以让Docker缓存那些第三方库的依赖了，除非是Cargo.toml文件发生变化。群友指出，可以使用cargo fetch命令来下载依赖，代替dummy.rs这种方式。Read Morehttps://mgattozzi.com/caching-rust-docker-builds/每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-26 22:20"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"缓存Docker build"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"还没有提交问卷的小伙伴，来填写一下问卷。回头会把统计结果给大家分享，目前的统计结果很有意思，但是样本有点少，需要大家的配合。到时候把结果放出来，大家也可以对国内的Rust社区有一个了解。 来填问卷喽 https://wj.qq.com/s/2801182/f890"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-25 11:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Rust每日新闻」调查问卷"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该工具实现了一些宏，包装了Rust的一些构建命令，让开发者可以自定义自己的构建工具tinyrickhttps://github.com/mcandre/tinyrick"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-25 11:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」tinyrick：形式比较自由的Rust build工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"此程序可以自动充分利用所有代理，VPN和接口。构建于网络层，可以自动让应用层选择每一个连接的代理。reflowhttps://github.com/net-reflow/reflowRead more Reddithttps://www.reddit.com/r/rust/comments/9qvn97/reflow_a_systemlevel_proxy_switcher_a_routing/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-25 11:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」Reflow：统一代理规则"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该文作者对Haskell、Scala、Rust和TypeScript四种语言提供的代数数据类型（ADT）进行了对比。结论：\n作者认为Haskell 的最简单\nRust的次之，几乎和Haskell一样简单\nScala 排第三\nTypeScript最后，虽然比较冗长，但还是朝着简洁类型系统迈出了一大步\nRead Morehttps://blog.softwaremill.com/algebraic-data-types-in-four-languages-858788043d4e"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-25 11:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」四种语言中的代数数据类型"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该作者在学习Rust的第一个主要项目是Halite II 机器人，它是Two Sigma的AI编程竞赛的升级。广义上讲，它是一个游戏，在连续的二维地图上控制船队，寻路，并在舰与舰之间对战，资源管理等等，这些都有时间限制。后来作者参加MIT的Battlecode 2018，对方的机器人引擎是Rust实现的，而作者的是用Python，所以作者的机器人总是不断的超时。后来作者也切换到了Rust解决了这个问题。截止到今天，Halite III发布了，是一个资源管理游戏，支持Rust语言，大家可以去玩玩，用Rust打排名赛，截止到明年1月份。Read More https://www.reddit.com/r/rust/comments/9r48v3/rust_battlecode_and_halite_a_beginners_experience/ halite.io https://halite.io/Halite III代码仓库中可以找到Rust支持套件https://github.com/HaliteChallenge/Halite-III/blob/master/starter_kits/Rust/src/main.rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-25 11:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust，Battlecode和Halite：初学者对AI编程竞赛的体验"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本文是Shifgrethor GC的第三篇，withoutboats讲述了该GC标记算法中如何标记根对象。前两篇内容索引：\nI\nII\n精确跟踪GC一般有两种rooting策略：\n栈映射。编译器生成栈的元数据，来记录栈帧中GC指针的位置。GC按此元数据通过遍历栈来标识所有活动对象的根。\n运行时收集。运行时维护所有活动对象的root集合。遵循此模式的大多数Rust实现都使用了侵入式双向链表。\n栈映射通常被认为是最一流的办法，但是Rust遇到了一些问题。首先，栈映射需要语言自身支持，用库无法实现。其次，栈映射只能映射到栈，而不是堆。所以shifgrethor最初的实现是利用了Pin API实现了一个侵入式双向链表。因为root指针不能被移动。本文主要描述了该设计遇到Rust借用检查器，产生的一些问题，以及他如何解决。将来也许可能增加新的语法来支持这个。后面会写文章专门讨论这个想法。下一篇文章将讲述如何通过root跟踪GC堆的对象。 Read More https://boats.gitlab.io/blog/post/shifgrethor-iii/「博文」Rust学习心得该文作者是《Ruby原理剖析》原作者Pat写的。他现在也开始学习Rust，尝试用Rust改写之前的Ruby脚本，然后在这个过程中有一些心得，通过该文进行记录。感兴趣的可以看看Read Morehttp://patshaughnessy.net/2018/10/24/summer-school-with-the-rust-compiler每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-25 11:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「研究项目」「系列文章」Shifgrethor III: Rooting"},"type":"text"}],"type":"title"}},]
