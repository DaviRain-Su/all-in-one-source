export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cargo now has native support for the cargo add command (from the cargo-edit crate)!https://www.reddit.com/r/rust/comments/u6qrbd/cargo_now_has_native_support_for_the_cargo_add/cargo现已支持原生cargo add命令，避免了从 crates.io 手动查找信息的需要，然后将其编辑为Cargo.toml。以下是使用原生cargo add功能的一些例子：https://crates.io更多细节可以参见这篇书写规范的PR；https://github.com/rust-lang/cargo/pull/10472在官方原生支持cargo add命令之前，社区实现版本的cargo-edit的cargo add子命令提供类似的功能，cargo-edit提供的其他子命令包括：https://github.com/killercup/cargo-edit期待cargo能够早日实现类似于cargo-edit的其他原生子命令！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-19 15:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cargo现已支持原生cargo add命令" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "A Performance Evaluation on Rust Asynchronous Frameworkshttps://zenoh.io/blog/2022-04-14-rust-async-eval/Zenoh （发音：/zeno/）是一个基于async_std的异步零开销发布/订阅、存储/查询和计算框架，Zenoh是用Rust编写的，它利用异步特性来实现高性能和可扩展性；https://zenoh.io/在这篇博客中，Zenoh官方评估了三个异步框架(async_std/Tokio/smol)在异步网络上的性能。对每一种方法进行评估，并与Rust标准库提供的等效同步原语提供的基线性能进行比较。https://async.rs/评估显示，async_std和smol非常接近标准库，并且在某些工作负载上优于标准库。另一方面，Tokio似乎很快就达到了它的极限，即100 msg/s时达到18µs，并且TCP和UDP之间没有差异。此外，Tokio似乎受到CPU限制（Rust）异步任务的不利影响。基于这些结果，Zenoh认为他们别无选择，只能继续使用async_std。也就是说，了解Tokio为什么会在比较中暴露这种行为，并改善其原始性能以缩小与async_std的差距，这将是一件有趣的事。目前，Tokio在本地主机上增加了8µs延迟，在网络上增加了10µs延迟。作者坦言，理想情况下，他们希望看到一个异步框架成为“标准”，但要做到这一点，不能忽视原始性能。他们也期待着与社区其他人接触并共同努力，帮助实现这一目标。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-19 15:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust异步框架的性能评估" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rewriting sysctl(8) in Rust: systeroidhttps://blog.orhun.dev/rewriting-sysctl-in-rust/sysctl命令用于运行时配置内核参数，这些参数位于/proc/sys目录下。systeroid是“打了激素的sysctl”。与sysctl类似，它是使用procfs实现的，主要目标是管理内核参数。它有一系列特性，可以简化读取和修改值的过程，甚至可以从正式的Linux内核文档中检索有关这些值的信息。它还有一个基于文本的用户界面，用于可视化内核参数的状态，并以交互方式执行这些管理操作。https://en.wikipedia.org/wiki/ProcfsRust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-19 15:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "systeroid: 用Rust重写sysctl(8)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者认为目前的孤儿规则是安全的,但是过于严格. 随着 Rust 的发展, 作者认为是时候需要对 孤儿规则 进行一定的弱化,并且提出了自己的一些想法.原文链接http://smallcultfollowing.com/babysteps/blog/2022/04/17/coherence-and-crate-level-where-clauses/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-18 20:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "对孤儿规则等的重新思考" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "create-rust-app 可以让你使用一个命令快速创建一个 rust + react 的web app.github地址https://github.com/Wulf/create-rust-app" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-18 20:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "create-rust-app: 添加对 actix-web 和 poem 的支持" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cornucopia 是一个基于 tokio-postgres 的小型命令行工具, 可以将你的PostgreSQL` 查询按需转换为正确的类型检查的 Rust 代码。github地址https://github.com/LouisGariepy/cornucopia" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-18 20:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cornucopia: 从 PostgreSQL 中生成 Rust 代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rustea是 go 包 Tea 的 Rust 实现. 基于 Elm架构, 具有简单易用的特点.github 地址https://github.com/lazops/rustea--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-18 20:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustea: 简单易用的 TUI" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "随着 bevy 新版本的更新，作者做了一个快速上手的视频，方便那些没有时间阅读的人提供迁移指南，或者只是想通过视频的形式来了解。更多请看：https://www.reddit.com/r/rust/comments/u4uhdd/bevy_06_to_07_migration_guide/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/u4uhdd/bevy_06_to_07_migration_guide/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-18 00:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy 0.6 到 0.7 迁移指南" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "通过运行一个命令，建立一个rust+react 的 web 应用，项目地址：https://github.com/Wulf/create-rust-app" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Wulf/create-rust-app" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-18 00:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一键生成 rust+react 的 web 应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Ferium 是一个易于使用的脚手架程序，用于从 Modrinth、CurseForge 和 GitHub Releases 下载和更新 Minecraft（我的世界）模式。只需通过脚手架指定你使用的模式，只需一个命令，你就可以下载你配置的所有模式。项目地址：https://github.com/theRookieCoder/ferium" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/theRookieCoder/ferium" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-18 00:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Ferium 3.20.1版本更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "DidYouMean（或dym）是一个用rust语言编写的命令行拼写纠正器。DidYouMean 适用于那些你知道一个词听起来像什么，但你不太确定它是如何拼写的时刻。项目地址：https://github.com/hisbaan/didyoumeanhttps://github.com/Jancd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/hisbaan/didyoumean" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-18 00:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "DidYouMean 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "写给那些不知道的人，Bevy是一个令人耳目一新的简单数据驱动引擎，使用rust构建。你可以查看快速入门指南以开始使用。Bevy也是永远免费和开源的。您可以在Github上获取完整的源码，查看Bevy Assets以获取社区开发的插件、游戏和学习资源的集合。要将现有的 Bevy 应用程序或插件更新到 Bevy 0.7，请查看我们的 0.6 到 0.7 迁移指南。与往常一样，此版本中有大量新功能、错误修复和质量调整，但这里有一些亮点：\n骨骼动画和网格蒙皮\nGLTF动画导入\n...\nGithub 链接，https://github.com/bevyengine/bevy文章链接，https://bevyengine.org/news/bevy-0-7/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://bevyengine.org/news/bevy-0-7/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-16 22:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy 0.7" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "sysctl(8) 是类 Unix 操作系统上的实用程序，用于读取和修改内核的属性，例如版本号和安全设置。 systeroid 是“steroids上的 sysctl”。它可以做 sysctl 所做的一切，甚至更多。它提供了一个更安全、性能更高且用户友好的 CLI/TUI，用于在运行时管理内核参数。Github 链接，https://github.com/orhun/systeroid文章链接，https://www.reddit.com/r/rust/comments/u4tu4m/introducing_systeroid_a_more_powerful_alternative/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/u4tu4m/introducing_systeroid_a_more_powerful_alternative/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-16 22:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "systeroid：一个更强大的 sysctl(8) 替代方案" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Hello，Rustacean！我是 Rust 编程语言的新手，所以我决定使用 tauri 创建一个应用程序！Tauri是什么？你们可能已经知道了，tauri 是一个允许你使用 rust 和 web 前端编写桌面应用程序的工具。Request 是用于 api 开发的小工具。您可以使用 Web 界面测试您的 API，甚至可以为您的请求生成代码。很简单，对吧？Github 链接，https://github.com/aiocat/request文章链接，https://www.reddit.com/r/rust/comments/u4liwx/my_first_desktop_application_using_tauri_request/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/u4liwx/my_first_desktop_application_using_tauri_request/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-16 22:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Request：我的第一个用Tauri开发的桌面程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "导引：Python 得益于丰富的生态库，是科学计算以及大数据处理首选的编程语言，但是受限于 GIL 导致的多线程执行问题使得并发处理大量数据时性能相对迟缓。但 Rust FFI 的互操作性使得改良数据处理库的性能很方便。今天日报就给大家带来两款基于 Rust 后端并提供 Python API 的数据处理库：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-15 23:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "类似 pandas 的数据框架库，提供强大的表达式、IO功能以及惰性框架（LazyFrame）。惰性框架可以构建查询后通过后端执行计划优化再进行查询，配合流式IO可以极大地提高数据处理的效率。\n官网：https://www.pola.rs/\n手册：https://pola-rs.github.io/polars-book/user-guide/\n仓库：https://github.com/pola-rs/polars/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-15 23:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "polars 闪电般快速的数据框架库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "DataPrep.EDA 使用 Python编写的、最快与最简单的探索式数据分析工具，让你能够仅使用几行代码即可快速处理理解 Pandas/Dask DataFrame。提供大量工具函数（DataPrep.Clean) 以及强大的数据库连接器（DataPrep.Connector）\n官网：https://dataprep.ai/\n仓库：https://github.com/sfu-db/dataprep\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-15 23:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "dataprep 探索式数据分析工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "为了构建一个网络应用，你需要在一系列的主题中做出架构决定。Ruby on Rails或Django的优点在于它们为你做出了这些决定，所以你可以直接开始构建你的网络应用。他们还用优秀的文档来支持这些决定。Rust on Nails是一个利用现有解决方案的框架，可以满足全栈开发的需要。我们研究每一个需要做出的决定，然后拉来解决方案，并将所有东西打包，使其能够一起工作。这是一个有主见的框架，这也是Cloak的建立方式，请看Cloak Github Repo。https://github.com/purton-tech/cloakBlog: https://cloak.software/blog/rust-on-nails/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://cloak.software/blog/rust-on-nails/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-14 20:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "To铁锈 - 使用Rust开发web全栈应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "高阶虚拟机（High-order Virtual Machine, HVM）是一个纯函数式编译目标，它是惰性的、无GC的和深度并行化的。它也是β-最优的，也就是说，在一些情况下，它可以比大多数函数式运行时（包括Haskell的GHC）快出指数级。这是由于一种新的计算模型，即交互网，它结合了图灵机和兰姆达微积分。这个模型以前的实现在实践中是低效的，然而，最近的一个突破极大地提高了其效率，诞生了HVM。尽管只是一个原型，它已经在许多情况下击败了成熟的编译器，并将朝着未知的性能水平扩展。欢迎来到不可阻挡的计算机并行化、功能化的未来!Github: https://github.com/Kindelia/HVM" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Kindelia/HVM" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-14 20:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Hvm - 使用Rust开发的深度并行化和优化的函数式运行时" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 438: https://this-week-in-rust.org/blog/2022/04/13/this-week-in-rust-438/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/04/13/this-week-in-rust-438/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-14 20:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 438" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ReadMore:https://blog.sekun.dev/posts/create-static-binaries-and-docker-images-with-nix/#problem-3-static-assets" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.sekun.dev/posts/create-static-binaries-and-docker-images-with-nix/#problem-3-static-assets" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-13 23:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Nix 创建静态 Rust 二进制文件和 Docker 映像" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Minty 是一款出色的文件重复数据删除应用程序。Minty 使用 parrellism 进行快速安全的重复数据删除搜索。该应用程序读取每个文件的内容，然后将内容与其他内容进行比较，从而实现真正可靠的应用程序。ReadMore:https://crates.io/crates/minty" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/minty" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-13 23:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "minty - 一款出色的文件重复数据删除应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n改进格式；\n将代码移动到单独的函数中；\n重新排序代码；\n重命名；\n添加断言以明确不变量；\n改进和简化类型；\n提高一致性；\n删除冗余数据；\nReadMore:https://nnethercote.github.io/2022/04/12/how-to-speed-up-the-rust-compiler-in-april-2022.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://nnethercote.github.io/2022/04/12/how-to-speed-up-the-rust-compiler-in-april-2022.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-13 23:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何加速Rust编译器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "《Rust 编码规范》现在已发布 1.0 beta版，欢迎各大公司或开源团队参考应用，并期待反馈。目前只是中文版，英文版即将启动，对中译英感兴趣的小伙伴可以联系张汉东老师，同时欢迎在 github issues 中留下你们公司的应用反馈https://github.com/Rust-Coding-Guidelines/rust-coding-guidelines-zh/issues/107书籍主页https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/overview.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-12 16:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《Rust 编码规范》发布 1.0 beta" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "chumsky 是一个用于上下文无关语法的解析器库，其设计符合人体工程学，同时也很强大。在众多解析器库中，它对于解析过程中的错误消息处理尤为突出。https://github.com/zesterer/chumsky官方同时提供了一个介绍性教程，您可以在一小时内快速学习，最后可以获得一门简洁的玩具编程语言。教程 github 链接https://github.com/zesterer/chumsky/blob/master/tutorial.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-12 16:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 chumsky 快速实现语法解析器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 目前在游戏开发领域也是持续发力，来看看 Rust GameDev 工作组对于 3 月进展的总结吧。原文链接https://gamedev.rs/news/032/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-12 16:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "3 月 GameDev 进展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "reddit 热议：Rust-For-Linux 目前进展到哪一步了？有一个明确的合入主分支的时间点吗？评论区也很多人给出了解答，总结如下：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-12 16:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust-For-Linux 进展如何" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者自己使用 Rust 实现了一个 DNS client, 不仅是因为 dig 这个命令有点笨拙难用,更因为作者想了解更多的 DNS 知识.原文链接https://blog.adamchalmers.com/making-a-dns-client/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-11 20:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我从使用 Rust 制作 DNS client 中学到了什么" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者列出了这本的优缺点,并且给出了自己的整体感受.作者的观点是，这本书试图一下子教太多的东西。整本书只专注于系统编程部分。以目前的形式来看，这本书的内容太多了。原文链接https://blog.frankel.ch/rust-action/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-11 20:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "<<Rust in acton>> 读后感" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Locutus是一个平台，可以很容易地创建去中心化的应用。这些去中心化的应用程序将易于使用，可扩展，并通过密码保护。可以使用 React 或 Vue.js 等熟悉的工具来构建 Locutus 应用。github 地址https://github.com/freenet/locutus--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-11 20:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "locutus: 一个去中心化应用开发平台" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 ScyllaDB 的客户端驱动程序，用纯 Rust 编写，使用 Tokio 实现完全异步 API。尽管针对 ScyllaDB 进行了优化，但也与 Apache Cassandra 兼容。例子：对此，团队还专门写了一篇文章《为什么我们要将数据库驱动程序移植到异步 Rust》，他们想把所有的数据库驱动底层都用 Rust。文章链接：https://thenewstack.io/why-were-porting-our-database-drivers-to-async-rust/文档：https://rust-driver.docs.scylladb.com/stable/index.htmlGitHub：https://github.com/scylladb/scylla-rust-driver" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "scylla-rust-driver：适用于 Rust 的异步 CQL 驱动程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有类似 vim 的键映射。受到 vifm 的启发，同时关注：\n简单快速\n容易配置如何打开文件\nGitHub：https://github.com/kyoheiu/felix" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "felix：tui文件管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "工作原理：给定硬盘驱动器上的路径（也可以是根路径，例如 /），diskonaut 会扫描它并将其元数据索引到内存，以便浏览其内容（即使在仍在扫描时）。完成后，可以在子文件夹中导航，获取占用磁盘中文件的树状图表示，甚至可以删除文件或文件夹，diskonaut 将跟踪在此会话中释放了多少空间。GitHub：https://github.com/imsnif/diskonaut" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "diskonaut：终端磁盘导航" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "并发数据结构面临着决定何时可以安全地释放内存的问题。尽管某个对象可能已在逻辑上被删除，但之前加载该对象的其他线程可能仍在访问它，因此立即释放该对象并不安全。多年来，已经设计了许多算法来解决这个问题。但是，大多数传统的内存回收方案在性能、效率和稳健性之间进行权衡。例如，基于 epoch 的回收快速且轻量级，但缺乏鲁棒性，因为停滞的线程可以阻止回收所有已停用的对象。Hazard pointers 是另一种流行的方案，可跟踪单个指针，使其高效且鲁棒，但通常要慢得多。https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf另一个通常不被考虑的问题是工作负载平衡。在大多数回收方案中，停用对象的线程是回收对象的线程。这会导致读取为主（read-dominated）的工作负载中的回收不平衡；当只有一小部分线程正在写入时，并行性会降低。这在使用由 Tokio 等异步运行时提供的 M：N 线程模型时尤其普遍。Seize 基于 hyaline 回收方案，该方案使用引用计数来确定何时可以安全地释放内存。但是，引用计数器仅用于已停用的对象，从而避免了传统引用计数方案带来的高开销，其中每次内存访问都需要修改共享内存。性能通常与基于 epoch 的方案相当或优于基于 epoch 的方案，而内存效率与 Hazard pointers 相似。回收是自然平衡的，因为最后一次引用对象的线程是释放它的线程。还跟踪了 Epoch 以防止线程停滞，使回收真正无锁。https://arxiv.org/pdf/1905.07903.pdfSeize 与所有支持单字原子操作（如 FAA 和 CAS）的现代硬件兼容。文档：https://docs.rs/seize/latest/seize/GitHub：https://github.com/ibraheemdev/seize" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "seize：为并发数据结构提供快速、高效且可靠的内存回收" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "特征包括：\n📡 基于 Notion notetaking app 构建的全功能 C2 平台。\n🚧 轻松设置：设置 Notion 开发人员 API 帐户，将 Agent 放到目标处执行。\n🖥️ 在 Rust 中内置的跨平台代理，使用相同的代码库为 Linux、Windows 和 macOS 编译。包括一个 Python 设置/控制器脚本以简化过程。\n☢️ 一系列功能，包括端口扫描、权限提升、异步命令执行、文件下载和 shell 代码注入，所有这些都可以通过 Notion 页面的舒适控制！\n📜 随时记录！Agent 会标识特殊语法来运行命令，可随时使用 Notion 页面的其余部分来记录操作。\n🤝 协作设计！允许多个人编辑和查看笔记。监听页面可以处理多个代理，可以邀请红队朋友访问页面。这是一个团队服务器！\n📱移动 C2！从您的移动设备上使用 Notion 应用程序，可以从任何地方向代理发出命令。\n🕵️ 隐身！C2 在本机上通过 Notion API 通信。C2 流量看起来像是有人正在将 Notion 用于其预期目的。\nGitHub：https://github.com/mttaggart/OffensiveNotion" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "OffensiveNotion：C2平台" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "wachy 是一个基于 eBPF 的性能 debug UI 工具。需满足：\nLinux 4.6 或更高版本的内核\n跟踪的二进制文件应采用编译语言，并具有调试符号\n介绍：https://www.rubrik.com/blog/technology/22/1/introducing-wachy-a-new-approach-to-performance-debugging主页：https://rubrikinc.github.io/wachy/GitHub：https://github.com/rubrikinc/wachy" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "wachy：适用于 Linux 的动态跟踪探查器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Move 是一个新的可编程平台，用于区块链和其他安全性和正确性至关重要的应用。它是一种可执行的字节码语言，旨在提供安全和可验证的面向事务的计算。该语言具有强大的类型系统，具有线性资源类型，运行时检查和形式验证。GitHub：https://github.com/diem/move" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "move语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "nvim 自动补全框架。需要 Neovim 0.7+，由于 Rust 代码必须编译，因此还需要 rustup 工具链（rust从1.58+，make，ar）才能使用。GitHub：https://github.com/noib3/nvim-compleet" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "nvim-compleet：nvim自动补全" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "通过从针对灵活性和编译时间优化的组件组成解析器来解析命令行参数。GitHub：https://github.com/pacak/bpaf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "bpaf：命令行解析器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用于 Rust 的 WebAssembly 工具已经取得了很大的改进，并且在过去两年中已经非常成熟。借助 Trunk 等工具，以及能够使用 yew 或 dioxus 等各种框架编写前端代码，构建和打包步骤现在变得更加简单。现在很多 crate 也支持 wasm，基本的如 chrono 或更高级别的库如 plotters。https://trunkrs.dev/此外，Rust 服务器端的可用选项有所增加。随着像 tower 这样的项目为客户端 / 服务器提供可重用的构建块，像 axum 这样的 Web 服务器出现了，它允许快速组合 Web 应用程序而无需太多模板。https://github.com/tower-rs/tower在本教程中，作者将使用 Rust 作为前后端的默认配置，这适用于使用 WASM/JS 进行渲染和路由的典型单页应用。服务器选择了 axum，前端选择了 yew，其他选择也应该类似。文章：https://robert.kra.hn/posts/2022-04-03_rust-web-wasm/GitHub：https://github.com/rksm/axum-yew-setup" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust全栈教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Zaplib 是一个开源库，用于使用 Rust 和 WebAssembly 来加速 Web 应用程序。文档链接，https://zaplib.com/docs/GitHub链接，https://github.com/Zaplib/zaplib" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Zaplib/zaplib" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-09 23:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Zaplib" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rayon 是 Rust 的标准数据并行库，Spliter 是用简单方法实现 Rayon 并行化图搜索。文章链接，https://tavianator.com/2022/parallel_graph_search.htmlGitHub链接，https://github.com/tavianator/spliter" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/tavianator/spliter" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-09 23:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rayon ParallelIterator" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Lingua，Rust 最准确的自然语言检测库，适用于长文本和短文本等。该库现在可以编译为 WebAssembly，允许在任何基于 JavaScript 的项目中使用它，无论是在浏览器中还是在 Node.js 上运行的后端。GitHub链接 ，https://github.com/pemistahl/lingua-rshttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/pemistahl/lingua-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-09 23:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Lingua" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RisingWave 是一款云原生的流式数据库（Streaming Database），团队希望打造一款快速、可扩展、可靠的为处理实时流式数据的数据库。然而，该数据库仍然有学习曲线高、难以运维的劣势。介绍：https://singularity-data.com/blog/risingwave-A-Cloud-Native-Streaming-Database/仓库：https://github.com/singularity-data/risingwave" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://singularity-data.com/blog/risingwave-A-Cloud-Native-Streaming-Database/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-08 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RisingWave 开源" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "号称是最准确的语言识别库，现在可以支持 WASM了https://github.com/pemistahl/lingua-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/pemistahl/lingua-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-08 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Linga 1.4 支持 WASM" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://users.rust-lang.org/t/a-summarized-table-about-the-new-dep-and-cargo-feature-syntax/73958--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://users.rust-lang.org/t/a-summarized-table-about-the-new-dep-and-cargo-feature-syntax/73958" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-08 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "对cargo 关于 dep 和 feature 新语法的总结表" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 1.60.0 stable 正式发布，赶快升级到最新稳定版本体验 Rust 带给你的强劲动力吧 :)\n对基于 llvm 的覆盖工具的支持\ncargo --timings 收集构建信息\n支持 Cargo 关于特性的新语法：dep: 前缀以及 \"package-name?/feature-name\"\n重新启用增量编译\n保证 Instant 的单调性\nAnnouncing Rust 1.60.0: https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-07 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.60.0 stable 正式发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Jon 神在这个视频中分享了一些关于 Noria 实施的内容，还谈到对多个线程之间共享的数据的无锁最终一致并发访问。Rust at speed — building a fast concurrent database: https://www.youtube.com/watch?v=s19G6n0UjsMNoria: data-flow for high-performance web applications: https://github.com/mit-pdos/noria" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mit-pdos/noria" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-07 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "视频考古 - Rust 速度 ：构建一个快速、并发的数据库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 437: https://this-week-in-rust.org/blog/2022/04/06/this-week-in-rust-437/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/04/06/this-week-in-rust-437/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-07 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 437" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者Aria Beingessner，本篇是《Rust的不安全指针类型需要重做》的下篇。https://gankra.github.io/blah/fix-rust-pointers/作者尝试详细讲述内存模型的一些基本概念，以及尝试对提出的想法进行相对严格的证明。作者的字里行间显得非常专业。rust社区有理论高手的。https://gankra.github.io/blah/tower-of-weakenings/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gankra.github.io/blah/tower-of-weakenings/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-07 19:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "虚弱之塔：每个人都应该懂的内存模型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在Fiberplane，作者尝试在React Redux界面库的使用中，引入Rust通过wasm来实现Redux的Reducer。https://fiberplane.dev/blog/writing-redux-reducers-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fiberplane.dev/blog/writing-redux-reducers-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-07 19:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust写Redux Reducer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本库最大的特点就是设计之初就基于quic，充分利用quic的强大特性，实现一个高性能的代理库。https://github.com/EAimTY/tuic" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/EAimTY/tuic" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-07 19:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tuic - 基于quic的高性能的代理库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Qiskit是一家量子计算创新公司。之前的编程主要使用py来做（机器学习技术栈？）。现在引入Rust了。https://medium.com/qiskit/new-weve-started-using-rust-in-qiskit-for-better-performance-a3676433ca8c" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://medium.com/qiskit/new-weve-started-using-rust-in-qiskit-for-better-performance-a3676433ca8c" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-07 19:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Qiskit引入Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "市场方向已经展示了我们可能正处于一个临界点：从C/C++开始提升到一个更安全更现代的系统编程语言。可能不是所有嵌入式软件，但是新的项目应该勇于尝试。而Rust语言是这个提升要求的不二选择。一句话，时代召唤。本篇发起了最强音。https://apollolabsblog.hashnode.dev/why-you-should-be-worried-about-the-future-of-cc-in-embedded-a-case-for-rust--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://apollolabsblog.hashnode.dev/why-you-should-be-worried-about-the-future-of-cc-in-embedded-a-case-for-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-07 19:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么你需要担心C/C++在嵌入式领域的未来" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust Magazine 2022 第一季发布https://mp.weixin.qq.com/s/T0pzrbymw6lEGS6PoEnZuQ发刊通告2022年 《Rust Magazine》 将重新定位为：Rust 生态观察者。《Rust Magazine》将按季度发布，分类记录 Rust 生态中的一举一动。Rust 用户可以在这里找到不错的学习资源、项目实践的灵感、有趣的开源项目，并且可以及时了解 Rust 官方动态、社区事件等。Rust 生态第一季回顾\nRust 语言团队 2024 Roadmap 已经发布；\nWebAssembly 发展初露苗头；\nRust 生态中终端应用不断涌现出优秀应用；\nRust 跨平台开发尤其在 GUI 领域已凸显出了它的优势；\nRust 在区块链领域的应用也非常值得关注；\nRust 安全依然不容忽视，Rust 中内存安全和线程安全漏洞依然多于其他漏洞；\nRust 在生物信息科技领域也有好几个开源应用，比想象中要多，主要集中在基因测序方向上；\n有人开始用 Rust 来重写经典软件了，比如 Fornjot 要创建下一代 Code-CAD ；\n在学术领域，研究 Rust 和 WebAssembly 的论文越来越多了。\n详情：Rust Magazine 2022 第一季发布https://mp.weixin.qq.com/s/T0pzrbymw6lEGS6PoEnZuQ" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-06 11:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《Rust Magazine》 2022 第一季发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust Lang Roadmap for 2024https://blog.rust-lang.org/inside-rust/2022/04/04/lang-roadmap-2024.html核心目标Rust 2024 的目标：扩大赋能的规模。通过设计和实现Rust这个有大量高质量库和工具集支撑的强大语言，以及维护和建设一个强大而有力的社区，吸引更多乃至大规模用户学习和使用Rust，从而让每个人都能够构建可靠高效易扩展的软件。三个主题扁平化学习曲线：向新用户和新用例扩展让新老用户都能更方便地使用Rust，让解决困难问题变得更容易。帮助Rust的用户互相帮助：扩大生态系统的规模赋予库的作者权力，以便他们能够反过来赋予他们的用户权力。帮助Rust项目扩大规模：扩大项目规模开发流程以适应越来越多的用户的需求和用例；评估并完成我们已经开始的项目。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-06 11:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 2024 路线图" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 安全参考 ｜ Rust 编译到 WebAssembly 可能出现侧信道攻击https://mp.weixin.qq.com/s/8ahnHTCsGADV5N6cL5jQqQ背景一篇来自 Trail of Bits 安全公司博客的文章，介绍了 Rust 利用 LLVM 编译到 WebAssembly 时可能出现新的侧信道攻击风险。https://www.trailofbits.com/许多工程师选择 Rust 作为他们实现加密协议的首选语言，因为它具有强大的安全保证。尽管 Rust 使安全的密码工程更容易，但仍有一些挑战需要注意。其中之一是需要保留恒定时间（constant-time）属性，这确保无论输入如何，代码都将始终花费相同的时间来运行。这些属性在防止时序攻击（timing attack）方面很重要，但它们可能会受到编译器优化的影响。解决方案如何阻止编译器优化破坏代码的恒定时间呢？有几种方案：\n使用 -C opt-level=0 关闭所有优化。这种方案基本不可行，因为我们需要编译器的优化；\n使用来自 subtle crate 的构造来尝试阻止 LLVM 优化恒定时间代码路径的尝试；\n语言内置私密类型来支持。之前有一个 Rust RFC 引入了 secret types，但这已被推迟，等待 LLVM 支持。\n总结通过插入优化屏障来对抗 LLVM 并不是提供恒定时间保证的好方法。正在努力在语言层面解决这个问题。私密类型 RFC和CT-Wasm 项目分别为 Rust 和 Wasm 引入了私密类型，是这种努力的两个很好的例子。缺少的是一种将机密类型和相应语义导入 LLVM 的方法。这很可能是 Rust 实现向前发展的先决条件。（Rust RFC 目前被推迟，等待 LLVM 的相应 RFC。）如果没有 LLVM 支持，很难看出依赖 LLVM 的高级语言如何提供任何绝对恒定时间的保证。在那之前，我们都在和编译器后端玩捉迷藏。https://github.com/rust-lang/rfcs/pull/2859" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-06 11:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 安全参考 ｜ Rust 编译到 WebAssembly 可能出现侧信道攻击" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Coppers: Rust test harness that measures energy consumptionhttps://www.reddit.com/r/rust/comments/twvz21/coppers_rust_test_harness_that_measures_energy/Coppers是一种Rust测试工具，借助 Intel RAPL，可以测量Rust程序在不同版本之间的功耗变化。https://lwn.net/Articles/545745/项目地址：https://github.com/ThijsRay/coppersRust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ThijsRay/coppers" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-06 11:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Coppers：测量能源消耗的Rust测试框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "由 Rust 中文社区 myrfy 来制作，其中也包含了一些非嵌入式领域需要懂的基础知识，比如链接脚本工作机制：\nhttps://b23.tv/YnRUJFX\nhttps://b23.tv/w9RMsSx\nhttps://b23.tv/veMMi9e\n视频合集地址https://space.bilibili.com/500416539/channel/collectiondetail?sid=177577" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-04 18:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust嵌入式开发入门视频教程系列" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "已经 2022 年了, 使用 Rust 来构建前后端的服务已经很方便了, 本文展示了 axum 和 yem 来搭建前后端开发项目的过程.原文链接https://robert.kra.hn/posts/2022-04-03_rust-web-wasm/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-04 18:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 前后端项目的搭建示例" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "toipe 是一个用Rust写的终端的打字测试.原文链接https://github.com/Samyak2/toipe--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-04 18:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "toipe: 一个用Rust写的终端的打字测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "youki 是一个 Rust 实现的容器运行时，是 OCI 运行时规范的实现，类似于 runc。此次 0.0.3 版本带来了 wasm 支持。项目地址：https://github.com/containers/youki" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/containers/youki" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-03 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Youki v0.0.3 版本更新，增加 WASM 支持" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自 rust 官博的更新，宣布 我们很高兴地公开宣布， Weihang Lo 和 Ed Page 已经加入了Cargo团队。详情请看：https://blog.rust-lang.org/inside-rust/2022/03/31/cargo-team-changes.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/inside-rust/2022/03/31/cargo-team-changes.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-03 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo 团队的变化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "项目是一个用 Rust 从头开始​​编写的神经网络库，以及一个用于构建 + 训练神经网络 + 可视化其输出的基于 Web 的应用程序项目地址：https://github.com/Ameobea/neural-network-from-scratch" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Ameobea/neural-network-from-scratch" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-03 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "neural-network-from-scratch" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Melody 是一种编译为正则表达式的语言，旨在更易于阅读和维护。现在支持 NodeJS 绑定（通过 WASM），并支持一个新的 Babel 插件项目地址：https://github.com/yoav-lavi/melodyhttps://github.com/Jancd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/yoav-lavi/melody" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-03 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Melody 项目更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们很高兴宣布我们新的WebAssembly框架Spin。Spin是Fermyon平台的基础部件。这也是开始为云编写WebAssembly的好方法。什么是wasm框架？我们认为WebasseMbly主要作为编译目标。选择语言，编写代码，并将其编译为WASM。但是在webassembly中写的是什么类型的代码？运行webassembly模块的原始方法是在浏览器中。因此，早期的WebAssageMbly努力集中在优化在网页或客户端Web应用上执行的性能密集型代码。。。。Github 链接，https://github.com/fermyon/spinhttps://github.com/fermyon/spint文章链接，https://www.fermyon.com/blog/introducing-spin" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.fermyon.com/blog/introducing-spin" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-03 09:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "spin" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文档跟踪各种语言对变异成WebAssembly的支持。它被组织成三个部分：前20种语言，WebAssembly特定语言和其他值得注意的语言。我们跟踪语言是否可以编译在浏览器中运行，在其他非浏览器环境中以及在WASI环境中运行。在每种语言的详细信息页面中，我们不仅会尽最大努力说明当前的支持级别，同时也附加了一系列有用的资源。Github 链接，https://github.com/fermyon/wasm-languages文章链接，https://www.fermyon.com/wasm-languages/webassembly-language-support" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.fermyon.com/wasm-languages/webassembly-language-support" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-03 09:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fermyon WebAssembly Language Guide" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是我第一次公开发布crate：欢迎意见和建议lavendeux解析器是一个可扩展的数学表达式解析引擎。它支持变量和函数分配、各种数据类型，并且可以通过javascript编写的扩展在运行时轻松扩展。扩展在没有主机或网络访问的沙箱环境中运行。下面是一个使用示例Github 链接，https://github.com/rscarson/lavendeux-parser文章链接，https://www.reddit.com/r/rust/comments/ttrbwj/released_my_first_crate_an_extensible_parsing/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/ttrbwj/released_my_first_crate_an_extensible_parsing/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-03 09:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "发布我的第一个 crate - 一个用于数学表达式的可扩展编译引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "以下步骤将使用 Rocket “hello world” 应用程序作为演示。Dockerfile 正常来说基本配置将是：然后构建镜像我们可以看到生成1.38GB 的​​镜像，构建时间为12 分钟。接下来使用多阶段构建和 cargo-chef 来使镜像尺寸更小它会生成628MB的图像大小，最后一次由于缓存的原因构建只需要1 分钟左右。更可以通过 distroless 或者 scratch 镜像来再加速构建，但是这里如果是 scratch 必须将工具链目标更改为 musl。scratch:结果：distroless:结果：以上结果还是非常可观的。结论第一次尝试生成 1.38GB 的​​映像大小，构建时间为 12m。现在我们可以生成一个非常小的图像，并且构建速度非常快。选择权在你手中。如果您对 musl 目标没问题，请使用 scratch 镜像。否则，选择 distroless 。\nhttps://azzamsa.com/n/rust-docker/\nRust 在软件可靠性和性能方面向前迈出了一大步，这直接转化为节省的金钱和时间。Rust 解决了我作为开发人员每天面临的许多问题，例如不变性和良好的抽象。但与所有技术一样，Rust 也有一些缺点并使之不会成为您项目的最佳选择。今天 Sylvain Kerkour 想探讨一下他认为 Rust 的不好用例。\nhttps://kerkour.com/why-not-rust\nRust.cc 论坛: 支持 rss微信公众号：Rust 语言中文社区https://rustcc.cn/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-04-01 14:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Databend：新一代云原生数仓\n共享存储（弹性）\n存储计算分离（弹性）：存算分离后，增加计算节点时不需要做数据迁移，可以达到秒级增加计算资源的效果。算力的扩张很快。\n计算资源可以根据不同的业务做划分（弹性）：例如下图中的node4可以作为数据导入专用节点，node3作为BI计算专用节点。\n资源扩张秒级弹性（弹性）：这样的架构计算节点异构化，资源分配粒度更细，资源控制更加灵活。\nBlog: https://databend.rs/blog/databend-0-7-0-release" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://databend.rs/blog/databend-0-7-0-release" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-31 21:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Databend 发布0.7版本，部署更容易，查询更迅速" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 436: https://this-week-in-rust.org/blog/2022/03/30/this-week-in-rust-436/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/03/30/this-week-in-rust-436/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-31 21:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 436" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Zee 是一个现代的终端编辑器，由 Rust 编写。演示自己编辑自己的源代码。ReadMore:https://github.com/mcobzarenco/zee" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mcobzarenco/zee" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-31 09:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Zee - Rust编写的终端编辑器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该Tools team 开发维护了一个名为Cross的项目，允许轻松地使用Docker交叉编译 Rust 项目。https://github.com/rust-embedded/wg#the-tools-team安装:cross使用预配置的 Dockerfile ，由工具团队维护。支持的平台如下:https://github.com/rust-embedded/cross/tree/master/dockerReadMore:https://kerkour.com/rust-cross-compilation" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://kerkour.com/rust-cross-compilation" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-31 09:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 的交叉编译" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Slint作为跨平台原生 UI 工具包,愿景是为任何设备提供用户界面。最初,我们专注于在支持 OpenGL ES 的桌面级机器和嵌入式设备上运行。几个月前，我们开始将 Slint 移植到微控制器 (MCU)https://slint-ui.com/ReadMore:https://slint-ui.com/blog/porting-slint-to-microcontrollers.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://slint-ui.com/blog/porting-slint-to-microcontrollers.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-31 09:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "将 Slint UI 工具包移植到具有 264K RAM 的微控制器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "cargo-edit 是一个通过命令行管理 cargo 依赖的工具，非常方便。近日，其发布了 v0.9 版本，修改了很多面向开发者的 API，同时也优化了命令行参数解析上的用户体验。CHANGELOGhttps://github.com/killercup/cargo-edit/blob/master/CHANGELOG.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-29 13:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-edit 发布 v0.9 版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "robots.txt 是一种存放于网站根目录下的文本文件，它通常告诉搜索引擎的爬虫，此网站中的哪些内容是不应被获取的，哪些是可以被获取的。因此，一个运行良好 robots.txt 解析器是任何爬虫程序的第一步，为了解决这个问题，作者开始创建 Texting Robots，这是一个用 Rust 编写的解析库，旨在实现大规模的可靠性和正确性。作者希望将来通过 FFI 和 WASM 等方式，提供给其他语言使用。https://github.com/Smerity/texting_robots原文链接https://state.smerity.com/smerity/state/01FZ3813Q79VTTVDHWHFA2A15E" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-29 13:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 处理 robots.txt" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Github 提供了 Profile README 页面的功能，结合一些 Github Actions，能够以图片的形式展示出你的项目经历，这很棒，但是作者并不满足于这一点，他想要在个人页面中添加可点击的链接，比如链接到你的某个 PR 或者仓库。因此，作者基于 Github Graphql API 实现了这样一个 Profile Generator，其主页就是通过此工具生成的，如果觉得还不错，不妨动手试一试。https://github.com/autarch原文链接https://blog.urth.org/2022/03/28/yet-another-github-profile-generator/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-29 13:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Yet Another GitHub Profile Generator" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者自己动手写了一个clippy的 lint,其过程比他想象中的要简单和容易测试的多. Clippy团队在提供示例、快速代码审查和大量易于使用的共享utils代码方面做了大量工作。原文链接https://jamesmcm.github.io/blog/2022/03/26/my-first-clippy-lint/#en" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-28 20:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我的第一个 Clippy Lint" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ProjClean 会为你找到 node_modules(node)、target(rust)、build(java)等目录及其存储空间，所以你可以很容易地检查或清理。github 地址https://github.com/sigoden/projclean" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-28 20:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ProjClean: 查找和清理 build 和 cache 目录" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "提供 Axum 下的 HTTP auth extractor. 支持 Bearer 和 Basic Auth.Bearer Authentication:Basic Authentication:github 连接https://github.com/Owez/axum-auth" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-28 20:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "axum-auth: HTTP auth extractor" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Expectrl 是一个rust模块，用于生成子应用程序，控制它们，并在进程的输出中响应预期的模式使用该库你可以:\nSpawn process\nControl process\nInteract with process's IO(input/output).\ngithub地址https://github.com/zhiburt/expectrl--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-28 20:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "expectrl" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者 Aria Beingessner 在文中指出了他认为 Unsafe 指针类型中的三个大问题：\n允许把整数声明为指针 （Integer-To-Pointer Casts Are The Devil）\n引用的有效断言过于严格（References Make Really Strong Assertions）\n偏移和位置很混乱（Offsets And Places Are A Mess）\n并且在文中给出了一些解决方案。原文：https://gankra.github.io/blah/fix-rust-pointers" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-27 22:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust unsafe 类型需要大修(Rust's Unsafe Pointer Types Need An Overhaul)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这款工具需要两样东西：\nmarkdown 格式的模板文档，里面可以用占位符以供获取代码\n规格文档，用以列举需要用在模板中的代码清单\n原文：https://www.cryptologie.net/article/553/the-code-is-the-specification-introducing-cargo-spec/仓库：https://github.com/mimoo/cargo-specification" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-27 22:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-spec 用以将代码转换成规范文档（specification)的工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 是系统级编程语言，重点关注内存安全。Google 在一些项目中使用了 Rust：包括 Android、Fuchsia 和 ICU4X；并一直参与在 Linux 内核中评估 Rust 的工作。Google 也是 Rust 基金会的创始成员。部分列表（经允许）如下：找了几次，没在原文中找到到底奖了啥；）不过，Google Open Source Peer Bonus 主页有：一张预付借记卡和一封奖励信 :Dhttps://opensource.google/documentation/reference/growing/peer-bonus另外，社区成员说 Gary Guo 大佬是中国人~地址：https://opensource.googleblog.com/2022/03/Rewarding-Rust-contributors-with-Google-Open-Source-Peer-Bonuses.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-27 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Google对25名Rust开源贡献者做出奖励" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "社区张汉东老师关于 Rust 在移动开发和跨平台模式方面的探究，大纲如下：\nRust 语言 对 iOS 和 Android 平台支持状态\nRust 用于移动开发的几种方式\nAndroid 官方支持 Rust 的方式\n给 Apple 的一封公开信：请用 Rust 替换 Objective-C\n地址：https://zhuanlan.zhihu.com/p/484269271" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-27 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust移动开发与跨平台模式探究" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "其中 Fuse 是生产者，Bomb 是消费者。使用指南：GitHub：https://gitlab.com/nebneb0703/bombs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-27 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "bombs：单生产者多消费者通信类型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用 Rust 和 LALRPOP 从头开始实现一个 C 风格架构的编程语言。视频：https://www.youtube.com/watch?v=OynJIFEsf3oGitHub：https://github.com/eZanmoto/norpl使用 Rust 实现 Brainfuck 语言。Brainfuck 是 Urban Müller 于 1993 年创建的一种极简、深奥的编程语言。 该语言以其极简主义著称，仅包含八个简单的命令、一个数据指针和一个指令指针。虽然它是完全图灵完备的，但它并不是为了实际使用，而是为了挑战和娱乐程序员。 ——来自维基百科Brainfuck 的 Hello World 是这样的：小编内心 OS：谁吃饱了撑的没事干搞这个^_^地址：https://rtoch.com/posts/brainfuck-interpreter-implementation-part-1/GitHub：https://github.com/CrazyRoka/brainfuck-interpreter" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-27 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust写个语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个阿拉伯数字转自然语言的小工具。使用方法：也可以在命令行使用：GitHub：https://github.com/Ballasi/num2words/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-27 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "num2words：数字转文本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "项目通过使用共享库来防止代码重复，保持完全原生的 UI 体验和对平台最新 API 的简单访问。它也非常灵活，允许在不同平台之间轻松迁移，包括传统的跨平台框架，如 Flutter 或 React Native。例如，您可以使用 Rust+React Native 或 Rust+Flutter 开发您的 MVP，然后迁移到原生 iOS/Android，而无需重写所有内容。  您甚至可以使用 WebAssembly 或桌面应用程序将您的核心重用于 Web 应用程序（同样，您可以使用本机或跨平台框架，如 Electron）。如果你有意向，可以在项目上开个 Issue，或给作者发邮件：mailto:ivanhp978@gmail.comGitHub：https://github.com/ivanschuetz/rust_android_ios" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-27 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust_android_ios寻找维护者" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个 repo 尝试评估 Rust 字符串类型。Github 链接：https://github.com/epage/string-benchmarks-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/epage/string-benchmarks-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-26 22:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 字符串解析基准测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust for Linux 是一个旨在将 Rust 支持作为头类语言引入 Linux 内核的项目。这意味着为用 Rust 编写内核模块（例如驱动程序或文件系统）提供支持，并且使用尽可能少的不安全代码。本次会议将简要解释 Rust 支持如何在内核中工作，并将提供项目状态的更新，以及近期的计划。它还显示可以帮助该项目的 Rust 功能的愿望清单。Youtube链接：https://www.youtube.com/watch?v=fVEeqo40IyQ" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=fVEeqo40IyQ" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-26 22:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【视频】Miguel & Wedson：Rust for Linux 当前状态" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用 Rust、Wasm、SIMD 和多线程 Web Worker 进行程序性地形生成。网址：https://ianjk.com/terrain_generator/Github链接：https://github.com/kettle11/open_world_gamehttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/kettle11/open_world_game" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-26 22:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "程序性地形生成" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n移动设备优先。\n直观而优雅的杂志设计。\n最佳的阅读体验。\n主题可定制，扩展友好。\n支持 RSS Feed 。\n支持开放图谱协议（Open Graph Protocol）。\n建立静态网站，托管在任何地方。\nGitHub - zineland/zine: https://github.com/zineland/zine《TO-D 杂志》- 由 Zine 驱动: https://github.com/zineland/2d2d" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/zineland/2d2d" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-24 23:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Zine  - 简单易用的个人杂志生成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Fig 为现有终端添加 IDE 风格的自动补全。此前，Fig 是一个捆绑了 CLI 的桌面 App 。而现在，Fig 用 Rust + Clap 进行了重现，变成一个可以添加到桌面 App 中的 CLI 工具。这意味着：\n跨平台体验，支持 Linux 和 Windows，更好的性能\n在远程计算机上运行\n发布酷炫的新产品\n同时，Fig 也为 Rustacean 提供 System Engineer 职位。fig.io: https://fig.io/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fig.io/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-24 23:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fig.io 使用 Rust 重写其 CLI" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 435: https://this-week-in-rust.org/blog/2022/03/23/this-week-in-rust-435/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/03/23/this-week-in-rust-435/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-24 23:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 435" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "洛佳发布了RustSBI 0.2.2版本。RustSBI现已支持最新的RISC-V SBI 1.0.0正式批准版的规范标准。另外，本次更新预留了主从机不同的指针宽度，准备为虚拟化软件提供SBI接口实现支持。相比0.2.0版本，新版修复了一个较为严重的逻辑漏洞，推荐0.2.0版本用户立即更新。RISC-V SBI是RISC-V桌面与服务器平台不可或缺的基础软件，而RustSBI是RISC-V SBI标准采纳的软件实现之一。RustSBI完全由嵌入式Rust编写，自从2020年RustSBI发布第一个版本以来，软件久经考验，是成熟的RISC-V内核支持接口实现。详情：https://github.com/rustsbi/rustsbi/releases/tag/v0.2.2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-23 23:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustSBI软件发布v0.2.2版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个玩具，可以试试。https://github.com/kognise/arpchat" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/kognise/arpchat" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-23 23:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "arpchat - 用局域网地址发现arp协议实现一个聊天软件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust与C++交互是工业界非常重要的课题。作者整理对比了 bindgen，cpp!, cxx, autocxx 这个库四种方法的优劣。最后做了一个非常有价值的表格。https://blog.tetrane.com/2022/Rust-Cxx-interop.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.tetrane.com/2022/Rust-Cxx-interop.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-23 23:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust与C++交互操作生态相关的辅导文章" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "superconsole是一个基于组件的Rust TUI库。可以看一下效果。本项目已进入facebook孵化器。https://github.com/facebookincubator/superconsole" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/facebookincubator/superconsole" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-23 23:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "superconsole - 又一个TUI库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "视频：https://youtu.be/-QXj0UexUw0文章：https://github.com/jack1232/wgpu-step-by-step" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jack1232/wgpu-step-by-step" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-23 23:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust wgpu 图形编程系列教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Announcing fluent-uri: a fast, easy and strict URI parserhttps://www.reddit.com/r/rust/comments/timilj/announcing_fluenturi_a_fast_easy_and_strict_uri/简介一个严格遵守IETF RFC 3986和RFC 6874的Rust URI解析器。https://datatracker.ietf.org/doc/html/rfc3986/特性\n快速：零拷贝解析，据观察，比Rust中常见的URI解析器快2-25倍；\n简单：精心设计和文档良好的API；\n严格：解析RFCs中定义的所有可能的URI，并拒绝其他任何东西。\n项目地址：https://github.com/yescallop/fluent-uri-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/yescallop/fluent-uri-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-22 18:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "fluent-uri：一个快速、简单和严格的URI解析器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rename-future: Name anonymous Future from async fn without dyn or Box!https://www.reddit.com/r/rust/comments/tj8ayi/renamefuture_name_anonymous_future_from_async_fn/关于rename-future由于当前编译器不支持关联类型的命名Future（解决命名impl Trait的type_alias_impl_trait特性还未稳定），想自定义命名Future需要依赖box和dyn特性；rename-future提供了一种解决命名impl Future的思路：实现原理宏展开后生成代码如下：注意这个项目还没有经过很好的测试！不要在生产代码中使用这个库！项目地址：https://github.com/ArtBlnd/rename-future" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ArtBlnd/rename-future" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-22 18:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rename-future: 支持无dyn或box的命名Future" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Dynamic language extensions for Rust?https://www.reddit.com/r/rust/comments/tiqei3/dynamic_language_extensions_for_rust/C语言程序员使用Lua来扩展他们应用程序的功能，Rust可以使用哪些类似的语言？以下是一个可嵌入Rust代码中的脚本语言的汇总列表：https://arewegameyet.rs/ecosystem/scripting/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://arewegameyet.rs/ecosystem/scripting/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-22 18:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust的动态语言扩展？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Announcing mlua 0.8.0-beta with Roblox Luau supporthttps://www.reddit.com/r/rust/comments/tjrmf3/announcing_mlua_080beta_with_roblox_luau_support/我很高兴地宣布第一个支持Roblox Luau的mlua 0.8.0-beta.1版本。mlua为所有Lua版本（5.1-5.4）提供了统一的高级接口，包括LuaJIT和现在的Luau，并通过feature flags在它们之间进行简单切换。Luau支持只在vendored模式下工作（不需要vendored特性标志），并提供所有关键的mlua特性，包括async/await和userdata值（通过仿真它们）。同时，mlua实现了加载Luau模块的require函数，因为标准实现中没有这个功能。唯一值得注意的缺失功能是只读表和沙盒功能，这些功能将在下一个版本中得到支持。简单使用:" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-22 18:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mlua 0.8.0-beta.1: 首个支持Roblox Luau的版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tiny lisp interpreterhttps://www.reddit.com/r/rust/comments/tit9js/tiny_lisp_interpreter/使用：项目地址：https://github.com/ktfth/rs-lispRust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ktfth/rs-lisp" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-22 18:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rs-lisp：一个用Rust编写的小型lisp解释器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "mozilla/gecko-dev 2022年 3 月的统计. 展示了语言构成比例, 目前 Rust 占据大约 10%, 位居第五位, 前四分别是 Javascript, C++, HTML, C.原文链接https://4e6.github.io/firefox-lang-stats/?2022-03" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-21 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Firefox 现在约 10% 的代码为 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文讲述了如何使 Embedded Rust 提供的驱动, 通过 I2C 的方式来读取和修改传感器的数据.原文链接https://lupyuen.github.io/articles/rusti2c" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-21 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 使用 I2C 的方式读取传感器数据" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本来列举了几种常见语言中的错误处理, 例如 Go, Java 等,并且与 Rust 的错误处理方式进行了对比.原文链接https://blog.frankel.ch/error-handling/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-21 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "对比 Rust和其他语言中的 错误处理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "fluent-uri 是一个 Rust URI解析器，严格遵循 IETF RFC 3986 和 RFC 6874。特性:\n快速: 零拷贝解析。观察到它比Rust中常见的URI解析器快2倍~ 25倍。\n简单: 精心设计和文档化的api\n严格: 解析rfc中定义的所有可能的URI，并拒绝任何其他内容。\n原文链接https://github.com/yescallop/fluent-uri-rs--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-03-21 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "fluent-uri: 一个 Rust URI parser" }, "type": "text" }], "type": "title" } },]
