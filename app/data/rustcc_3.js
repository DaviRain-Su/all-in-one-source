export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Nethercote 是一位从事 rustc 的软件工程师。他介绍了最近在 rustc 上做的一些性能工作，重点介绍了 rustc 是如何将代码分割成代码生成单元（CGU），以及这对编译速度和代码质量有什么影响。他解释了不同数量和大小的 CGU 之间的权衡，以及 rustc 如何使用 LLVM 来并行化代码生成和优化。Nethercote 还探索了一些形成和排序 CGU 的替代方法，并报告了他的实验结果。Nethercote 发现，很多时候，无法在编译速度、内存占用、编译体积和质量上都实现提升，一个指标的提升，经常伴随另一个性能指标的下降。尽管他没有发现比现有方法更明显的改进，但还是希望在未来继续研究这个问题，同时他的这份博客也写的非常详尽，值得深入学习。\n博客原文\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-11 21:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustc 的并行编译性能优化探索" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "词法分析（lexical analysis） 是编译器的第一个阶段，实现词法分析的代码称为 lexer。有人最近研究了 logos 这个 rust 中广受欢迎的 lexer，logos 声称其目标是能比手动实现的 lexer 更快，作者提出了质疑，因为在他看来，通用性和性能无法兼得。因此他一步步实现了一个 lexer，探索了多种优化技巧，并与 logos 进行了多轮性能对比。https://github.com/maciejhirsz/logos最终的结果表明，手动实现的基于状态机的 lexer 比 logos 实现了 20% 左右的性能提升。\n代码和性能测试仓库链接\n原文链接\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-11 21:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "实现一个更快的 Lexer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者原先一直在用 C++ 写逆向工具，但是 C++ 这门语言不是很友好，于是研究了下如何使用 Rust 实现 DLL 注入的“工具”。大致原理就是让 Rust 生成一个 C 样式的 DLL，然后使用 unsafe 去操作裸指针，操作程序内存，最后实现一下 DLL 注入就可以了。\ngithub链接\n原文链接\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-11 21:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 实现 DLL 注入" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个 high-level 封装包简化了Rust集成到你的Flutter应用程序中的过程，无需代码生成或本地工具。它考虑到易用性、未来的可扩展性和卓越的性能，处理所有复杂的后台工作。只需将此包添加到您的 Flutter 项目中，你就可以开始编写Rust了！添加 Rust 让你的 Flutter 应用变的超快把.原文链接https://pub.dev/packages/rust_in_flutter" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-10 18:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust In Flutter" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章讨论了Rust中的 Deref 特征和它的一些用法。Deref 特征允许您将类型转换为另一种类型，而无需显式地编写代码。这个特性在Rust中非常常见，但是有时会导致混淆和错误。文章中提到了一些常见的问题和解决方案，例如自动解引用规则、Deref和 DerefMut 之间的区别、Deref 和 DerefMut 的实现方式等等原文链接https://www.fuzzypixelz.com/blog/deref-confusion/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-10 18:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Deref 困惑" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "经过 166 贡献者共同努力, 在提交了 522 pull requests之后, Bevy 0.11 发布了.其中包含了以下改进:\nScreen Space Ambient Occlusion (SSAO)：通过模拟“间接”漫反射光的遮挡来提高场景渲染质量。\nTemporal Anti-Aliasing (TAA)：一种流行的抗锯齿技术，使用运动矢量将当前帧与过去帧混合在一起，以平滑处理伪影。\nMorph Targets：在预定义状态之间动画网格上的顶点位置。非常适合像角色定制这样的事情！\nRobust Constrast Adaptive Sharpening (RCAS)：智能锐化渲染，与TAA配对效果更佳。\nWebGPU支持：Bevy现在可以使用现代的WebGPU Web API更快地在Web上渲染，并具有更多功能。\n改进的着色器导入：Bevy着色器现在支持粒度导入和其他新功能。\n视差映射：材质现在支持可选深度图，通过视差材质的纹理使平面表面具有深度感。\nSchedule-First ECS APIs：更简单、更人性化的ECS系统调度API。\n即时模式Gizmo渲染：轻松高效地渲染2D和3D形状进行调试和编辑器场景。\nECS音频API：一种更直观、更惯用的播放音频方式。\nUI边框：UI节点现在可以有可配置的边框！\n网格UI布局：Bevy UI现在支持CSS样式网格布局。\nUI性能改进：UI批处理算法已更改，产生了显着的性能提升。\n原文链接https://bevyengine.org/news/bevy-0-11/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-10 18:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy: 0.11发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Agnesoft是一种使用对象 'no-text' 查询的持久化内存映射图数据库。它可以用作主要的持久化存储、数据分析平台以及快速的内存缓存。其类型化的无模式数据存储允许以灵活无缝的方式进行数据更新，而无需停机时间或昂贵的迁移。所有查询都是通过构建器模式（或直接作为对象）构建的，而无需特殊的语言或文本解析。主要特点如下：\n在图上绘制的数据\n附加到图元素（节点和边）的类型化键值属性\n持久的基于文件的存储\n符合 ACID 要求\n使用构建器模式的对象查询（无文本，无查询语言）\n内存映射以实现快速查询\n无依赖\n基本用法示例：演示创建数据库、插入带有数据的图元素，并使用 select 和 search 查询它们。使用此代码的函数必须处理 agdb::DbError 和 agdb::QueryError 错误类型，以便使操作符。这段代码创建了一个名为user_db.agdb的数据库，其中包含一个简单的由4个节点组成的图形。第一个节点别名为users，然后通过边与Alice、Bob和John的3个用户节点连接到users节点。任意的用户名属性和稀疏连接属性被附加到用户节点上。可以通过它们的ID选择图元素（节点和边），以获取它们及其关联的数据（键值属性）：还可以通过搜索来获取想要的图元素：GitHub: https://github.com/agnesoft/agdb" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/agnesoft/agdb" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-09 23:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Agnesoft图数据库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个用于播放音乐混音的命令行实用程序，适用于编程和专注（来自musicforprogramming.net），能够唤起心流状态！也可直接下载编译好的：https://github.com/guptarohit/mfp/releasesGitHub; https://github.com/guptarohit/mfp" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/guptarohit/mfp" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-09 23:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mfp音乐播放器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "无论您是 Rust 爱好者还是为即将到来的面试做准备，这份全面的资源将帮助您在 Rust 编码挑战和面试中取得卓越的表现。内容包含：🔍 精选收集：精心编制了一份筛选过的面试问题、编程练习和深入解释的集合，旨在提升您的 Rust 技能水平。💡 概念洞察：通过详细的解释，获得对 Rust 关键概念和习惯用法的扎实理解，使您能够高效地解决复杂问题。GitHub: https://github.com/imhq/rust-interview-handbook链接: https://intmain.co/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://intmain.co/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-09 23:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust面试手册" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在这个版本中，官方 ECMAScript 测试套件（Test262）中的一致性从 74.53% 增加到 78.74%。虽然这看起来只是一个小幅增加，但与上个版本相比，现在通过了 6079 个更多的测试。无论如何，这个版本的重大变化与一致性无关，而是与大规模的内部增强和新的 API 相关。具体的ChangeLog：https://github.com/boa-dev/boa/blob/v0.17/CHANGELOG.mdGitHub: https://github.com/boa-dev/boa链接: https://boajs.dev/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://boajs.dev/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-09 23:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Boa v0.17发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在过去的几个月里，我一直致力于在 Rust 中重写 ShellCheck。我这么做是为了学习，我是 TypeScript 团队的一员，我一直想加强我对解析器、 lexer、代码分析等的理解。(我主要专注于编辑体验，因此没有太多机会与语言本身的更深层次进行交互)。无论如何，这是一次疯狂的旅行。文章链接，https://www.reddit.com/r/rust/comments/14ts2au/shebling_rewriting_shellcheck_in_rust/Github 链接，https://github.com/MariaSolOs/shebling" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/MariaSolOs/shebling" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-08 22:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Shebling: 用rust重写的ShellCheck" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个 CLI 工具，用于在终端中的目录之间进行书签和跳转。可能有太多像这样的 CLI 实用程序，但我想尝试自己创建一个，只是为了好玩。我很乐意听到任何关于可以改进的地方的建议。Cheers！文章链接，https://www.reddit.com/r/rust/comments/14u4i7l/markd_v010_released/Github 链接，https://github.com/VoltaireNoir/markd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/VoltaireNoir/markd" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-08 22:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Markd V0.1.0发布！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我做了一个非常糟糕的内存分配器，它为每一次分配创建并映射一个文件到内存中。这个库甚至有一个功能，可以图形化交互，以确认和提供一个文件路径。主要是一个奇怪的练习，关于你能让一个内存分配器变得多糟糕。。。文章链接，https://www.reddit.com/r/rust/comments/14to3yo/stupidalloc_what_if_memory_allocation_was_bad/Github 链接，https://github.com/shadyfennec/stupidallochttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/shadyfennec/stupidalloc" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-08 22:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "CephStupidAlloc: 如果内存分配实际上很糟糕怎么办" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在安卓应用开发领域，优先考虑代码的正确性和安全性是至关重要的。虽然像 Java 和 Kotlin 这样的管理型语言很适合安卓应用开发，但系统级编程通常需要像 C 和 C++ 这样的语言。然而，C 和 C++ 中的内存安全漏洞带来了持续的挑战，导致了 Android 生态系统中的稳定性问题和安全漏洞。为了解决这些问题，安卓开源项目（AOSP）现在支持 Rust 编程语言来开发操作系统本身。Rust 以其内存安全保证、并发支持和令人印象深刻的性能而闻名，为防止内存错误和提高整体代码的正确性提供了一个强大的解决方案。通过编译时和运行时检查的结合，Rust 确保有效的内存访问，同时提供与 C 和 C++ 相同的性能。通过将 Rust 原生库无缝集成到 Android 应用程序中，我们可以利用 Rust 的独特功能来提高安全性、稳定性和性能。更多请看原文: https://blog.subcom.tech/supercharging-your-android-app/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.subcom.tech/supercharging-your-android-app/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-08 12:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用 Rust 原生库为你的安卓应用增色" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们将指导您完成构建一个电影收藏管理器，使用 Rust 作为 API、Actix-Web 作为 Web 框架、SQLx 用于数据库连接、Dioxus 用于前端以及 Shuttle 用于部署来构建全栈应用程序的过程。详情请看：https://bcnrust.github.io/devbcn-workshop/index.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://bcnrust.github.io/devbcn-workshop/index.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-08 12:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 全栈 workshop" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rustc_codegen_gcc 是 Rustc 的 GCC 预先编译，这意味着它可以被现有的 Rustc 前端加载，但通过支持更多的架构和获得 GCC 的优化而受益于 GCC。它不能与 gccrs 混淆，后者是 Rust 的 GCC 前端。详情请看：https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-24https://github.com/Jancd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-24" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-08 12:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustc_codegen_gcc：进度报告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "complgen 允许使用类似 EBNF 的语法为所有主流 shell 生成补全脚本。一方面，它可以将语法文件编译成可以用于独立分发的 bash/fish/zsh  shell 。另一方面，它也支持 \"just-in-time\" 模式，可以根据语法在 stdout 上完成补全，适用于交互式 shell 。GitHub- exograph ：https://github.com/exograph/exograph" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/exograph/exograph" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-07 04:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "complgen：为  shell 生成补全的新方法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Weekly Rust Trivia（每周 Rust 小知识）是一系列以问题为导向的文章，帮助开发者学习 Rust。每篇文章都使用 Rust 标准库或利用流行且经过验证的 crate 来解决简单的日常开发任务。Weekly Rust Trivia: https://www.thorsten-hans.com/tags/weekly-rust-trivia/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.thorsten-hans.com/tags/weekly-rust-trivia/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-07 04:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "系列文章：Weekly Rust Trivia" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 502: https://this-week-in-rust.org/blog/2023/07/05/this-week-in-rust-502https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/07/05/this-week-in-rust-502" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-07 04:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 502" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "虽然 Rust 的标准库中已经有了一个LinkedList数据结构，但创建自己的数据结构是了解更多 Rust 的一种有趣的方式。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-06 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "让我们从 abandon 开始--用 rust 写链表" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "让我们首先定义我们的 Node 结构来保存模版。我们的 Node 将包含一个数据项，以及 Node 可能存在或可能不存在的上一个和下一个数据项。通过将数据项存储在引用计数器指针 ( Rc) 中，在创建新节点时无需克隆或复制数据。Rust 需要在编译时知道结构的大小，这会导致自引用数据类型出现一些问题。prev如果我们将和字段的类型设置next为Node，我们会收到如下所示的编译器错误消息：编译器错误消息为我们提供了如何继续操作的提示。我们正在被推动使用间接，这是谈论指针的另一种方式。为了处理这个编译器错误，我们需要提供某种指针来代替Node. 我们可以定义一个自定义类型Link作为我们的间接Node包装器：请注意，因为我们的Link类型使用Rc（引用计数器指针）而不是Arc（原子引用计数指针），所以我们的实现Node不是线程安全的。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-06 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "节点" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们的每个Node方法都将包含在一个块中：impl Node { ... } 这允许我们的方法获取通用类型的数据项T，使我们Node非常灵活！现在我们知道我们的意志如何Node链接到其他人，我们可以实现该new()方法。每个都Node将开始作为通用类型的数据项保存T，并且不连接到上一个或下一个Node。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-06 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "节点构造" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们更新前一个和下一个节点的方法将相当简单。使用我们的引用计数Link，我们只需要在使用我们的设置方法时克隆另一个链接。确保彼此相邻的两个节点正确指向彼此的逻辑将由我们的LinkedList." }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-06 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Node setters" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "与我们的 setter 方法类似Node，我们的 getter 方法只需要克隆下一个或上一个链接。为了获取我们存储的数据Node而不需要克隆或复制数据，我们可以返回引用计数指针的克隆。为了方便我们的实现，我们将定义一个静态方法来从数据项LinkedList创建新的：LinkT实现了我们的Node结构及其方法后，我们可以继续我们的 LinkedList 实现。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-06 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Node getters" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们 LinkedList 需要跟踪它的第一个和最后一个节点（头节点和尾节点）及其长度。虽然我们可以动态计算 的长度LinkedList，但在推送和弹出数据项时跟踪其长度会更有效。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-06 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "LinkedList" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们的LinkedList方法将包含在一个块中：impl LinkedList { ... }。与我们的Node方法一样，此实现块将允许我们的LinkedList方法接受通用数据类型的数据项T，使我们的方法LinkedList像我们的方法一样灵活Node！新的LinkedList开始是空的，没有头节点或尾节点，长度为 0。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-06 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "链表构造函数" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们的 LinkedList push 方法是这个项目开始变得真正有趣的地方！按照惯例，“push”本身意味着 push 到 LinkedList 的末尾，而“ push 到前面”正是这个意思。要将新节点 push 到列表末尾，我们首先创建另一个包含新数据项的节点。 如果 LinkedList 为空，则新 Node 成为新的头和尾。 否则，新节点成为新尾部。 我们的 push() 方法的最后一部分确保旧尾部和新尾部彼此指向，并且 LinkedList 正在跟踪新尾部。在 Link 实例上调用的 as_ref() 方法允许我们借用 Option 实例中持有的 Rc，而不是取得它的所有权。 借用 Rc 后，我们可以通过对嵌套在 Link 中的 RefCell 调用的borrow_mut() 方法动态借用 Link 中包含的 Node。我们对称的最重要的部分LinkedList是我们的push_front()方法最终类似于push()，其中头/尾和上一个/下一个的引用被交换。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-06 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "push 方法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们从数据项中弹出的值LinkedList取决于它是否包含节点。与我们的推送方法一样，“pop”本身是指从末尾（尾部）删除一个值，LinkedList而“从前面弹出”就是它所说的意思。如果我们LinkedList至少包含一个Node，我们的pop()方法将返回包含在已删除节点中的值，该值包装在 中的 aSome中Option。否则，它将返回一个None值，表明没有Node被删除。与push 方法一样，pop 方法也是对称的。对于该pop_front()方法，与该方法相比，对 head/tail 和 prev/next 的引用被交换pop()。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-06 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pop 方法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在检查我们的长度LinkedList非常简单，因为我们一直在推送和弹出节点时跟踪它们。为了完整起见，我们应该实现一个is_empty()方法，因为我们有一个len()方法。如果该字段等于 0，我们的LinkedList将为空。len" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-06 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Checking length" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "为代码编写和使用测试用例是一个很好的做法。这样您就可以知道您的实现是否按预期运行，并在代码更改发生重大变化时保持警惕。下面是一些示例测试方法，我们可以使用它们来检查LinkedList. 这些测试方法绝不是排他性的——您可以随意自己编写更多测试用例。您可以使用命令执行测试方法cargo test。\n源码\nhttps://cmooneycollett.github.io/2023/07/01/writing-a-linkedlist-in-rust\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-06 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Bevy XPBD是一款适用于Bevy游戏引擎的2D和3D物理引擎，该引擎采用了一种较新的物理仿真方法——扩展位置基础动力学（Extended Position Based Dynamics），可以提供无条件稳定、时间步骤无关和物理上准确的仿真。与Bevy生态系统中的其他物理引擎不同，Bevy XPBD专门为Bevy设计，并使用实体组件系统（ECS）作为公共API和内部的基础。Bevy XPBD 0.1已经具备了许多功能，包括：\n动态、运动学和静态刚体\n碰撞检测和碰撞响应\n碰撞事件\n可访问碰撞实体\n传感器碰撞器\n碰撞层\n弹性和摩擦力\n重力、外力和力矩\n关节\n内置XPBD约束和自定义约束支持\n模块化插件架构，允许您用自定义实现替换现有功能\n可配置的时间步长和子步长\nReadMore: https://joonaa.dev/blog/02/bevy-xpbd-0-1-0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://joonaa.dev/blog/02/bevy-xpbd-0-1-0" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-04 18:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy XPBD：适用于Bevy游戏引擎的物理引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "您是否认为开发类似UI组件的终端应用程序很酷？使用Rust编写可视化脚本，可以帮助您自动化工作流程，并与他人共享。Zellij团队刚刚对我们的WebAssembly插件系统进行了全面升级，并邀请插件开发人员与我们一起构建这个功能。什么是Zellij插件？Zellij插件提供了类似于终端多路复用器的功能。插件可以：\n绘制自己的用户界面\n以编程方式管理用户的工作区（窗格、选项卡、命令、编辑器等）\n在特定事件（如文件访问、按键、命令结束等）发生时被唤醒等等。\nReadMore: https://zellij.dev/news/new-plugin-system/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://zellij.dev/news/new-plugin-system/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-04 18:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为您的终端构建基于WebAssembly（Rust）的Zellij插件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust Changsha Workshop - 使用Rust从零编写向量键值数据库报名： https://www.meetup.com/rust-chinese-group/events/294590663/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-04 18:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "7.22 长沙线下 Rust Workshop 活动预告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "当您的 Rust 项目达到一定的规模时，了解如何组织代码以及package、crate和module的概念变得至关重要。提前阅读专家的建议可以帮助避免常见的陷阱、性能问题或编译问题。这篇文章收集了两篇不错的文章来帮你理清这一切.原文链接https://rust-journey.com/rust-at-scale-packages-crates-and-modules/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-03 18:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust项目规划" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章是关于使用Rust编写eBPF XDP程序的。eBPF XDP程序允许非常高效的自定义数据包处理, eBPF XDP程序在到达内核网络堆栈之前运行。本文详细解释了如何使用Rust编写eBPF XDP程序，以及如何使用它来提高性能。它还解释了eBPF是什么，为什么它很重要以及如何使用它来提高性能。原文链接https://thenewstack.io/catch-performance-in-ebpf-with-rust-xdp-programs/?utm_content=bufferceba7&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-03 18:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust编写eBPF XDP程序来提高性能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章解释了Rust中的生命周期是什么，为什么它很重要以及如何使用它。它还解释了如何使用生命周期来避免编译器错误，并提供了一些示例来说明如何使用生命周期。在Rust中，生命周期是编译器（或更具体地说，它的借用检查器）用来确保所有借用都是有效的构造。具体来说，变量的生命周期从创建时开始，到销毁时结束。虽然生命周期和作用域经常一起提到，但它们并不相同。原文链接https://ezesunday.com/blog/rust-lifetimes-simplified/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-03 18:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "简化 Rust 生命周期" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "结构化并发是程序的一个属性。它不仅仅是指任意的数据结构，程序的结构保证是一棵树，而不管内部有多少并发。一个好的思考方式是，如果你可以将程序的实时调用图绘制成一系列关系，它会整齐地形成一棵树。原文链接https://blog.yoshuawuyts.com/tree-structured-concurrency/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-03 18:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "树形结构并发" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Deez 是一个用于轻松实现单表设计的 DynamoDB 抽象库，灵感来自于 ElectroDB。GitHub: https://github.com/Sife-ops/deez" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Sife-ops/deez" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-03 00:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "deez：用于 Rust 的单表设计的 DynamoDB 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Demo链接：https://ivanceras.github.io/ultron/GitHub: https://github.com/ivanceras/ultron" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ivanceras/ultron" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-03 00:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ultron：基于Web的文本编辑器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Parsel是一个从语法树节点类型直接生成解析器的库。GitHub: https://github.com/H2CO3/parsel/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/H2CO3/parsel/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-03 00:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "parsel：解析器生成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "与Rust 开发者，500Blockchains的Rust高级工程师Jester Hartman的访谈。包括程序员、Rust和编程幽默笑话，迷因等。链接: https://paah.vhx.tv/videos/rustfullhttps://www.youtube.com/watch?app=desktop&v=TGfQu0bQTKc" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-03 00:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust开发者访谈" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果你准备发布你Rust项目的第一个版本，你很可能想要上传一些包含预构建二进制文件（适用于macOS、Linux和Windows）的assets到你的GitHub发布页面。这是使项目广泛可用的最早步骤之一，并且在设置其他安装方法（如Homebrew）时会非常有帮助。然而，找出跨平台编译的方法并不容易，特别是通过GitHub Action来进行。通过阅读本文，你将拥有一个完全可用的部署流水线，它会自动创建发布并将二进制文件上传到该发布的Windows、Linux和macOS平台上。你将拥有一个类似下面这样的发布页面：链接: https://dzfrias.dev/blog/deploy-rust-cross-platform-github-actions" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://dzfrias.dev/blog/deploy-rust-cross-platform-github-actions" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-03 00:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用GitHub Actions部署Rust跨平台二进制" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 bard 的一个新的主要版本发布。此版本还附带了一本书。重大变更：\n在 bard 2.0 中，通过 TeX 生成的 PDF 输出已进行了全面改进。\nTeX 输出已被替换为 PDF 输出，不再有 process 字段。\n相反，bard 会自动检测已安装的 TeX 并运行相应的渲染命令。现在有一些新选项可以（可选地）配置 TeX 查找。\n除此之外，bard.toml 项目文件格式已更改，现在也具有版本号。\nbard 是一款歌谱编译器，它可以读取 Markdown 文件，并生成 PDF、HTML 和 Hovorka 格式的歌谱。GitHub: https://github.com/vojtechkral/bard" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/vojtechkral/bard" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-03 00:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bard 2.0发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "crates.io 团队会议上讨论了名称抢注的情况，并得出结论，可能是时候更新 crates.io 的政策了。讨论链接，https://rust-lang.zulipchat.com/#narrow/stream/318791-t-crates-io/topic/policy.20updates/near/371412272" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust-lang.zulipchat.com/#narrow/stream/318791-t-crates-io/topic/policy.20updates/near/371412272" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-02 10:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "crates.io 面临政策更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用 Web 框架 Leptos 和 WASM Web 应用捆绑器 Trunk 可以在 Rust Web 前端中集成 TailwindCSS。https://leptos.dev/参考链接，https://github.com/leptos-rs/leptos/tree/main/examples/tailwind_csr_trunk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/leptos-rs/leptos/tree/main/examples/tailwind_csr_trunk" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-02 10:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Web 前端中使用 Tailwind" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "开源图数据库 Zawgl 目前已可用于测试。GitHub链接，https://github.com/alexandre-ricciardi/zawgl" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/alexandre-ricciardi/zawgl" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-02 10:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "开源图数据库 Zawgl 发布 v0.1.2" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 编译器 rustc 可以作为一个库，这使得开发者能够使用自定义 lint、编译器错误来扩展 Rust 编译器，甚至创建自定义标准库和语义。博文比较了它和它的 C/C++ 版本，为什么你会使用或不使用它们，以及在高层次上它们是如何工作的。原文链接，https://xy2.dev/blog/hacking-rustc/https://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://xy2.dev/blog/hacking-rustc/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-07-02 10:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 编译器即库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "受到一个《代码降临》问题的启发，我们自发地决定探索康威的生命游戏，并讨论了各种有效解决该问题的技术。这篇博文简明扼要地总结了我们长达数周的研究，我们深入研究了为生命游戏寻找更快的解决方案。详情请见博客：https://binary-banter.github.io/game-of-life/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://binary-banter.github.io/game-of-life/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-30 21:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "生命游戏 Rust 快速实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "reddit 上的一个分享，大致内容如下【机翻】：帖子原文: https://www.reddit.com/r/rust/comments/14mh824/i_introduced_rust_at_work/https://github.com/Jancd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/14mh824/i_introduced_rust_at_work/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-30 21:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "工作中使用 Rust 心得分享" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "摘要：本文介绍如何在Rust编程语言中实现实用的过程宏。首先解释了不同类型的宏，然后展示了一个遵循最佳实践的过程宏实现，重点关注测试和人体工程学。假定读者对Rust有一定的了解。博文: https://xy2.dev/blog/simple-proc-macro/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://xy2.dev/blog/simple-proc-macro/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-30 00:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「博文」 实用过程宏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "摘要：在这篇博文中，作者讨论了在tantivy中实现可索引位集的方法。详情: https://quickwit.io/blog/compressed-indexable-bitset" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://quickwit.io/blog/compressed-indexable-bitset" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-30 00:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个可压缩、可索引的位集合（A compressed indexable bitset）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 501: https://this-week-in-rust.org/blog/2023/06/28/this-week-in-rust-501/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/06/28/this-week-in-rust-501/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-30 00:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 501" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章是关于 Google 在 2022 年使用 Rust 的经验分享，其中包括了一些对 Rust 的误解和事实的澄清。以下是文章的主要内容：总的来说，这篇文章揭示了 Google 在使用 Rust 过程中的一些发现和经验，这些信息对于那些正在考虑采用 Rust 的公司来说是非常有价值的。ReadMore: https://opensource.googleblog.com/2023/06/rust-fact-vs-fiction-5-insights-from-googles-rust-journey-2022.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://opensource.googleblog.com/2023/06/rust-fact-vs-fiction-5-insights-from-googles-rust-journey-2022.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-28 22:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "谷歌 2022 年对 Rust 的5个见解" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "cargo binstall为安装rust二进制文件提供了一种简单的方法，从源代码编译或下载包。ReadMore:https://github.com/cargo-bins/cargo-binstall/releases" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/cargo-bins/cargo-binstall/releases" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-28 22:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-binstall 1.0 版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n新版许可证\n集成OpenGL\n增加了新的小部件\nReadMore: https://slint.dev/blog/slint-1.1-released" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://slint.dev/blog/slint-1.1-released" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-28 22:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Slint 1.1 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Zellij 是一个类似 tmux 的终端复用器，并且提供了插件的能力。插件可以编程式地管理用户的工作区（窗格、选项卡、命令、编辑器），并在特定事件（文件访问、按键、命令结束等）时被唤醒。其近日发布了最新的插件系统，提供了一个 Rust SDK（zellij-tile）来开发 Rust 插件（其他语言即将推出！）。与传统的终端应用程序不同，Zellij 插件不需要管理自己的输出缓冲区，相反，它可以在需要呈现其 UI 组件的位置进行渲染; Zellij 还为插件提供了访问后台工作程序以执行长时间运行的任务（例如大型搜索查询）的功能。\n\n原文链接\n\n\n示例插件 monocle\n\n\n示例插件 multitask\n\n原文链接https://zellij.dev/news/new-plugin-system/示例插件 monoclehttps://github.com/imsnif/monocle示例插件 multitaskhttps://github.com/imsnif/multitask" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-27 21:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Zellij 支持使用 Rust Sdk 来开发 WebAssembly 插件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "代码覆盖率是一种度量代码保护程度的指标，一般而言，覆盖率越高代表着代码越值得信赖。根据测量单元的不同，可以有下面几种级别划分：本文介绍了，在 1.60 版本之后，如何使用 Rust 和 LLVM 工具来生成代码覆盖率报告，包括启用编译时代码覆盖率、执行性能测试程序等步骤，并使用例如 grcov 这样的工具生成可视化报告。文章还提到了一个名为 Tarpaulin 的强大工具，可以帮助开发者更加便捷地生成代码覆盖率报告，下面是使用 cargo-tarpaulin 运行覆盖率报告的示例:\n\n原文链接\n\n\ngrcov\n\n\ntarpaulin\n\n原文链接https://rrmprogramming.com/article/code-coverage-in-rust/grcovhttps://github.com/mozilla/grcovtarpaulinhttps://github.com/xd009642/tarpaulin" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-27 21:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中的代码覆盖率" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "伴随着更加友好的协议，Slint 这个广受欢迎的 UI 库发布了 1.1 版本。这个版本中，带来了一系列更新和改进，例如：同事，Slint 的协议在 GPLv3 协议的基础上进一步开放，允许在桌面或者 web 应用中集成并发布，但不允许单独发布而不将其集成到应用程序中。\n\nSlint 更新日志\n\n\nSlint 协议更新\n\nSlint 更新日志https://slint.dev/blog/slint-1.1-releasedSlint 协议更新https://github.com/slint-ui/slint/blob/master/LICENSES/LicenseRef-Slint-Royalty-free-1.0.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-27 21:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Slint 发布 1.1 版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个非官方的免费 ChatGPT 桌面应用, Rust 编写. 支持 Windows, Mac 和 Linux. 目前 38.3k ⭐️.github地址https://github.com/lencx/ChatGPT" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-26 19:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 编写的 ChatGPT桌面应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章是关于如何使用 GitHub Actions 进行 Rust 项目的跨平台部署的。文章中提到了如何使用 GitHub Actions 进行持续集成，以及如何在 Windows、macOS 和 Ubuntu 上构建和测试 Rust 项目。原文链接https://dzfrias.dev/blog/deploy-rust-cross-platform-github-actions" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-26 19:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 github action 发布多平台的 rust 二进制程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "nutype 设计哲学是: 类型系统可以用来跟踪某些事情是否已经完成，因此无需再次执行。如果一段数据已经过一次净化和验证，我们可以依靠类型而不是在怀疑时一遍又一遍地进验证。这个想法的好处是可以减少代码中的重复工作，提高代码的可读性和可维护性。原文链接https://github.com/greyblake/nutype/releases/tag/v0.3.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-26 19:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "nutype: 0.3 版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "spin 是一个 rust 的支持WebAssembly微服务框架.本教程演示如何使用 spin 来快速搭建 Rust 的微服务.原文链接https://morioh.com/p/53e245cb0ab1?f=5de8aabc41863624e4665a32--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-26 19:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何使用 spin 框架构建 Rust 的微服务" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我一直在不断改进我的fast_qr crate。与上次相比发生了什么变化：https://crates.io/crates/fast_qr\n更好的文档，包含每个用例的示例\n支持 QRCode 部件的自定义颜色\n改进了 SVG 输出文件大小\n改进了 QRCode 输入，现在可以任意u8切片（感谢 @parasyte）\n更好一点的QRCode扫描检测\n更好的 Wasm 集成（现在 svg 是在 Rust 方面构建的）和实用函数\n总体更好的测试\n请查看Github 存储库，如果您愿意，请留下一颗星，或者直接从演示网站https://fast-qr.com进行测试https://github.com/erwanvivien/fast_qr未来的目标是达到 1.0（0.9 是一个很好的 RC），我希望您能帮助了解该 API 是否符合您的需求" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-25 22:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "fast_qr v0.9 - 优化的 QRCode 生成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "[🛠️项目](https://www.reddit.com/r/rust/search?q=flair_name%3A\"🛠️ project\"&restrict_sr=1)在发布第一个版本后，我收到了来自社区的极好的反馈和建议，这使得 Tui-Journal 从一个有趣的项目变成了一个可供现实世界使用的实用工具。我感谢所有使此版本成为可能的支持和贡献。TUI-Journal 是一个用 Rust 编写的基于终端的应用程序，允许您在舒适的终端上编写和管理您的日记/笔记。它支持两种不同的本地后端：JSON 格式的纯文本后端和使用 SQLite 的数据库后端。以下是 Tui-Journal 0.2.0 版的新增内容：以下是GitHub和Crates.io上该项目的链接https://github.com/AmmarAbouZor/tui-journal" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-25 22:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "发布 Tui-Journal 版本 0.2.0 - 包含令人兴奋的新功能！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我发现自己经常思考 TUI 应用程序的想法，但我不想编写前端，所以我从不构建它们。因此，我创建了一个库，可以启动 TUI，该 TUI 可以使用合理的默认值进行配置，但不需要构建前端。我很想听到有关想法、代码或其他任何内容的反馈。www.github.com/nonzac/tui_viewhttp://www.github.com/nonzac/tui_view" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-25 22:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我制作了一个库来快速创建 TUI 应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Unrar 是一个用于列出和提取 RAR 压缩文件的库。大约8年前，我在这里发了一个帖子宣布我的第一个crate。今天，我很高兴地宣布这是这个包有史以来最大的一次发布。文章链接，https://www.reddit.com/r/rust/comments/14gzmow/announcing_unrar_050/Github 链接，https://github.com/muja/unrar.rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/muja/unrar.rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-24 21:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "unrar 0.5.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 Ockam 的早期，我们正在开发一个 C 库。几个月后，我们决定放弃成千上万行 C 语言代码，用 Rust 重写代码。在我们开始之前，这周我和InfluxData的 CTO Paul Dix 一起参加了一个录制的网络研讨会，在那里我们一起讨论了在 Rust 中InfluxData和 Ockam 的重写。为什么这两个开源项目选择重写，为什么我们选择 Rust 作为我们的新语言，我们从中学到的经验教训等等。一定要听一下这个录音。这是个很有见地的讨论。Ockam 使开发人员能够构建可信动态数据的应用程序。我们提供了简单的工具，可以将端到端加密和相互验证的通信添加到任何环境中运行的任何应用程序。文章链接，https://www.ockam.io/blog/rewriting_in_rustGithub 链接，https://github.com/build-trust/ockam" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/build-trust/ockam" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-24 21:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用rust重写Ockam" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，我想宣布Cephalon。Cephalon 是一个用 Rust 编写的开源知识库工具。目前在 v0.0.4中，它支持用户从文档执行语义搜索的能力。Cephalon 的目标是使在文档和机器学习模型之间创建数据pipeline变得更加容易。目前，我们有一个预先构建的pipeline，但随着我们的发展，我希望让用户有更多的选择来确定他们的模型和数据源。文章链接，https://www.reddit.com/r/rust/comments/14h5y1q/announcing_cephalon/Github 链接，https://github.com/Maruti-io/cephalon-rshttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Maruti-io/cephalon-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-24 21:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cephalon" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "今日Rust Blog官博上Tobias Bieniek发文写到，如果您最近在 crates.io 上生成了新的 API 令牌，您可能已经注意到我们的新 API 令牌创建页面及其现在支持的一些新功能。以下是内容：以前，当单击 https://crates.io/settings/tokens 上的“New Token”按钮时，您只能选择令牌名称，而没有任何其他选择。我们知道我们希望为用户提供更大的灵活性，但在以前的用户界面中这会很困难，因此我们的第一步是构建一个适当的“New API Token”页面。 我们的路线图包括两个称为“令牌范围”的基本功能。第一个允许您将 API 令牌限制为特定操作。例如，您可以配置令牌以仅启用现有 crate 的新版本发布，同时禁止创建新 crate。第二个提供了一个可选的限制，其中令牌可以被限制为仅适用于特定的板条箱名称。如果您想详细了解这些功能是如何规划和实施的，您可以查看我们相应的跟踪问题。 为了进一步增强 crates.io API Token的安全性，我们优先考虑了过期日期的实施。由于我们已经接触了大部分与令牌相关的代码，所以这相对简单。我们很高兴地宣布，我们的“新 API 令牌”页面现在支持端点范围、包范围和到期日期：图片引用自： Rust Blog   https://blog.rust-lang.org/images/2023-06-23-improved-api-tokens-for-crates-io/new-api-token-page.png原文链接：https://blog.rust-lang.org/2023/06/23/improved-api-tokens-for-crates-io.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2023/06/23/improved-api-tokens-for-crates-io.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-24 10:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "New API Token：改善crates.io上的API tokens" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Lemmy是一个自托管的社交链接聚合和讨论平台。它完全免费、开放，不受任何公司控制。这意味着没有广告、跟踪或秘密算法。内容被组织成社区，因此很容易订阅您感兴趣的主题，而忽略其他主题。投票用于将最有趣的项目带到顶部。同时，Lemmy 也不仅仅是 Reddit 的替代品；它是一个由不同人和组织运营的相互关联的社群网络，所有这些社群结合起来创建一个充满您最喜欢的新闻、文章和迷因的独立且个性化的首页。Lemmy v0.18.0    https://join-lemmy.org/news/2023-06-23_-_Lemmy_Release_v0.18.0Lemmy Repo   https://github.com/LemmyNet/lemmy" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/LemmyNet/lemmy" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-24 10:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Lemmy v0.18.0 版发布：用Rust编写的Reddit替代品" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "以下是Wasmer 4.0 的一些特性，进行简单列举：\n允许插入自定义运行器的新运行器架构\n更加稳定的 WASIX\n将 WAPM 统一为 Wasmer\nWasmer 集成 Wasmer Edge\n同时，你可以在 CLI 中 快速使用  Wasmer CLI 4.0 ：原文链接：https://wasmer.io/posts/wasmer-4.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://wasmer.io/posts/wasmer-4.0" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-24 10:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Wasmer 4.0 版发布：" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ESP32C3 微控制器中的远程控制收发器 (RMT) 外设提供了一种简单高效的方式来发送和接收远程控制信号。它通常用于红外 (IR) 远程控制系统等应用。RMT 可以产生可编程脉冲模式，具有内置载波调制，并支持多个发送和接收通道。虽然 ESP32C3 微控制器中的 RMT 外设主要设计用于远程控制应用，但它也可用于涉及生成和接收脉冲串信号的其他用途。这包括但不限于以下应用程序：传感器接口、LED 控制、信号生成以及定时和同步。在这篇文章中，我将构建一个使用 RMT 在两个不同引脚上生成两个不同波形的应用程序。我还将利用 Wokwi 逻辑分析仪来验证/监控引脚的输出。原文链接：https://apollolabsblog.hashnode.dev/esp32-embedded-rust-at-the-hal-remote-control-peripheral?ref=twitter-share阅读更多：https://wokwi.com/projects/366942397702382593" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://wokwi.com/projects/366942397702382593" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-24 10:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust嵌入式：RMT 外设在 no_std Rust 中生成自定义波形" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果您是活跃的rustlang贡献者，您可以申请Rust 基金会奖学金，申请截止时间为 6 月 30 日晚上 11:59（太平洋时间）图片来自：https://twitter.com/rust_foundation/status/1672012091023056897/photo/1申请链接：https://foundation.rust-lang.org/grants/fellowships/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://foundation.rust-lang.org/grants/fellowships/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-24 10:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "申请Rust基金会的奖学金" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Exograph 允许你使用声明的方式，创建灵活、安全和高效的 GraphQL 后端，提供 Query 和 Mutation API 。 Exograph 还提供涵盖开发生命周期各个阶段的工具，从开发到部署再到维护。GitHub- exograph ：https://github.com/exograph/exograph" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/exograph/exograph" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-23 00:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Exograph：轻松构建 GraphQL 后端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在使用 Rust 开发原生 Python 扩展时，必须解决一些问题，使其能够适用于各种环境。这篇文章从 CI/CD 和发布入手，演示了如何使用 Maturin, Manylinux & Docker 构建原生 Python 拓展，并展示了构建更复杂扩展的方法。作者此前还撰写了一篇 Documenting Native Python Extensions Made With Rust and PyO3 介绍了如何为使用 Rust / PyO3 构建的原生 Python 拓展创建相应的文档。https://blog.savant-ai.io/documenting-native-python-extensions-made-with-rust-and-pyo3-227aff68e481Building Portable Native Python Extensions With Rust, PyO3, And Maturin ：https://blog.savant-ai.io/building-portable-native-python-extensions-with-rust-pyo3-and-maturin-3c1a1634d324" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.savant-ai.io/building-portable-native-python-extensions-with-rust-pyo3-and-maturin-3c1a1634d324" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-23 00:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "文章：使用 Rust、 PyO3 和 Maturin 构建可移植的原生 Python 扩展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 500: https://this-week-in-rust.org/blog/2023/06/21/this-week-in-rust-500https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/06/21/this-week-in-rust-500" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-23 00:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 500" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你可能已经看过了Lucas Palmieri的博客文章Are we observable yet? An introduction to Rust telemetry。如果你还没有看过，我们建议阅读一下，因为它提供了一个全面的介绍，介绍了如何处理 Rust 代码中的日志。https://www.lpalmieri.com/posts/2020-09-27-zero-to-production-4-are-we-observable-yet/然而，仅仅记录日志可能是不够的，特别是在分布式架构中。在 Quickwit 中，我们经常使用跟踪来理解性能瓶颈并提高速度。当我们遇到 Quickwit 的搜索响应缓慢时，我们经常会问自己：是什么导致了减速？是网络相关的问题，磁盘 I/O 还是过多的 CPU 使用？在本博客文章中，我们将展示如何为 Rust 应用程序进行测量，并生成跟踪数据，从 DevOps 视角利用它们。我们的目标将是双重的：\n使用广泛认可的 Jaeger UI 分析跟踪，以获取有关应用程序行为的见解。\n从这些跟踪数据中派生 RED（速率、错误和持续时间）指标，并在 Grafana 中监视它们。如果您想进一步了解，我们建议参考以下资源：Weaveworks 的 RED 方法和 Google SRE 书籍中有关监控分布式系统的部分。\n现在，让我们深入介绍步骤，其中我们将涵盖以下关键方面：\n为使用 Actix 构建的简单 Web API 进行测量。\n将您的跟踪和指标数据推送到 Quickwit。\n在 Jaeger UI 中检测、诊断和解决问题。\n在 Grafana 中监视您的应用程序的 RED 指标（速率、错误、持续时间）。\n在深入了解之前，请确保您的系统上已安装并正确运行以下软件：\nRust 1.68+\nDocker\n如果您仍在运行旧版本的 Docker，则需要安装 docker-compose。\n我们将使用 Actix Web 框架创建一个基本的 Rust 应用程序。这个应用程序是一个包含单个端点的 Web API。它将从受欢迎的 JSONPlaceholder 公共 Web API 获取帖子及其评论，并将它们显示为 JSON。为了更好地了解我们的应用程序生命周期并可能优化它，我们将确保测量以下例程：https://actix.rs/\n从 /posts 获取帖子。\n获取每个帖子的评论 /posts/1/comments\n创建一个名为 rust-app-tracing 的新目录。在终端中切换到该目录，并运行以下命令初始化一个新的 Rust 项目。让我们还要确保在 web-api/Cargo.toml 文件中拥有所需的依赖项。\nactix-web：用于在 Rust 中构建 Web 应用程序的快速 Web 框架。\nactix-web-opentelemetry：actix-web 框架的 open-telemetry 扩展。\nopentelemetry：Rust 的核心 open-telemetry SDK，包括跟踪和指标。\nopentelemetry-otlp：提供各种 open-telemetry 导出器的 crate。\nreqwest：提供一个直观的 API 来进行 HTTP 请求。\ntokio：为我们的应用程序提供异步运行时。\n首先，让我们通过创建一个名为 telemetry.rs 的文件来配置应用程序跟踪，我们将在其中处理所有跟踪配置。Copy接下来，我们将实现我们的 API 端点，并在处理程序函数中添加一些测量代码。重要的是要注意，我们的重点不在于此应用程序的功能，而在于从应用程序生成有意义且可利用的跟踪数据。首先，我们有一些模型文件，允许我们对 post 和 comment 进行序列化和反序列化。接下来，让我们处理 API 端点处理程序。请注意，某些函数上装饰有 instrument 属性。这是我们如何在处理程序函数和它用于执行任务的后续函数上启用跟踪的方法。在上面的片段中，我们仅发送跟踪。也可以使用可靠的日志收集器来收集日志并将其发送到 Quickwit 或其他后端。https://quickwit.io/docs/log-management/supported-agents现在我们已经构建了应用程序。让我们与 Quickwit 一起运行，并确保生成的跟踪被 Quickwit 索引。与我们在之前的博客文章中所做的不同，我们将创建一个 docker-compose 文件来简化 Quickwit、Jaeger 和 Grafana 之间的设置。以下 docker-compose 文件包含所有必要的配置。https://quickwit.io/blog/quickwit-as-official-jae" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://quickwit.io/blog/observing-rust-app-with-quickwit-jaeger-grafana" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-20 21:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Quickwit、Jaeger和Grafana监控您的Rust应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章中讨论了 Rust 中的静态,动态的内存布局,所有权和借用模型，以及如何使用它们来管理内存。文章还讨论了 Rust 中的生命周期和引用，以及如何使用它们来避免内存泄漏和数据竞争原文链接https://dev.to/aneshodza/memory-in-rust-5g7e" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-19 17:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中的内存管理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "lz4_flex 是一个 Rust 编写的 LZ4 压缩库. 目前 0.11 发布, 此版本性能有巨大提升, 几乎全面超越 c++版本的实现.原文链接https://flexineering.com/posts/lz4-011/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-19 17:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "lz4_flex: 0.11发布,性能提升" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "heapless 库是 Rust 的一个库，它提供了一些数据结构，这些数据结构可以在固定的内存大小下工作。这些数据结构包括 Vec、String、Deque 等。heapless 库的一个主要特点是，它的数据结构是由静态内存分配支持的。这意味着，你可以使用 heapless::Vec 来代替 std::Vec，它具有固定的容量，但是不能在运行时重新分配内存github地址https://github.com/japaric/heapless" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-19 17:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "heapless: 无动态内存分配的数据结构" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个关于 unsafe Rust 主题的油管视频, 视频主要涉及以下三个方面:\nRaw Pointers\nDereferencing Raw Pointers\nstatic mut\n油管视频https://www.youtube.com/watch?v=w2IcN33HNAk--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-19 17:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "unsafe Rust: raw pointer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-18 23:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2023第三届中国Rust开发者大会" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "变更日志：\n添加数据修剪支持\n添加邮件目录存储\n向 API 添加删除消息\n添加 TLS 支持\n添加 SMTP 普通身份验证支持\ngithub: https://github.com/mailtutan/mailtutan/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-18 23:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "发布 Mailtutan v0.3.0 - 用于测试和开发环境的 SMTP 服务器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Kani 是一个开源验证工具，它使用模型检查来分析 Rust 程序。Kani 对于验证 Rust 中的不安全代码块特别有用，其中编译器不检查“不安全的超级大国”。https://model-checking.github.io/kani/tool-comparison.html以下是版本0.30.0中的新功能摘要：https://github.com/model-checking/kani/releases/tag/kani-0.30.0\n在https://github.com/model-checking/kani/pull/2495中删除 @celinval 存根中的 --harness 要求\n通过@celinval 在[https://github.com/model-checking/kani/pull/2507(https://github.com/model-checking/kani/pull/2507)中为 cargo kani 添加目标选择]\n通过@celinval 在https://github.com/model-checking/kani/pull/2512更新 Cbmc 版本\n通过 @zhassan-aws 在https://github.com/model-checking/kani/pull/2456将 Rust 工具链升级到 2023-04-30\n完整更新日志：https://github.com/model-checking/kani/compare/kani-0.29.0...kani-0.30.0Github：https://github.com/model-checking/kani" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-18 23:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Kani 0.30.0 已经发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章从一个以 IDE 为中心的教程快速开始，需要很少的预备知识。如果你有一个 Rust 项目并且想弄清楚如何拆分文件，那很好。这篇文章将深入细节，让你了解在 Rust 中文件和模块加载的原理。原文链接，https://schneems.com/2023/06/14/its-dangerous-to-go-alone-pub-mod-use-thisrs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://schneems.com/2023/06/14/its-dangerous-to-go-alone-pub-mod-use-thisrs/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-18 11:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Rust 中 use 和 mod 究竟做了什么？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "redb，是一个 Rust 实现的简单、便携、高性能、ACID、嵌入式 KV 数据库，受到 lmdb 的启发。它提供了与其他嵌入式 KV 数据库（如 rocksdb 和 lmdb）类似的接口，但不是像 sqlite 这样的 SQL 存储。官网，https://www.redb.org/1.0.0，https://github.com/cberner/redb/releases/tag/v1.0.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/cberner/redb/releases/tag/v1.0.0" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-18 11:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "嵌入式 KV 数据库 redb 发布 v1.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "AI 应用程序数据库 PostgresML，在其最新博客表示 PgCat(Postgres Pooler) 的 Prepared Statements 功能可以将 Postgres 的速度提高 30%。原文链接，https://postgresml.org/blog/making-postgres-30-percent-faster-in-production" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://postgresml.org/blog/making-postgres-30-percent-faster-in-production" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-18 11:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Postgres Pooler 使生产环境的 Postgres 的速度提高 30%" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "照片直播链接，https://as.alltuu.com/album/1541620079/?from=link&menu=livehttps://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://as.alltuu.com/album/1541620079/?from=link&menu=live" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-18 11:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "彩蛋：RustChina Conf 2023" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "根据LibHunt网站Rust主题下有关统计，这里列出前5个Rust Top开源项目：deno、rust、tauri、alacritty、rustdesk。阅读更多：Top 23 Rust Open-Source Projects  https://www.libhunt.com/topic/rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.libhunt.com/topic/rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-16 22:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "推荐23个Rust Top开源项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "🦀 😍" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-16 22:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tweets：找一本可以解决世界饥饿问题的书" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-16 22:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust在Stack Overflow上连续8年成为最受欢迎语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust-drive-ai是用Rust和Bevy游戏引擎构建的一个自动驾驶 AI 模拟小游戏，它底层使用了神经网络和遗传算法。Reop：https://github.com/bones-ai/rust-drive-ai" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/bones-ai/rust-drive-ai" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-16 22:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-drive-ai：由Bones AI发布的有趣的自动驾驶小项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "社区的同学们，讲讲你们学习C++的故事吧👀为什么不学习Rustlang呢？" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-16 22:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "看图说故事！ Why not Rust？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "P0 赶往会场进行准备P1 开始拆包裹P2  吃饱才能开工P3 开始分装礼袋P4 生成你的专属海报想要生成自己的专属海报，戳： https://code.flows.network/lambda/J6RGvttSM9本海报的前后端都部署在 flows.network 平台上，都在 WasmEdge 里运行，@Second State         https://mp.weixin.qq.com/s/W7RK_ud3QKp4xbqKdAQ4Kg期待明天同大家面基😁！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://code.flows.network/lambda/J6RGvttSM9" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-16 22:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "今日彩蛋：忙碌的RustChina Conf 2023会前准备" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "promethes 是我们常用的监控系统之一，下面是一个使用 rust_client 的🌰:\n更多使用示例\nOpenAI Hub 是一个全面而强大的工具，旨在简化和增强您与 OpenAI 的 API 的交互。它采用创新的方式来平衡多个 API 密钥，允许用户在不需要单独的 OpenAI API 密钥的情况下发出请求。此外，它还采用全局访问控制列表 (ACL)，使您能够控制用户可以使用哪些 API 和模型。该集线器还包括用于安全可靠的用户身份验证的 JWT 身份验证，现在还包括用于跟踪 API 使用情况和令牌消耗的访问日志功能。主要特征\n负载平衡：有效利用多个 API 密钥，防止过度使用任何单个密钥。\nAPI 密钥保护：允许用户在不需要单独的 OpenAI API 密钥的情况下发出请求，从而增强安全性和易用性。\n全局 ACL：规范用户对特定 API 和模型的访问，确保合适的人可以访问合适的资源。\nJWT 身份验证：使用 JSON Web 令牌 (JWT) 的安全可靠的用户身份验证系统。\n访问日志：使用我们新实施的访问日志功能跟踪 API 使用情况和令牌消耗。您可以选择将日志存储在文件、SQLite、MySQL 或 PostgreSQL 后端。\nor\nhttps://github.com/lightsing/openai-hub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-15 21:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "最近Dioxus团队在RustNL分享了他们最新的进展，并且演示了Dioxus的一些功能，包括热重载、移动端支持等。热重载部分的演示相当惊艳，在视频的38:46处，感兴趣的可以看一下。视频: https://www.youtube.com/watch?v=aSxdmXjZutI" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=aSxdmXjZutI" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-15 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "跨平台的GUI框架 Dioxus" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用Rust开发的代码编辑器今天公布了开源计划，将会在接下来几个版本的zed里逐步开源，最终目标是让大家能够通过zed编辑器本身给zed项目做贡献。详情: https://zed.dev/blog/open-sourcing-zed-on-zed值得关注的是，zed编辑器使用的名为GPUI的gui框架，本身也是warp终端使用的。目前就zed和warp的使用体验而言，已经是可用的状态了，这次zed开源，该框架应该也会一同开源。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://zed.dev/blog/open-sourcing-zed-on-zed" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-15 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "zed 编辑器计划开源" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 499: https://this-week-in-rust.org/blog/2023/06/14/this-week-in-rust-499/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/06/14/this-week-in-rust-499/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-15 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 499" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Mailtutan 是一个用 Rust 构建的 SMTP 服务器。它允许您模拟 SMTP（简单邮件传输协议）服务器，以进行测试和开发，而不必向实际地址发送电子邮件。该服务器支持同时支持多个客户端连接，它还提供了一个 Web 界面和 REST API 来查看电子邮件列表，并使用 WebSockets 实时更新 Web 界面。Mailtutan 的实现非常轻量级和高效，Docker镜像小于2MB。它支持多种存储选项：内存（默认），Maildir（文件中）。可以通过下面的命令快速安装:\ncargo install mailtutan\ndocker run -p 1080:1080 -p 1025:1025 -d mailtutan/mailtutan:latest\ngithub地址https://github.com/mailtutan/mailtutan" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-13 21:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Mailtuta: 一个轻量的 SMTP 服务器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个库是 libtracecmd 的 Rust 包装器，允许您编写程序来分析由 trace-cmd 记录的 Linux 的 ftrace 数据。（要在程序中使用此包，您需要在系统上安装 libtracecmd>=1.2.0）。例如：首先使用 trace-cmd 记录各个 syscall 的调用情况，这将得到一个名为 trace.dat 的记录文件：trace-cmd record -e syscalls sleep 10运行下面的指令，使用仓库中的 top_n_events 示例，统计每一个 syscall 的调用次数：cargo run --example top_n_events -- --input trace.dat --n 10 --prefix sys_enter_最终的输出如下所示：更多内容请阅读原文github地址https://github.com/mailtutan/mailtutan" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-13 21:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "libtracecmd-rs: libtracecmd 的 rust 封装" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "非常好的Rust系列文章，通过生成的汇编代码，让你了解很多Rust内部的工作机制。例如文章有原文链接https://www.eventhelix.com/rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-12 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust到汇编：了解 Rust 的内部工作原理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个库是libtracecmd的Rust wrapper，它允许编写程序来分析由trace-cmd 生成的Linux的ftrace数据。github地址https://github.com/google/libtracecmd-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-12 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "libtracecmd-rs: google发布的 libtracecmd Rust wrapper" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cells是一款单人游戏，灵感来自用Rust编写的 agar.io。github地址https://github.com/psincf/Cells" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-12 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cells" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一系列Rust学习教程， 本文是第3章， 函数的介绍。原文链接https://dev.to/fadygrab/learning-rust-03-the-basics-functions-4d92--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-12 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust学习系列: 函数" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是我一直在研究的 Rust 中的 Telegram Bot 框架。我尝试了其他 Rust 库，但我发现它们对于我正在构建的机器人类型来说过于原始或过于具体。它带有 Telegram Bot API 的完全原生实现，并且：\n支持消息、频道、贴纸、回调等的原始电报 API。\nWeb 框架样式的路由 API，支持基于消息的路由和嵌套处理程序堆栈。\n简单的应用程序状态管理。MOBOT 确保您的处理程序获得每次聊天的正确状态。\n集成测试基础架构 (FakeBot)，以简化为您的机器人编写单元测试。\n支持进度条、内联键盘、“正在打字……”指示器等。\n观看使用 crate 的系统管理员机器人的演示视频mobot。https://i.imgur.com/Gn2VfKH.mp4" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-11 22:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MOBOT 的第一个版本，这是一个 Rust 中的 Telegram Bot 框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "亲爱的 Rust 社区，我很高兴地宣布 Nickel 1.0 的发布，这是一种用 Rust 开发的配置语言。它在某种程度上是一种通用但领域特定的语言，Nickel 专门用于生成配置（例如，通常评估为 YAML 或 JSON），但比纯序列化格式更具表现力，使配置可重用、可维护等正确（特别是选择加入静态类型和运行时合同）。它适用于任何类型的配置，但典型的用例会相当大且复杂，例如基础架构即代码部署或构建系统。https://www.tweag.io/blog/2023-05-17-nickel-1.0-release/除了作为 Rust 代码库之外，我认为社区可能会感兴趣，因为它特别容易用作Rust 应用程序的本机配置语言，这要归功于serde. 例如，参见模块的测试deserializer，它直接从 Nickel 源反序列化 Rust 结构和枚举：https://github.com/tweag/nickel/blob/dc6804acd123257460eef60d615da2eb0a8aca78/src/deserialize.rs#L584很高兴收到任何建设性的反馈和意见。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-11 22:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Nickel 1.0，一种用 Rust 编写（并可用）的配置语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，我想分享一个用 Rust 编写的新项目，它是一种新的查询语言，语法类似于 SQL，可以在不创建任何新文件的情况下对 .git 文件执行查询Github：githuto b.com/amrdeveloper/gqlhttps://github.com/amrdeveloper/gql有关想法和实现的更多详细信息，您可以查看这篇文章https://itnext.io/how-i-created-a-query-language-for-git-files-gql-fc431949dc4c更多样品" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-11 22:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GQL：一种用 Rust 编写的 .git 文件的查询语言" }, "type": "text" }], "type": "title" } },]
