export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "今日头版" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "两年半的时间，我们一期期走来，到了今天发行的第1000期。回想我第一次看《Rust日报》，还是在Rust 2018刚推出的时候。丰富的新闻和思考让我眼前一亮，我慢慢开始喜欢这样的报纸。每天浏览日报，已经成为许多Rust爱好者的生活习惯。Rust日报社很高兴能和读者们共同进步，也很乐于见到更多的企业、研究团队开始关注这门编程技术。希望在未来的时间里，我们能更好地推广Rust语言，传递更多的社区开发知识，第一时间传播各地Rust开发者的动态和新闻。加油，Rust爱好者们！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《Rust日报》第1000期，感谢有你" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "生态圈" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Apache Arrow项目定义了基于内存的数据格式，致力于解决系统与系统间的数据传输问题。目前此项目已经发布了重大的更新v2.0.0版本，其中包含的Rust子项目尤为重要。Apache Arrow PMC认为，Rust实现正在缩短与C/C++实现的功能差距，慢慢赶上功能最多的Java、C/C++版本。本次更新的重点包含很多个模块。核心的“Arrow”模块包含了数据的表示，更新增加了原始类型数组的支持，现在它能从一个迭代器里被加载和转换。实现内部现在使用动态长度的数组，来统一32、64位平台间的差异。Arrow的运算内核也有了较大的改进，添加了大量针对字符串、整数的函数。运算内核现在能使用SIMD，将性能提升到五倍以上。针对不含空变量的数组，一些计算内核也有了优化，明显地提高了速度。另外，更多的计算内核被优化，来降低内存复制的次数。其它的优化包括增加了Array trait的应用程序接口，方便确认数组已经分配的内存大小。针对列式存储格式Parquet的写入器也正在制作中。这个写入器包含重要的提升，比如支持嵌套的Arrow类型，和针对空值写入的优化等等。另外，更新也面对Arrow之上编写的DataFusion模块，它是一个查询器引擎，支持DataFrame和SQL两种接口。它现在支持更多的DataFrame接口，它的实现也综合利用了async/await语言特性，相比直接使用线程，它能优化多线程表现。Arrow IPC是进程间交互和序列化的格式。Apache基金会在网站上描述了这个格式，期望包括在流中和文件中，交换Arrow数据的应用程序都使用这个格式。从前的1.0.0版本已经更新到了Arrow IPC的第五版，也有对第四版的兼容性设计。在全新的2.0.0版本，Arrow使用Rust语言实现这个数据格式，正在支持最新的第五版标准。Arrow项目期望在下一个版本前，支持稳定的Rust发行版，支持更多的运行平台，提高和其它语言的兼容性。它是一个开源项目，欢迎所有的开源软件开发者提供支持和帮助。Apache Arrow项目主页https://arrow.apache.org/blog/2020/10/27/rust-2.0.0-release/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "内存数据交换格式Apache Arrow发布了v2.0.0版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "知名集成开发环境公司Jetbrains更新了IntelliJ Rust开发插件。现在，IDEA企业版和RubyMine软件都已能在Windows平台上开发，虽然目前只支持MSVC工具链，并且需要安装特殊的插件。另外，加载项目的每个步骤，都在软件的“同步”栏界面有一定的显示，能更方便地查找项目加载中可能的错误。一些小的功能更新包括，针对Rustc编译器、Clippy静态检查软件的代码补全已经被支持。在Cargo.toml配置文件中，可以通过“跳转到定义”功能，查找当前包特性的定义来源。使用F6按键的重构代码不仅支持跨文件、目录的移动，还能移动到另一个包。内置的Rust REPL工具提供了新的“:clear”命令，可以清空界面变量的类型信息。本次更新还包括更多的修复，包括非零类型在调试中的显示、移动语义项时较好地处理换行，以及帮助新的开发者设置工具链等等。IntelliJ Rust在项目主页中，详细地说明了本次更新的所有修改和有关信息。IntelliJ Rust项目主页https://intellij-rust.github.io/2020/11/02/changelog-134.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "IntelliJ Rust发布第一百三十四期更新公告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "广泛应用的rust-analyzer代码分析软件发布了本次更新公告。现在，VSCode插件的内联提示将使用更小的字体，来提高类型提示等的可读性。遇到JSON-RPC的错误，现在将会产生可控的错误提示，而非直接停止运行。本期更新包括一定量的修复和内部提升。语法高亮模块已做少量更改，来修复一种较为不常见的尖括号高亮错误问题。语句开头的负号也得到了高亮提示。针对特定模块的可见性描述符，它的表示模块做了一定修复，包括一些针对内联提示的语法高亮提示。在包根部的全局标签现在能被正常识别。现在，结构体的文档测试也已经被支持。这次更新内部的优化包括更新依赖库LSP的版本，和更新Rust trait解析器chalk的版本号。Rust-analyzer项目主页https://rust-analyzer.github.io/thisweek/2020/11/02/changelog-49.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust-analyzer发布第四十九期更新公告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者@BlackBinary编写了这个项目。async-smux实现了smux网络协议，允许我们复用同一条TCP连接，以构建在其上的多个TCP套接字。项目合理运用Rust语言的async/await语法，相比现有的Go语言实现，吞吐量提升到两到三倍，握手速度也达到一至两倍。项目接口包装友好、易于使用，已经发布到crates.io网站，并且使用MIT协议开源。async-smux项目主页https://github.com/black-binary/async-smux" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-smux：异步TCP连接流复用软件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rocket框架的作者塞尔吉奥·贝尼特斯编写了Figment项目。Figment是能从多个配置源中，提取配置信息并整合的库，比如从多个不同类型的配置文件。项目以Apache-2.0/MIT双协议在GitHub上开源。Figment项目主页https://github.com/SergioBenitez/Figment" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Figment：半分层多源配置库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "开发者乌格拉罕·阿阔克发布了这个汇总项目。Rust语言在生态上的期望涉及到方方面面，包括网页、机器学习和游戏应用，也包括基础的图形和异步编程等等。项目给出了一系列的汇总，标记出Rust在这些领域的进度和发展状况，以供开发人员和贡献者参考。项目主页https://github.com/UgurcanAkkok/AreWeRustYet" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我们能用Rust了吗？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "思想碰撞" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust语言的泛型是在编译时单型化的。也就是说，编译器会复制需要泛型的源代码，填入具体的类型，然后再生成目标代码。这样生成的泛型代码运行速度较快，但牺牲了目标代码的体积。这是因为，如果我们的泛型可能性非常多，每个具体的类型，都需要完整地复制原有的泛型代码。最终生成的二进制文件中，每个类型都对应一部分一模一样的代码。Possible Rust网站给出了一种解决方案，尝试解决这种问题。方案认为，可以把函数的非泛型部分置入函数内部，分为母函数和子函数。母函数具有泛型参数，它将简单转换泛型参数为非泛型的，然后传给非泛型参数的子函数里。这样对所有的类型，只需要生成一个共同的子函数，然后生成多个简单的转换函数即可。通过这种方式，我们完成了同时节省时间和空间的目标。在具体的技术实现上，可以把子母函数并列位于模块中。但随着函数数量的增加，我们不得不小心命名私有的子函数，防止模块内的函数冲突。于是我们的考虑是，把子函数的定义放在母函数内部，这样就可以避免命名空间冲突了。这就构成了我们最终的“非泛型内部函数”的写法。文章还从中层中间语言（MIR）的角度，分析了不同写法下Rust编译器前端输出代码的差别。文章认为，目前这种“提取公因式”的优化还需要手工完成，但随着时间的推移，未来的Rust编译器可以自己完成优化步骤，不需要开发者额外关心——这将会是非常好的结果。Possible Rust网站https://www.possiblerust.com/pattern/non-generic-inner-functions" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "非泛型内部函数" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "EBU R.128是欧洲广播联盟发起的标准，定义了符合人类感知的响度标准和算法。为了计算统一的响度值，C语言的libebur128是常用的库。本次文章中，作者塞巴斯蒂安·德罗格将这个库移植到Rust语言，来为他的项目减少外部链接依赖的数目。作者的库参照了nnnoiseless的编写思路，使用了smallvec和bitflags两款小依赖。编写这个库，作者首先编写C库的Rust应用接口。然后替换其中较小的函数到Rust语言，并导出到C语言的二进制接口。替换二进制接口到Rust语言，最终更换所有的函数到Rust语言。在这之后，整个库已经迁移完毕，可以选择保留或取消C语言的接口。作者选用了bindgen工具，用于生成C库的Rust接口代码。这里，作者使用Rust语言里的结构体，慢慢替换C语言定义的类型。C语言的少量for语句，可以修改成Rust语言的迭代器语法。而后，作者使用Box类型的语法，编写导出到C语言的接口。为了测试编写的代码，作者需要比较输出的浮点数值，使用了quickcheck这款库。在C语言使用宏的部分，作者一部分使用了trait，来适配不同类型的同种函数。为了记录响度算法要求的历史记录，Rust语言带参数的枚举类型帮助了作者，运行时的“懒加载”作者使用了Rust标准库提供的Once类型，使用标准库提供的VecDeque结构体。最终，作者替换了应用程序接口，完成了重写过程。作者做了简单的性能测试，最终对相同的样例，Rust语言的实现只用了原C语言实现50%~70%的时间，显著地提升了处理效率。响度算法在广播电视、流媒体行业有一定的实际应用。人类倾向于听到响度更高的声音，于是节目制作人不惜牺牲动态范围，提高响度，以获取更多观众的注意。上世纪50年代开始，这场“响度大战”开始了，广告商、电视台不断拉高响度，观众只能调整音量来应对——久而久之，这样的军备竞赛开始影响观众的听觉和观感。最终，ITU-R BS.1770标准问世，各大国家、地区制定相应的音频技术规范，“响度大战”才最终结束。我国中央电视台的目标响度值为-24 LKFS±2LU。博客链接https://coaxion.net/blog/2020/09/porting-ebu-r128-audio-loudness-analysis-from-c-to-rust-porting-details/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust重写EBU R.128声音响度算法库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者德雷克·摩尔分享了它两年来的Rust开发经历。作者主要关注Rust在嵌入式处理器的运用，从开发到调试，包括宏、格式化到内联汇编，分享了很多Rust语言改进为开发带来的便利之处。Rust提供有别于传统C语言的思路，是丰富而功能强大的语言。作者认为，提升与Rust的关系将是他事业中最重要的部分。博客链接http://dtrace.org/blogs/bmc/2020/10/11/rust-after-the-honeymoon/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《蜜月后的Rust语言》" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "广而告之" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "SIMD是“单指令多数据流”运算技术的外文名称。这项技术通过引入较长的向量寄存器和指令，允许处理器使用单个指令同时处理多个数据。要达到这一点，每个处理器平台都给出了各不相同的指令集。Rust库团队发起这个小组，期望提出统一的std::simd包，在相同的程序接口下，涵盖尽可能多的处理器平台。“可移植SIMD”并不是完全涵盖的，它将是一个最佳实践的标准，期望作为自动向量化优化的补充，允许在更多场合下使用这一统一的加速技术。另外，如果用户的平台不支持SIMD指令集，它将默认转换为普通的标量运算指令。现在，“可移植SIMD”组织正在招收新的志愿者，帮助完成这一标准的开发和完善过程。这一组织的官方页面给出了目前的RFC草稿，和他们在Zulip协作软件上的联系方式。Rust语言官方博客https://blog.rust-lang.org/inside-rust/2020/09/29/Portable-SIMD-PG.html来自 日报小组 洛佳" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-03 15:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust库团队发起“可移植SIMD”小组" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "arc-swap 类似 Arc, 但是对于读多写少的场景进行了优化. 对于读来说, 他几乎是 lock-free的(除了每次线程的第一次access). 因此他可以在读多写少场景下提供非常高的吞吐, 例如 配置更新等场景.目前 arc-swap 终于要进入稳定版本了(当前还是 1.0-rc1)原文连接https://vorner.github.io/2020/10/31/stabilizing-arc-swap.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-02 17:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "arc-swap 即将进入 1.0 稳定版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 dtolnay的一个小玩具, 可以通过小测试的方式了解一下 Rust 的一些好玩的知识.dtolnay 是 anyhow, thiserror, cxx, paste 等一系列 crates 的作者.rust quiz地址https://dtolnay.github.io/rust-quizgithub地址https://github.com/dtolnay/rust-quiz" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-02 17:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Quiz: Rust 小测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果你想让一个 native的 Rust 程序运行在 web 上,能够接收输入并且能够渲染.那么可以继续阅读一下该文.作者通过详细的讲解, 来演示如何让一个使用 SDL2 和 OpenGL 的 native Rust 程序运行在 web 上.同时作者保证: 该文以及内部的示例代码会一直保持能够运行,为想了解的人提供一个合适的参考.原文链接https://blog.therocode.net/2020/10/a-guide-to-rust-sdl2-emscripten" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-02 17:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust + SDL2 + OpenGL: 让 native 程序运行在 web 上" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Qovery Engine 是一个 云 服务商的抽象层, 可以让你无缝快速的把程序发布到各个云平台上.现在支持 AWS, GCP, Azure 以及其他的云平台.该项目使用 Rust 编写, 使用 Terraform, Helm, Kubectl 以及 Docker 等来管理资源.github 地址https://github.com/Qovery/engine" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-02 17:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Qovery Engine: 让发布变的更容易" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "message-io 是一个异步的 message 库, 基于他, 可以快速的构建基于网络的应用.适用的目标:\n构建基于 tcp/udp 协议沟通的应用.\n想构建多人游戏(server or client).\n不想处理并发或者 socket 连接细节.\n想专注于处理 apps 之间的 messages, 而不是如何传输.\ngithub地址https://github.com/lemunozm/message-io" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-02 17:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "message-io: 异步 message 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是<<从零到生产>>的新一章.这一章主要讲述如何发布我们的程序到生产环境中. 文中以发布到 DigitalOcean 为例, 讲述如何编写 Dockerfile, 打包镜像, 以及最终发布到 DigitalOcean的过程.感兴趣的后端同学可以看看.原文链接https://www.lpalmieri.com/posts/2020-11-01-zero-to-production-5-how-to-deploy-a-rust-application/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-02 17:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 程序的 CD (Continuous Deployment)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rustRapier是rust实现的2D/3D物理引擎，它还支持通过wasm在浏览器中使用。0.3版本新增了圆锥体、圆柱体碰撞过滤功能。Repohttps://github.com/dimforge/rapier" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-01 17:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rapier 0.3 released" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rustwaitfor 会阻塞直到指定的条件完成，如果有多个条件，可以在任何一个条件满足后继续运行。现在支持的条件类型有：\ndelay 在指定的时间后继续运行，watitfor --delay 1h10m20s\nexists 再找到制定的文件后继续运行，waitfor --exists foo.txt\nnot-exists 不存在文件时继续执行，waitfor --not-exists foo.txt\nget http请求结束后继续执行，waitfor --get 200,https://baidu.com\n如果有多个条件，比如：waitfor --delay 10m --exits foo.txt 表示任意一个条件满足后则继续执行。repohttps://github.com/aeshirey/waitfor" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-01 17:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "waitfor cli 应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust这是一本为后端开发写的书，书中介绍了完整实现一个Rust服务端应用的过程，包括前期技术调研，应用结构设计，可扩展性设计，如何编写测试，如何收集日志和跟踪信息，搭建一个鲁棒性强的持续集成和持续部署应用。Read Morehttps://www.zero2prod.com" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-01 17:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《Zero to production in Rust》" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#cliWebsocat 是一个用于websocket的Netcat、curl、socat工具。Examples:\n连结一个公众的echo服务 websocat ws://echo.websocket.org\n运行一个服务 websocat -s 1234\n在chromium中打开一个远程调试工具\n后台代理TCP到websocket\n在所有websocket客户端广播信息\nRepohttps://www.github.com/vi/websocat" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-11-01 17:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "websocat" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "colo是一个小型的CLI工具，可以显示颜色并在不同的颜色空间之间进行转换。它支持RGB、CMY、CMYK、HSV、HSL、LCH、LUV、CIELAB、Hunter lab、CIE 1931 XYZ和CIE YXY。非常感谢color_space包，这是colo用于转换的包！Github 链接，https://github.com/Aloso/colo" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Aloso/colo" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-31 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "colo" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在设计Rust代码时，我们能做什么来让它更容易测试？这是我所能找到的关于Rust测试的所有调查，特别关注为可测试性和正确性而设计。有些文章展示了在一个工作示例中需要做的多种事情，有些文章更侧重于一个特定的技巧。文章链接，https://alastairreid.github.io/rust-testability/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://alastairreid.github.io/rust-testability/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-31 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust可测性设计：一个调查" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rkvm是跨多台Linux计算机共享键盘和鼠标的工具。它基于客户机/服务器架构，其中服务器是控制鼠标和键盘并将事件(鼠标移动、按键按下……)传递给客户机的机器。通过可配置的快捷键在不同的客户端之间切换。Github 链接，https://github.com/Aloso/colo" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Aloso/colo" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-31 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rkvm" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个CLI工具，以图形的形式可视化任务之间的依赖关系。Github 链接，https://github.com/greyblake/xplanhttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/greyblake/xplan" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-31 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "xplan" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "字节的飞书团队从2017年开始就调研并采用Rust构建飞书跨平台sdk，在国内应该算是Rust工程师最多的团队，团队很nice，福利很棒，感兴趣的同学欢迎投简历：联系人wx：newpants629JD如下：跨平台研发工程师职位描述1、开发跨平台高性能native客户端核心组件；2、负责沟通及创作工具的系统设计, 实现, 优化和演进；3、研究分析主流 IM，优化实现方案，改进产品功能；4、负责设计和优化 IM 协议、弱网通信、推送、存储、网络并发、并行计算、加密以及安全等；5、保证工程质量和开发效率。职位要求1、良好的系统编程能力. 喜爱或有Rust经验、C/C++功底更佳；2、喜爱关注新技术, 愿意尝试更优解决方案；3、不设边界, 愿意探索了解事物运转原理；4、熟悉开源社区；5、热衷自动化完成事情；6、关注代码设计，有持续学习习惯。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-30 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "字节跳动飞书团队招聘Rust跨平台开发工程师" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者是Intellij Rust（使用Kotlin开发）和rust-analyzer（使用rust开发）两个项目的核心开发者之一，这篇文章作者在学习曲线、构建工具、生态系统、并发性、性能和安全性等方面对比Rust和Kotlin，认为Rust在复杂的应用开发中，开发效率丝毫不输Kotlin。链接：https://ferrous-systems.com/blog/rust-as-productive-as-kotlin/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ferrous-systems.com/blog/rust-as-productive-as-kotlin/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-30 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "For Complex Applications, Rust is as Productive as Kotlin" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者打算写三篇博客，记录他使用Rust编写的一个Mini编译器，这个编译器主要功能就是解析中缀算数表达式编译成WebAssembly。第一篇是讲词法分析，期待后续博客。链接：https://christine.website/blog/minicompiler-lexing-2020-10-29" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://christine.website/blog/minicompiler-lexing-2020-10-29" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-30 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust构建一个Mini编译器，从Lexer（词法分析器）开始" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "链接：https://levelup.gitconnected.com/rust-binary-tree-30efdd355b60" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://levelup.gitconnected.com/rust-binary-tree-30efdd355b60" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-30 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust手动实现一个简单的二叉树" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "公告原文：Rust 2020 中国大会，将于 12月26，27日在上海举办。本次大会由 Rust语言中文社区 主办，一年一度中国 Rustaceans 最盛大的节日。现在开始筹备。大会估计接收 30 个左右 Topics，观众报名售票会在12月开始。现在开始征集 Topic, 同时大会接受使用 Rust 或对 Rust 感兴趣的企业的赞助，赞助门槛不高，详情有意愿的朋友请与我联系沟通。也欢迎各同学朋友在所在公司大力宣传，把您的公司LOGO映在大会的赞助墙上！另外，线下场地有限，大会会同步进行网络直播，可免费远程观看（但是就没法享受线下聚会的各种福利好处咯~~）后续大会进展大家多多关心哦，一定精彩！！！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-29 23:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust China 2020" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "与 C/C++ 和其他本地语言一样，Rust 也可以对条件编译的支持。指示编译器是否在编译中包括或忽略一段代码的最常见方法是添加具有所需条件的cfg属性。IntelliJ Rust可检测项目中有条件禁用的代码块，并将其从代码库中排除。 更多请看博客原文：https://blog.jetbrains.com/clion/2020/10/intellij-rust-new-functionality-for-cargo-features/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-29 23:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "IntelliJ Rust插件更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "其实就是 ls 命令的化身，效果如下图，项目地址：https://github.com/willdoescode/nat" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-29 23:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "nat 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目前基于 tokio 实现的 Zookeeper client，完全使用 Rust 实现，项目地址：https://github.com/bonifaido/rust-zookeeper" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-29 23:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-zookeeper" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RISC-V指令集的SBI标准规定了类Unix平台下，操作系统运行环境的规范。目前，RustSBI项目已获得SBI编号4，代表它已经被收录入RISC-V SBI标准。RISC-V架构中，存在着定义于操作系统之下的运行环境。这个运行环境不仅将引导启动RISC-V下的操作系统，还将常驻后台，为操作系统提供一系列二进制接口，以便其获取和操作硬件信息。RISC-V给出了此类环境和二进制接口的规范，称为“操作系统二进制接口”，即“SBI”。规范定义了跨核软中断IPI、跨核页表刷新RFENCE、硬件线程监视器HSM等模块，构成二进制接口的各个部分，以支持在其上的操作系统正常工作。RustSBI项目发起于鹏城实验室的“rCore代码之夏”活动，它是完全由Rust语言开发的SBI实现。目前，它支持RISC-V SBI规范最新的v0.2版本，支持包含QEMU、勘智K210在内的多款平台。RustSBI有特殊的兼容性设计，以兼容以往版本的指令集和芯片。除了提供多款平台的二进制实现，RustSBI也可以作为组件库，帮助更多的SBI开发者适配自己的平台，或者开发更复杂的SBI实现。参考链接：https://github.com/riscv/riscv-sbi-doc/pull/61RustSBI项目主页：https://github.com/luojia65/rustsbihttps://crates.io/crates/pin-project)" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-29 08:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustSBI项目已进入RISC-V SBI标准" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "它使用File API在浏览器中完全呈现一个世界。它永远不会将您的世界上传到任何地方进行任何处理，而一切都在浏览器中进行。详情:https://www.reddit.com/r/rust/comments/jj6k9b/any_minecraft_fans_rust_and_wasm_to_map_minecraft/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/jj6k9b/any_minecraft_fans_rust_and_wasm_to_map_minecraft/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-29 08:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "有《我的世界》的粉丝吗? Rust和WASM在本地绘制Minecraft世界" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用rust-scriptRust文件和表达式可以像shell或Python脚本一样执行。功能包括：\n缓存已编译的工件以提高速度。\n读取嵌入Rust脚本的货运清单。\n通过Unix shebangs和Windows文件关联支持可执行的Rust脚本。\n使用表达式作为流过滤器（即用于命令管道）。\n通过脚本运行单元测试和基准测试。\n命令行表达式和过滤器的自定义模板。\n安装需要最新的稳定版Rust（1.47）。reddit:https://www.reddit.com/r/rust/comments/jjnyv1/rustscript_run_rust_files_and_expressions_as/rust-script:https://rust-script.org/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust-script.org/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-29 08:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "run-script: Rust 文件和表达式作为脚本运行" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "此前的Rustc编译器基于LLVM后端开发。由红帽、Mozilla和英特尔等公司组成的“字节码联盟”发布了编译器后端软件Cranelift，它致力于功能和安全性，并完全使用Rust语言构成。评论认为，相比于目前的LLVM后端，Cranelift小幅提高了调试模式的编译速度。Cranelift的另一特色是，可以重复利用输出的字节码值，以提高生成效率。这意味着，Rust编译器从前到后，从最底层的生成、优化后端，到语词法、软约束前端，已经有能力全由Rust语言自举。Cranelift最出名的应用是作为网页汇编（WebAssembly）的运行时，它是知名项目Wasmtime的后端，协助编译网页汇编代码到机器码，以此提供给网页浏览器，完成即时执行工作。GitHub合并请求 Reddit讨论帖https://github.com/rust-lang/rust/pull/77975" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-27 20:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "快讯：Cranelift已成为Rustc编译器的后端之一" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "开发者德米特里·斯迪潘诺夫发布了这个库，实现了有名的“头部相关传输函数”（HRTF）算法。这是一种空间音效定位的处理技术，它的实现原理非常复杂。人耳聆听自然界声音时，声音除了直接传导，还会通过耳廓、肩膀反射到人耳内；人的大脑能根据经验，判断得到音源的距离和方向。为了用虚拟空间的音源模拟这个过程，就应当使用特殊设计的算法处理音源，来得到真实的声场感。在空间听觉的研究和实现中，头部相关联的冲激响应（HRIR）占有十分重要的地位。这款处理库使用头部关联的冲激响应，创建一个三维空间内的点集，它们包含左、右耳的声谱，进而使用函数，处理输入的采样数据。默认的点集数据由44100赫兹频率下采样；对更多的频率，这款库将自动执行重采样操作，适应算法到用户需要的采样频率。这款库使用了重叠-存储卷积法完成运算过程，因此依赖于重量级的傅里叶转换库rustfft，需要使用较多的运算和内存操作。hrtf库使用MIT协议在GitHub开源。GitHub仓库地址https://github.com/mrDIMAS/hrtf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-27 20:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "hrtf：双耳空间音效定位处理库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "被广泛使用的Rust语言静态分析软件rust-analyzer发布了本次更新公告。现在，rust-analyzer的所有故障记录都能输出到人类友好的日志，源码中也为此完善了详细的注释。名字更长的项目和类型，能通过project.json文件指定更短的项目显示名称，以供开发环境显示和提示。不活跃的cfg宏标签现在将会高亮。细节的功能更新包括将字符串常量更换为字符常量、自动补全clippy的标签，以及填写借用类型函数参数时提示借用局部变量。本次更新还包括若干项内部优化和修复。rust-analyzer项目官网https://rust-analyzer.github.io/thisweek/2020/10/26/changelog-48.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-27 20:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust-analyzer发布第四十八次更新公告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Reddit网友发起了帖子，来论证Rust语言还不够完善和满意的地方。帖子收到了较多客观的讨论。网友认为，Rust语言的学习曲线较陡峭，编译速度有待提升，图形、音频等生态圈部分还需要更多的促进。从市场来看，Rust语言的工作岗位还不够多。另外，它一部分语言特性是其它语言没有的，需要第一次学习Rust的开发者适应和注意。Rust是一门优秀的语言，这也不妨碍我们客观审视它的各项特征，来更好地改进和优化它，也为新学习Rust的开发者提供有参考价值的帮助。Reddit贴文https://www.reddit.com/r/rust/comments/jia2xn/what_are_some_of_rusts_weaknesses_as_a_language/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-27 20:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "作为编程语言，Rust语言的弱点在哪里？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Pueue是一款任务管理器，允许并行或顺序地执行用户安排的任务，提供友好轻便的控制台界面。我们可以以Shell命令的格式输入任务，使用这款管理器能抽象它们，来得到更方便的功能。任务管理器Pueue和具体的某个终端没有关联，因此我们能从登录到系统的任何终端，调整和控制已经安排的任务。即使所有的终端断开了连接，任务也将继续进行。目前项目支持Linux和macOS操作系统，可以使用cargo安装。或者要下载编译好的可执行文件，可以通过NixOS、Homebrew和Arch Linux的AUR等包管理器安装。项目已经在GitHub上以MIT形式开源，项目主页提供了完善的使用说明书和文档。项目主页https://github.com/Nukesor/pueue" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-27 20:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "命令行任务管理器Pueue发布0.8.0版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "下面的 pull request 合并之后, Box 将会支持自定义的 allocators.Box 的定义将会从 Box<T> 变成 Box<T, A = Global>.github pull requesthttps://github.com/rust-lang/rust/pull/77187" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-26 17:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Box 即将支持自定义的 allocators" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "curl 是使用 C 语言编写的流行工具, 已安装在全世界 600 多万的设备上.前段时间, curl 开始尝试增加一个新的 backend, 该 backend 是 Rust 编写的 HTTP 库, Hyper.但是这并不意味着 curl 会用 Rust 重写. 除此之外, ISRG 的工程师也在尝试使用 Rusttls 作为一个 TLS 的 backend.原文链接https://www.infoq.com/news/2020/10/memory-safe-curl-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-26 17:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 的 Hyper 会让 Curl 变的更安全" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "名词解释:\nOIBIT, 全称 opt-in built-in traits, 他的另外一个名字我们比较熟悉 auto traits.\nspecialization, 是 nightly Rust 提供的一个 feature. 允许我们在 traits 实现有重叠的时候标记一个 default 的实现.\n阅读完本文,你将了解到:原文链接https://pwychowaniec.com/en/posts/imitating-specialization-with-oibits/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-26 17:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 OIBIT 实现 specialization 功能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 的 value 被 drop 之后,默认并不会变成零值的. 但是,在有一些高度安全的设备和行业中, 我们是不希望把一些敏感的信息在内存中停留时间超过他本该停留的时间, 由于上面特性, 会导致即使变量 drop 了, 数据仍然是在内存中的, 直到该内存重新被覆盖.crate zeroize 可以帮助我们来做到安全的设置数据为零值, 而且可以防止编译优化.本文主要介绍了 stack 变量和 heap 变量在使用 zeorize 的时候一个小陷阱.原文链接https://benma.github.io/2020/10/16/rust-zeroize-move.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-26 17:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "move/copy/drop 语义和 zeroing data 的一个小陷阱." }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Ungrammer 例子如下他和 EBNF 很像, 区别在于, Ungrammer 描述的是 concrete syntax tree, 是一系列数据或者一系列 trees.原文链接https://rust-analyzer.github.io/blog/2020/10/24/introducing-ungrammar.html--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-26 17:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Ungrammar : 描述 concrete syntax tree 的一种新形式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #cargocargo-wipe 是cargo的一个子命令，用来清除当前目录下的所有 target目录和node_modules目录。0.3版本添加了清除前后的文件夹大小对比功能。类似这样的工具还有node-prune用来清除node_modules文件夹。https://github.com/tj/node-pruneRepohttps://github.com/mihai-dinculescu/cargo-wipe" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-25 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cargo-wipe 0.3 release" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rustpart 1 dyn Classhttps://www.osohq.com/post/rust-reflection-pt-1part 2 dyn Attributehttps://www.osohq.com/post/rust-reflection-pt-2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-25 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为Rust构建运行时反射系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust一级（Tire-I）目标，意味着 ARM 架构将得到 Rust 的全面支持。Rust 目标 的 RFC 在三天前被合并，RFC: Promote aarch64-unknown-linux-gnu to a Tier-1 Rust target #2959https://github.com/rust-lang/rfcs/pull/2959Read Morehttps://github.com/rust-lang/rfcs/pull/2959" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-25 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RFC 2959：提升 Aarch64 Target 为一级" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "纵观游戏开发的历史，离不开GPU编程，其中最为重要的一个概念是Sharder language，即着色器语言。如今主流的着色器语言主要有三种：\n基于 OpenGL 的 OpenGL Shading Language，简称 GLSL;\n基于 微软DirectX 的 High Level Shading Language,简称 HLSL;\n还有 NVIDIA 公司的 C for Graphic，简称 Cg 语言\n然而，随着游戏引擎的发展，这些语言未能提供处理大型代码库的机制，与其他编程语言相比，这些语言普遍落后于形势。部分原因是它是小众市场的小众语言，部分原因是整个行业已经在现状上投入了大量的时间和精力。过去出现了很多优秀的语言，比如CUDA和OpenCL，但都没有能够替代GLSL和HLSL，也没有在游戏开发社区中获得任何明显的吸引力。而现在，来自瑞典斯德哥尔摩的Embark公司尝试希望通过rust-gpu这个项目，把Rust带到 GPU 编程领域，从而推动整个行业的发展。这个项目现在在社区反响很激烈，虽然还处在非常早期的阶段，但是值得期待！链接：https://github.com/embarkstudios/rust-gpu" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/embarkstudios/rust-gpu" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-23 21:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-gpu v0.1发布，尝试让Rust成为GPU编程的一等语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "部分岗位职责：\n\n参与Rust编译器前端、后端、分析工具的设计和实现。\n\n\n结合开源和闭源开发工具技术，专注于提供Rust编译器的改进，以支持Windows和Linux上的内部产品组。\n\n\n在Rust OSS社区中代表微软\n\n参与Rust编译器前端、后端、分析工具的设计和实现。结合开源和闭源开发工具技术，专注于提供Rust编译器的改进，以支持Windows和Linux上的内部产品组。在Rust OSS社区中代表微软链接：https://careers.microsoft.com/us/en/job/917051/Senior-Software-Engineer" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://careers.microsoft.com/us/en/job/917051/Senior-Software-Engineer" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-23 21:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "微软在招聘高级Rust工程师专注于改善Rust编译器和周边工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Armin Ronacher是Flask和Jinja2的作者，在Python社区具有很大影响力，多年前就拥抱了Rust社区。他目前是Sentry的技术总监，这篇专访Armin聊到了Sentry，Python和Rust等，可以看看。链接：https://evrone.com/armin-ronacher-interview" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://evrone.com/armin-ronacher-interview" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-23 21:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Flask作者、Rust社区影响力人物-Armin Ronacher专访" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "链接：https://medium.com/kata-containers/kata-containers-version-2-0-e45df4dd328" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://medium.com/kata-containers/kata-containers-version-2-0-e45df4dd328" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-23 21:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Kata-container 2.0的Agent全部用Rust重写" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "关于这件事reddit上有讨论，总得来说拿钱给开源社区干事，是一件好事。Reddit: https://www.reddit.com/r/rust/comments/jfkmxo/facebook_is_hiring_a_team_to_work_on_the_rust/推特: https://twitter.com/nadavrot/status/1319003839018614784" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://twitter.com/nadavrot/status/1319003839018614784" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-22 17:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Facebook正在招聘一个团队来研究Rust编译器和库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Lunatic是一组库和一个WebAssembly运行时，允许开发人员构建弹性的actor系统。目前还是早期阶段。Read More: https://kolobara.com/lunatic/index.htmlGithub: https://github.com/lunatic-lang/lunatic" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/lunatic-lang/lunatic" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-22 17:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Lunatic一个用于构建快速、安全和可扩展的actor系统的平台" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对于nightly通道的用户来说，通常在使用过程中会伴随着频繁的升级你的rust版本，而对于日常维护的项目，如果你升级了rust版本之后，target编译文件夹里面会生成多个版本的编译文件。这个时候就是使用cargo sweep的时候了，它会帮你清理掉除了当前版本以外的target目录下多余的文件。用例：cargo sweep -i -r -v ~/src\n-i 是开启保留~/src目录下target文件夹内当前电脑上已安装rust版本的编译文件。\n-r 是开启递归（recursively）搜索\n-v 是开启详细（啰嗦模式，开启之后会告诉你它干了啥。）\n如果你的电脑上没有cargo sweep，可以用以下命令安装：cargo install cargo-sweepRead More: https://www.reddit.com/r/rust/comments/jfdiao/tip_for_nightly_users_use_cargosweep_after/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/jfdiao/tip_for_nightly_users_use_cargosweep_after/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-22 17:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "给nightly通道用户的小提示：在更新rust之后使用cargo-sweep来帮助你清理垃圾" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者是一个很有经验的程序员，初次接触rust时，发现自己之前的经验并不足以很快适应rust，因此将这个过程记录了下来，并且分享了一些自己的感悟。Read More: https://thefuntastic.com/blog/fighting-rusts-type-system" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://thefuntastic.com/blog/fighting-rusts-type-system" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-22 17:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "与Rust类型系统做斗争：一个OOP程序员学习FP" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Atelier Assets是Amethyst游戏引擎的资产管理工具，现在Bevy宣布以后将要迁移资产管理到这个项目上面，无疑是一件好事。Read More：https://github.com/bevyengine/bevy/issues/708" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/bevyengine/bevy/issues/708" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-22 17:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy决定要将自身的asset系统迁移到Atelier Assets" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "流行的密码管理器 1Password 发布了 Linux 桌面客户端的首个 beta 版本。这是一个功能完整的 Linux 桌面应用，正式版本预计将在明年初释出。Linux 版本的后端是完全用 Rust 语言开发的，利用了 ring 加密库实现端对端加密。其主要功能包括：快速查找和智能搜索建议；新的外观；等等。Read More: https://blog.1password.com/1password-for-linux-beta-is-now-open/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.1password.com/1password-for-linux-beta-is-now-open/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-22 17:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "1Password for Linux 发布首个 beta 版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用 Rust 实现的玩具神经网络，灵感来自于 11行Python代码实现玩具神经网络https://iamtrask.github.io/2015/07/12/basic-python-network/原文链接：https://www.reddit.com/r/rust/comments/jf6t5v/toy_neural_network_in_rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/jf6t5v/toy_neural_network_in_rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-21 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 玩具神经网络" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/jf66eu/why_are_there_no_increment_and_decrement/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/jf66eu/why_are_there_no_increment_and_decrement/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-21 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Reddit 讨论：为什么 Rust 没有自增（++）和自减（--）运算符？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Iced：是跨平台的 Rust GUI 库https://github.com/hecrj/iced/（效果看起来还是很不错的）https://cryptowat.ch/apps/desktop" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://cryptowat.ch/apps/desktop" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-21 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "加密货币监测平台 Cryptowatch 推出基于 Iced 的客户端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://blog.thoughtram.io/lifetimes-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.thoughtram.io/lifetimes-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-21 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "博客：Rust 生命周期" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://www.youtube.com/playlist?list=PLDWmoWFf46givBRQmh5DyE27OsXMJPfag" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/playlist?list=PLDWmoWFf46givBRQmh5DyE27OsXMJPfag" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-21 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "视频：STM32 Rust 系列教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "€49.99 发布一条招聘信息https://rust.careers/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust.careers/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-21 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Careers : Rust 招聘网站" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 语言编写的，面向 中小型企业的 轻量级 开源 私有云平台。A light-weight 'private cloud solution' for SMEs, it can bring huge help and commercial value to start-up companies.面向中小型企业的轻量级私有云平台, 可快速生成各种虚拟机环境, 为产品兼容性验证和自动化测试提供高效的基础环境原文链接：https://gitee.com/kt10/ttstack" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-20 23:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "纯 Rust 写的私有云" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "职位描述：职位要求：Tel：18500632998（微信同号） 邮箱：summer@i-career.net（编者按：这个岗位描述和去年字节跳动发出的岗位高度一致，可能字节跳动还没有找到合适的员工。）" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-20 23:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 招聘" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "仓库：https://github.com/shadowsocks/crypto涵盖如下几类加密算法：\n硬件加速\n摘要算法\n分组对称加密算法\n序列对称加密算法（流密码）\n公私钥非对称加密算法\n认证加密算法（AE）\n非认证加密算法\n密钥派生函数（KDF）\n消息认证码（MAC）\n其它加密算法\n注意，该库和 rust-crypto是不同的两个 crate。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-20 23:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Crypto -- 又一个加密算法库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本福特定律，也称为本福特法则，说明一堆从实际生活得出的数据中，以1为首位数字的数的出现概率约为总数的三成，接近直觉得出之期望值1/9的3倍。推广来说，越大的数，以它为首几位的数出现的概率就越低。它可用于检查各种数据是否有造假。(来自百度百科)这篇文章通过验证本福特定律的方式来学习 Rust (入门级).大纲如下:\n本福特定律 介绍\nInstalling Rust\nSetting up the Project\nReading the Dataset\nLogging\nParsing the Dataset\nComparing Results\nError Handling\nCommand Line Arguments\n总结\n原文链接https://gliderkite.github.io/posts/learn-rust-with-benford/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-19 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "通过本福特定律来学习 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "shared-arena 是一个 memory pool. 当不停的申请和释放大量的相同 size 的数据时,memory pool 可以有效的减少 allocating 和 deallocating 的时间.github地址https://github.com/sebastiencs/shared-arena" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-19 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "shared-arena: 一个线程安全的 memory pool" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "xshell 是一个 Rust 库, 可以让你在 Rust 中优雅的调用和编写 bash 脚本.跨平台, 让你专注于 shell 脚本的编写.github地址https://github.com/matklad/xshell" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-19 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "xshell: Rust 中优雅的编写调用 bash 脚本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "timed 是一个新的 profiling 工具, 主要使用宏来标记需要 profile 的函数等.具有以下特性:\n支持 main\n支持 async\n支持多种 printer, 例如 println!, info! 或者其他自定义.\n支持chrome中的 tracing 展示结果.\ngithub地址https://github.com/y2kappa/timed--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-19 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "timed: 使用宏来profile你的程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "LSP现已成为开放标准，可以阅读以下内容了解更多有关 LSP的内容。微软支持的语言服务器协议致力于语言，工具的互操作性，新协议在不同的IDE和代码编辑器中一致地集成了多种语言。https://www.infoworld.com/article/3088698/microsoft-backed-langauge-server-protocol-strives-for-language-tools-interoperability.html谷歌开源了一个Vimscript Language Server 库：Repohttps://github.com/google/vimscript-language-server" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-19 08:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Rust中为vimscript / vimL语言实现语言服务器协议（LSP）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有趣~Proving that 1 + 1 = 2 in RustGisthttps://gist.github.com/gretingz/bc194c20a2de2c7bcc0f457282ba2662" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-19 08:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Rust中证明 1 +1 = 2" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "获取已挂载磁盘的信息（to get information on your mounted disks）Reophttps://github.com/Canop/lfs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-19 08:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "lfs：一个小而实用的list filesystems程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust实现的Supervisor二进制接口，运行在M-mode。这个项目最初是Code 2020活动的rCore Summer的一部分。现在它能够在广泛支持的RISC-V设备上运行rCore-Tutorial和其他操作系统。Github 链接，https://github.com/luojia65/rustsbi" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/luojia65/rustsbi" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-17 17:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustSBI" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "健康宏(Macro hygiene)是宏一个概念，支持在所有的上下文中工作。他们不影响周围，也不受周围任何事物的影响。理想情况下，所有的宏都是完全健康的，但是有很多陷阱使得很容易意外地编写不健康的宏。了解module模块。首先，稍微讲一下Rust模块系统的细节，特别是路径;以后了解这个很重要。文章链接，https://gist.github.com/Koxiaet/8c05ebd4e0e9347eb05f265dfb7252e1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gist.github.com/Koxiaet/8c05ebd4e0e9347eb05f265dfb7252e1" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-17 17:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何编写健康的rust宏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个简单的时间通知实现。允许您订阅带有回调的事件，并触发这些事件。事件的形式是(字符串、值)，回调是接受值参数的闭包形式。代码示例Github 链接，https://github.com/Dylan-Kerler/event_emitter_rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Dylan-Kerler/event_emitter_rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-17 17:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "event-emitter-rs" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们在BitBox02硬件的固件中广泛使用rust。在这样的安全设备中，您不希望将敏感材料留在内存中超过必要的时间。特别是，当删除该值时，应该用零安全地覆盖内存，以减少内存泄漏的风险。zeroize是一个包，被设计使这项任务容易和安全。文章链接，https://benma.github.io/2020/10/16/rust-zeroize-move.htmlhttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://benma.github.io/2020/10/16/rust-zeroize-move.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-17 17:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust的move/copy/drop语义和数据归零的陷阱" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tag1首席执行官Jeremy Andrews创建的负载测试软件Goose自创建以来已进行了许多改进。 最显着的改进之一是添加了 Gaggles。设计思路以及使用相关请看原文：https://www.tag1consulting.com/blog/using-gaggles-distribute-your-load-testingGaggles 是受 Locust 启发的 Rust 负载测试工具。 用户行为是使用标准 Rust 代码定义的。 负载测试是依赖于 Goose 库的应用程序。 Web 请求是使用 Reqwest HTTP 客户端发出的。项目地址：https://github.com/tag1consulting/goose" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/tag1consulting/goose" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-16 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Gaggles 分发负载测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "博客系列，首先要求对Rust错误处理有基本的了解。在本文中，我们将从 Rust 的标准库中剖析 std::io::Error 类型的实现。 源码在这里：library/std/src/io/error.rs【https://github.com/rust-lang/rust/blob/5565241f65cf402c3dbcb55dd492f172c473d4ce/library/std/src/io/error.rs】。你可以通过以下任一方式理解这些代码：\n对特定标准库的研究。\n高级错误管理指南。\n一个漂亮的API设计案例。\n更多请看原文：https://matklad.github.io/2020/10/15/study-of-std-io-error.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://matklad.github.io/2020/10/15/study-of-std-io-error.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-16 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "对 std::io::Error 的学习" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "declio 是一个声明式I / O序列化库。declio 提供了[Encode]和 [Decode] 这对 trait，它们有助于二进制数据流（the std::io traits）和任意数据类型之间的双向转换。项目地址：https://github.com/agausmann/declio" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/agausmann/declio" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-16 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "declio 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "YouTube：https://www.youtube.com/watch?v=TWNYSdxK4KY" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-16 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 与你的朋友一起打造数字乐器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rye 是一个很小的，仅x86-64的实验，目的是在 Rust 中添加纤程【fibers】。Rye 公开了一个 API，该 API 允许生成、调度和取消分配纤程。 这个 API 虽然很安全，但是却基于 rust 编译器不一定能保证的许多不安全的假设。 这只是一个实验项目，千万别用于生产。学习地址：https://github.com/mpdn/rye使用示例：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-16 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rye 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pin-project安全且符合人体工程学。https://crates.io/crates/pin-project1.0版本的主要是删除了不赞成使用的API。有关更多信息，请参见发行说明。https://github.com/taiki-e/pin-project/releases/tag/v1.0.0详情请见-reddit:https://www.reddit.com/r/rust/comments/jai12s/pinproject_10_released/详情请见-crates.io:https://crates.io/crates/pin-project" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/pin-project" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-14 21:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pin-project 1.0 released" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者叫Fedor,正在用Rust制作游戏和游戏工具。作者经过5年以上的专业游戏开发，现在辞去了工作，制作了第一款使用RustSHAR制作的大型3D动作游戏。https://fedorgames.itch.io/shar作者在使用 rust 做游戏开发的过程中, 根据经验写了一套游戏引擎miniquad - 是一种零依赖的跨平台渲染中间件。http://github.com/not-fl3/miniquad/macroquad - 是我一直梦寐以求的游戏引擎。http://github.com/not-fl3/macroquad/简短的 mini/macroquad 项目事例详情请见-github: https://github.com/sponsors/not-fl3/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sponsors/not-fl3/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-14 21:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "not-fl3 在寻找赞助" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "帖主是一名视觉特效工业领域的软件工程师，该领域以 C++ 为主导，而帖主两年前学习 Rust 之后就对 Rust 爱不释手，然而苦于工作领域只有 C++ 使得帖主只能对 C++ 越学越深，但是尝过 Rust 的甜头之后就觉得再深入 C++ 太痛苦了原帖已火原文链接：https://www.reddit.com/r/rust/comments/ja5aoe/getting_back_to_c_after_rust_is_a_pain/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-13 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust之后再用C++很痛苦（Getting back to C++ after Rust is a pain.）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们文档致力于打造东半球最强的文档产品，团队正在热聘 P6，P7，P8 岗位前端、Java、Rust 岗位。从企业级钉盘文件存储方案，到上层文档 Word，Excel，PPT 三件套传统办公产品再到例如协同脑图，流程图，便签，白板，在线表单等创新产品，有无限空间等你来创造～我们是一群对技术有追求的人，期待有rust经验的你加入我们，让我们一起学习，一起进步～联系我： farmerx@163.com" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-13 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "阿里巴巴文档团队诚招rust工程师" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "油条哥 @老油条 参与开发的 async_graphql 发布新版啦！ 这次内部大量重构，现在api能好用，过程宏参数错误会提示，并且还能给出建议， 而且性能提升一大截哦！仓库： https://github.com/async-graphql/async-graphql" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-13 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async graphql v2.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "@Mr.Panda 个人作品这是基于Rust编程语言的对象存储服务器，项目创建的目的是为了解决作者本人管理大量媒体文件的困扰，所以便开始自行创建一个简单的对象存储服务器，用于支持在低功耗设备运行（比如树莓派），并同时提供不错的性能，因为操作系统提供的文件系统对比管理海量文件性能有限，以及难以有效合并分散于多个磁盘的文件，所以这个项目使用集中管理文件内容的方式组织多个文件，以及支持多磁盘和多位置合并，为了提高读写速度，本项目使用多线程同时写入多个文件，将读写负载分散到多个目标文件来获得并行读写速度，而且对于SSD固态存储的写入放大（WAF）等等问题也做了相应优化.仓库： https://github.com/quasipaa/Physeter" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-13 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Physeter -- 基于Rust编程语言的对象存储服务器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用每一种语言就如同每段感情一样, 都有蜜月期. 当蜜月期过后, Rust 是否还是你的最爱呢?作者两年前就写过 <<爱上Rust>> 的相关博客. 两年过去了, 如同作者说:我仍然坚持我之前所说的一切.他们仍然结着婚,而且很幸福.除此之外,作者还列举了很多大大小小的细节,来说明为什么他仍然最爱 Rust:\nno_std  可以选择性关闭标准库.\n{:#x?}  更加 pretty 的打印变量.\n数字字面量  例如 0b0000_1011_1000_0000\nDWARF的支持  让 debug 没那么痛苦.\ngimli 和 goblin 这是两个 crates, gimli 是用来消费 DWARF数据,从而可以制作调试工具. 而 globlin 可以处理 ELF.\ndata-bearing enums 用过 Rust 的 enum 都说好.\npaste crate paste 可以像 C 的宏那样,所以粘贴多个标识符组成一个标识符.\nunsafe 虽然 Rust 最大特性之一是 safe,但是 unsafe 的存在也给了我们更多选择.\n多平台支持\nanyhow! + RUST_BACKTRACE 错误处理体验非常棒.\nasm! 提供了非常方便的宏语法,让你写汇编不再那么痛苦.\nstring的连续性\n--pretty=expanded 和 cargo expand 展开宏\n原文连接http://dtrace.org/blogs/bmc/2020/10/11/rust-after-the-honeymoon/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-12 18:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "蜜月期之后的 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 Rust 中, 可选参数并不在语法层面上被支持.这篇文章列出了下面多种方式来支持可选参数, 并且附上了优缺点:\nOption<T>\nInto<Option<T>>\n自定义的 struct.\n使用builder模式.\nEndpoint-oriented 接口\nHybrid derive pattern\nGrouping up endpoints\nMacros\n原文链接https://vidify.org/blog/rust-parameters/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-12 18:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中的可选参数" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个 Rust + WASM 编写的非常酷的 Gameboy 模拟器, 运行在浏览器中.github地址https://github.com/BlueBlazin/gbemu" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-12 18:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Gameboy 模拟器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "riscv-rust 是一个 RISC-V 处理器和周边设备的模拟器. 使用 Rust 编写并且编译成 WebAssembly.你可以在你的浏览器中运行 Linux 或者 xv6.github地址https://github.com/takahirox/riscv-rustonline demohttps://takahirox.github.io/riscv-rust/wasm/web/index.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-12 18:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "riscv-rust: Rust + WASM 编写的 RISC-V 的处理器模拟器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Puffin 是一款 rust 性能剖析器, 用法非常简单, 如下:如果想使用 UI,还可以使用插件 crate puffin-imgui 来展示火焰图等,他的样子如下:github地址https://github.com/EmbarkStudios/puffin--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-12 18:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "puffin: 非常棒的 Rust profile 工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Riccardo D'Ambrosio 最近发布了 RSLint，这是一个用于 JavaScript 的 lint，完全用 Rust 编写。 RSLint 致力于尽快，可定制和易于使用。 RSLint 仍处于开发的早期阶段，具有基本的 Visual Studio Code 集成功能。原文地址：https://www.infoq.com/news/2020/10/rslint-fast-rust-js-linter/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.infoq.com/news/2020/10/rslint-fast-rust-js-linter/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-11 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RSLint：Rust实现的js linter" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "微软 Ryan Levick 录制的视频，在此视频中，我们讨论 bindgen, C ABIs，链接器以及更多其他问题。视频地址：https://www.youtube.com/watch?v=jNNz4h3iIlw&feature=youtu.be" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=jNNz4h3iIlw&feature=youtu.be" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-11 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust FFI：微软飞行模拟器SDK" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如图，是不是很酷，文章直达：https://thefuntastic.com/blog/rust-tide-clock" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-11 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust和树莓派做一个潮汐钟" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Ocean 是一个完全使用 Rust 实现的项目管理器，类似于 Cargo，主要针对其他系统编程语言-c/c++。命令语法与Cargo的语法非常相似。项目地址：https://github.com/STBoyden/ocean" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/STBoyden/ocean" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-11 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Ocean - C/C++ 工程管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Crux是一种使用符号测试来提高软件质量的工具，主要使用 Rust 实现，目前支持 C/C++ 和 Rust。 与诸如随机模糊测试或单元测试之类的技术相比，Crux 可以为您提供额外的保证，确保您的代码可以完成您想要的工作，并提供更大的可能输入范围。项目地址：https://github.com/GaloisInc/crucible" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/GaloisInc/crucible" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-11 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Crux 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "最近，ISRG（Internet Security Research Group，Internet 安全研究小组）宣布通过一系列的开发确保 curl 代码库关键部分的内存安全。包括：资助 curl 的主要作者 Daniel，增加对 Hyper 的支持，使用它作为 curl 的 HTTP 后端；同时，ISRG 工程师会增加对 Rustls 的支持，将其作为 curl 的 TLS 后端。小编整理了一些相关的链接，供大家了解更多信息。ISRG 博客中关于内存安全 curl 的文章，https://www.abetterinternet.org/post/memory-safe-curl/curl is C 旧文，https://daniel.haxx.se/blog/2017/03/27/curl-is-c/hyper C API的pr #2278， https://github.com/hyperium/hyper/pull/2278curl 作者在 hyper 上提的 issue #2265，https://github.com/hyperium/hyper/issues/2265Reddit 上的讨论，https://www.reddit.com/r/rust/comments/j7yegb/memory_safe_curl_for_a_more_secure_internet/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/j7yegb/memory_safe_curl_for_a_more_secure_internet/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-10 22:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于 curl 的讨论" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该系列是作者 Chris Fallin 在 Mozilla 关于 Cranelift 上的工作介绍。这篇文章是由三部分组成的系列文章的第一篇，文章中作者介绍了一些背景并描述了指令选择问题，尤其是讨论了过去九个月左右对指令选择器和后端框架的总体改进。Cranelift 是什么？该项目是用 Rust 编写的一个编译器框架，该框架专门设计用于即时编译（JIT，just-in-time）。Mozilla Hacks 的文章，https://hacks.mozilla.org/2020/10/a-new-backend-for-cranelift-part-1-instruction-selection/BTW，今天是作者在 Mozilla 的最后一天，所以其计划的其它 Cranelift 系列文章都将放在其博客上。阅读作者的博客原文，https://cfallin.org/blog/2020/09/18/cranelift-isel-1/https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://cfallin.org/blog/2020/09/18/cranelift-isel-1/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-10 22:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cranelift 的新后端系列文章" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "broono" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Yes! And it's freaking fast!arewewebyet.org网站最近更新了页面内容，认为rust的web生态已经逐步完善。“我已经可以替换 Rails/Django/Flask 应用了吗？”“是的！Rust语言已经有基于Actix Web和Rocket的成熟和生产可用的框架，以及更新的像Warp和Tide框架。这些框架可以满足你对一个web框架的所有期待，从路由到中间件，到模板，到JSON和表单处理。这些功能都有相应的crate，甚至更多！”reddit讨论: https://www.reddit.com/r/rust/comments/j76xgg/woohoo_milestones_being_made_updated_2_days_ago/arewewebyet网址: https://www.arewewebyet.org/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/j76xgg/woohoo_milestones_being_made_updated_2_days_ago/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-09 22:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Are we web yet?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "broono" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "“内存安全漏洞是对Internet安全的最大威胁之一。 因此，ISRG的我们对寻找使Internet上最依赖的软件安全的方法感兴趣。 今天，我们很高兴地宣布，我们正在与无处不在的curl软件的作者Daniel Stenberg和WolfSSL合作，以确保curl代码库内存的关键部分安全。”reddit讨论: https://www.reddit.com/r/rust/comments/j7yegb/memory_safe_curl_for_a_more_secure_internet/原文地址: https://www.abetterinternet.org/post/memory-safe-curl/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/j7yegb/memory_safe_curl_for_a_more_secure_internet/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-09 22:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "内存安全的curl" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 1.47.0 版本在10月8日发布了。Read More: https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1470-2020-10-08" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1470-2020-10-08" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-08 17:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.47稳定版发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本月看点除了以往的几个游戏更新进度报告外，还有两篇有关rust开发热重载的blog值得一看。以及用WGPU写的实时全局光照：游戏引擎方面，Godot的Rust绑定发布了0.9版本 :https://godot-rust.github.io/release-notes/0-9-0/Read More: https://rust-gamedev.github.io/posts/newsletter-014/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust-gamedev.github.io/posts/newsletter-014/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-08 17:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust游戏开发时讯第14期" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本篇博客讲解的细致入微，甚至连变量命名都讲解了。是一篇十分适合rust初学者的博客，如果你对rust中的链表等数据结构如何实现不了解，本篇也十分适合你。Read More: https://ferrous-systems.com/blog/dlx-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ferrous-systems.com/blog/dlx-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-08 17:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Dancing links 算法的Rust实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者学习rust中迭代器的笔记，也是一篇适合初学者的博客。Read More: https://blog.thoughtram.io/iterators-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.thoughtram.io/iterators-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-08 17:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust中的迭代器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本篇讲解一个函数式编程中的笑话：每段scala代码都能用traverse函数写出来（感谢洛佳的总结概括）同时也将rust中迭代器的一些用法，与scala做了一些比较。对函数式编程感兴趣的可以看看。Read More: https://www.fpcomplete.com/blog/collect-rust-traverse-haskell-scala/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.fpcomplete.com/blog/collect-rust-traverse-haskell-scala/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-08 17:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust中的迭代器与scala的比较" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本篇看点是Analysis部分。作者对自己的测试结果说明了rust异步是否是零成本抽象。Read More :https://github.com/jkarneges/rust-async-bench" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jkarneges/rust-async-bench" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-08 17:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust异步基准测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read More: https://reberhardt.com/blog/2020/10/05/designing-a-new-class-at-stanford-safety-in-systems-programming.html课程链接: https://reberhardt.com/cs110l/spring-2020/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://reberhardt.com/cs110l/spring-2020/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-08 17:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "斯坦福大学新开的rust相关的课程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "359。Read More：https://this-week-in-rust.org/blog/2020/10/07/this-week-in-rust-359/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2020/10/07/this-week-in-rust-359/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-08 17:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://arzg.github.io/lang/7/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://arzg.github.io/lang/7/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-07 22:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用 Rust 开发一门语言之开 发REPL" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者关于 Rust 的愿望清单，博客中写了他希望 2021 年 Rust 语言、库、编译器会有的 features.https://tmandry.gitlab.io/blog/posts/rust-2021-project/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://tmandry.gitlab.io/blog/posts/rust-2021-project/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-07 22:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "The Rust Project in 2021" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者关于 Rust 宏的愿望清单https://casualhacks.net/blog/2020-10-05/the-rust-2021-experience-macros/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://casualhacks.net/blog/2020-10-05/the-rust-2021-experience-macros/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-07 22:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "The Rust 2021 Experience - Year of the Macro" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/o2sh/onefetch" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/o2sh/onefetch" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-07 22:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Onefetch：git 仓库信息命令行显示器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/mozilla/uniffi-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mozilla/uniffi-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-07 22:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "uniffi : Rust 多语言绑定生成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果你想创建 Event-sourced 程序, 那么该 crate 是一个不错的开始.eventually-rs 提供了 event sourcing 所需要的 traits 和工具来驱动和模块化你的 Domain Entities.github地址https://github.com/ar3s3ru/eventually-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-05 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "eventually-rs: Rust 中的 Event Sourcing 支持" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是使用 Rust 创造一门新语言的第五篇文章.这篇文章主要讲述了如何支持类似 let a = 10 这种绑定的支持.感兴趣的小伙伴可以查看原文.原文链接https://arzg.github.io/lang/5/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-05 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 创造一门新语言: Part 5 绑定的用法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "This Month in Rust OSDev 系列博客主要是为了回顾每个月 Rust 中的一些重要更改和进度.这是九月份的一些主要变化.原文链接https://rust-osdev.com/this-month/2020-09/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-05 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Month in Rust OSDev (九月份)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该项目还在早期的开发当中,目标是开发一个尽可能快的语法提示器, 并且支持更多的自定义扩展.github地址https://github.com/RDambrosio016/RSLint--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-05 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RSLint: 一个 Rust 编写的 javascript 语法提示器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你好!我是杰克。这可能很明显，也可能不明显，这是我的第一篇博客文章。我不想过多地减损这篇文章的内容，但我认为至少有必要对我为什么要写这篇文章做一个简短的解释。这是对2021的Rust call for blog的一个回应。现在，我确实是traits工作组的负责人之一。并且在过去一年里，对Chalk做出了很大的贡献。但是，我要声明的是，我在这篇文章中提出的观点是我自己的，我在这里不是以任何“官方”的身份说话。文章链接，https://jackh726.github.io/rust/2020/10/01/rust-2021.htmlhttps://jackh726.github.io/rust/2020/10/01/rust-2021.html/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-03 18:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 2021-稳定性" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在Bearer，我们是一个多语言的工程师团队。无论是交流的语言，还是变成的语言。我们的技术栈是由Node.js，Ruby，Elixir，以及我们代理库支持的所有语言之外的其他语言写的服务组成。想大多数团队一样，我们再使用正确的工具工作和使用正确的工具节省时间中取得平衡。文章链接，https://blog.bearer.sh/how-rust-lets-us-monitor-30k-api-calls-min/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.bearer.sh/how-rust-lets-us-monitor-30k-api-calls-min/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-03 18:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust如何使我们监控30k/min的API调用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章是关于群体智能的，以及我们如何尝试模拟它来展示集体行为如何能够为可能无法解决的问题找到更好的解决方案。从维基百科中，我们可以将群体智能(SI)定义为:SI系统通常由一个简单的代理或人口与本地交互彼此和他们的环境。这些代理遵循非常简单的规则，尽管没有集中控制结构来规定个体代理应该如何行为，局部的，并且在一定程度上是随机的，这些代理之间的交互导致了“智能的”全局行为的出现，而个体代理不知道。蚁群智能系统最常见的例子之一就是蚁群，这就是formicarium试图模拟的。文章链接，https://gliderkite.github.io/posts/formicarium/Github 链接，https://github.com/gliderkite/formicariumhttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/gliderkite/formicarium" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-03 18:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Formicarium(蚁群)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIn Rust, We Trust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-01 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【特辑】祝大家双节快乐！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在Rust中实现Barnes-Hut和直接算法，Reophttps://github.com/Katsutoshii/barnes-hut-rsRead Morehttps://galaxy-sim.github.io/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-01 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust和WebAssembly进行碰撞星系模拟" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "The Rust && C++ LDN Talks.Read Morehttps://www.meetup.com/Rust-London-User-Group/events/273056379/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-01 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust和C++的联合Talk" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "binserver 建立在 Actix 之上！Reophttps://github.com/mufeedvh/binserve" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-01 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "binserve：单二进制（Single binary）的静态Web服务器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n用Rust增强您的Electron应用程序\nAMD正在招聘使用Rust编写的新Radeon驱动程序工具\n以开源方式学习Rust\nRead Morehttps://this-week-in-rust.org/blog/2020/09/30/this-week-in-rust-358/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-01 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【@ThisWeekInRust】本周Rust：" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 Rustcc 上的【Rust 新闻/聚合】板块，现在已经有九百多篇Post了，我们计划在第一千篇时，举行一次活动，各位小伙伴有什么好的建议，可以联系我们 日报小组。我们的第一篇日报，致敬！Read Morehttps://rustcc.cn/article?id=4cf38b16-9533-4cc8-89e3-828afaed9f94" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-10-01 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【彩蛋】活动预告！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GUI 是一个难题,但是 RUST 社区有解决难题的记录,希望 rust 能构建出高性能表现力强的 GUI 工具包。详情请见-blog:https://raphlinus.github.io/rust/druid/2020/09/28/rust-2021.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://raphlinus.github.io/rust/druid/2020/09/28/rust-2021.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-09-30 21:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 2021 - GUI" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Electron已成为创建跨平台桌面应用程序的主要技术。它用于Atom，VS Code，Spotify，Slack，Discord等知名和流行的平台。JavaScript是一门\"缓慢的语言\"，但是在本教程中将演示如何使用Rust来加速Electron应用程序来获得更好的用户体验。Rust是具有高级人体工程学的\"低级语言\"。它速度超快而且内存占用极低。详情请见-blog:https://blog.logrocket.com/supercharge-your-electron-apps-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.logrocket.com/supercharge-your-electron-apps-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-09-30 21:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust增强您的Electron应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文中作者用Rust编写了一个程序，用于量子场的物理模拟,却遇到了在 linux 平台比 windows 平台运行快的场景, 感兴趣的同学可以关注和参与讨论。reddit 话题:https://www.reddit.com/r/rust/comments/j2ilkn/rust_program_runs_faster_on_linux_than_windows/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/j2ilkn/rust_program_runs_faster_on_linux_than_windows/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-09-30 21:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust程序在Linux上的运行速度比Windows快？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一年多以前，文中作者在“smaller Rust”（一种高级语言）上写了一些笔记，该语言可以从Rust的类型系统创新中汲取灵感，但由于以对用户要求不那么严格的域为目标，因此会更简单控制和性能。在今年的失业期间，作者致力于勾勒出类似的语言的外观。写了一些关于这段时间得出的新结论。https://without.boats/blog/notes-on-a-smaller-rust\n我们的语言的目的\n资源类型和数据类型\n借用和引用\nCells\n结论\n详情请见-blog: https://without.boats/blog/revisiting-a-smaller-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://without.boats/blog/revisiting-a-smaller-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-09-30 21:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "再次讨论 \"smaller Rust\"" }, "type": "text" }], "type": "title" } },]
