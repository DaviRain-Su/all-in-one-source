export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "又是一篇讲Pin的blog，是作者本人在学习Rust异步过程中做的一些总结和理解，方便大家在学习异步时遇到相关疑惑可以查阅。Read More: https://blog.adamchalmers.com/pin-unpin/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.adamchalmers.com/pin-unpin/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-26 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pin,Unpin为什么Rust需要它们" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Typing the technical interview是一篇将计算机知识拟作魔法的小说？鉴于小编学识有限，对这篇blog不是很了解，如有对这篇Blog熟悉的小伙伴，可以帮忙介绍一下。原文提到的相关代码都是使用Haskell写的，现在社区里有人将其用Rust重新实现了一遍：Github: https://github.com/insou22/typing-the-technical-interview-rust/同时，如果对这篇原文感兴趣的，链接也在这里：Read More: https://aphyr.com/posts/342-typing-the-technical-interview" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://aphyr.com/posts/342-typing-the-technical-interview" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-26 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Typing the technical interview从Haskell翻译到Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这一部分的主要目标是建立一个高层次的心理模型，说明我们在前一章中读到的不同部分是如何一起工作的。我希望这将使我们在接下来的几章中深入研究特质对象和生成器等主题之前，更容易理解高层次的概念。这并不是创建一个异步系统模型的唯一方法，因为我们要对运行时的具体情况进行假设，而这些情况可能会有很大的不同。这是我认为最容易建立的方式，而且对于理解你在异步生态系统中发现的很多真实的实现也很有意义。最后，请注意，由于需要简洁明了，代码本身是 \"假的\"。Read More: https://cfsamson.github.io/books-futures-explained/2_a_mental_model_for_futures.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://cfsamson.github.io/books-futures-explained/2_a_mental_model_for_futures.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-26 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于Futures和运行时如何工作的心智模型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RustSBI 0.2.0-alpha.5版本发布。良好支持您的业务和学术研究系统，兼容性强，先进的模块化设计，值得信赖。RustSBI是RISC-V下的引导程序环境，它支持多款模拟器和芯片平台。在今年的首届全国大学生系统能力竞赛操作系统赛中，RustSBI被来自全国高校的赛队广泛使用，用于实现自己的比赛用系统，并取得全国一、二和三等奖。本次更新特性：兼容性修改指南：文档主页：https://docs.rs/rustsbi/0.2.0-alpha.5/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://docs.rs/rustsbi/0.2.0-alpha.5/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-24 20:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustSBI 0.2.0-alpha.5 版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "default-args: zero-cost default arguments in rust!https://www.reddit.com/r/rust/comments/pa3ii5/defaultargs_zerocost_default_arguments_in_rust/通过使用default_args::default_args!宏来实现带缺省值的函数，下面是用例：项目主页：https://github.com/buttercrab/default-args.rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/buttercrab/default-args.rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-24 20:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "default-args: 零开销实现带缺省值的函数" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RustDesk 1.1.8 release: yet another remote desktop softwarehttps://www.reddit.com/r/rust/comments/paj2w2/rustdesk_118_release_yet_another_remote_desktop/开源远程桌面软件RustDesk 1.1.8 版本发布，更多细节参见Release Noteshttps://github.com/rustdesk/rustdesk/releases/tag/1.1.8项目主页：https://github.com/rustdesk/rustdeskRust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rustdesk/rustdesk" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-24 20:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustDesk 1.1.8 发布：开源远程桌面软件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "2021第一届全国大学生操作系统比赛的比赛结果公布了，哈工大（深圳）的李程浩，宫浩辰，任翔宇获得了内核实现赛道的一等奖，指导教师为夏文老师和江仲鸣老师。他们用Rust语言设计实现了基于RISC-V64的多核操作系统UltraOS，支持qemu和k210平台运行，在比赛过程的多个评比阶段排名第一。项目网址 https://gitlab.eduxiji.net/ultrateam/ultraos https://github.com/xiyurain/UltraOS项目使用GPL3.0协议，欢迎开发者使用该项目进行学习。项目使用了洛佳等开发者的RustSBI 2021.03.26版本，以及吴一凡等开发者的rCoreTutorial-v3 2021.03.26版本（清华大学计算机系2021 OS课实验指导教程）。这也说明了，基于开源社区的模式，采用Rust开发操作系统等系统软件是Rust语言的一种发展趋势。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-23 20:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "UltraOS获第一届全国大学生操作系统比赛一等奖" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "nom是一个用Rust编写的解析组合器库。它的目标是提供构建安全解析器的工具，而不影响速度或内存消耗。为此，它广泛使用Rust的强类型和内存安全来生成快速和正确的解析器，并提供函数、宏和特征来抽象大多数容易出错的管道。现在最新的7.0版本已经发布.crate.io 地址https://crates.io/crates/nom" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-23 20:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "nom: 7.0 发布了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在本文中，作者分享了自己组织大型Rust项目的经验。这并不权威, 只是作者通过反复试验发现的一些技巧。原文链接https://matklad.github.io/2021/08/22/large-rust-workspaces.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-23 20:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何组织大型 Rust workspace" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "miette是Rust的诊断库。它包括一系列的traits/protocols，允许您hook到它的错误报告工具，甚至编写您自己的错误报告!它允许你定义错误类型，可以像这样打印出来(或以任何你喜欢的格式!):原文链接https://github.com/zkat/miette--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-23 20:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "miette: 人类友好的错误诊断库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "@pierre_marijon 开发了一个 fastq parser，目前还有一些限制：https://twitter.com/pierre_marijon\nfastmap 只适用于未压缩文件\nbuffer 必须比 2 records 大\nAPI 还没有文档\n还需要想一个 crate 名字\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-22 22:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fastq parser" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Reddit 上的热帖，作者想将 Rust 代码中通过 C 实现的 SIMD，改为 Rust 自己的 SIMD，作者有两个改造目的：经过改造后发现这两个目标都翻车了，详细内容请阅读原文。原文https://www.reddit.com/r/rust/comments/p99e80/rust_simd_native_vs_clibary/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-22 22:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【Reddit】Rust SIMD native VS C library" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pastebin 是一种在线内容托管服务，用户可以在其中存储纯文本。第一个pastebin是同名的pastebin.com。sweetpaste 是一个简单的 pastebin 服务器，它是一个纯服务端的程序，没有任何客户端代码。Repohttps://github.com/Absolucy/sweetpaste" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-22 22:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "sweetpaste 一个用 Rust 实现的 pastebin" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "2048 这个游戏相比大家都不陌生，它是一个以合成 2048 数字为目的的游戏，游戏玩法只有左右上下，通过将两个 2 合并成 4，将两个 4 合并成 8，以此类推合并出 2048。https://2048.nishchith.com/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://2048.nishchith.com/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-22 22:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 WebAssembly 实现的 2048 游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我刚刚发布了 https://github.com/trusch/snakeos 的 v0.1.0！这是继在 Rust 博客系列中编写操作系统之后适用于 x86 CPU 的可启动贪吃蛇游戏。它支持 async/await 和动态内存管理，当然，玩蛇 :)我在发布中附上了一个可启动的映像，所以你们所有想要短暂休息的人，现在你可以在裸机上玩贪吃蛇了！文章链接，https://www.reddit.com/r/rust/comments/p86a24/snakeos_v010_released/Gitlab 链接，https://github.com/trusch/snakeos" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/trusch/snakeos" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-21 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SnakeOS v0.1.0发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Pueue 是一个命令行任务管理工具，用于顺序和并行执行长时间运行的任务。简单地说，它是一个处理 shell 命令队列的工具。最重要的是，有很多方便的特性和抽象。文章链接，https://github.com/Nukesor/pueue/releases/tag/v1.0.0Gitlab 链接，https://github.com/Nukesor/pueue" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Nukesor/pueue" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-21 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pueue v1.0.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Apache Arrow 团队很高兴地宣布 DataFusion 5.0.0 版本。这涵盖了 4 个月的开发工作，包括来自以下 31 位不同贡献者的 211 次提交。文章链接，https://arrow.apache.org/blog/2021/08/18/datafusion-5.0.0/Gitlab 链接，https://github.com/apache/arrow-rshttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/apache/arrow-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-21 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Apache Arrow DataFusion 5.0.0 版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章思路基于 Rust 实现 Python wordsegment 库，目的是为了实现更快的即时域搜索。文章将分词实现问题分为两点：实现一种估计句子在现实世界中出现的概率的方法以及实现一种对输入字符串的所有可能分段进行评分的有效方法。让我们来讨论这两者是如何工作的：\nhttps://instantdomainsearch.com/engineering/instant-word-segmentation-with-rust\ncargo 构建时如果发生错误将用类似于 diff 的方式显示输出建议帮助开发者修改程序。\nhttps://github.com/rust-lang/rust/pull/86532\nGUI框架在如今一方面可以用于构建游戏、嵌入式应用程序和（在较小程度上）网络应用程序的工具，另一方面可以用于构建传统桌面应用程序的工具。而 Rust 的主要优势之一就是方便使用 cargo 和 crates.io 构建和共享组件是。在这篇推荐文章中，作者想尝试列举几个参与构建桌面 GUI 框架的子项目。这些项目可以被认为是基础设施，理想情况下，它们可以作为各种 GUI 项目共享的独立工具存在。\nhttp://www.cmyr.net/blog/rust-gui-infra.html\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-20 17:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "实验性的自动微分库，由作者自己维护的 ndarray 分叉提供 wgpu 支持。这也为向 ndarray 添加 wgpu 支持提供了概念性的验证。GitHub - rust-grad: https://github.com/RustyBamboo/rust-gradGitHub - ndarray/wgpu: https://github.com/RustyBamboo/ndarray/tree/wgpu" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/RustyBamboo/ndarray/tree/wgpu" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-19 23:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-grad 用 Rust 写成的自动微分库，支持 wgpu 计算" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "wgpu 是安全和可移植的 GPU 抽象，使用 Rust 写成，并实现了 WebGPU API 。新版本值得期待的特性包括更为扁平化的 GPU 抽象和小巧的代码库，以及完全用 Rust 技术栈带来的便利，包括更方便的构建以及减少编译时的怪异行为。Bevy 团队决定完全移除旧的 “抽象渲染层” ，转为使用 wgpu 作为核心的渲染抽象，以使得代码更精练、更简单，并且与广泛的 wgpu 生态更兼容。Release of a Pure-Rust v0.10 and a Call For Testing: https://gfx-rs.github.io/2021/08/18/release-0.10.htmlBevy 核心开发者的评论: https://www.reddit.com/r/rust/comments/p6z1i3/release_of_a_purerust_wgpu_v010_and_a_call_for/h9geqjm?utm_source=share&utm_medium=web2x&context=3" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/p6z1i3/release_of_a_purerust_wgpu_v010_and_a_call_for/h9geqjm?utm_source=share&utm_medium=web2x&context=3" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-19 23:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "wgpu v0.10 发布，采用纯 Rust 写成" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)值得一提的是，This Week in Rust 404 的页面并没有走丢！This Week in Rust 404: https://this-week-in-rust.org/blog/2021/08/18/this-week-in-rust-404/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/08/18/this-week-in-rust-404/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-19 23:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 404" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者写了 <<如何写出非常慢的 Rust 代码>> 之后, 收到了很多反馈, 这些反馈提供了非常多的意见来改进代码, 让代码变的更高效. 作者给出了很多编写高效 Rust 代码的示例.原文链接https://renato.athaydes.com/posts/how-to-write-fast-rust-code.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-16 20:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何写出高效的 Rust 代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#[derive(Clone)] 是大家经常使用的宏. 但是你真正的了解他吗? 本文作者将带入深入理解该宏的方方面面.原文链接https://stegosaurusdormant.com/understanding-derive-clone/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-16 20:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "理解 #[derive(Clone)]" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "MeiliSearch是一个快速、功能丰富的全文搜索引擎。它构建在LMDB键值存储的基础上，安装在Ubuntu或MacOS上时是一个35mb的二进制文件。它有一个内置的客户端，服务器和web界面。诸如词干提取、停止词、同义词、排序、过滤器和面等功能都可以开箱即用，使用合理的默认值，并可以轻松定制。原文链接https://tech.marksblogg.com/meilisearch-full-text-search.html--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-16 20:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MeiliSearch: 一个极简的全文搜索引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果你没有听（用）过 Json Schema，请允许我首先简单介绍一下。JSON Schema 是用于验证 JSON 数据结构的工具，如果你厌恶对 Json 数据各种 if else 的判断和校验，那该工具非常适合。它的官网：JSON Schema | The home of JSON Schema，先看一个简单的例子，假设我们有下面的 Schema：https://json-schema.org/这个 Schema 一共定义了四个字段，每个字段的类型都做了规定，address 本身也是一个 Json Object。此时，有效的数据是：而下面这样的无效数据则会被 Json Schema 验证并报错：Json Schema 本身是语言无关的，这里已经有很多实现了：Implementations | JSON Schema，Rust 版本的使用与其他语言类似：https://json-schema.org/implementations.html这个工具唯一有个麻烦的地方就是编写 Schema 比较费劲，可以理解为设计类。不过好在写好之后就省事了。GitHub：Stranger6667/jsonschema-rs: JSON Schema validation libraryhttps://github.com/Stranger6667/jsonschema-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-15 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "jsonschema-rs：Rust Json 校验工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用法如下：GitHub：Eolu/vec-const: Rust crate to allow declaration of vecs as constshttps://github.com/Eolu/vec-const" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-15 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "vec-const：允许将 vecs 声明为 consts" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "包括：构建、发布、文档等功能。Cargo 功能已经很强大了，为啥还要做这个东西呢？因为有时我们需要做更多的事情，比如复制一些文件、发布到 ftp 或输入长命令。这些重复性任务必须自动化（也称为 “工作流自动化”）。GitHub：LucianoBestia/cargo-auto: cargo auto - automation tasks written in Rust languagehttps://github.com/LucianoBestia/cargo-auto" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-15 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-auto：自动任务工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RillRate 是完全使用 Rust 和 Yew 框架制作的机器人、微服务和物联网的快速 UI。  全栈 Rust 是真实存在的！本周增加的新功能：\n新控件：按钮、开关、选择器和滑块。\n新数据类型：表格、仪表、直方图（尚未图形化）。\nGitHub：rillrate/rillrate: Dynamic UI for bots, microservices, and IoT.https://github.com/rillrate/rillrate" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-15 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rillrate 新版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "具体使用方式如下：不过，谁会这么写代码呢，完全没有可读性嘛，看来只能用来装逼了。GitHub：TOETOE55/for_ch: A macro to write nested for loophttps://github.com/TOETOE55/for_ch" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-15 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "for_ch：一个展平嵌套的 for 循环和 if-let 的 macro" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该库提供了通过 Any 动态地对类型进行专门化的函数。  基本思想是，如果 T 和 U 实际上是同一类型，则允许将任何 T “强制转换” 为任何其他 U。GitHub：Kimundi/identity_casthttps://github.com/Kimundi/identity_cast" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-15 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "identity_cast：动态地对类型专门化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "TrueLayer 团队用支持中间件的客户端reqwest-middleware包装 reqwest，并暴露相同的简单 API，在满足弹性和可观察性要求下，使其建立可重复使用的组件。开发人员可以通过导入几个 crate 并在客户端设置代码中添加with_middleware调用来加强与远程 HTTP 的集成，这对任何其他应用的代码都不会造成干扰。https://truelayer.com/示例代码如下：原文链接，https://truelayer.com/blog/adding-middleware-support-to-rust-reqwest/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://truelayer.com/blog/adding-middleware-support-to-rust-reqwest/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-14 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "reqwest 增加中间件支持" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "此 crate 的目的是为了更容易地与谷歌产品类别/分类一起工作。这是通过 google_taxonomy::ProductCategory枚举提供的，其中包含截至 2021-08-13 的所有类别。crate 链接，https://crates.io/crates/google_taxonomy" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/google_taxonomy" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-14 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "google_taxonomy，谷歌分类/产品类别" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "cargo-smart-release，无所畏惧地发布工作空间 crate，无需处理依赖关系或版本。cargo-release 是这个工具存在的原因，因为它让我迷上了一个了解git的全自动化发布工作流程。截至2021-08-12，这对简单的工作区或单速率工作区来说是完美的，所以请使用它：cargo install cargo-release。以下是 cargo smart-release 的不同之处。\n安全地执行，所以默认情况下，它被解除了武装\n指定一个或多个 crate，并自动检测哪些板块需要发布\n处理依赖性循环，以增加整体成功的机会\n当出现问题时，努力避免让工作区处于不一致的状态\n成为 gitoxide 的 playground，为应用程序作者提供更多的便利和更多的可行性。\ncrate 链接，https://crates.io/crates/cargo-smart-release" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/cargo-smart-release" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-14 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-smart-release" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Black Hat Rust 是一本深入研究使用 Rust 编程语言的进攻性安全（Offensive Security）的书籍，支持PDF，Kindle 和 Epub。这本书是一项正在进行的工作。它可以在早期访问计划的背景下使用，这意味着各章节将在写完后立即发送给你，我们非常感谢你的反馈。当前状态：可访问页数：250+代码进度：~90% (https://github.com/skerkour/black-hat-rust)预计最终出版：Q3 2021估计的页数：~320备注：作者为感谢所有帮助其完成这本书的人，所有早期访问的买家还将获得以下奖励：一个高级恶意软件分析的策划清单。在开发自己的攻击性工具时，会在里面找到巨大的灵感。书籍网址，https://academy.kerkour.com/black-hat-rust?coupon=BLOGhttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://academy.kerkour.com/black-hat-rust?coupon=BLOG" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-14 20:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【书籍】Black Hat Rust 早期访问版" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rg3d 最近发布了 0.22 版，作者在 Reddit 发布了一段 rg3d 的演示视频，看起来非常棒！可能是目前最成熟的一个 Rust 3D 游戏引擎了。这个游戏引擎昨天的日报已经推荐过了，今天小编再推荐一次。因为确实很赞！Github: https://github.com/rg3dengine/rg3dReddit: https://www.reddit.com/r/rust/comments/p2x38x/media_rg3d_game_engine_v022_feature_highlights/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/p2x38x/media_rg3d_game_engine_v022_feature_highlights/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-13 23:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rg3d - 可能是目前最成熟的一个 Rust 3D 游戏引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "git-cliff 可以基于 commit 约束格式或正则来自动生成 changelog，而且扩展性也很高。比如下面的几条 commit：会自动生成如下的 changelog:Github: https://github.com/orhun/git-cliff" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/orhun/git-cliff" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-13 23:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "git-cliff - 基于 git commit 自动生成 changlog 的利器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "unfuck 是一个反混淆 Python 2.7 .pyc 字节码文件的工具，下图是一个反混淆之后的对比：Github: https://github.com/landaire/unfuck" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/landaire/unfuck" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-13 23:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "unfuck - Python 2.7 字节码的反混淆库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "helix-editor 是一个深受 neovim 启发使用 Rust 开发的编辑器，感兴趣的朋友可以看看。Github: https://github.com/helix-editor/helix" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/helix-editor/helix" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-13 23:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "helix-editor - 一个受 neovim 启发的编辑器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "小编的 Rust 插件发布新版本半个多月了，一直忘了发帖了，今天补上。欢迎大家体验！更新说明：https://github.com/huhu/rust-search-extension/wiki/V1.3.0-Release-Candidate-(zh_CN)Changelog: https://rust.extension.sh/changelog" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust.extension.sh/changelog" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-13 23:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Search Extension 1.3 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "机翻请谅解：上周我在这里分享了一篇文章，描述了一个重写我的手机游戏的项目，一堆人对源代码表示很感兴趣。所以我回来了，带着我承诺的代码回来了你可以在 https://github.com/lucamoller/pandadoodle-rust-wasm 找到它。一些免责声明。这些代码是为了好玩而写的，最初只是给我看的。为了与大家分享，我试着把代码清理/整理了一下（相信我，它仍然混乱得多），但仍有很多事情可以做。另外，这些代码并不是为了 \"锈化\"。恰恰相反，我是想看看用Rust编写非Rust风格的代码能走多远（我在文章中谈到了这一点），所以你可能会发现一些奇怪的东西。如果有些东西伤害了你的眼睛，请原谅我 :)不过，我还是很愿意听取反馈意见的！如果你发现了反常规的问题，请告诉我。如果你发现了一个反常规或你认为可以用更简单或更优雅的方式来完成的东西，我很乐意听到。 我最终使用了大量的Rc+内部可变性，因为这使得代码更容易翻译/管理/归纳。与浏览器的渲染瓶颈相比，这些模式对性能的影响似乎可以忽略不计（仅仅是使用WASM而不是Javascript，我就得到了很多执行游戏逻辑的空间），所以我在添加一些Rc的地方之前没有多想，这将使我的生活更轻松 :P谈到性能，我做了一些工作来改善安卓版Firefox上的东西（当我第一次发布时，游戏在那里运行得很慢），这似乎有很大的影响：在我的手机上，帧数从20到40。感觉更容易忍受了，但仍然比Chrome慢。我怀疑火狐浏览器正在以根本不同的方式进行画布渲染，而我无法对其进行优化（有些人认为这可能与另一篇帖子中的画布指纹保护有关，但我还没有找到激活/停用这些保护的标志来确认它）。最后，请随时提出关于代码的任何问题。我很乐意尝试回答!https://lucamoller.medium.com/rewriting-my-mobile-game-in-rust-targeting-wasm-1f9f82751830Read More: https://www.reddit.com/r/rust/comments/p2szr4/show_rrust_source_code_rewriting_my_mobile_game/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/p2szr4/show_rrust_source_code_rewriting_my_mobile_game/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-12 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "(包含源代码）用Rust重写我的移动游戏，并支持WASM" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个项目目前仍然很简陋，但是很有用。就是让提高对可能会出现意外结果的测试的容忍度，只要在多次运行(目前默认是3，有个PR支持了自定义次数)中一次是正确的就认为测试通过。Github: https://github.com/denoland/flaky_test" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/denoland/flaky_test" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-12 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "遇到flaky_test可以使用这个库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "视屏在Reddit上有条件的朋友可以看看。Read More: https://www.reddit.com/r/rust/comments/p2x38x/media_rg3d_game_engine_v022_feature_highlights/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/p2x38x/media_rg3d_game_engine_v022_feature_highlights/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-12 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rg3d 游戏引擎发布v0.22 - 同时发布了一个展示版本特色的视屏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文是前天日报提到的博客：如果你想实现一个GUI框架系列的第二篇，作者在第一篇的基础上，又对GUI框架的基础设施应该要满足那些需求做了补充Read More: http://www.cmyr.net/blog/rust-gui-infra.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "http://www.cmyr.net/blog/rust-gui-infra.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-12 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust GUI 基础设施" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这周的周报昨天的日报已经发过了，恰好这周官方日报组没收到引语提名，周报小组成员写了首押韵的英文小诗，大概就是抱怨没有人给周报小组进行语录提名这件事。– a very sorry llogiq(请提名你喜欢的语录，并为下周语录投票!)[https://users.rust-lang.org/t/twir-quote-of-the-week/328]" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-12 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周语录" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ReadMore:https://this-week-in-rust.org/blog/2021/08/10/this-week-in-rust-403/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/08/10/this-week-in-rust-403/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-12 00:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 403" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "今天是Bevy的第一个生日！Bevy 是一个用 Rust 构建的简单数据驱动游戏引擎。它是永远免费和开源的！ReadMore:https://bevyengine.org/news/bevys-first-birthday/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://bevyengine.org/news/bevys-first-birthday/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-12 00:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy的第一个生日!" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n简单、富有表现力、流畅的 API。\n许多内置帮助程序可轻松进行请求匹配。\n并行测试执行。\n可扩展的请求匹配。\n具有同步和异步 API 的完全异步核心。\n高级验证和调试支持。\n网络延迟模拟。\n支持正则表达式匹配、JSON、serde、cookies 等。\n带有Docker 镜像的独立模式。\n支持基于 YAML 文件的模拟规范。\nReadMore:https://github.com/alexliesenfeld/httpmock" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/alexliesenfeld/httpmock" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-12 00:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "httpmock - 一个 http 服务端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "So you want to write a GUI frameworkhttps://www.cmyr.net/blog/gui-framework-ingredients.html当我们讨论GUI的时候我们在讨论什么？根据一个GUI框架是否和平台/环境紧密集成，可以将GUI框架划分成两个阵营：游戏和嵌入式设备的GUI游戏和嵌入式设备的GUI框架，其中大部分可以从系统集成的角度来考虑：游戏和嵌入式应用程序不必做那么多，因为在只有一个window 的场景下，很多功能都需要应用自己去完成。原生客户端应用的构成\n渲染窗口(Windowing)\n\nTabs: 标签页\nMenus: 菜单栏\nPainting: 绘图\nAnimation: 动画\nText: 文本\nThe compositor: 排版\nWeb views: 渲染HTML页面\n\n\n处理输入(Handling input)\n\nPointer：鼠标\nKeyboard：键盘\n\n\n便利性(Accessibility): 大量辅助技术的总称\n国际化与本土化(Internationalization and Localization)\n其他一些常见和不常见的特性\n\nTabs: 标签页\nMenus: 菜单栏\nPainting: 绘图\nAnimation: 动画\nText: 文本\nThe compositor: 排版\nWeb views: 渲染HTML页面\n\nPointer：鼠标\nKeyboard：键盘\n将以上所有要素集成起来\n设计跨平台的API；\n不要拒绝 web view；\n原生的视觉和感觉；\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-10 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如果你想实现一个GUI框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "[Media] System Tools with real-time Web UI 🖥️ 🚀https://www.reddit.com/r/rust/comments/p1b65e/media_system_tools_with_realtime_web_ui/MultiTool：项目使用RillRate(一个为机器人、微服务和IoT设备设计的实时UI工具)，实现了对CPU、内存和系统信息的监控，将数据可视化并实时呈现在web界面上。https://github.com/rillrate/rillrateTODO：\n网络监控器\n磁盘监控器\n进程监控器\n其他一些惊喜\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-10 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MultiTool: 带有实时Web界面的系统监控工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "gzp: v0.3.0 now with support for parallel compression with Snappyhttps://www.reddit.com/r/rust/comments/p1ejla/gzp_v030_now_with_support_for_parallel/gzp是一个用Rust实现的多线程压缩编码库，目前支持Gzip格式（依赖flate2)和snappy格式(依赖rust-snappy)https://github.com/rust-lang/flate2-rs\ngithub：https://github.com/sstadick/gzp\ncrate: https://crates.io/crates/gzp\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-10 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gzp: v0.3.0 现在支持多线程压缩snappy" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "FeoBlog (A distributed, Tumblr-like social network in Rust) v0.6.0 Released#新特性：改进：\n更快的在服务器之间同步数据；\n更好的在浏览器上缓存静态文件；\n支持登陆用户设置背景颜色；\nBug修复：\n切换页面时渲染组件(的bug)；\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-10 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "FeoBlog（类似Tumblr的分布式社交网络） v0.6.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "std::fs (Part 2)https://motw.rs/blog/2021/08/08/stdfs-part-2-dirs-dirs-dirs/本周继续讲解（std::fs Part 1) Rust 标准库中std::fs模块https://motw.rs/blog/2021/08/01/stdfs-part-1/std::fs 是Rust标准库中操作文件系统的模块，包括创建、读取、更新、删除等常见操作。由于不同操作系统支持的API不尽相同，本文仅展示了与平台无关的一些例子：\n通过修改时间(mtime)来聚合相同年份、月份乃至日期的文件；\n硬链接(hard link)一个路径至另一个路径；\n递归创建目录；\n递归删除文件夹；\n拷贝文件；\nRust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-10 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一周一库（Rust Module of the Week）：std::fs Part 2" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 是围绕着“零成本抽象”的概念构建的。其理念是，您可以编写人机友好的高级代码，而编译器将为您提供至少与您自己编写的任何优化的低级别代码一样好的性能。使用零成本抽象，您不再需要在可维护性和性能之间进行权衡。不幸的是，很难确保零成本抽象是真正的零成本，并且在实践中Rust经常不能满足这个崇高的理想。在这篇文章中，我将展示两个例子，在这两个例子中，即使看似简单的零成本抽象实际上也不是零成本。原文链接https://blog.polybdenum.com/2021/08/09/when-zero-cost-abstractions-aren-t-zero-cost.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-09 20:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "当零成本抽象不再是零成本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "fd 是一种简单,快速和用户友好的find替代方案. 是使用 Rust 编写的一个命令行工具, github 有 18.3k 星.现在作者因为家庭以及其他的维护工作, 无法持续提供特别的精力在这个项目上. 如果有人想参与一个中型大小的项目, 可以联系作者.原文链接https://www.reddit.com/r/rust/comments/p0fvte/fd_is_looking_for_contributors/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-09 20:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "fd 正在寻找贡献者" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文链接https://blog.frankel.ch/start-rust/9/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-09 20:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 的 Vector" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "第 24 期 Rust GameDev 月刊.原文链接https://gamedev.rs/news/024/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-09 20:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Month in Rust GameDev" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "由rust.cc举办的Rust Meetup今天在杭州鼎创财富中心B2座2层举办，主要议程如下：\n《Rust+Tokio/mio在又拍云的实践》 夏功勋 又拍云工程师\n《Tokio Internals》 王福音 溪塔工程师\n《Rust 生态的性能调试器》 pprof-rs 杨可真 pprof-rs 作者\n《深挖 move 语义》丁邵顺\n《Rust 的 Web 开发见解》赵春霖 Rust Web 开发者\n《ARM 上的 Cloud- Hypervisor》李枫 独立开发者\n《cps 变化在 Rust 语言中尾递归应用及其性能分析》常开颜 中科院博士\n本次会议联合主办方：又拍云、CITA Hub；直播支持：CSDN。大会录播视频剪辑好后，将会在MikeTang的B站主页公布。https://space.bilibili.com/25566598?from=search&seid=360512592641993419" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-08 21:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Meetup 杭州站" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作何 Tim McNamara 是一位经验丰富的程序员，对自然语言处理、文本挖掘以及更广泛的机器学习和人工智能形式有着浓厚的兴趣。 他在包括新西兰开源协会在内的开源社区中非常活跃。Rust in Action 是使用 Rust 进行系统编程的实践指南，它是为具有好奇心的程序员编写的，提供了远远超出语法和结构的实际用例。国外最近的Rust的书籍，除了《Rust In Action》还有另外两本，《Refactor to Rust》和 《Rust Servers, Services, and Apps》。Amazonhttps://www.amazon.com/dp/1617294551/ref=cm_sw_r_cp_awdb_imm_VJ4HZ4859SDB7K5B7VQK" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-08 21:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《Rust In Action》书籍第一版发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Golang、Rustlang net 库受到之前在 Netmask 中发现的严重 IP 地址验证漏洞的影响。 GitHub 上 “import net” 的结果超过 400 万条，Kubernetes 也 cherry picked 了修复程序。本周，在DEF CON上，安全研究人员Cheng Xu、Victor Viale、Sick Codes、Nick Sahler、Kelly Kaoudis、opennota和John Jackson披露了 Go 和 Rust 语言的 net 模块的一个缺陷。CVE-2021-29922（针对Rust） 和 CVE-2021-29923（针对Golang）。IP地址可以用多种格式表示，包括十六进制和整数，不过最常见的IPv4地址是用十进制格式表示的。例如，BleepingComputer的IPv4地址以十进制格式表示为104.20.59.209，但同样的地址也可以以八进制格式表示为：0150.0024.0073.0321。假设你得到一个十进制格式的IP地址，127.0.0.1，这被广泛理解为本地回环地址或localhost。如果你在它前面加上一个0，应用程序是否仍应将0127.0.0.1解析为127.0.0.1或其他什么？在Chrome的地址栏中输入0127.0.0.1，浏览器会将其视为八进制格式的IP。在按下回车键或返回键时，该IP实际上变成了十进制的87.0.0.1，这就是大多数应用程序应该处理这种模糊的IP地址的方式。根据IETF的原始规范，IPv4地址的部分内容如果前缀为 \"0\"，可以解释为八进制。但是Go和Rust中的net模块都忽略了这一点，将部分地址视为十进制。rust 1.52.1 std::net 及以下版本中IP地址输入未按八进制处理而导致不确定的 SSRF 和 RFI 漏洞。例如，攻击者向依赖std::net::IpAddr的网络程序提交IP地址，可以通过输入位组的输入数据引起 SSRF；如果位组（octet）是3位，攻击者可以提交可利用的IP地址，最小可利用的位组是08（拒绝服务），最大可利用的位组是099（拒绝服务）。例如，攻击者可以提交010.8.8.8，也就是8.8.8.8（RFI），然而std::net::IpAddr将计算为10.8.8.8。同样，攻击者可以输入127.0.026.1，这实际上是127.0.22.1，但Rust将其计算为127.0.26.1。\nSSRF是Server-side Request Forge的缩写，中文翻译为服务端请求伪造。\nRFI 是Remote File Inclusion的缩写，客户端可控制网页包含远程文件。\n受影响 Rust 版本： 1.52.1 及以下。PoC 代码：https://github.com/sickcodes/security/blob/master/advisories/SICK-2021-015.mdhttps://www.bleepingcomputer.com/news/security/go-rust-net-library-affected-by-critical-ip-address-validation-vulnerability/Read Morehttps://www.bleepingcomputer.com/news/security/go-rust-net-library-affected-by-critical-ip-address-validation-vulnerability/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-08 21:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "[CVE-2021-29922] Rust 标准库net 模块漏洞： 前导零改变 IP 地址" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "《End-to-End Encryption with Rust》是一本实践指南， 在本指南中，我们将创建两个名为 Alice 和 Bob 的小型 Rust 程序。 Alice 和 Bob 将通过云服务通过网络相互发送消息。 在我们的代码示例中，Alice 和 Bob 将相互进行身份验证，并将获得加密保证，以确保其消息的完整性、真实性和机密性得到端到端的保护。网络上的中间云服务和攻击者将无法看到或更改途中消息的内容。 在后面的示例中，我们还将看到即使当 Alice 和 Bob 之间的通信路径更复杂 - 具有多个传输连接、各种传输协议和许多中介时，我们如何才能实现这种端到端保护。Read Morehttps://github.com/ockam-network/ockam/tree/develop/documentation/use-cases/end-to-end-encryption-with-rust#readme" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-08 21:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 进行端到端加密" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "欢迎阅读新一期的“本月 Rust OSDev”。在这些帖子中，我们定期概述了 Rust 操作系统开发生态系统中的显着变化。本系列在 GitHub 上公开开发。随意在那里打开pull requests，其中包含您希望在下一期中看到的内容。如果您在此页面上发现了一些问题，请通过创建issue或使用我们在此页面底部的评论表来报告它们。文章链接，https://rust-osdev.com/this-month/2021-07/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust-osdev.com/this-month/2021-07/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-07 23:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本月 Rust OSDev（2021 年 7 月）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Hi! 我已经学习 Rust 大约一个月了，我正在研究我的第一个 Rust 项目“Reason”（https://github.com/jaywonchung/reason）Reason 是“研究论文的shell”。调用 reason 将打开一个命令提示符，您可以在其中运行 ls、cd、touch、open 或 ed 等命令。文章链接，https://www.reddit.com/r/rust/comments/ozo139/request_for_first_project_code_review/Github 链接，https://github.com/jaywonchung/reason" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/ozo139/request_for_first_project_code_review/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-07 23:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "请求第一次项目code review" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，我一直在做一个模拟，它在你的浏览器中运行，使用人工智能（具体来说：遗传算法）来尝试制造越来越好的车辆。车辆必须克服障碍路线，从一些小山坡开始，然后是陡峭的山坡，最后是一些跳跃。车辆由面板和轮子制成，连接在一起，类似于Besiege游戏。Github 链接，https://github.com/Bauxitedev/vehicle_evolver_deluxehttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Bauxitedev/vehicle_evolver_deluxe" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-07 23:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我制作了一个网络应用程序，可以学习使用 AI（遗传算法）构建车辆，使用Rust编写" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ConnectorX 团队观察到现有解决方案在下载数据时或多或少会多次冗余数据。此外，在 Python 中实现数据密集型应用程序会带来额外的成本。ConnectorX 是用 Rust 编写的，并遵循“零拷贝”原则。这允许它通过变得对缓存和分支预测器友好来充分利用 CPU。此外，ConnectorX 的架构确保数据将直接从源复制到目标一次。\nhttps://github.com/sfu-db/connector-x\nDatafuse 是 Rust 编写的一种具有云原生架构的现代实时数据处理和分析 DBMS，旨在简化数据云。\nhttps://mp.weixin.qq.com/s/E1lL-zj6sTS3sH-vv5NEKw （官方）\nhttps://rustcc.cn/article?id=9773eea8-e7a4-4d5e-940a-74edf81557ef (站内)\n文章仔细研究 Base64 算法，并使用 Rust 编程语言从头开始实现编码器和解码器。\nhttps://dev.to/tiemen/implementing-base64-from-scratch-in-rust-kb1\n\nhttps://ibraheem.ca/writings/a-simple-web-server/\nTokio 是一个 Rust 异步运行时库，底层基于 epoll/kqueue 这样的跨平台多路复用 IO 以及 event loop，目前正在支持 io_uring。它的 scheduler 和 Erlang/Go 实现的 N:M threads 类似，线程会执行 Task，可以充分利用多核。Task 是 Rust 基于 Future 抽象出的一种绿色线程，因为不需要预先分配多余的栈内存，可以创建大量 task，很适合做 IO 密集型应用。\nhttps://tony612.github.io/tokio-internals/01_intro_tokio.html\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-06 18:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 创业公司、开源 Data Cloud 服务商 「Datafuse Labs」完成数百万美金种子轮及天使轮融资，融资资金主要用于第一代产品的研发和国际化团队的搭建。Datafuse Labs 核心成员均是 ClickHouse 社区头部贡献者。目前在使用 Rust 构建一个完全面向云架构的新式开源数仓 Datafuse ，致力于为用户、企业提供更低成本、更高性能、更加易用的数据建设处理一体化平台。代码地址： https://github.com/datafuselabs/datafuse项目官网： https://datafuse.rs关注周报以了解第一手开发资讯： https://github.com/datafuselabs/weekly" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/datafuselabs/weekly" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-06 16:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "负责 Datafuse 内核设计与研发，有丰富的分布式系统经验，熟悉  Rust 或 C++ ，对数据库有着浓厚的兴趣，可 Remote 办公。负责 Datafuse Cloud 产品设计与研发，有 Kubernetes 开发经验者优先，可 Remote 办公。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-06 16:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "加入我们" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "slitter 是由 Backtrace Labs 团队设计实现并用于 C 后端服务器的 slab 分配器，采用 Rust 编写。在实际生产的两个月中，该团队使用 slitter 来：\n检测错误的分配类别\n避免使用任何带内元数据（in-band metadata）\n保证类型稳定分配\n允许每个分配类指定如何映射它的备份内存\nSlitter: a slab allocator that trusts, but verifies (in Rust, for C): https://engineering.backtrace.io/2021-08-04-slitter-a-slab-allocator-that-trusts-but-verifies/GitHub: https://github.com/backtrace-labs/slitterCrates.io: https://crates.io/crates/slitter" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/slitter" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-05 23:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "slitter 可信且经过验证的 slab 分配器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "IMDb-ID 被设计成一个易于使用的交互式命令行工具，用于按名称搜索某些电影或电视节目并获取它的 IMDb ID 。codeberg: https://codeberg.org/alpha-tango-kilo/imdb-idCrates.io: https://crates.io/crates/imdb-id" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/imdb-id" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-05 23:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "IMDb ID" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 402: https://this-week-in-rust.org/blog/2021/08/04/this-week-in-rust-402/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/08/04/this-week-in-rust-402/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-05 23:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 402" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "感谢 @AlexZhang 供稿GAT RFC 从2016年启动，到今年已经五年了，现在终于接近稳定状态了。GAT 是 Rust github 仓库里期待率最高的一个问题。现在经过编译器的大量修改，终于让 GAT 达到了一个 「完整」状态，虽然还有一些诊断问题，但现在你在 nightly 下使用 GAT 将不会看到 “generic_associated_types is incomplete”这种错误。 但是现在想 稳定 GAT ，还需要大家来帮助测试此功能，为你发现但任何错误或潜在的诊断改进提出问题。并且官方还希望可以在 GAT 上实现一些有趣的模式。如果不出意外，未来几个月内稳定应该会比较顺利。详细内容请看原文吧，原文也介绍了什么是 GAT 。[https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html]（https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html）" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-04 21:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "官方 | 来推动 GAT 稳定吧" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "毫无悬念。对于这件事，我想社区大部分人已经审美疲劳了，感兴趣的请直接访问下面地址查看原始数据：https://insights.stackoverflow.com/survey/2021#technology-most-loved-dreaded-and-wanted" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://insights.stackoverflow.com/survey/2021#technology-most-loved-dreaded-and-wanted" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-04 21:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust连续6年成为开发者最喜爱编程语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 云原生组织成立，用于推动 Rust 在云原生领域的生态发展。其实 Rust 生态中已经有一些有关云原生的项目了。\nBottlerocket OS\nCloud Native Rust Day\nFirecracker\nkube-rs\nKubewarden\nKrustlet\nRust Foundation\nTiKV\n详情请参考：https://nickgerace.dev/post/launching-rust-cloud-native" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://nickgerace.dev/post/launching-rust-cloud-native" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-04 21:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 云原生组织成立" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个库不知不觉已经来到 v0.9 了。界面长这个样子：是否愿意尝试，读者自己决定。https://github.com/kas-gui/kas" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-04 21:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "kas - 一个新的 GUI 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Gcc Rust？对，Kernel 需求推动的 gcc 对 rust 的支持。稳步推进中。https://thephilbert.io/2021/08/02/gcc-rust-monthly-report-8-july-2021/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://thephilbert.io/2021/08/02/gcc-rust-monthly-report-8-july-2021/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-04 21:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Gcc Rust 月报" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者的游戏之前是用 C++ 写的。这篇文章详细记录了他决心使用rust重写的心路历程和一些idea的发展。推荐阅读：https://itnext.io/rewriting-my-mobile-game-in-rust-targeting-wasm-1f9f82751830" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://itnext.io/rewriting-my-mobile-game-in-rust-targeting-wasm-1f9f82751830" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-04 21:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust重写我的手机游戏，并且编译到 wasm" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "CRDT 全称 Conflict-Free Replicated Data types. 主要用于在线合作文档编辑等方面. 作者详细介绍了如何提升相关实现和算法的一些过程,并且最终使得提升了 5000 倍的速度.原文链接https://josephg.com/blog/crdts-go-brrr/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-02 20:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "5000倍速度提升的 CRDT" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者分享了自己如何使用 Rust 重写自己的 Lisp 代码, 如何成功的写出更慢的代码 并且 修复他们的故事.原文链接https://renato.athaydes.com/posts/how-to-write-slow-rust-code.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-02 20:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何写出运行缓慢的 Rust 代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "egglog 是一个 prolog-like 语法的库, 作用用他来证明了一个定理.原文链接https://www.philipzucker.com/egglog2-monic/在线 demohttp://www.philipzucker.com/egglog/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-02 20:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Egglog: 使用 Rust 来证明一个定理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一系列的 Rust 教学视频, 本期展示如何使用vim 和 tmux 来搭建自己的 Playground.油管视频https://www.youtube.com/watch?v=SkxdcOea-rE--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-02 20:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust playground at your fingertips" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Voila 是一种通过 CLI 工具启动的特定领域语言，用于以快速可靠的方式处理大量文件和目录。安装需要切换到 nightly 版本：一些使用实例：语法如下：GitHub：Alonely0/Voila: Voila is a domain-specific language launched through CLI tool for operating with files and directories in massive amounts in a fast & reliable way.https://github.com/Alonely0/Voila" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-01 20:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "voila：另类处理文件的方式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "获取任意 Read 流并在不消耗原始流的情况下 “窥视” 到流中：GitHub 地址：orlp/peekread: Rust crate for making Read streams peekable.https://github.com/orlp/peekread" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-01 20:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "peekread：使 Read 流变得可窥视" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自维基百科的解释：ONNX（英语：Open Neural Network Exchange ）是一种针对机器学习所设计的开放式的文件格式，用于存储训练好的模型。它使得不同的人工智能框架（如 Pytorch、MXNet）可以采用相同格式存储模型数据并交互。 ONNX 的规范及代码主要由微软，亚马逊， Facebook 和 IBM 等公司共同开发，以开放源代码的方式托管在 Github 上。目前官方支持加载 ONNX 模型并进行推理的深度学习框架有： Caffe2, PyTorch, MXNet，ML.NET，TensorRT 和 Microsoft CNTK，并且 TensorFlow 也非官方的支持 ONNX。https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BD%AFGitHub：haixuanTao/onnxruntime-rs: Rust wrapper for Microsoft's ONNX Runtime (version 1.7)https://github.com/haixuanTao/onnxruntime-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-01 20:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "onnxruntime-rs：ONNX 的 Rust 皮（V1.7）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个为学习 ptest 解析器而构建的内存 SQL 数据库。一些例子：看样子是有一本书要写，不过还没开始。GitHub：andrewhalle/byo-sql: An in-memory SQL database in Rust.https://github.com/andrewhalle/byo-sql" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-01 20:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "sql-rs：内存数据库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "相比 earlyoom 有更少的内存占用（注意是 Linux 系统的，不是跨平台的噢）：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-01 20:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "bustd：轻量进程杀手守护进程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个 NUT（Network UPS Tools）的 Rust 客户端。确认 UPS 已经连接：GitHub: aramperes/nut-client-rs: A Network UPS Tools (NUT) client library for Rust.https://github.com/aramperes/nut-client-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-01 20:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "nut-client-rs：NUT Rust 客户端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "嗯，这个打出来的效果真的是这样的：代码如下：大家觉得好看么？欢迎留言；）GitHub: MakotoE/prettier-print: 🌈 Prettier-printed debug strings 🌈https://github.com/MakotoE/prettier-print" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-01 20:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Prettier-Print" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个框架一出，意味着 tokio 生态正在强势建立！ 算的上是 Rust Web 开发领域的里程碑事件！让其他 web 框架顿时失色！当然，我并不是否认其他 web 框架的优秀！该框架全面整合 tokio 生态，并且由 tokio 团队自己维护。这一点就很占优势了！博客链接，https://tokio.rs/blog/2021-07-announcing-axum" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://tokio.rs/blog/2021-07-announcing-axum" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-31 19:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Axum: Tokio 出品的 Web 框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rustc_codegen_gcc 是 rustc 的 GCC 代码，这意味着它可以被现有的 rustc 前端加载，通过支持更多的架构和 GCC 的优化而受益于 GCC。当前状态：Antoyo 手动实现了 popcount（因为 gcc 会产生一个对某些函数的调用，这在 no-std 中是行不通的）。除此之外，修复了一些东西，使之更容易在 godbolt 中添加这个 gcc 代码，并使 Antoyo 的这个PR合并到 rustc 中。https://github.com/rust-lang/rust/pull/87260报告#2的详情参见 Antoyo 的博客链接，https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-2" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-31 19:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustc_codegen_gcc 进展报告#2" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Hora，Rust 实现的近似最邻近搜索（Approximate Nearest Neighbor Search, ANNS）算法库。先发布了 v0.1.0，专注于近似最邻近搜索领域，已经实现了 HNSW（Hierarchical Navigable Small World Graph Index）索引，SSG（Satellite System Graph）索引，PQIVF（Product Quantization Inverted File）索引，BruteForceIndex，其他索引也即将推出。Hora 可以部署在任何操作系统平台上，已经支持的 PC 操作系统 Linux，Mac OS，Windows，将支持移动设备操作系统 IOS 和Android，以及将来支持嵌入式系统（no_std），并将支持多语言绑定，包括 Python，Javascript，Java，Ruby，Swift 和 R。相关链接信息：Github：https://github.com/hora-search/hora官网：https://horasearch.com/在线Demo：https://horasearch.com/#DemosPython library: https://github.com/hora-search/horapycrate: https://crates.io/crates/hora" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-31 19:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Hora 0.1.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Scott Mabin 全职加入 Espressif，将为其所有芯片提供 Rust 支持，改善其芯片的 Rust 生态系统。乐鑫科技（股票代码：688018）是一家全球化的无晶圆厂半导体公司，成立于2008 年，在中国、捷克、印度、新加坡和巴西均设有办公地，团队来自20 多个国家和地区。支持esp的分叉编译器已经被移到 esp-rs组织中，同时还有一些idf支持板块--很快就会有更多的内容。在esp-rs/rust资源库中的讨论已经开始，在过去的一个月中，Espressif每周都会举办社区会议，重点是推动Rust支持的发展。@ivmarkov 一直在努力将Rust STD库移植到esp-idf上，esp-idf是Espressif芯片的基于C的开发环境，esp-idf有一个newlib环境，可以用来构建Rust库。@ivmarkov把rust-esp32-std-hello演示版本放在一起，以展示其功能，其中包括WiFi、线程和使用esp-idf的驱动来驱动显示器。非常酷的东西! 有一些初期的问题，你可以在这里追踪，但希望我们很快就能开始向上游提供这些补丁。为了补充Espressif芯片的标准库，esp-idf-hal已经被更新并移到esp-rs组织中。这个 crate 有API来使用标准库中没有抽象的外围设备和硬件，例如SPI外围设备。与HAL一起，esp-idf-svc也被加入，它是Espressif芯片的嵌入式svc特性的实现。embedded-svc背后的目标是提供围绕更高级别的嵌入式服务的抽象，WiFi、Ping、HTTPD、NVS等。博文链接，https://mabez.dev/blog/posts/esp-rust-espressif/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://mabez.dev/blog/posts/esp-rust-espressif/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-31 19:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Scott Mabin 全职加入乐鑫科技 Espressif" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Lemmy 类似于Reddit、Hacker News等网站。你订阅你感兴趣的论坛，发布链接和讨论，然后投票，并对其进行评论。在背后它却是非常不同的；任何人都可以很容易地运行一个服务器，所有这些服务器是联合的（类似电子邮件），并连接到同一个宇宙，称为Fediverse。对于一个链接聚合器来说，这意味着在一个服务器上注册的用户可以订阅任何其他服务器上的论坛，并可以与其他地方注册的用户进行讨论。总体目标是创建一个容易自主托管的、分散的替代Reddit和其他链接聚合器的网站，不受公司控制和干涉。Github链接，https://github.com/LemmyNet/lemmy发布链接，https://lemmy.ml/post/75818https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://lemmy.ml/post/75818" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-31 19:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Lemmy 发布 v0.11.3" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n属性宏上可以调用函数式宏了\n例如，如果你的项目的 README 已经有一个很好的文档注释了，你可以使用 include_str! 直接将里面的内容加入文档中。\n稳定了 wasm32 intrinsics API\nWasm32平台的一些 intrinsic 已经得到了稳定，从而可以访问 WebAssembly 中的 SIMD 指令。\n\n第 n 次重新默认启用了增量编译\n\n\n标准库稳定了如下 API：\n\nBTreeMap::into_keys\nBTreeMap::into_values\nHashMap::into_keys\nHashMap::into_values\narch::wasm32\nVecDeque::binary_search\nVecDeque::binary_search_by\nVecDeque::binary_search_by_key\nVecDeque::partition_point\n\n\n第 n 次重新默认启用了增量编译标准库稳定了如下 API：\nBTreeMap::into_keys\nBTreeMap::into_values\nHashMap::into_keys\nHashMap::into_values\narch::wasm32\nVecDeque::binary_search\nVecDeque::binary_search_by\nVecDeque::binary_search_by_key\nVecDeque::partition_point\n链接：https://blog.rust-lang.org/2021/07/29/Rust-1.54.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2021/07/29/Rust-1.54.0.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-30 20:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.54 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "futures-core 的 ready!() 宏存在好几年了，这个宏可以在处理 Future 的时候减少很多模板代码：ready!() 宏稳定之后将会在  std::task 模块。链接：https://github.com/rust-lang/rust/pull/81050" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-lang/rust/pull/81050" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-30 20:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "task::ready! 宏将在 1.56 稳定" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "链接：https://blog.guillaume-gomez.fr/articles/2021-07-29+Interacting+with+data+from+FFI" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.guillaume-gomez.fr/articles/2021-07-29+Interacting+with+data+from+FFI" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-30 20:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 如何和 FFI 的数据打交道" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ra 的作者出了一系列视频讲解 ra 的原理。链接：https://www.youtube.com/playlist?list=PLhb66M_x9UmrqXhQuIpWC5VgTdrGxMx3y" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/playlist?list=PLhb66M_x9UmrqXhQuIpWC5VgTdrGxMx3y" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-30 20:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Explaining rust-analyzer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Reddit上有人问：我一直在每一个我认为会经常被调用的函数上拼命地写#[inline]，但这真的需要吗？inline只是提示编译器该函数可以被内联，而编译器可以忽略这一点或自行决定何时进行内联，所以我应该在什么时候用#[inline]标记我的函数？我正在制作一个使用一些自定义迭代器进行音频处理/合成的crate，我希望这些crate能快速运行。推介阅读一下这片博客，同时也是热评的回复：Read More：https://matklad.github.io/2021/07/09/inline-in-rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://matklad.github.io/2021/07/09/inline-in-rust.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-29 13:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "什么时候去使用#[inline]" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个通用的异步HTTP请求创建包，旨在成为各种HTTP客户端的一个薄的包装，并处理TLS、序列化和解析。主要目标是允许二进制文件（拉入一些利用HTTP客户端的库）指定应该使用什么实现。如果使用代理,则通过HTTP_PROXY自动检测。Read More：https://docs.rs/crate/generic-async-http-client/0.1.1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://docs.rs/crate/generic-async-http-client/0.1.1" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-29 13:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "generic-async-http-client" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Reddit上的帖子，不过回复的热评是之前日报报道过的项目，因为也是今日的热帖，所以再报道一次：如果你想尽可能的减少Rust生成的二进制文件大小，请看这里：min-sized-rust：https://github.com/johnthagen/min-sized-rust如果这还不够满足你的需求，还可以再看这里：https://blog.mgattozzi.dev/rusts-runtime/Read More：https://www.reddit.com/r/rust/comments/otam71/question_about_rusts_binary_size/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/otam71/question_about_rusts_binary_size/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-29 13:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "与c相比，如何改善Rust巨大的二进制大小？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Reddit上的帖子：感觉我开始的每一个涉及互联网的项目都有一些问题，无法编译 \"openssl-sys\"，或者需要一些工具链的更新或使用平台方的ssl进行交叉编译，等等。我总是要花上一两个小时来解决这个问题。我来自NodeJs和Python，在那里我可以随心所欲地进行网络请求，以前甚至从来没有想过SSL的问题，为什么处理SSL的问题会让Rust头疼？作者遇到的问题，相信使用过跨平台编译的锈都有所体会，最简洁的解决方案，热评里已经提供：我也有同样的感觉，但后来我意识到，我可以使用特征标志将我拥有的几个使用OpenSSL的程序配置为使用RusTLS。非常简单。评论还将Reqwest作为例子，在大部分Rust网络相关的crate里，你都能使用找到相关的feature进行替换。https://docs.rs/reqwest/0.11.4/reqwest/#optional-featuresRead More：https://www.reddit.com/r/rust/comments/oto406/why_is_ssl_such_a_pain/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/oto406/why_is_ssl_such_a_pain/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-29 13:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust编程里SSL为什么是痛点？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "macroquad游戏引擎在最近将其音频系统给单独提取出来，作为一个更通用的Rust包，该crate是对多个平台的多个音频后端的统一抽象，目前完成度如下：\n Web: WebAudio\n Android: OpenSLES\n Linux: Alsa\n Mac: CoreAudio\n Windows: Wasapi\n IOS: CoreAudio(?)\nGithub：https://github.com/not-fl3/quad-sndRead More：https://twitter.com/fedor_games/status/1420427861517905920" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://twitter.com/fedor_games/status/1420427861517905920" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-29 13:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "macroquad游戏引擎分离出音频系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Local Native是一个跨平台的Rust写的桌面应用程序，使用的UI框架是iced，教程记录了如何搭建整个程序的过程，因为本人水平有待提高，因此教程肯定会有不少问题，希望对此感兴趣的朋友可以提出问题，我会尽可能解决。这个项目会长期维护，知道iced等重要依赖达到1.0稳定版本。上次收到的反馈有注释过长之类的，在新版本中有了改正，非常感谢大家的反馈。项目总结：https://localnative.app/blog/2021/07/28/localnative-2021-soc-retrospective-blog0-9章：https://localnative.app/docs/tutorial0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://localnative.app/docs/tutorial0" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-29 13:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Local Native系列教程完结了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "– Ralf Jung 发表于 Eureka Alert Science Newshttps://www.eurekalert.org/pub_releases/2021-07/su-cs071521.phpRead More:https://this-week-in-rust.org/blog/2021/07/28/this-week-in-rust-401/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/07/28/this-week-in-rust-401/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-29 13:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周引语" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章主要介绍了关于编程语言对生产力和程序效率的影响的讨论。ReadMore:https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://renato.athaydes.com/posts/revisiting-prechelt-paper-comparing-languages.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-29 00:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Prechelt 的论文 - 比较Rust、Java、Lisp、C/C++ 和脚本语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Gloo 团队很高兴地宣布一个新的、姗姗来迟的 Gloo 版本：v0.3.0。Gloo 是一个模块化工具包，用于使用 Rust 和 WASM 构建快速、可靠的 Web 应用程序和库。ReadMore:https://gloo-rs.web.app/blog/release-0.3.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gloo-rs.web.app/blog/release-0.3.0" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-29 00:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Gloo v0.3.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 写的esp8266驱动程序,通过串口与esp8266 模块通信。通过这个模块，可以加入现有的接入点或创建自己的接入点。创建网络后，该模块既可以侦听传入的 TCP 连接，也可以连接到其他套接字。ReadMore:https://github.com/alekseysidorov/esp8266-wifi-serial" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/alekseysidorov/esp8266-wifi-serial" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-29 00:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "esp8266-wifi-serial" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "9 advantages of programming in Rusthttps://tim.mcnamara.nz/post/657832047640985600/nine-advantages-of-programming-in-rust和其他拥有安全特性的编程语言相比，Rust语言提供的安全保证不以额外的运行时开销为代价。在同等情况下，Rust语言编写的程序往往占用更少的内存，这使得可以在更少的机器节点上运行更多的Rust应用程序，机器资源的需求降低意味着更多的成本被节省。Rust编译器人性化的错误输出更像是一个教练而不是一个严厉的批评家，使你更容易发现和调试错误。由于Rust编译器提供了安全保证，即使是新手或者不自信的普通程序员也能受益于Rust高效的生产速度。Rust对于很多人来说并非第一门编程语言，即使是完全使用Rust编写程序的开发人员也很少见。Rust的社区是一个多学科的社区，这意味着Rust的生态系统受益于很多经过酝酿和提炼的来自不同领域的想法。虽然Rust标榜自己是一门“系统编程语言”，但在许多其他领域Rust也展现出了很强的适用性。Rust的设计流程是高度协同的，一个新的功能往往要经过好几年才会成为稳定特性，部分原因是通常要经过多轮深思熟虑的设计迭代。使用Rust编写依赖第三方程序库的项目，仅仅需要在配置文件中加入一两行代码。这使你避免了可能会遇到诸如区分多解释器版本、不匹配的版本依赖、奇怪的链接错误或者使用神秘的模块系统等各种问题。Rust社区的首要目标是提升生产力。当你花时间去学习Rust并且你的工作因为Rust而变得富有成效时，你会发现自己会更有信心。关于作者：Tim McNamara是《Rust in Action》一书的作者，他活跃在Twitter上，并且在Youtube上开设了一系列课程。https://www.manning.com/books/rust-in-action" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-27 22:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust编程的9个优势" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 闭包你了解底层实现嘛？https://mp.weixin.qq.com/s/c1DyCemMTRfPjCsA5BBDTg闭包 Closure, 又称词法闭包 Lexical Closure 或函数闭包 function closures, 是引用了自由变量的函数。闭包是由匿名函数和与其相关的引用环境组合而成的实体。闭包捕获变量优先只读引用，然后可变引用，最后 move 所有权" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-27 22:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 闭包你了解底层实现嘛？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Awesome Unstable Rust Featureshttps://lazy.codes/posts/awesome-unstable-rust-features/本文讲解了Rust编译器的若干不稳定特性，并且通过例子来使读者了解不稳定特性的基本用法和情况。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-27 22:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "棒极了的Rust不稳定特性" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Understanding Rust futures by going way too deephttps://fasterthanli.me/articles/understanding-rust-futures-by-going-way-too-deep深入了解Rust的futures，文章较长，阅读大约需要107分钟。Rust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-27 22:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "深入了解Rust futures" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "年度 Rust 中国大会从 2019 年开始，从未缺席，即使在 2020 严肃的疫情大环境下也是热情不减。而在这背后，是 Rust 社区集体的力量！Rust 大会志愿者们都是一群无法抑制内心技术骚动的人，为了推广 Rust 的共同目标，全情的投入，发挥自己最大的能量。作为 Rustaceans，Rust 即是我们的信仰。我们一直秉承这个信念，相信 Rust 会成为未来的潮流，相信 Rust 社区会越来越壮大，相信 Rust 大会越办越好。这个信念，值得我们长期为之努力。Rust 很酷，我们期待你的加入～原文链接https://www.wjx.top/vm/exW24IP.aspx" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-26 20:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "志愿者招募令: 一起 Rust the world!" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cool Bear最新的文章.通过一步一步的代码示例,帮你深入理解 Rust 中的 Future.原文链接https://fasterthanli.me/articles/understanding-rust-futures-by-going-way-too-deep" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-26 20:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "通过深入了解的方式理解 Rust 的 Future" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "相比其他语言，Rust 的异步很有趣、很强大、很独特。而 Tokio 是 Rust 社区的一个非常流行的异步 runtime 实现，非常值得学习。本文会讲解 Tokio 的内部源码实现，以及一些精彩设计。原文链接https://tony612.github.io/tokio-internals/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-26 20:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio 内部实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust究竟是一门怎样的语言? 为什么连续五年夺得”最受程序员喜爱的编程语言”称号。我们有幸邀请到Rust中文社区的苏林老师分享一下:课程主题：《认识面向基础架构语言Rust》课程时间：  2021年8月1日 20:30-21:30课程内容：\nRust语言设计思想\nRust语言现状和未来\n通过一个hello word理解Rust语言如何执行\n原文链接https://mp.weixin.qq.com/s/z-L33EyR7qac8KUlSxUFlA" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-26 20:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "公开课：认识面向基础架构语言Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 已经开始进入linux 内核中, 这对于安全来说, 将是一个巨大的进步.原文链接https://www.techrepublic.com/article/let-the-linux-kernel-rust/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-26 20:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Let the Linux kernel Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "@tobmansf一直在研究用于游戏原型设计和故事逻辑的脚本语言 github.com/t-mw/throne。 它编译成 WebAssembly，可以在 t-mw.github.io/throne-playgro 上试一试https://twitter.com/tobmansfRepot-mw.github.io/throne-playgro" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-25 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Throne 一个游戏原型设计和故事逻辑的脚本语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Godot 的 egui 集成版本发布初始版本了！你可以在github上获取Repohttps://github.com/setzer22/godot-egui" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-25 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Godot 的 Egui 继承版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read Morehttps://www.youtube.com/watch?v=PmtwtK6jyLc" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-25 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【视频】使用Rust创建AWS Lambda" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read Morehttps://www.heapstack.sh/why-you-should-code-in-rust-in-2021?utm_source=twitter.com&utm_medium=social&utm_campaign=some-times-ago--i-wrote-an-article-on-wh&utm_content=52800808" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-25 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么你应该在 2021 年学习用 Rust 编写代码" }, "type": "text" }], "type": "title" } },]
