export const propertiesForNewPages = [{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个易于使用的库，用于打印漂亮的 Rust 结构和枚举表。使用：要将结构或枚举列表作为表打印，您的类型应该实现 Table trait，或者使用 \"#[derive(Tabled)]\"宏派生它。大多数默认类型都是默认实现 trait 的。文章链接，https://www.reddit.com/r/rust/comments/xs3x9r/media_tabled_v090_an_easy_to_use_library_for/Github 链接，https://github.com/zhiburt/tabled"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/zhiburt/tabled"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-10-01 10:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"tabled  [v0.9.0]: 一个易于使用的美观打印表格的库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rumqttd 诞生于我们对可扩展性和性能代理的需求，以支持我们在 Bytebeam 解决的各种物联网用例。我们一直相信开源是构建核心基础设施组件的正确方法。为此，我们现在开放了 MQTT 代理的新版本。从 MQTT 客户机的角度来看，这个新版本向前兼容早期版本。但是，内部和配置文件语法已经进行了修改，以便将来的开发更加容易。...文章链接，https://bytebeam.io/blog/the-rust-based-mqtt-broker-rumqtt-gets-new-internals-cl8d5ur0u650711mmnqn9elrxgGithub 链接，https://github.com/bytebeamio/rumqtt"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/bytebeamio/rumqtt"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-10-01 10:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rumqtt：基于rust的mqtt代理"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个轻量级高性能 HTTP 请求路由器重新设计了节点数据结构，使其更加健壮和安全。文章链接，https://www.reddit.com/r/rust/comments/xsa0o9/pathtree_v060_a_lightweight_high_performance_http/Github 链接，https://github.com/viz-rs/path-treehttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/viz-rs/path-tree"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-10-01 10:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"path-tree [v0.6.0]"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"✨🎊🎉它可以工作!!!!🎉🎊✨🦀🐧🍎🔻🧊🇼👩🔥🦊⚙️可以运行 GNOME!! Firefox 可以正常运行!! 能看 YouTube, 玩 Neverball, 运行 KDE 应用程序, 还有更多的东西可以使用!! 没有崩溃!!!🎉🎉运行在 Apple M1 的本机 Linux GPU 驱动程序上!!🚀在我最新的视频里展示了这些成果!!!油管: https://www.youtube.com/watch?v=k0cnMUroMlQ上面是推特的原文翻译，感兴趣的可以去看看视频。对了，这个驱动是用Rust开发的，作者还写了一篇经验稿：关于Asahi linux: https://asahilinux.org/about/源推: https://twitter.com/LinaAsahi/status/1575343067892051968"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://twitter.com/LinaAsahi/status/1575343067892051968"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-29 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Asahi Lina开发的苹果M1显示驱动程序可以正常工作了"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2022/09/28/this-week-in-rust-462/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-29 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week in Rust 462"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"小编非常喜欢的车企（夹带私货～～～）和大佬。这篇文章是对我们的嵌入式 Rust 先驱之一 Julius Gustavsson 的采访，他是沃尔沃汽车公司的技术专家和系统架构师。在采访中 Julius 讲述了09年它接触了 Rust 的经历和吸引他的点。\nhttps://medium.com/volvo-cars-engineering/why-volvo-thinks-you-should-have-rust-in-your-car-4320bd639e09\nFlutter 和 Rust 都是业内相当新颖的技术。两者还引入了如何处理可移植性的范式转变，这是一个非常古老且难以解决的问题。由于平台、设备和操作系统之间缺乏共同点，可移植性很困难。为了实现它，Flutter 自带了MethodChannel 的概念，一个允许编写和调用平台本机代码的跨界接口。然后，它可以实现无缝集成，这在使用操作系统特定的用户界面或本机访问设备外围设备时必不可少。得益于适当的集成机制，无需再进行任何调整。另一方面，Rust 在各种生态系统中受到关注，该语言的一个特别有趣的特征是它在几乎任何环境中的适应性。用 Rust 编写的程序可以作为二进制文件公开给许多现代操作系统。不仅如此，感谢基于 Rust 的代码的外部函数接口 (FFI) 集成可能性，它成为编写平台无关代码并通过 FFI 公开它的可行替代方案。\nhttps://blog.argonauths.eu/2022/09/26/flutter-and-rust-combined-creating-a-plugin-to-support-various-operating-systems/\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-29 19:10"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"您是否知道标准库充满了用户永远看不到的有用检查？标准库中有很多断言，它们会做一些事情，比如检查 char::from_u32_unchecked 必须针对一个有效的 char、CStr::from_bytes_with_nul_unchecked 只能在没有内部 null 字节的情况下调用，copy 或者 copy_nonoverlapping 必须针对内存布局对齐的非 null 指针（非重叠）。但是，由 rustup 分发的常规标准库是在没有调试断言的情况下编译的，因此用户很难从这些额外检查中受益。cargo careful 就是为了弥补这个差距，它在第一次调用时，会从源代码构建一个带有调试断言的标准库，然后使用该标准库运行您的程序或测试套件。https://github.com/RalfJung/cargo-careful您可以通过 cargo install cargo-careful 快速安装，然后执行 cargo +nightly careful run/test 用于执行二进制 crate 或测试，并进行额外的调试检查。需要注意的是，这自然会比常规调试或发布版本慢，但它比在 Miri 中执行程序要快得多，并且仍然有助于找到一些未定义的行为。当然，如果您想要更加彻底的检查，Miri 会是一个更好的选择，两者结合使用，体验更佳。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-27 21:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo careful：为你的代码提供更多安全保证"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者使用 Axum 时候，思考了这样一件事：Rust 是一个静态编译的语言，并且没有函数重载和可选参数这类特性，但是 Axum 中，get 函数却可以接收不同类型的函数指针，这是为什么呢？作者创建了一个仓库，动手实践，详细解释了其中的奥秘。https://github.com/alexpusch/rust-magic-function-params值得一提的是，Axum 当时也参考了 bevy 的 querysystem 设计，感兴趣的小伙伴不妨来学习一下。https://github.com/bevyengine/bevy"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-27 21:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Axum 风格的函数参数示例"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 编译器背后为我们做了很多优化，但是，如果让你来实现，你会如何下手呢？典型的思路可能是：如果将很多编译优化方法结合起来，编译器的性能就能提升一大截。但是，这也绝非易事，在一个场景下实现编译优化，所要考虑的因素和需要的信息，远比你想象的要多。本文的作者就通过几个例子，解释了他对于编译优化背后的思考，相信你耐心看完，肯定有不少收获。https://faultlore.com/blah/oops-that-was-important/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-27 21:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"编译器优化的思考"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Apache APISIX建立在两个巨人的肩膀上:\nNginx, 一个广泛使用的开源反向代理\nOpenResty, 一个允许通过 LuaJIT 使用Lua编程语言编写 Nginx 脚本的平台\n这让 APISIX 提供可以满足大多数业务需求的开箱即用Lua插件. 但总有一天, 通用插件无法满足您的需求. 在这种情况下, 您可以编写自己的Lua插件.本文演示的如何使用 Rust 来编写这类插件.原文链接https://blog.frankel.ch/rust-apisix/1/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-26 17:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Apache APISIX 热爱 Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Boa 是一个用Rust编写的实验性Javascript词法分析器、解析器和解释器.经过大约3个月的开发，我们非常高兴地向您展示Boa JavaScript引擎的最新版本. Boa 使得在你的项目中嵌入JS引擎变得很容易，你甚至可以从WebAssembly中使用它.Boa 目前支持部分 JavaScript 语言特性。在这个版本中, Boa 在官方 ECMAScript 测试套件(Test262)中的一致性从62.29% 增长到了 74.53%, 引擎现在总共通过了 68612 项测试.原文链接github地址https://boa-dev.github.io/posts/2022-09-25-boa-release-16/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-26 17:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Boa: v0.16发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"skillet 是一个轻量级的, Rust编写的 交互式科学可视化工具, 使用 vtkio 和 glium 实现.github 地址https://github.com/JeffIrwin/skillet--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-26 17:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"skillet: 使用 Rust 可视化科学数据"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust AST 资源管理器https://carlkcarlk.github.io/rust-ast-explorer/粘贴任何 Rust 代码。请参阅 AST（抽象语法树）。希望对任何创建 proc 宏的人有用。[更新： AST explorer 更高级。我看到了它，但错过了它的 Rust 选项，这是通过下拉。]https://astexplorer.net/Rust 通过提供同步（解析和格式化）和 WASM（用于交互性）使这个项目变得简单。源代码位于https://github.com/CarlKCarlK/rust-ast-explorer。欢迎投稿。https://github.com/dtolnay/syn"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-25 20:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust AST 资源管理器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Bpaf 是一个轻量级的命令行解析器，其 API 支持组合和派生方法，并返回严格类型化的结果。编译时间快，没有外部依赖项，除非您选择加入派生功能。\n帮助生成、使用线生成\n非常小的 API - 您只需要知道大约 10 个 API 名称，总 API 大小约为 25-30 个左右的名称\n任意嵌套的命令，包括链接和重复它们\n完整的非 utf8 参数支持\n动态外壳完成\n遵循“解析，不验证”的解析方法\n没有不安全的代码\n快乐的用户和开发人员:)\n在来自/u/epage的一些很好的反馈之后的最后一个公告中，我删除了一些OsString特定的函数（现在可以通过一个 trait 获得）并添加了一些约束函数——因此你现在可以解析几乎任何你想要的东西。https://www.reddit.com/u/epage/由于关于 CLI 解析器的传统问题是“为什么使用 that vs clap”：\n就解析而言，支持的功能集应该大致相同，但您也可以组合可用的原语来解析更多不寻常的东西：https ://docs.rs/bpaf/0.6.0/bpaf/_unusual/index.html\nAPI 体积缩小 5-7 倍，轻松找到所需内容，轻松掌握\n编译速度提高 5-7 倍 - 非常适合 CI 和开发\n二进制文件的开销减少 5-7 倍 - 非常适合运输\n动态 shell 完成 - 非常适合用户友好\n/u/epage https://github.com/rosetta-rs/argparse-rosetta-rs/blob/main/docs/tradeoffs.md做了一个很好的概述https://www.reddit.com/u/epage/但简而言之，与其给你一堆预制的方法来处理某事，不如给你bpaf一堆原语，你可以将它们链接成一个迭代器。从 0.5.x 迁移指南在这里：https ://github.com/pacak/bpaf/blob/master/Changelog.mdhttps://github.com/pacak/bpaf/blob/master/Changelog.md"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-25 20:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"另一个命令行参数解析器：bpaf 0.6.0"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Tidis是 TiKV 的服务层，旨在提供基于 PingCAP 的 Redis 协议兼容的分布式存储服务。它实现了多种数据类型（string/hash/list/set/sortedset），已被社区广泛使用。之前是 go 语言实现的 1.0 版，现在已经完全用 Rust 重新设计和重写，以便获得更好的性能和更低的延迟。以及更重要的功能，例如 Lua 脚本、TLS 连接、锁优化等。https://github.com/tidb-incubator/tidis/blob/master/docs/tidis-introduction.md"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-25 20:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"PingCAP Rust 重新实现的 Tidis 现在已开源"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 抽象语法树查看器，粘贴 Rust 代码，可查看它生成的AST 抽象语法树。https://carlkcarlk.github.io/rust-ast-explorer/Github链接，https://github.com/CarlKCarlK/rust-ast-explorer"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-24 23:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 抽象语法树查看器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Bpaf 是一个轻量级的命令行解析器，支持bash、zsh、fish和 elvish的自动补全。Github链接，https://github.com/pacak/bpaf"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-24 23:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"命令行参数解析器 bpaf"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本周，Linus 提到 Rust 将被添加 Linux 6.1 内核。Brandon Minor 认为这将对机器人社区起到巨大的推动。更多信息详见原文，https://www.therobotreport.com/linux-embracing-rust-will-boost-robotics-community/https://github.com/lesterli"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-24 23:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"拥抱 Rust 的 Linux 将推动机器人社区的发展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Niko Matsakis 最近的一篇博文，他最近一直在思考 \"Rust 2024\"会是什么样子。这里并不是单指 Rust 2024 edition，而是在畅想在我们完成了未来几年的工作之后，Rust 会是什么样子？他认为答案是，Rust 在 2024 将是 \"无处不在 \"的一年。到目前为止，Rust 有很多不错的功能，但它们只是在某些时候才会发挥作用。到了 2024 年，它们将在你想使用它们的任何地方工作，他认为这将使 Rust 的感觉大为改观。更多请看原文：https://smallcultfollowing.com/babysteps/blog/2022/09/22/rust-2024-the-year-of-everywhere/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://smallcultfollowing.com/babysteps/blog/2022/09/22/rust-2024-the-year-of-everywhere/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-23 20:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 在 2024 将会无处不在？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"如果 crate 在工作日不成比例地经常下载，则该系数为正，如果在周末不成比例地经常下载，则该系数为负。0 是 crates-io 上所有 crate 的平均值。出处：https://twitter.com/davidtolnay/status/1573129704550576129"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://twitter.com/davidtolnay/status/1573129704550576129"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-23 20:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一些广泛使用的 Rust crates 的“行业系数”。"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"libc 中的 DNS 实现是同步的，这意味着为了在异步代码中使用它，需要将其移动到阻塞线程池中。 tokio 和 async-std 都使用这种策略。这个项目的目标是异步执行 DNS，根本不需要阻塞线程池（除了文件操作）。仍然需要进行一些优化（例如，可以缓存更多内容），但除此之外，我认为这个 crate 应该可以满足您的异步 DNS 需求。项目地址：https://github.com/notgull/async-dnshttps://github.com/Jancd"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/notgull/async-dns"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-23 20:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"async-dns 项目发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 1.64.0 stable 正式发布，赶快升级到最新稳定版本体验 Rust 带给你的强劲动力吧 :)一起看下新版本有哪些值得关注的特性吧：\n使用 IntoFuture 增强 .await\ncore 和 alloc 提供 C 兼容的 FFI 类型\nrust-analyzer 现在可以通过 rustup 获取\nCargo 改进：workspace 继承和多目标构建\nAnnouncing Rust 1.64.0: https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-22 23:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 1.64.0 stable 正式发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"mediatoascii 是一个可以将媒体文件（图像/视频）转换为 ascii 输出的 CLI 程序，即可以输出控制台文本，也可以输出媒体文件。GitHub -  spoorn/media-to-ascii: https://github.com/spoorn/media-to-asciicrates.io - mediatoascii：https://crates.io/crates/mediatoascii"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://crates.io/crates/mediatoascii"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-22 23:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Media-To-Ascii"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 461: https://this-week-in-rust.org/blog/2022/09/21/this-week-in-rust-461/https://github.com/PsiACE"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2022/09/21/this-week-in-rust-461/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-22 23:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week in Rust 461"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"WebAssembly 程序是经过沙盒处理的，彼此之间以及与主机之间都是隔离的，因此它们不能读取或写入外部的内存区域，不能将控制权转移给进程中的任意代码，也不能自由访问网络和文件系统。这使得运行不受信任的WebAssembly程序是安全的：它们不能逃离沙盒，从你的笔记本电脑的其他地方窃取私人数据，或在你的服务器上运行僵尸网络。但是，这些安全属性只有在 WebAssembly 运行时正确实现的情况下才能成立。这篇文章将介绍在Wasmtime WebAssembly运行时及其编译器 Cranelift 中确保正确性和安全性的方法。ReadMore: https://bytecodealliance.org/articles/security-and-correctness-in-wasmtime"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://bytecodealliance.org/articles/security-and-correctness-in-wasmtime"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-20 17:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Wasmtime 中为安全性和正确性所做的努力"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"已经有很多篇文章来解释 Rust 中 &str、&'static str、&'a str、String 和 &String 之间区别。大多数文章都从以下方面入手\n堆和栈\n所有权\n生命期\n虽然这些都很重要，但对新手来说，可能没那么容易理解。在这里，我们将使用类比的角度来学习这两者的不同\nReadMore: https://cooscoos.github.io/blog/stress-about-strings/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://cooscoos.github.io/blog/stress-about-strings/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-20 17:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"从类比的角度看 String 与 str 的差异"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"ReadMore: https://intellij-rust.github.io/2022/09/12/changelog-178.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://intellij-rust.github.io/2022/09/12/changelog-178.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-20 17:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"INTELLIJ RUST CHANGELOG #178"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是一个Rust编写的比较有趣的程序,通过将两个线程固定在两个不同的 CPU 内核上，我们可以让它们进行一系列比较交换操作，并测量延迟。github 地址https://github.com/nviennot/core-to-core-latency"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-19 19:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"测量 CPU 不同核心之间的延迟"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本文是 Dyn async traits 系列文章的 part 8 部分, 通过演示来讨论Rust如何处理动态调度的问题.原文链接https://smallcultfollowing.com/babysteps/blog/2022/09/18/dyn-async-traits-part-8-the-soul-of-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-19 19:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Dyn async traits: Rust的灵魂"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Stalwart JMAP 是一种开源的 JSON 元应用程序协议服务器，旨在安全、快速、健壮和可扩展。JMAP 是一种用于同步数据（例如邮件、日历或联系人）的现代协议，可以更有效地利用网络资源。目前刚刚开源不久.github 地址https://github.com/stalwartlabs/jmap-server"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-19 19:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"jmap-server: JSON Meta Application Protocol server"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Hurl 是一个命令行工具，它运行以简单纯文本格式定义的HTTP 请求。它可以执行请求、捕获值并评估对标头和正文响应的查询。Hurl 非常通用：它可以用于获取数据和测试 HTTP会话.目前 1.7 版本刚刚发布.github地址https://github.com/Orange-OpenSource/hurl--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-19 19:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"hurl: 使用纯文本格式来测试你的 http 请求"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在欧洲开源峰会上，Linus Torvalds 宣布，他将在当天（在内核维护者峰会上）推动 Rust 进入即将推出的 6.1 Linux 内核。网址：https://www.zdnet.com/article/linus-torvalds-rust-may-make-it-into-the-next-linux-kernel-after-all/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-18 22:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Linus提议将Rust添加到Linux6.1内核"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在 Reddit 上一个「你最爱的 Rust CLI 工具」的帖子，获得了不少人的关注。原帖内容如下：回复的帖子里也有很多不错的工具，比如 battop、btm、exa、rg、just 等等。感兴趣的读者可以通过下面的网址进一步了解。网址：https://old.reddit.com/r/rust/comments/oygrp1/your_favorite_rust_cli_utility_i_have_my_top_10/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-18 22:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"最爱的RustCLI"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Seaography 是一个 GraphQL 框架，用于使用 SeaORM 实体构建 GraphQL 解析器。它附带一个 CLI 工具，可以从现有的 MySQL、Postres 和 SQLite 数据库生成可直接编译的 Rust GraphQL 服务。特点如下：\n轻松快速上手。\n生成可读的代码。\n可扩展的项目结构。\n基于流行的异步库：async-graphql 和 SeaORM。\n文档：https://www.sea-ql.org/blog/2022-09-17-introducing-seaography/GitHub：https://github.com/SeaQL/seaography"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-18 22:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"seaography：用于SeaORM的GraphQL框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Chartered 是一个私有的、带有身份验证的 Cargo 仓库。文档：https://book.chart.rs/GitHub：https://github.com/w4/chartered##Polars 0.24.0 发布本次版本包含许多错误修复、性能改进和附加功能。Polars 是使用 Apache Arrow Columnar Format 作为内存模型在 Rust 中实现的高性能 DataFrame 库。GitHub：https://github.com/pola-rs/polars/releases/tag/rust-polars-v0.24.0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-18 22:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"chartered：私有cargo仓库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"libConsoleGameEngine 是一个用于在 Linux 中创建基于角色的游戏的 API，目前包括：\n创建游戏板（以字符为单位的矩形）。\n绘制字符串，设置单元格并用块 Unicode 字符填充等功能。\n从非阻塞键盘读取输入的功能。\nGitHub：https://github.com/coderarjob/libConsoleGameEngine"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-18 22:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"基于Linux的终端游戏引擎"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Hexerator 是一个具有独特功能集的十六进制编辑器。专注于二进制文件探索和辅助模式识别的多功能 GUI 十六进制编辑器。用 Rust 编写。它的主要重点是让查看二进制文件变得有趣和更容易理解，但它也旨在成为一个很好的通用十六进制编辑器，适用于广泛的用途。文章链接，https://crumblingstatue.github.io/hexerator-book/Github 链接，https://github.com/crumblingstatue/hexerator"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/crumblingstatue/hexerator"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-17 22:41"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Hexerator: 我用 Rust 制作了一个具有一些很酷功能的十六进制编辑器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"IMD 是一个可执行文件，用于在您可能在 CTF 中找到的机器上进行远程发现/侦察。这是我为 OSCP 考试编写的 shell 脚本的演变，我决定使用 Rust 制作它作为一种学习体验，并用于像 HackTheBox 上的 CTF 中。特性：\n带有服务发现的通用 TCP 端口扫描\n完整的 TCP 端口扫描\nNFS 共享的检测\n...\n文章链接，https://kmanc.github.io/intelligent_machine_discovery/Github 链接，https://github.com/kmanc/intelligent_machine_discovery"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/kmanc/intelligent_machine_discovery"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-17 22:41"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"智能机器发现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是我最近一直在研究的一个元胞自动机模拟器。它目前被设置为运行一个产生蠕虫状形式的神经元胞自动机。它可以在 github 上找到，但我确实没有太多文档，而且代码非常混乱。这通过 wgpu 和计算着色器在 gpu 上运行。如果编辑设置模拟的文件“lib.rs”，则可以更改每次渲染运行的帧数。我的机器每秒可以进行大约 1000 次更新。这允许非常快速地运行元胞自动机这个应用程序还支持完全自动机并使用相同的“B3/S23”规则字符串。我最终会添加一个 GUI 并使整个事情对用户更加友好，但现在，它可以工作。存储库中有测试、示例和简单的基准测试。文章链接，https://www.reddit.com/r/rust/comments/xfoab3/gpu_accelerated_neural_cellular_automata_simulator/Github 链接，https://github.com/Barbacamanitu/wgpu_automatahttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/Barbacamanitu/wgpu_automata"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-17 22:41"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"GPU 加速神经元胞自动机模拟器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我在Rust中写过一些TUI，UI组件所需的代码量总是让人感觉过多。一段时间以来，我一直在考虑能够用类似SwiftUI的DSL编写组件，并像React那样用钩子管理状态。Intuitive是这种挫折感和愿望的结果。https://docs.rs/intuitive/latest/intuitive/Github: https://github.com/enricozb/intuitive"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/enricozb/intuitive"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-16 11:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Intuitive 一个用于声明性地编写TUI的包"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在一个定制的《我的世界》服务器上运行（用Rust编写），能够以比vanilla服务器快10000倍的速度进行红石计算。这个服务器甚至用jit编译红石电路，以加快其执行速度。这真是令人难以置信你好，我是MCHPRS的作者。虽然MCHPRS确实有一个完整的jit，以使用cranelift的redpiler后端形式存在，但不幸的是，它并没有被维护，除非你设置了feature的flag，否则不会被编译。cranelift后端的问题是，在红石时间方面使事情准确的唯一方法是使用这种非常天真的方法，考虑到当时cranelift的代码输出状态，最终甚至没有那么快，或者是一种非常复杂的可逆转的jit方法，但从未出现。目前，默认情况下，它所做的是将整个红石构建编译成一个有向加权图，可以通过几个优化通道运行。最终的图具有较小的节点尺寸，希望能适合你的CPU缓存并尽可能快地执行。这就是所谓的 \"直接 \"后端。这里有一个有趣的图形，是我在游戏中建立的一个8位CPU，通过redpiler运行：。这张图太大了，我不得不用Gephi来渲染它。我试着让dot运行一整夜，但它从未完成。Github: https://github.com/MCHPR/MCHPRS油管: https://www.youtube.com/watch?v=-BP7DhHTU-I"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.youtube.com/watch?v=-BP7DhHTU-I"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-16 11:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"在《我的世界》中实现的红石CPU/GPU上运行《我的世界》"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 460: https://this-week-in-rust.org/blog/2022/09/14/this-week-in-rust-460/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2022/09/14/this-week-in-rust-460/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-16 11:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week in Rust 460"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者以写 Go 为主，他认为学习任何语言都可以从一个 web 程序入手，那么事情就会变得明朗，本文展示的是作者在学习了一段时间 Rust 后开始搭建简单博客系统的过程，很有意思。\nhttps://mortenvistisen.com/posts/how-to-build-a-simple-blog-using-rust\n\nhttps://www.youtube.com/playlist?list=PL85XCvVPmGQhVCcPkmgbMUfJv4iGVixj-\n在学生时代我们可能都在课上倒腾过 51，stm32 这种芯片做了各种小玩意，比如彩灯，超声测距 etc...在这篇文章中，作者将探讨 stm32f4xx-hal 中 PWM 外设的用法。作者将配置和设置 PWM 外设以在蜂鸣器上播放不同的音调。不同的音调将用于生成曲调。作者所有代码都可以在这里可以找到，stm32f4xx_hal的手册在这里～https://github.com/apollolabsdev/stm32-nucleo-f401re\nhttps://apollolabsblog.hashnode.dev/stm32f4-embedded-rust-at-the-hal-pwm-buzzer\n岗位说明（重要）这个岗位是针对 华为的 Rust 跨平台开源项目而设定，并非是为了招正式员工或外包岗位而设定，所以严格来说并不存在转正与否的问题。如果你是在校学生，有一定 Rust 基础，愿意挑战自己，可以参与本次开源实习活动。联系方式（三选一）：1.简历发送至  zhanghandong3@huawei.com2.微信我 (blackanger)3.飞书直接联系--张汉东（如果在飞书群）工作内容1、参与社区项目开发；2、基于开源UI框架项目，进行快速原型验证说明：Rust 用于跨平台开发，具体什么开源项目，暂时不便公开。工作形式：到深圳华为基地或华为北京研究所线下办公。如果你在实习期间有上课或考试，也可以回去参加，并不影响。实习期限：预计从 2022 年 10月 开始 ，一共半年时间。实习薪资待遇：5000～12000 元/月实习岗位要求：1、计算机相关专业本科/硕士/研究生；2、至少熟练掌握C/C++，Rust、JS/TS编程语言中的两种 ，或 精通其中一种；3、熟悉Android、IOS、鸿蒙上的应用开发技术之一；4、熟悉开源项目运作流程或参与过开源项目开发；5、熟悉终端相关UI编程框架之一（比如 React Native/Flutter等）6、对于整个UI上屏流程或原理有较好理解，如控件的创建、布局、渲染等"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-14 20:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"generic associate types 是 Rust 近期最令人兴奋的特性之一，经历了无数次迭代和改进之后，其终于稳定了！！！下面推荐一些和 GAT 相关的文章：\n\nGAT Stabilize MR\n\n\nGAT issue track\n\n\nGAT pattern\n\n\nGAT 实现 zero cost async trait\n\n\n了解一些关于 GAT 的事\n\nGAT Stabilize MRhttps://github.com/rust-lang/rust/pull/96709#issuecomment-1245350608GAT issue trackhttps://github.com/rust-lang/rust/issues/44265GAT patternhttps://smallcultfollowing.com/babysteps/blog/2022/06/27/many-modes-a-gats-pattern/GAT 实现 zero cost async traithttps://zhuanlan.zhihu.com/p/463367405了解一些关于 GAT 的事https://rustmagazine.github.io/rust_magazine_2021/chapter_5/rust-gat.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-13 22:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Stabilize GAT"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Sniffnet 是该作者发布的第一个 rust crate，该框架由网络数据包嗅探器/过滤器组成，可以生成图形和文本报告，并提供丰富的统计信息。输出结果如下图所示。https://github.com/GyulyVGC/sniffnet该工具可以通过 cargo install sniffnet 快速安装"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-13 22:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Sniffnet v0.4.0 发布 - 多线程跨平台的网络分析器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"使用 Rust 来编写 Kernel module 看上去很有吸引力，但是在缺少优秀示例的情况下，人们很难去衡量 Rust 在这种场景下的适用性。这不，有两位开发人员就分享了他们使用 Rust 开发的内核模块（可不仅仅是 Hello World 哦），以及他们从中学到了什么。LWN原文链接https://lwn.net/SubscriberLink/907685/75fc924f5ec91869/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-13 22:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust kernel modules 示例"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"大多数电子游戏都没有太多的测试方式，作者介绍了自己如何使用 Bevy来测试自己的代码。原文链接https://chadnauseam.com/coding/gamedev/automated-testing-in-bevy/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-12 20:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Bevy中测试游戏代码"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"包含在Rust标准库中的并发特性与c++ 11中的特性非常相似: 线程、原子、互斥体、条件变量等等。然而，在过去的几年中，作为c++ 17和c++ 20的一部分，c++获得了相当多新的与并发相关的特性，未来的版本还会有更多的提议。本来梳理了c++并发性特性，并且给出它们的Rust等价物是什么样子的，以及要达到这个效果需要做些什么。原文链接https://blog.m-ou.se/rust-cpp-concurrency/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-12 20:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust和c++的并发库对比"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"终端中显示 spinner 的一个简单库, 效果如下图github地址https://github.com/ad4mx/spinoff--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-12 20:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"spinoff: 终端spinner库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"对于任何想要让 Discord 机器人启动并运行（使用 Rust）的人 - 穿梭 v.0.5.1 已经发布，增加了Serenity支持。https://github.com/serenity-rs/serenity提醒大家，shuttle是一个开源的“Rust-native”云开发平台，它使你的应用程序部署变得非常容易（主函数上的一个注释）https://shuttle.rs/在我们的最新版本中，除了引入生活质量改进之外，我们还增加了对 Serenity 的支持；Discord API 的 Rust 库。我们在我们的存储库（hello-world和postgres）中添加了两个示例，您可以试一试！与此同时；下周我们将发布一篇教程文章，它将指导您完成创建 Discord 天气预报机器人的过程！https://github.com/shuttle-hq/shuttle/tree/main/examples/serenity/hello-world如果您需要帮助或想开始使用班车，请查看文档或加入Discord服务器并打个招呼！https://docs.rs/shuttle-service/latest/shuttle_service/特别感谢我们所有的贡献者和社区，他们共同打造了航天飞机的未来！更多激动人心的变化即将到来，敬请期待！"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-11 12:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Shuttle v0.5.1 已发布 ━ 创建和部署一个带有Shuttle & Serenity 的 Discord 机器人！"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"youtube.com/watch?...https://www.youtube.com/watch?v=SU8clrSVWtI8 月的 Google 开源直播活动重点介绍了在您的团队中采用 Rust 以及由 Rust 团队成员和社区提供的多个会议。在本次活动中，您可以找到以下课程 - 在大型代码库中采用 Rust 并与之互操作，Linux 内核中的 Rust，保持您的 Rust 工具链和依赖项最新并快速运行，以及将 C++ 库移植到 Rust。Github: github.com/kurbos...https://github.com/kurbos/bevy-shell-template"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-11 12:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"完整活动 | Google 开源 Rust 日"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"youtu.be/sbVxq7...https://youtu.be/sbVxq7nNtgo"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-11 12:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust on Rails（编写永不崩溃的代码）"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-10 21:30"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust日报小组恭祝大家中秋快乐！"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"pg_idkit是一个用于生成 ID 的 Postgres 扩展，使用 pgx 开发的，它使 Postgres 实例可以使用一些更奇特的 UUID 生成策略（Timeflake、CUID、UUIDv6-8 等），目前仍是一个 WIP。https://github.com/t3hmrman/pg_idkitpgx是一个用于在 Rust 中开发 PostgreSQL 扩展的框架，并努力使其尽可能符合习惯和安全。https://github.com/tcdi/pgx"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-10 21:30"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"pg_idkit介绍"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"axum-login 是一个 Tower 中间件，为 axum 应用程序提供基于会话的用户身份验证。主要功能：https://github.com/maxcountryman/axum-login\n将用户存储与身份验证分离\n支持任意用户类型和任意存储后端\n提供方法：登录、注销和访问当前用户\n包装 axum-sessions 以提供灵活的会话\n利用 tower_http::auth::RequireAuthorizationLayer 保护路由\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-10 21:30"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"axum-login"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"TL;DR创建 Rust 库的动态库版本可以显着提高开发过程中的增量编译速度。 cargo add-dynamic 使设置过程自动化。https://github.com/rksm/cargo-add-dynamic原文链接，https://robert.kra.hn/posts/2022-09-09-speeding-up-incremental-rust-compilation-with-dylibs/https://github.com/lesterli"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-10 21:30"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用动态库加快 Rust 增量编译速度"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"来自 Grapl 的博客文章。在 Grapl，我们相信为了构建最好的防御系统，我们需要深入了解攻击者的行为。作为该目标的一部分，我们正在投资于进攻性安全研究。随时关注我们的博客，了解有关高风险漏洞、利用和高级威胁策略的新研究。这篇博客文章介绍了如何攻击 Firecracker 中的漏洞，Firecracker 是一种用 Rust 编程语言编写的开源微型虚拟机 (microVM) 监视器。它是为在 AWS Lambda 中使用而开发的，这是一种无服务器软件即服务 (SaaS) 应用程序托管服务。Firecracker 也用于 AWS 的类似 Fargate 服务，该服务提供了一种运行容器的方法，而无需管理服务器以进行容器编排。由于多租户引入的风险，Firecracker 在设计时具有安全意识。更多请看原文：https://www.graplsecurity.com/post/attacking-firecracker"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.graplsecurity.com/post/attacking-firecracker"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-09 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"攻击 Firecracker"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是 Reddit 上的一个讨论，发起者在代码中代码偶尔会在内存中删除并创建巨大的对象，并且发现它会有泄漏内存的现象。作者设法创建了一个具有类似内存问题的简单程序，如下：参与讨论请看：https://www.reddit.com/r/rust/comments/x9bq8k/bizarre_memory_leak_caused_by_tokio_runtime/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/x9bq8k/bizarre_memory_leak_caused_by_tokio_runtime/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-09 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"由 tokio 运行时引起的奇怪的内存泄漏"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"serde-numpy 是一个用于将 JSON 直接反序列化为 numpy 数组的库，主要使用 rust 实现。项目地址：https://github.com/wnorcbrown/serde-numpyhttps://github.com/Jancd"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/wnorcbrown/serde-numpy"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-09 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"serde-numpy 项目"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这个 5 月 4 日就打开的 PR 现在进入到最后评论期，也许我们将会在最近的版本中看到这个重要的变化。其目标是稳定 #![feature(general_association_types)] 。虽然将来可能还需要引入很多补充和修复，但正确地完成这些工作需要大量的语言设计，且最终应该是向后兼容的。鉴于社区对在 stable 上拥有某种形式的泛型相关类型（GAT）的渴望和“简单”用法的稳定性，使 GAT 功能的当前子集变得稳定几乎可以肯定是接下来要进行的正确工作。Stabilize generic associated types: https://github.com/rust-lang/rust/pull/96709"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rust-lang/rust/pull/96709"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-09 00:24"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用于稳定泛型关联类型的 Pull Request 进入最后评论期"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者最开始的目标是使用 nom 来解析 PDF ，但最终他选择完成一个更小的想法：bencode 解析器。Bencode 是 BitTorrent 协议用来存储数据的编码，.torrent 文件使用这种编码。Creating a bencode parser with nom：https://edgarluque.com/blog/bencode-parser-with-nom/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://edgarluque.com/blog/bencode-parser-with-nom/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-09 00:24"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"文章 - 使用 nom 创建 Bencode 解析器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 459: https://this-week-in-rust.org/blog/2022/09/07/this-week-in-rust-459/https://github.com/PsiACE"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2022/09/07/this-week-in-rust-459/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-09 00:24"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week in Rust 459"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这篇文章主要讲述了怎样使编译器生成更快的代码，使编译器本身运行得更快，使 Wasmtime 更快地实例化已编译的模块，并在模块运行后使 Wasmtime 的运行时尽可能高效。ReadMore:https://bytecodealliance.org/articles/wasmtime-10-performance"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://bytecodealliance.org/articles/wasmtime-10-performance"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-08 10:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Wasmtime 将在 9月20 号 发布 1.0 版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"来自 fermyon 官方博客的文章，介绍了 WebAssembly 现存的一些风险和应对方法：\n标准化进展非常缓慢。 为此 Fermyon 加入了 字节码联盟 亲自推动标准化进程，并通过构建 Spin 代码实现来充分利用标准\n语言支持。 Fermyon 认为前 20 种语言中至少有 15 种必须完全支持 WebAssembly 以及 WASI 和组件，才能正确地认为 WebAssembly 被很好地采用。Fermyon 采取的立场是将注意力集中在最受欢迎的语言上，这就是为什么使用 Rust 而不是 C 或Zig\n这方面也有一些好消息：\n1. 语言支持正在迅速增长，今年C#、Python和Ruby都增加了支持\n2. wasi 支持现在是进入 wasm 游戏领域的筹码\n3. 在主流实现语言未能发挥作用的地方，该语言的替代实现正在加紧发展，比如 tinygo 对于 wasm 的支持就超越了 go\n生态系统不是可选的。WebAssembly 有望成为下一波计算浪潮，但除非 Fermyon 能围绕它建立生态系统，所以 Fermyon 正在努力联合相关其他企业合作共建社区。\n社区实现碎片化。（比如 deno 和其他非标准化实现，文章没有明说）。 可悲的是，有时这仅仅是由于无知和不参与：“我们不知道有一个标准为此而出现。” ，所以目前发布的组件规范（正在进行中，但正在迅速成熟）旨在解决这类问题，这个标准使得在不同的主机实现之间共享 WebAssembly 二进制文件成为可能。还有一个不幸的趋势，即一些开发人员选择与组件模型相反的工作，创建与他们自己的主机运行时的强链接。走这条路一方面会导致平台锁定，另一方面会毫无意义地重新编写相同的代码（针对略有不同的主机进行工具化）。幸运的是，那些准备最好的人（Fastly、Mozilla、Microsoft）反而选择推动互操作性标准以造福所有人。这是正确的第一步。为了阻止破坏性的碎片化“手榴弹”，我们必须增加社会压力，不要我行我素，而要坚持互操作性标准。做到这一点的一个关键方法是彼此公开合作（通过字节码联盟、W3 和 CNCF 等组织），不仅要创建和实施标准，还要创建对话论坛。\nFermyon 的愿景是，在五年内，WebAssembly 将成为常态，而不是小众市场。新一波应用程序将能够利用 WebAssembly 的速度、安全性和组件模型。为了实现这一目标，我们每个人都可以发挥作用。ReadMore:https://www.fermyon.com/blog/risks-of-webassembly"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.fermyon.com/blog/risks-of-webassembly"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-08 10:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"WebAssembly 的 风险"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个简单的例子。一个使用网络模块的示例。ReadMore:https://github.com/aalykiot/dune"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/aalykiot/dune"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-08 10:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Dune 一个 JS 和 TS 的runtime"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"示例：检测无效的 UTF-8在这个非常简短的示例中将演示来检测无效的 UTF-8,将以十六进制形式打印无效的 UTF-8 字节首先，让我们编写一个帮助程序函数，该函数将负责打印无效的 UTF-8 字节。也就是说，它以十六进制形式打印无效字节并着色。下面的函数负责迭代所有行，查找无效的UTF-8并打印行：main这利用了 bstr::decode_utf8 接口。它允许从字节字符串一次递增解码一个代码点。当您只想从字节字符串中的某个位置提取出代码点，并完全控制如何处理无效的 UTF-8 时，它偶尔会很有用。以下是如何使用该程序的示例：您在此处看不到颜色，但所有十六进制数字在打印到终端时都以粗体显示并涂成红色。ReadMore:https://blog.burntsushi.net/bstr/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.burntsushi.net/bstr/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-08 10:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"bstr - 一个字节字符库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"目前主流的操作系统内核都是用 C/C++ 编写的，这些语言在避免常见的安全问题方面捉襟见肘。Rust 等现代语言默认提供更好的安全保证，并防止许多常见的内存安全漏洞。在这篇文章中，我们将简要介绍 Rust 为实现这一安全目标所做的努力，并为 FreeBSD 构建一个基本的 Hello World 概念验证内核模块。ReadMore: https://research.nccgroup.com/2022/08/31/writing-freebsd-kernel-modules-in-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://research.nccgroup.com/2022/08/31/writing-freebsd-kernel-modules-in-rust/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-06 20:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Rust 编写 FreeBSD 内核模块"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"当使用枚举定义不同类型的数据时会非常方便，但是作为库的作者需要考虑的更多一点，比如 enum 字段拓展后的兼容性问题。假设开始的定义为：而后增加了 Http2如何编写库代码才能用使用者感知到这个变化而不产生 breaking change 呢，这里作者结合自己编写库的经验给出了三个场景下的解决方案。分别是:\nNon-exhaustive enums\nTranslating typical Error inheritance\nEnums with an “open-ended” variant\nReadMore: https://seanmonstar.com/post/693574545047683072/pattern-matching-and-backwards-compatibility"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://seanmonstar.com/post/693574545047683072/pattern-matching-and-backwards-compatibility"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-06 20:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"模式匹配兼容性策略"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 的迭代器搭配组合器非常有趣，可以让你的代码更简洁、更实用。这篇文档侧重于如何借助迭代器使您的代码更易于阅读或重构。ReadMore: https://kerkour.com/rust-combinators"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://kerkour.com/rust-combinators"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-06 20:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"学习使用 Rust 迭代器和组合子"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"unreal-rust 允许你用 虚幻引擎 在 Rust中 编写游戏原文链接https://maikklein.github.io/unreal-rust-1/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-05 19:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Unreal Rust 宣布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"valence 是一个用于构建Minecraft服务器的Rust框架github 地址https://github.com/valence-rs/valence"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-05 19:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"valence: 构建Minecraft服务器的Rust框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"The Witness (2016) 是一款奇妙的益智游戏.游戏中的谜题基于一个简单的机制: 通过网格画一条线,这条线从一个源头开始,沿着边缘行进,穿过交叉点,最终在一个出口结束，而不会越过自己.这两篇文章使用Z3和 Rust 来实现一个该游戏的高效的解谜器.Part1Part2https://www.techofnote.com/witness-part-1"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-05 19:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Rust 和 Z3 制作一个解谜器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是一个由3个部分组成的系列:\nPart1 我们将研究如何编写简单的程序来响应CGI调用。\nPart2 我们将了解一些更高级的概念，比如外部web组装模块如何直接使用wasm-to-oci。\nPart3 我们将看看如何使用 krustlet 在 Kubernetes 集群中部署和执行web组装模块。\nPart1Part2Part3https://medium.com/@shyamsundarb/wasm-wasi-wagi-web-assembly-modules-in-rust-af7335e80160--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-05 19:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"WASM + WASI + WAGI + WASM"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 基金会正在寻找一位社区倡导者，负责开发和管理 Rust 项目、用户社区和 Rust 基金会之间的良好沟通与协作。岗位要求：\n有在开源项目社区内工作/贡献的经验，最好是 Rust 项目或相关的 Rust 框架。\n在与不同兴趣和优先级的利益相关者沟通方面经验丰富。\n优秀的倾听技巧，具有同理心，能够促进妥协，适应快速变化或具有挑战性的情况。\n能够与项目、基金会和成员利益相关者建立融洽的关系。\n有管理项目/流程的经验。\n能够清晰简洁地理解和解释复杂的概念和信息。\n能够直接与软件开发人员合作，希望突出 Rust 社区的成就。\n有支持协作流程的经验，如向多利益相关工作组织提供会议和行政支持。\n有处理敏感或机密性质问题的经验，以及谨慎行事的能力。\n有跨各种平台通信的经验，如 GitHub、Zulip、Slack、Discord 等。\n岗位申请：https://app.beapplied.com/apply/xn5pe8foz0地址：https://foundation.rust-lang.org/careers/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-04 23:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Foundation 招聘社区倡导者"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"包括数个新功能和 Bug 修复，比如：\n将 LSP 标准错误输出添加到日志。\n添加跳转到类型定义。\n添加调整编辑器/终端/各种拆分大小的功能。\n自动更新。\n添加 Elixir 文件扩展名。\n为 WGSL 添加语法亮亮。\n……\n更多请查看下面链接。GitHub：https://github.com/lapce/lapce/releases/tag/v0.2.0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-04 23:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"lapce0.2.0发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"特征包括：\n可用于分析内存泄漏，查看内存的确切位置，识别临时分配并调查过多的内存碎片。\n收集每个分配和取消分配，以及完整的堆栈跟踪。\n可动态剔除临时分配。\n使用定制的堆栈展开实现，使其比其他工具更快。\n可以将收集到的数据导出为各种不同的格式。\n拥有基于 Web 的 GUI，可用于分析。\n可以将分析数据动态流式传输到另一台计算机。\n支持 AMD64、ARM AArch64 和 MIPS64 架构。\n支持分析使用 jemalloc 作为其分配器的应用程序。\n支持给予 Rhai 的嵌入式 DSL，允许编程和/或自动数据分析。\n文档：https://koute.github.io/bytehound/GitHub：https://github.com/koute/bytehound"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-04 23:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"bytehound：Linux内存分析器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"使用 Rust 从头构建一个与 Minecraft 兼容的服务器。在 Valence 中，所有游戏逻辑都背后都是同一个 Trait。诸如插件系统、专用可执行文件、香草（预设）游戏机制等功能都可以在 Valence 上实现。目前仍在开发中。当前状态：\n 用于 Minecraft NBT 格式的新 serde 库。\n 身份验证、加密和压缩。\n 区块状态。\n 块。\n 实体和跟踪数据。\n 用于快速空间实体查询的边界体层次结构。\n 玩家列表和玩家皮肤。\n 维度、生物群系和世界。\n JSON Text API。\n 用于将数据从游戏提取到 JSON 文件的 Fabric 模组。\n 块实体。\n 库存和物品。\n 代理支持。\n 声音、粒子等。\n 用于连续碰撞检测的实用程序。\n视频：https://www.youtube.com/watch?v=6P072lKE01sGitHub：https://github.com/valence-rs/valence"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-04 23:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"valence：构建Minecraft服务器的框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"早在 2020 年，我们就开始着手在 Rust 编程语言中实现 Tor 协议的新实现。现在我们相信它已经为更广泛的使用做好了准备。在这篇博文中，我们将向您详细介绍 Arti 项目的历史、现在的情况以及下一步的发展方向。背景介绍：为什么是Arti？怎么做的？为什么要用 Rust 重写 Tor？文章链接，https://blog.torproject.org/arti_100_released/https://tauri.app/blog/tauri_1_0/https://blog.torproject.org/arti_100_released/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-03 20:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Arti 1.0.0 发布：我们的 Rust Tor 实现已准备好用于生产。"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Clockwork 是我编写的一个 midi 插件，您可以在任何 DAW 中使用它，以可变速度重复音符。它使用用 Rust 编写的 NIH-Plug 插件框架。文章链接，https://www.reddit.com/r/rust/comments/x49m4m/media_clockwork_simple_midi_note_repeater_plugin/Github 链接，https://github.com/AlexW00/clockwork/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/AlexW00/clockwork/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-03 20:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Clockwork：用 Rust 编写的简单 MIDI 音符中继器插件"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Hi, 我将我的 C++ ringbuffer 移植到了 rust。这是一个高性能、单生产者、单消费者、连续字节的有界循环缓冲区，支持无锁原子批处理操作，适用于线程间通信。存储库中有测试、示例和简单的基准测试。Github 链接，https://github.com/erenon/cueue文章链接，https://www.reddit.com/r/rust/comments/x44uhw/cueue_a_truly_circular_spsc_queue/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/x44uhw/cueue_a_truly_circular_spsc_queue/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-03 20:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Cueue - 一个真正的循环 SPSC 队列"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我很惊讶这个东西还不存在（或者是我不善于上网搜索）。总之，这个工具箱允许你打开、关闭和锁定你的CD驱动器。它可以在Linux和Windows上运行，如果有人愿意做，或者我找到了在VirtualBox上用CD驱动器运行Mac的方法，它也可以在Mac上运行。在进入维护模式之前，我可能会在未来几周增加一些功能，比如floppys/usbs或列出所有驱动器。是的，这是受的启发，现在你可以在Rust中制作你自己的free cup holder:)Crates.io: https://crates.io/crates/eject"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://crates.io/crates/eject"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-01 22:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"eject  一个弹出CD的crate"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"由于不在本博文范围内的原因，我最近不得不测量一个CPU-core能以多快的速度通过一个无符号32位整数（u32）的无排序列表，并输出排序后的索引列表，其中的值在一个给定的区间内。博文: https://quickwit.io/blog/filtering%20a%20vector%20with%20simd%20instructions%20avx-2%20and%20avx-512/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://quickwit.io/blog/filtering%20a%20vector%20with%20simd%20instructions%20avx-2%20and%20avx-512/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-01 22:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"在Rust中用AVX-2和AVX-512过滤矢量"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Helix是一个模式化的文本编辑器，内置支持多选、语言服务器协议（LSP）、树状图，并实验性地支持调试适配器协议（DAP）。今天是22.08版本，这个版本有大量的修复和新功能。衷心感谢我们的贡献者! 这个版本有87个贡献者。🎉让我们来看看22.08版的重点功能。22.08版本发布: https://helix-editor.com/news/release-22-08-highlights/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://helix-editor.com/news/release-22-08-highlights/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-01 22:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Helix 编辑器发布22.08版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 458: https://this-week-in-rust.org/blog/2022/08/31/this-week-in-rust-458/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2022/08/31/this-week-in-rust-458/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-01 22:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week in Rust 458"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"RustDesk 是一款基于 Rust 的远程桌面软件，开箱即用，无需任何配置。用户完全掌控数据，不用担心安全问题。这几天在Rust 开源项目 Top 10 中跻身第九。目前 RustDesk 还有一系列的开发计划也在进行中欢迎贡献。https://github.com/EvanLi/Github-Ranking#rust\nhttps://github.com/rustdesk/rustdesk/discussions/918\ntrunk 是一个基于 Rust 的 PHP 解释器。虽然它距离成为和 nikic/php-parser 包旗鼓相当的 PHP 解析器还有很长的路要走，但是在作者工作了几个星期中已经取得了长足的进步，它能够解析函数、类、接口等等。让我们看一个简单的例子：PHP:像这样的 PHP 脚本最终会编译成类似这样的 Rust 代码：然后可以将 Rust 代码存储在某个地方并使用 Rust 编译器进行编译。\nhttps://github.com/ryangjchandler/trunk\nhttps://ryangjchandler.co.uk/posts/experimentally-compiling-php-code-to-rust\nRust.cc 论坛: 支持 rss微信公众号：Rust 语言中文社区https://rustcc.cn/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-09-01 00:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Diesel 是一个安全的、可扩展的 ORM 和 Rust 查询构建器。其借助 Rust 的语言特性，在不牺牲性能的前提下，消除了运行时错误。其支持的数据库有：\nPostgreSQL\nMySQL\nSQLite\n本版本是超过 135 人历时 3 年多开发的结果。自上一个 RC 版本以来，合并了以下细微更改：\n从 v0.3 开始支持日期/时间类型\n对 rustc 生成的错误消息的一些可选的修正\n对 Selectable 这个 derive 的一些改进\n将 extensive join 的编译时间减少了约 4 倍的修复\n详细内容请参考 CHANGELOGhttps://diesel.rs/changelog.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-08-30 20:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Diesel 2.0.0 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Fearless Development 是 Rust 的一个关键词，\"If it compiles, it works\"。但是在 Rust 的整套开发流程中，有一个环节并不是让人 fearless，也就是 cargo update，即升级项目的依赖。绝大多数情况下，cargo update 都没有什么后果，伴随着依赖的优化，通常还能带来一定的性能提升。但是在某些场景下，由于 API 的变化（函数签名，auto-trait 等），cargo update 会造成整个项目编译不通过的情况，此时要么选择回退版本，要么选择拥抱新的 breaking change ...... 无论如何都很棘手。但是，借助 cargo-semver-check 这个工具，可以提早发现 cargo update 潜在的依赖问题，从而避免上述一系列问题，提升开发体验。感兴趣的可以参考其 Github 主页 和 原文。https://github.com/obi1kenobi/cargo-semver-check"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-08-30 20:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Fearless cargo update"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Jonas Hietala 九年来，一直用 Hakyll 作为静态站点的生成工具，如今，他终于下定决心，打算转向自己用 Rust 亲手编写的自定义站点生成器，并解决以下几点问题：作者原先很担心，例如模板引擎、高亮显示的功能无法在 Rust 中实现，但事实证明，每一个功能都有理想的工具辅助实现：\n用 pulldown-cmark 来解析 Markdown；\n用 syntect 实现语法高亮，能够支持 Sublime Text 语法；\n用 yaml-front-matter 解析帖子中的元数据；\n用 grass 作为纯 Rust 中的 Sass 编译器；\n用 axum 创建负责在本地托管站点的静态文件服务器；\n用 hotwatch 监控文件变更，这样就能在文件内容变化时更新页面；\n用 scraper 解析生成的 html。用于某些测试和特定转换；\n用 rust-s3 将生成的站点上传至 S3 存储端。\n最终作者实现了一个不错的 blog 工具，可以参考 Github 仓库地址，项目的实现细节可以参考原文介绍https://github.com/treeman/jonashietala"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-08-30 20:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Rust 重写 blog 构建工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"目前,一个 RLS 的 pull request 已经被合并, 在一些 IDE 上会提示 RLS 已经不再可用,并且提示用户使用 rust-analyzer.这意味着 RLS 开始正式谢幕.原文链接https://github.com/rust-lang/rust/pull/100863"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-08-29 20:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RLS 谢幕"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Cxx-Qt 是一个自动生成代码的库，通过通用接口(比如可以直接公开到QML的qobject)在Rust和c++之间传输数据.目前已经可以完成使用 cargo 进行开发应用了.原文链接github地址https://github.com/KDAB/cxx-qt/pull/221"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-08-29 20:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Cxx-Qt: 现在可以完全使用 cargo 来编写 QML 的应用了"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Sycamore是一个 响应式 库，可以使用 Rust 和 WebAssembly 创建web应用。特点是:\n速度快. 使用 rust 和 WebAssembly\n符合人体工程学和直觉. 编写代码非常自然, 所有都构建在响应式基础上, 没有使用虚拟 DOM.\n无 Javascript.\n目前 0.8 版本发布.原文链接github地址https://sycamore-rs.netlify.app/news/announcing-v0.8.0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-08-29 20:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Sycamore: 0.8 版本发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在 python 中,加载大量的 OpenEXR 文件是非常缓慢的, 作者使用 rust + PyO3 来加速 OpenEXR 文件的加载, 效果显著.原文链接https://dragly.org/2022/08/27/speeding-up-loading-openexr-in-python/--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-08-29 20:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Rust 来提速在 python 中加载 OpenEXR 文件"},"type":"text"}],"type":"title"}},]
