export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你好 r/rust 的小伙伴，我今天发布了 Paperoni 的 v0.6.0-alpha1。Paperoni 是一个文章下载器，可以将网络文章下载到 EPUB 文件中。此当前版本还允许您将文章导出为 HTML 文件，这为导出为 PDF 提供了可能性。这是大约 3 个月前当我第一次发布关于这个项目时要求的功能。请随意检查并提供任何反馈。谢谢！文章链接，https://www.reddit.com/r/rust/comments/oqo8bu/paperoni_060_release/Gitlab 链接，https://github.com/hipstermojo/paperoni" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/oqo8bu/paperoni_060_release/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-25 10:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Paperoni:0.6.0发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你好！我正在编写一个 base64 编码器，以在 Rust 中获得乐趣，以学习良好的 CLI 开发实践。我正在关注 Rust CLI Book，这个非常好。我目前正在关注测试部分，并且我试图断言如果未使用 stdin，我的 CLI 命令会写入一条错误消息。我正在使用 atty 来检测 stdin 是否是 TTY，如果它不是 TTY，我将打印错误消息。我正在尝试在 https://github.com/skovmand/all_your_base/blob/cli_tests/tests/cli.rs 中对此进行测试，但没有运气。我无法模拟 stdin 是 TTY（当然，在测试的情况下，stdin 不是 TTY）。文章链接，https://www.reddit.com/r/rust/comments/oqqbt6/test_cli_command_without_stdin/Gitlab 链接，https://github.com/skovmand/all_your_base/blob/cli_tests/tests/cli.rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/oqqbt6/test_cli_command_without_stdin/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-25 10:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "不用stdio测试 cli 命令" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "xlcat：类似于 cat，是用于 Excel 文件xlcat 就像命令行工具 cat，用于 Excel 文件（准确地说是 xlsx 文件）。无论多大，您都可以快速查看任何 Excel 文件的内容。大文件将开始在屏幕上传输，就像小文件一样快。这篇文章描述了我为什么创建 xlcat 以及我如何让它如此之快（即使在处理大文件时）。文章链接，https://xlpro.tips/posts/xlcat/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://xlpro.tips/posts/xlcat/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-25 10:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我的第一个 Rust 项目：xlcat 就像 cat，用于 xlsx 文件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "单纯看到 Rust 所有权模型，工作池模式会不太适合 Rust。但是相反，拥抱函数式编程和不可变数据使 Rust 拥有了更简单易用和更优雅的工具：并行迭代器和流。作者提供了 #计算密集型# 和 #I/O 密集型# 两种作业的工作池使用方式\n阅读原文 : https://kerkour.com/blog/rust-worker-pool\n通过 jni 让 rust 和 Java 结合起来，可以在 Java 中使用 rust function\n阅读原文 : https://blog.frankel.ch/start-rust/7\n按照原文中步骤，将准备好并设置好让您的 Rust 代码在您的 electron app 中运行。就像使用 wasm-pack 设置 webassembly 一样简单，另外将其加载到 electron 中的过程在某种程度上是不直观的，需要一些后续优化。作者下一步将尝试通过比较原生 js 代码与 webassembly 来获得一些性能上的见解。\n阅读原文 : https://domtac.github.io/rust/webassembly/electron/2021/07/20/Run-rust-in-electron.html\nRalf Jung 是位来自于 Saarbrücken 的 Max Planck 软件系统研究所 Derek Dreyer 教授的“编程基础”研究小组的博士后研究员。自 2015 年以来，Jung 一直专注于最初由 Mozilla 赞助的编程语言，他的博士论文中建立了名为 RustBelt 的证明来验证 Rust 类型系统的安全性，从而展示 Rust 如何自动且可靠地防止整类编程错误。\n阅读原文 : https://www.eurekalert.org/pub_releases/2021-07/su-cs071521.php\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-23 16:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 2021 版进入 公开测试期 。该版本的所有计划功能现在都可以在 nightly 版本中率先体验。同时还提供了方便的迁移办法，以便将代码从 Rust 2018 快速迁移到 Rust 2021 。Datafuse 团队目前正在进行 Rust 2021 迁移的尝鲜体验，相关工作可以关注：https://github.com/datafuselabs/datafuseRust 2021 public testing period: https://blog.rust-lang.org/2021/07/21/Rust-2021-public-testing.htmlthe nightly version of Rust edition guide: https://doc.rust-lang.org/nightly/edition-guide/rust-2021/index.htmlDatafuse: [rust 2021] migrate to rust 2021: https://github.com/datafuselabs/datafuse/pull/1159" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/datafuselabs/datafuse/pull/1159" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-23 00:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 2021 进入公开测试期" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "arrow2 和 parquet2 是对官方 arrow 和 parquet 的重写，由 Jorge Leitao 重构和发布。arrow2 的核心目标是安全地实现 Arrow 格式。对官方实现进行完全重写，修复由于设计限制而导致的严重健全性问题。parquet2 同样关注安全，并使用 #![forbid(unsafe_code)] 。编码器和解码器更快也更安全。Reddit - Release of arrow2 0.1 and parquet2 0.1: https://www.reddit.com/r/rust/comments/ooyhn1/release_of_arrow2_01_and_parquet2_01/GitHub - arrow2: https://github.com/jorgecarleitao/arrow2)GitHub - parquet2: https://github.com/jorgecarleitao/parquet2)" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jorgecarleitao/parquet2" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-23 00:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "arrow2 和 parquet2 v0.1 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 400: https://this-week-in-rust.org/blog/2021/07/21/this-week-in-rust-400/本周引语小贴士：每当你想到 Pin 可能算一种解决方案时，它其实不是。\n@SkiFire13 on the official Rust Discord\nhttps://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/07/21/this-week-in-rust-400/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-23 00:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 400" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "cargo-ui在cargo命令行工具之上提供了一个简单的 GUI 。ReadMore:https://sixtyfps.io/blog/introducing-cargo-ui.htmlReadMore:https://github.com/sixtyfpsui/cargo-ui" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sixtyfpsui/cargo-ui" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-21 23:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-ui: cargo 的 GUI" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Wedson Almeida Filho发布了 PL061 GPIO 驱动程序的翻译以及原始驱动程序。呈现再网页上左边是 c 代码右半边是 rust 代码。ReadMore:https://lwn.net/Articles/863459/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://lwn.net/Articles/863459/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-21 23:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中的 GPIO 驱动程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tokio 为 Linux 上的 io-uring 系统 API 提供支持。此版本提供异步文件操作，将在后续版本中添加对更多操作的支持。ReadMore:https://tokio.rs/blog/2021-07-tokio-uring" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://tokio.rs/blog/2021-07-tokio-uring" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-21 23:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio 支持 io-uring" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者两年前就提出了如何让 Rust 解析 float 更快更安全, 不过最近, 这些改变才合并到libcore.这意味着, 当你解析大量的 float 类型时, 性能会得到非常夸张的提升.例如:原文链接https://www.reddit.com/r/rust/comments/omelz4/making_rust_float_parsing_fast_libcore_edition/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-19 21:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "让 Rust 更快的解析 float类型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这里并不是比较 Rust 和 JAVA 的区别,而是如何使用 JNI 在 JAVA 中调用 Rust.原文链接https://blog.frankel.ch/start-rust/7/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-19 21:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 和 Java 的 JVM" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rasn 一个 #[no_std] 的 codec 库.github地址https://github.com/XAMPPRocky/rasn/releases/tag/v0.3.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-19 21:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rasn: 速度超快的 codec 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "mygit 是一个 Rust 实现的 git server, 可以进行简单的 git 服务部署.github地址https://github.com/alexwennerberg/mygit" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-19 21:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mygit: Rust实现的 git server" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "toyDB 是一个Rust编写的分布式SQL 数据库, 他以学习为目的, 想学习数据库底层和 Rust 的同学可以参考一下.github地址https://github.com/erikgrinaker/toydb--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-19 21:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "toyDB: Rust编写的分布式SQL 数据库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果用过 ES，会感到非常熟悉，具体包括以下步骤：第一步：编写索引配置文件 wiki_index_config.json（以 wiki 为例），保存到当前目录：第二步：创建索引：其中，wikipedia 是空文件夹第三步：添加一些文档（需提前下载文档文件到当前目录）：文档看起来是这样：第四步：启动 Server：然后就可以进行 Query 了：文件目录如下：噢，差点忘了，它还同时提供 gRPC 接口，默认 8082 端口；）文档：Search more with less | Search more with lesshttps://quickwit.io/GitHub 地址：quickwit-inc/quickwit: Quickwit is a highly cost-efficient search engine in Rust.https://github.com/quickwit-inc/quickwit最后，顺带再安利一下另一个酷炫的搜索引擎：meilisearch/MeiliSearch: Powerful, fast, and an easy to use search engine。https://github.com/meilisearch/MeiliSearch" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-18 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Quickwit：亚秒级延迟的对象存储搜索引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一旦 cargo install libreddit 后，只需：Reddit 就启动了。主页：Libreddithttps://libredd.it/GitHub 地址：spikecodes/libreddit: Private front-end for Reddit written in Rusthttps://github.com/spikecodes/libreddit" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-18 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "libreddit：用 Rust 编写的 Reddit 私有前端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "QUIC: QUIC - Wikipediahttps://en.wikipedia.org/wiki/QUICGitHub 地址：cloudflare/quiche: 🥧 Savoury implementation of the QUIC transport protocol and HTTP/3https://github.com/cloudflare/quiche" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-18 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "quiche：QUIC 和 HTTP/3 的实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "正常打出来是这样的：使用本模块转为 String 打出来是这样的：看起来舒服多了。GitHub 地址：aDotInTheVoid/debug2: Space Efficient Pretty Printerhttps://github.com/aDotInTheVoid/debug2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-18 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "debug2：省空间的 Printer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Quilkin 是一种非透明 UDP 代理，专门设计用于大型多人专用游戏服务器部署，以确保安全性、访问控制、遥测数据、指标等。GitHub 地址：googleforgames/quilkin: Quilkin is a non-transparent UDP proxy specifically designed for use with large scale multiplayer dedicated game server deployments, to ensure security, access control, telemetry data, metrics and more.https://github.com/googleforgames/quilkin" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-18 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "quilkin：用于大型多人专用游戏服务器部署的非透明 UDP 代理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GitHub 地址：lmt-swallow/puppy-browser: An example implementation of a tiny Web browser for educational purposes.https://github.com/lmt-swallow/puppy-browser/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-18 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个教学目的的轻量 Web 浏览器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "米兰理工大学的一名研究助理，担任了 “设计的曲线和表面”课程的助教，这门课主要是为设计专业的学生解释三维数学概念。 因为没有趁手的教学工具，所以这位助教自己用 Rust 实现了一个。第一个版本是 cpp 实现的。然后新版本用 Rust 重写了，为什么呢？所以，现在用 WebGPU + Rust 重写了这个工具，基于 wgpu。FranzPlot目前是闭源的，未来可能会开源。因为尽管重新写了软件，也还需要处理一些技术债务。另外想完全使用 WGSL 而抛弃 GLSL ，还想将界面替换为纯 Rust 实现，比如使用 egui 框架。现在是用 imgui-rs。https://github.com/gfx-rs/wgpu介绍链接，https://gfx-rs.github.io/stories/franzplot" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gfx-rs.github.io/stories/franzplot" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-17 17:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 实现的教学软件 franzplot" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 Windows 上使用 Rust 进行开发，包括开发环境的设置、Windows 的 Rust 和代码示例。链接，https://docs.microsoft.com/en-us/windows/dev-environment/rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://docs.microsoft.com/en-us/windows/dev-environment/rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-17 17:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Windows 上使用 Rust 进行开发" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Minus，是 Rust 实现的一个快速，异步终端分页库。它提供了高级功能，可以方便地为任何终端应用程序编写分页器。minus 同时支持 tokio 和 async-std 运行时。更重要的是，如果只想使用 minus 提供静态输出，也可以选择不使用这些动态特性。项目Github链接，https://github.com/arijit79/minusMinus v4.0.0 Changelog，https://github.com/arijit79/minus/blob/main/CHANGELOG.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/arijit79/minus/blob/main/CHANGELOG.md" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-17 17:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Minus 发布 v4.0.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Lexopt 是一个 Rust 实现的参数解析器。它试图用最简单的设计保持正确性。它是如此简单，以至于使用起来有点乏味。使用示例如下：项目Github链接，https://github.com/blyxxyz/lexopt" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/blyxxyz/lexopt" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-17 17:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Lexopt" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Highnoon，一个 Rust 实现基于 Hyper 的最小化网络框架。使用示例如下：项目GitHub链接，https://github.com/sphenlee/highnoonhttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sphenlee/highnoon" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-17 17:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Highnoon" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "也支持依赖 crate链接：https://rust-script.org/GitHub：https://github.com/fornwall/rust-script" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/fornwall/rust-script" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-16 20:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-script，可以在没有任何设置或编译步骤的情况下运行 rust 文件和表达式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "quickwit 刚发布 0.1 版，他号称是一个高性价比的分布式搜索引擎，想让你花尽可能低的成本搜索大量数据。链接：https://quickwit.io/blog/quickwit-first-releaseGithub：https://github.com/quickwit-inc/quickwit" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/quickwit-inc/quickwit" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-16 20:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "quickwit - 又一个基于 tantivy 的新 Rust 搜索引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "国外一个工程师用 Rust 重写 go 项目，最开始慢 4～5 倍，然后经过 Rust 社区网友支招优化以后，反过来比 go 项目快且稳定。这个帖子下涉及一些异步优化技巧可以看看链接：https://www.reddit.com/r/rust/comments/oje3w7/rewrote_golang_project_in_rust_its_4x_times/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/oje3w7/rewrote_golang_project_in_rust_its_4x_times/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-16 20:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 重写 go 项目的一次实践" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文标题：Rust Nibbles - Gazebo : Dupe「Rust Nibbles」 翻译成 「慢啃 Rust 」 没毛病吧 ？这是 Facebook for Develpers 网站出的Rust Nibbles系列文章，介绍 facebook 开源的各种 Rust 库。Gazebo 是 facebook 工程师 编写的基础库，Gazebo以独立模块的形式包含了一系列经过测试的Rust实用程序。这篇文章是介绍了 Gazebo 中的 Dupe trait 。在Rust中，有两个用于 \"复制 \"一个值的相关特性--Copy和Clone。在Gazebo中引入了第三个类似的trait，称之为Dupe，它可以在Gazebo Prelude中使用。（dupe 有复制物品/复制底片的意思）。Copy 是 编译器的自动行为，复制成本也不高。而 Clone 则不然。为了降低 Clone  的成本，一般可以使用 Arc，但是 Arc 使得代码阅读成本提升。比如 let xs = ys.clone();，你可能需要查看大量上下文来弄清是 调用了 Clone 还是 Arc 。当然你可以使用 let xs = Arc::clone(ys)来提升可读性，但缺点是，它破坏了抽象。所以，Gazebo 中引入了 Dupe trait, let xs = ys.dupe()。rustuse gazebo::prelude::*;#[derive(Clone, Dupe)]struct MyArc(Arc);看了一下实现源码：https://github.com/facebookincubator/gazebo/blob/master/gazebo/src/dupe.rsrustpub trait Dupe: Clone {fn dupe(&self) -> Self {self.clone()}}看上去和 Clone 很像，但它仅在 常量时或零分配下可用，比如 Arc。因为 Dupe 只给这些类型实现了。https://developers.facebook.com/blog/post/2021/07/06/rust-nibbles-gazebo-dupe/Forward : Rust 视界https://t.me/rust_daily_news/4960" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-15 21:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "慢啃 Rust 系列   | Gazebo 库 之 Dupe" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 Rust Maginze 月刊第四期中介绍过 Zenoh :  开源产品 | eclipse zenoh 助力雾计算和边缘计算https://rustmagazine.github.io/rust_magazine_2021/chapter_4/zenoh.htmleclipse zenoh （读： /zeno/ ） ，提供了零开销的Pub/Sub、Store/Query 和 计算。zenoh 统一了 动态/静止/使用中的数据并提供计算结果。它颇有分寸地将传统的Pub/Sub与地理分布的存储、查询和计算融合在一起，同时保留了远远超出任何主流协议栈的时间和空间效率水平。官网是 zenoh.io 。GitHub代码仓库 eclipse-zenoh/zenoh 。2020 年 12 月 Eclipse Edge Native 工作组启动，并将 Zenoh 引入 Eclipse 。并用 Rust 对 zenoh 进行重写。在本文中，Zenoh 团队剖析了他们如何改进让异步性能提升一倍。\n8字节payload 时超过3.5M msg/s\n1Mb payload 时超过 45Gb/s\n在 backlogged 场景下，延迟低至 35 微秒\n该团队如何做到的呢？一：准备工作二：寻找性能热点（hotspots）三： 堆分配还是栈分配？zenoh 团队 一直避免在关键环节进行堆分配。用 valgrind 仔细检查后发现，并没有不必要的堆分配，缓存未命中率也不高。因此该团队开始检查 栈分配的问题，利用 Rust 编译器的一个 flag （仅在 Rust Nightly 可用）来验证一个数据结构多大以及它的内存对齐方式。rust$ RUSTFLAGS=-Zprint-type-sizes cargo build --release用这种方式来编译 zenoh 即可。输出：rustprint-type-size type: net::protocol::proto::msg::Data: 304 bytes, alignment: 8 bytesprint-type-size     field .key: 40 bytesprint-type-size     field .data_info: 168 bytesprint-type-size     field .payload: 96 bytes异步数据结构也会这样打印出来。然后该团队发现了一个痛苦的事实：四： 性能测试结果该团队性能测试环境为：AMD Ryzen 5800x，32GB内存，通过100Gb以太网连接，根据前面所说的性能测试环境配置指南配置好。具体的性能测试图表，可以进一步查看文章。也可以关注 zenoh 团队的博客，因为他们性能优化还会继续。https://zenoh.io/blog/2021-07-13-zenoh-performance-async/Forward : Rust 视界https://t.me/rust_daily_news/4954" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-15 21:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Zenoh 性能提升的故事｜ 漫游在 Rust 异步仙境" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "随着 Rust 越来越受欢迎，越来越多的人想要学习它，我决定创建另一个主要针对初学者的教程。使用 Rust 创建桌面应用程序的方法很少，而 Tauri 绝对是一种可以让您制作漂亮的 UI（HTML/JS/CSS）并在后台利用 Rust 功能的方法。由于 Tauri 允许您选择任何前端框架（或不选择），因此我创建了一个使用 Svelte 和 Bootstrap（通过 Sveltestrap）的简单模板，为开发人员提供了一个很好的起点。为了演示如何使用它，我们将创建简单的密码生成器。恰好我的实习项目Local Native就是使用tauri-bundle进行多平台打包的，说实话，用起来很丝滑，很简单易用，在此再次感谢tauri团队！Read More: https://jbarszczewski.com/rust-tauri-svelte-tutorial" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://jbarszczewski.com/rust-tauri-svelte-tutorial" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-15 21:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust + Tauri + Svelte 教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文介绍了作者使用基于eBPF的内存分析器来优化Rust代码的事。Read More: https://medium.com/tezedge/halving-the-tezedge-nodes-memory-usage-with-an-ebpf-based-memory-profiler-2bfd32f94f69" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://medium.com/tezedge/halving-the-tezedge-nodes-memory-usage-with-an-ebpf-based-memory-profiler-2bfd32f94f69" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-15 21:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用基于 eBPF 的内存分析器将 TezEdge 节点的内存使用量减半" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "– qDot 发表于 twitterhttps://twitter.com/qDot/status/1412536312150716416Read More:https://this-week-in-rust.org/blog/2021/07/14/this-week-in-rust-399/中文:https://blog.budshome.com/budshome/rust-guan-fang-zhou-bao-399-qi-(2021-07-14)感谢张老师提供的内容" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.budshome.com/budshome/rust-guan-fang-zhou-bao-399-qi-(2021-07-14)" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-15 21:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周引语" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "北京望京凯悦酒店7 月 23 日，PingCAP DevCon 2021 开发者嘉年华7 月 24 日， 大会日，议程很丰富议程介绍： https://mp.weixin.qq.com/s/g2ydwn0HJ-uHLkINXhJ5Pg对 TiDB / TiKV 感兴趣并且能去的朋友可以联系我，我这有几张优惠码，可以免费参加噢。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-14 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "PingCAP DevCon 2021 活动 Rust 社区福利" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Nushell 是一种新的 Shell，注意 Shell 与 Commandline，Terminal 的区别。在这个新版本里，支持了 dataframes。dataframes 是一种处理大数据集的有效的方式：将大的数据集，按列存储，并提供一系列操作。blog: https://www.nushell.sh/blog/2021-07-13-nushell_0_34.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-14 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Nushell 0.34 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Halving the TezEdge node’s memory usage with an eBPF-based memory profilerhttps://medium.com/tezedge/halving-the-tezedge-nodes-memory-usage-with-an-ebpf-based-memory-profiler-2bfd32f94f69" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-14 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "分享一篇关于基于 eBPF 的内存分析器的文章" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在只发布了 Alpha 版本，但是已经比目前 Windows 自带的包管理器快 5 倍了。https://github.com/novus-package-manager/novus" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-14 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 实现的 Windows 上的下一代包管理器，非常快" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 开始写 bootloader 了。看起来这是一个相当严肃的项目，目前已经发布了 1.0.0。提供了如下功能：\n多镜像操作：存储，拷贝，升级，验证和启动。可灵活配置\n支持外部 flash 芯片\nGolden image rollbacks （怎么翻译？）\n自动或应用触发的升级\n……\n搞底层的同学，请严重关注一下此项目。Github: https://github.com/absw/loadstone" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-14 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Loadstone 发布，一个安全的裸金属的 bootloader" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 实现的 postgresql 扩展。能简化开发工作。其中提到一个理念：创建新的 SQL 函数，而不是重新发明语法。值得品味。推荐一读：https://blog.timescale.com/blog/introducing-hyperfunctions-new-sql-functions-to-simplify-working-with-time-series-data-in-postgresql/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-14 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "hyperfunctions: PostgreSQL 中的函数，用于简化时序数据的工作" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Node Replicated Kernel (NRK) 最早是在 VMware Research 里面的一个原型研究型 Os 项目，现在已经做出了一些学术成果。主要特点是要探索未来操作系统的结构。https://nrkernel.systems/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-14 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个研究型的 OS：NrOS" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "《Refactoring to Rust》https://www.manning.com/books/refactoring-to-rust摘要：这本书试图教会你，如何把现有项目用 Rust 语言重构。 比较适合想在公司里推广 Rust 的朋友。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-13 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "曼宁新书推荐：《Refactoring to Rust》" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "It’s Not Always iCachehttps://matklad.github.io/2021/07/10/its-not-always-icache.html摘要：众所周知，内联是一项很有用的代码优化技术。但有时候我们也常听到类似下面这样的观点：内联也会使代码变慢，因为内联会增加代码的大小，使指令缓存变大并导致缓存未命中。对于内联导致代码运行速度变慢的原因，不少人归结为内联使得iCache命中率降低，造成指令流水线在取指的过程中耗费更多的时间。本文作者通过使用若干有效的工具(perf/valgrind)对比了是否启用内联特性的代码性能和汇编指令，提出了内联可能造成代码变慢的另一种解释：https://perf.wiki.kernel.org/index.php/Tutorial试考虑内联技术将函数S内联展开于函数C中：参考资料：\nInline In Rust\nScylla’s Approach to Improve Performance for CPU-bound workloads\nRust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-13 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "并不总是iCache的原因" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 现在已经有一个被采纳的 I/O 安全的 RFC. 该 RFC 用于处理 文件操作符和 sockets 等的生命周期. 这让编写底层安全的系统对象有了可能.原文链接https://github.com/rust-lang/rfcs/blob/master/text/3128-io-safety.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-12 19:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RFC 3128: I/O Safety" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Greatness 是一个 Rust 编写的, 号称最好的 .file 文件管理器.github 地址https://github.com/IsaccBarker/Greatness" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-12 19:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Greatness: .file 文件管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者为了学习 k8s 的 controller 以及 Rust, 用 Rust 编写了一个 controller.原文链接https://blog.frankel.ch/start-rust/6/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-12 19:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个 Rust 编写的 k8s controller" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "<<Crust of Rust>> 作者的最新视频, 实现 hazard 指针的第二部分.油管视频https://www.youtube.com/watch?v=_LK7qvBWNYo--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-12 19:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Implementing Hazard Pointers in Rust (part 2)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个实时分析 Nginx 访问日志的工具。Read Morehttps://iximiuz.com/en/posts/pq/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-11 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pq - 作为时间序列解析和查询日志文件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "第一篇：https://bnjjj.medium.com/why-and-how-we-wrote-a-compiler-in-rust-blog-post-series-1-x-the-context-e2f83b10edb9第二篇：https://bnjjj.medium.com/why-and-how-we-wrote-a-compiler-in-rust-blog-post-series-2-x-the-stack-548dad1919d0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-11 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我们为什么以及如何用 Rust 编写编译器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个可以提取 Sarc 和 Bfres 文件的网站，这些文件是 Nintendo 常用的文件格式，它用 Rust 编写并编译为WebAssembly。Read Morehttps://tarnadas.github.io/ninres-rs/Repohttps://github.com/Tarnadas/ninres-rs/tree/master/ninres/examples/web" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-11 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个可以提取任天堂常用的文件格式的工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 Rust 中有很多关于 #[inline] 属性的知识。我发现自己经常在教别人它是如何工作的，所以我最终决定把它写下来。额外说明：这是我所知道的，不一定是真实的。此外，#[inline] 的确切语义不是一成不变的，在未来的 Rust 版本中可能会发生变化。内联是一种将函数调用替换为函数体的一种优化转换。举个简单的例子，在编译期间，编译器可以转换如下代码：转换后：文章链接，https://matklad.github.io/2021/07/09/inline-in-rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://matklad.github.io/2021/07/09/inline-in-rust.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-10 20:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust内联" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "今天，我很高兴地宣布 Tor 的新时代实现。在过去一年左右的时间里，我们一直致力于“Arti”，这是一个用 Rust 重写 Tor 的项目。感谢 Zcash Open Major Grants (ZOMG) 的资助，我们终于可以将 Arti 项目列入我们的优先事项列表，并投入更多时间。下面我将谈谈我们为什么要做这个项目，它对 Tor 用户和运营商意味着什么，它的未来发展方向，以及人们可以如何提供帮助。文章链接，https://blog.torproject.org/announcing-artiGitlab 链接，https://gitlab.torproject.org/tpo/core/arti/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.torproject.org/announcing-arti" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-10 20:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Arti: 一个纯Rust实现的Tor" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "fltk-rs 是 FLTK（gui 库）的 Rust Wrapper。自 1.0.0 版以来的主要更新：\nfltk-rs 移到了自己的 github 组织，里面也包含了与 fltk-rs 相关的工具，比如 fltk-calendar、fl2rust（fluid to rust transpiler）、fltk-fluid、fltk-webview...等。\n在 Windows 上使用 gdi+ 支持更新到最新的 FLTK（用于抗锯齿斜线和曲线）。\n...\n文章链接，https://www.reddit.com/r/rust/comments/ohftsq/fltkrs_version_110_released/Gitlab 链接，https://github.com/fltk-rs/fltk-rshttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/ohftsq/fltkrs_version_110_released/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-10 20:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "fltk-rs: 1.1.0发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Sycamore 是一个用于在 Rust 和 WebAssembly 中构建同构 Web 应用程序的库。v0.5.0 版本是Sycamore迄今为止最大的版本，包含大量新功能和错误修复。其中这个版本还引入了功能齐全的路由系统\n文章链接：https://sycamore-rs.netlify.app/news/announcing-v0.5.0\n项目源码\nfcp 旨在以更高的性能处理 cp 的最常见用例。但是它的目标并不是用它的无数选项完全取代 cp。其中比较重要的是 fcp 做了针对具有 SSD 的系统进行了优化。但是在带有 HDD 的系统上，fcp 可能表现出较差的性能。macOS:cargo:使用\ngithub : https://github.com/Svetlitski/fcp\nhttps://zmedley.com/tcp-proxy.html\n完整代码\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-09 17:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rustc_codegen_gcc 是在来自于 GCC 的 libgccjit 库的基础上构建的新的 Rust 编译器后端。有了 rustc_codegen_gcc ，就可以为 GCC 支持的更广泛的架构集生成编译产物，在某些场景可以享受 GCC 产生的优化。目前该提案已经被标记为 major-change-accepted，期间对于许可证兼容的问题引起了社区的关注和讨论。张汉东老师的文章《Rust 与开源 | GPL 许可证引发的问题》对此提供了全面的介绍和小结。GitHub Comment: https://github.com/rust-lang/compiler-team/issues/442#issuecomment-876358112Rust 与开源 | GPL 许可证引发的问题: https://mp.weixin.qq.com/s/1MF75OcC7HuVxwM8ouNsrQ" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://mp.weixin.qq.com/s/1MF75OcC7HuVxwM8ouNsrQ" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-08 23:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustc_codegen_gcc 被编译器团队采纳为新的编译器后端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "nanorand 是一个快速、轻量、高效的随机数生成器，其提供的 nanorand::WyRand 在 M1 Macbook Air 上速度可达 16.4 GB/s。目前 nanorand 发布了 v0.6 ，RandomGen 支持带符号整数和浮点数，RandomRange 支持带符号整数。GitHub: https://github.com/Absolucy/nanorand-rscrates.io: https://crates.io/crates/nanorand" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/nanorand" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-08 23:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "nanorand v0.6 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 398: https://this-week-in-rust.org/blog/2021/07/07/this-week-in-rust-398/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/07/07/this-week-in-rust-398/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-08 23:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 398" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如题.Rust for Linux 的启用现在已经达到了 33000 多行代码，之所以包含这么多代码的其中一个原因是目前在数据结构中包括了 Rust 的 \"alloc\" 标准库的一个子集，并在此基础上添加了一些内容。这使得开发者可以根据自己的需要进行定制。同时给上游提供所需的时间来评估这项变化。最终的目标是将内核需要的所有东西都放在上游的 \"alloc\" 中，并将其从内核树中删除。这些新补丁的另一个变化是，在之前的版本中想要编译 Linux 内核需要使用 Rust 编译器的 nightly 版本，而现在内核可以用 Rust 编译器的 Beta 测试版和稳定版。不过由于对内核的支持确实需要一些 Rust 编译器的最新功能，因此 Beta 版和稳定版在特定情况下会出现编译失败的情况。ReadMore:https://lore.kernel.org/lkml/20210704202756.29107-1-ojeda@kernel.org/ReadMore:https://github.com/Rust-for-Linux" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Rust-for-Linux" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-07 20:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Linux 支持 rust 提交补丁" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "即简单又可配置的命令行 HTTP 服务器ReadMore:https://github.com/EstebanBorai/http-server" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/EstebanBorai/http-server" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-07 20:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "http-server" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RustViz 是一款可视化工具，为简单的 Rust 程序生成可视化图例，来辅助用户更好地理解 Rust 的 生存期 和借用机制。github： https://github.com/rustviz/rustviz" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-06 21:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rustviz：可视化 Rust 生命周期" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Datafuse 是一款现代实时数据处理与分析的 DBMS，云原生架构，基于 Rust 编写，受到 ClickHouse 启发并由 arrow-rs 赋能。该框架秉持以下基本原则：\n无畏： 没有数据竞争，没有 unsafe，尽可能少的未处理错误\n高性能： 所有执行都是并行的\n高可扩展性： 所有组件都是分布式的\n高可靠性： 该框架的首要目标就是要可靠\ngithub：https://github.com/datafuselabs/datafuse" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-06 21:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Datafuse 现代实时数据处理与分析的 DBMS" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这其实是一个手把手教你如何使用 WebAssembly 的教程.原文链接https://blog.frankel.ch/start-rust/5/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-05 20:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 在前端中的使用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "butido 是一个 Rust 编写的 Linux 打包工具. 他基于 docker, 可以编译打包任何的 .rpm, .deb等.作者分享了自己设计开发这工具的整个过程.原文链接https://beyermatthias.de/butido-a-linux-package-building-tool-in-rustgithub地址https://github.com/science-computing/butido" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-05 20:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "butido: Rust 编写的 Linux 打包工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Transrangers 是针对遍历的一种高效的, 可组合的设计模式. pushgen 是 Rust 中的一个实现, 作者结合 c++的实现, 做了一些对比.原文链接https://github.com/joaquintides/transrangers/blob/master/rust.mdtransranges介绍https://github.com/joaquintides/transrangers/blob/master/README.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-05 20:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Transrangers in Rust: a C++/Rust comparison" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个异步编程的教学视频, 如果想学习如果使用 Tokio,可以跟着视频学习如果搭建一个聊天服务器.油管视频https://www.youtube.com/watch?v=4DqP57BHaXI" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-05 20:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Tokio 创建一个聊天服务" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个 Docker api 的 Rust库, 基本上涵盖了 docker 所提供的所有 API.github地址https://github.com/wojciechkepka/docker-api-rs--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-05 20:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "docker-api-rs: 一个 Docker API 的Rust库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对于这个问题，张汉东老师在 RustFriday 飞书群线上沙龙第十三期中进行了分享：\n视频：RustFriday 飞书群线上沙龙 第十三期 | 【讨论】如何在面试中考察一个人 Rust 水平？_哔哩哔哩_bilibili\n博文：如何在面试中 确定 Rust 程序员水平？\n还有一张导图很好地提供了一个结构化的框架：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-04 20:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何在面试中确定 Rust 程序员水平？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这样使用：GitHub 地址：AndWass/pushgenhttps://github.com/AndWass/pushgen这里还有一个对比：transrangers/rust.md at master · joaquintides/transrangershttps://github.com/joaquintides/transrangers/blob/master/rust.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-04 20:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pushgen: 用于处理范围和数据流的推式设计模式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "博客地址：zeke | tcp-proxyhttps://zmedley.com/tcp-proxy.htmlGitHub 地址：ZekeMedley/tcp-proxy: Simple Rust TCP proxy using Tokiohttps://github.com/ZekeMedley/tcp-proxy核心代码：使用：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-04 20:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "30 行的 TCP 代理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "地址：(2) Hands-On Rust : rusthttps://www.reddit.com/r/rust/comments/od4g1e/handson_rust/Ebook：Hands-on Rust: Effective Learning through 2D Game Development and Play by Herbert Wolversonhttps://pragprog.com/titles/hwrust/hands-on-rust/代码开源，书要钱：）" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-04 20:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "是的，又一个 Hands-on，For 2D Game" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "特点：\n快\n最小内存使用\n支持多种代码页\n支持重新定义 ascii (<0x80) 的代码页\n来自维基百科的解释：代码页：字符编码的别名，也称**内码表**，是特定语言的字符集的一张表。https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81字符编码（英语： Character encoding）、 字集码是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、 8 位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。常见的例子包括将拉丁字母表编码成摩斯电码和 ASCII。其中，ASCII 将字母、数字和其它符号 编号，并用 7 比特的二进制来表示这个整数。通常会额外使用一个扩充的比特，以便于以 1 个字节的方式存储。https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6在计算机科学及相关领域当中，内码指的是 “将信息编码后，透过某种方式存储在特定记忆设备时，设备内部的编码形式”。在不同的系统中，会有不同的内码。在以往的英文系统中，内码为 ASCII。 在繁体中文系统中，目前常用的内码为 大五码。在简体中文系统中，内码则为国标码。为了软件开发方便，如国际化与本地化，现在许多系统会使用 Unicode 做为内码，常见的操作系统 Windows、Mac OS X、Linux 皆如此。许多 编程语言也采用 Unicode 为内码，如 Java、Python 3。https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8简单使用：另外两个类似的库：\nlifthrasiir/rust-encoding: Character encoding support for Rust\ntats-u/rust-oem-cp: Rust library that handles OEM code pages (e.g. CP{437,737,850}) for single byte character sets\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-04 20:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Yore：根据 OEM 代码页解码 / 编码字符集的 Rust 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "非常快速的 NPM 包搜索引擎：fast-npm-search.xyz | NPM packages searchhttps://fast-npm-search.xyz/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-04 20:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 开发的 NPM 包搜索引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个非常有趣的项目，可以熟悉优秀的 Rust 资源，非常易于理解的逐步介绍光线追踪原理的指南。链接，https://clayto.com/2021/02/shaking-off-the-rust-1-ray-tracing-in-one-weekend/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://clayto.com/2021/02/shaking-off-the-rust-1-ray-tracing-in-one-weekend/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-03 21:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 实现光线追踪器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "prae，提供了一个方便的宏，允许生成类型包装器。让我们创建一个用户名（Username）类型。 它将是非空字符串（String）的包装器：Github链接，https://github.com/teenjuna/prae" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/teenjuna/prae" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-03 21:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "prae，类型包装器库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "示例如下：创建一个空的 tiling 模型。在原点放置一个多边形，增加了一个六边形。Github链接，https://github.com/jonasrmichel/tiling" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jonasrmichel/tiling" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-03 21:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tiling，构建正多边形库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "1Password 客户端应用程序 Rust 团队的高级开发人员谈到：几个月前，在对 Rust 中的 Async 和 Futures 进行了基础知识的第一次深入研究，试图揭开帷幕并解释它们是如何组合在一起的，尤其是着眼于那些主要用于 Promise 的开发人员感到惊讶的事情。视频链接，https://www.youtube.com/watch?v=HrxwOUVzyDUhttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=HrxwOUVzyDU" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-03 21:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【视频】1Password 开发者炉边谈话：深入了解 Rust 中的 Async & Futures" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Buck 是 Facebook 在 2013 年的Facebook Mobile DevCon上亮相的一个快速的 Android 构建系统。从那时起，它已经扩展到支持用15种以上的语言编写的应用程序，目标平台包括手机、服务器、智能设备和VR头盔等等。不过，随着时间的推移，Buck并没有跟上这种功能和灵活性的增长，没有进行必要的架构改变和改进来管理这种复杂性。随着Facebook内部和外部开发新的功能，发现这导致了巨大的实施复杂性，对核心和语言规则进行修改的挑战越来越大。虽然该团队在近4年前就开始了一项举措，逐步对 Buck 进行一些这样的跨领域的架构改进，但这些改变是非常困难的。所以，从2020年开始，该团队开始构思，如果从零开始构建 Buck 会怎么样？怎样才能写出一个可以在未来10年或20年中继续扩展的构建系统？以下是Facebook团队的思考\nhttps://developers.facebook.com/blog/post/2021/07/01/future-of-buck\n翻译from rust社区--张汉东\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-02 19:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Facebook 从 Java 到 Rust | Buck 的未来" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust错误处理项目组要解决的第一个挑战是在reporte错误时很容易丢失上下文,eg:我们实际获得的：当我们运行它时，我们更希望看到类似这样的输出：在这个错误消息中，我们可以看到程序因为panic而退出。我们可以看到通过访问的错误链中每个错误找到错误源.项目组希望这些更改将显着改善Rust错误处理的体验，这使错误报告更加一致和灵活，并让最终的应用程序开发人员定义他们自己的格式化错误报告。错误处理的工具将更紧密地集成到标准库和语言本身中，通过更普遍地对Error特征进行标准化为嵌入式生态系统带来额外的好处\nhttps://blog.rust-lang.org/inside-rust/2021/07/01/What-the-error-handling-project-group-is-working-towards.html\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-02 19:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust错误处理项目组正在朝着什么方向努力" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们一直在Web浏览器中托管WebAssembly模块，但这并不托管的唯一的方法。我们可以用Rust程序在Web浏览器之外托管wasm模块。博文介绍了如何做到这一点\nhttps://blog.knoldus.com/hosting-wasm-modules-in-rust-easily-using-wasmi/\n\nhttps://github.com/rust-lang/rfcs/pull/3107\nRust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-02 19:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Rust 中使用'wasmi'轻松托管wasm模块" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "投入 12 个月，50K+ 行代码变更，8 轮设计迭代，使用 Rust 为 Python 设计并实现一个 ASGI web 服务器。 ChillFish8 用一篇文章简单回顾了设计和实现 Pyre 的历程与收获。文章: https://www.reddit.com/r/rust/comments/ob4kli/12_months_of_rust_50k_changed_lines_of_code_8/GitHub: https://github.com/Project-Dream-Weaver/pyre-http" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Project-Dream-Weaver/pyre-http" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-01 23:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pyre 设计与实现之旅" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "supply-chain 子命令将会收集依赖关系图中涉及的 crates 的作者、贡献者以及发布者。它可以帮助你找到值得信任和依赖的人和团队，并识别依赖关系图中的潜在风险。GitHub: https://github.com/rust-secure-code/cargo-supply-chain" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-secure-code/cargo-supply-chain" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-01 23:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo supply-chain 新鲜出炉" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 397: https://this-week-in-rust.org/blog/2021/06/30/this-week-in-rust-397/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/06/30/this-week-in-rust-397/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-07-01 23:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 397" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "How using hyper in curl can help make the internet saferhttps://aws.amazon.com/cn/blogs/opensource/how-using-hyper-in-curl-can-help-make-the-internet-safer/摘要：curl作为一款开源的使用URL语法进行文件传输的命令行工具，在互联网各种平台下都有广泛的支持和使用。但是curl是用C语言编写的，由于臭名昭著的C语言引起的内存安全问题，跟curl相关的安全漏洞有50%都是由C语言错误引起的；https://daniel.haxx.se/blog/2021/03/09/half-of-curls-vulnerabilities-are-c-mistakes/另一方面，Rust语言自诞生之初就主打内存安全，一个自然的设想就是能否把curl的核心设施用rust语言编写的组件代替来提升curl的安全性。在今年二月初的时候，来自互联网安全研究小组(Internet Security Research Group)的Josh Aas、curl的作者Daniel Stenberg以及hyper和Amazon Web Services的Sean McArthur举行了一次联合网络研讨会(joint webinar)，讨论了内存安全和互联网安全的关系，并且探讨了如何在curl中应用hyper作为后端来提升整个互联网的网络安全质量。https://www.abetterinternet.org/具体措施是在curl中增加编译选项，使得提供设置hyper为curl的后端实现的选择。如今curl和hyper的代码开发都合入到了各自项目的主分支，但是新的发行版本可能要等到确保新开发的功能和原始C版本的实现逻辑一致，并通过足够完整的测试集覆盖后才会提上日程，这也是接下来要重点关注的事情。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-30 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在curl中应用hyper是怎样帮助互联网变得更安全的？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "The second edition of Programming Rust is officially available!https://www.reddit.com/r/rust/comments/o9nn3a/the_second_edition_of_programming_rust_is/摘要：由O'Reilly出版的《Programming Rust》第二版的电子书和实体书都已经上市了：\n实体书直达链接： https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/\n电子书直达链接：https://www.ebooks.com/en-us/book/210313783/programming-rust/jim-blandy/\n《Programming Rust》是一本深入考察Rust语言设计思想以及如何将其应用于一系列系统编程问题的技术书籍。本书通过若干入门级的项目示例，深入研究了Rust语言具体的语言特性和各种特性相互作用的逻辑，从类型系统到如何根据类型系统建模现实中的问题，从unsafe rust的本质探讨、如何处理FFI外部函数调用到Rust异步编程等高级特性，无一不做到了深入浅出。本书较之第一版，根据Rust编译器最新版本的特性完全进行了跟进，并且新增了一个详尽的讲述异步编程的机制和技巧的章节。《Programming Rust》是一本适合想要了解Rust语言的C、C++、Python、Java或者其他语言的开发者，或者那些想要提升自己编程技巧的Rust编程人员的书籍。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-30 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《Programming Rust》第二版已经官宣发行" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "What's wrong with the Rust community?https://www.reddit.com/r/rust/comments/oa6t5c/whats_wrong_with_the_rust_community/摘要：作者发现自己关注的repo凡事用rust语言编写的都有上千次的commit（最近的提交可能就在30秒钟之前），因此有感于Rust社区充满活力；和其他语言相比，Rust语言的生态系统虽然年轻但是也已经相当成熟了。( i <3 rust跟帖者可能的原因是：不少人认为，易于贡献代码 这一点自己再同意不为过。（：Rust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-30 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "讨论：Rust社区到底发生了什么？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "经过 4 年的编写, <<Rust In Action>> 终于正式发售了. 有实体版和电子版等多种选择, 英语好而且想看的小伙伴可以下单了.原文链接https://www.manning.com/books/rust-in-action?a_aid=rust&a_bid=0367c58f&utm_source=rust&utm_medium=affiliate&utm_campaign=affiliate&a_aid=rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-28 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "<<Rust In Action>> 正式发售了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 <<Crust of Rust>> 作者的最新视频, 实现 Rust 中的 Hazard Pointers.油管视频https://youtu.be/fvcbyCYdR10" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-28 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "实现 Rust 中的 Hazard Pointers" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "smallnum 可以对 number 进行 编译时大小优化。宏返回能够适合静态边界的最小数值类型。对于无符号整数，宏输入是一个最大值。对于有符号整数，宏输入可以是最大值或最小值。github地址https://github.com/tnballo/smallnum" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-28 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "smallnum: 编译期间的 number 优化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "fang是一个后台任务执行库. 支持:\n任务存储数据库\n并发任务数\n重启任务等\n原文链接github 地址https://www.badykov.com/rust/2021/06/27/fang/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-28 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "fang: 后台任务执行库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇是一篇采访纪录，@NavyataBawa邀请到了 Facebook 工程师 Daniel Xu，分享他在 Facebook 是如何使用 Rust 来构建 Linux 系统工具、库和服务的。https://twitter.com/NavyataBawa/Read Morehttps://developers.facebook.com/blog/post/2021/06/24/meet-rustaceans-daniel-xu/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-27 21:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Facebook Rust 是如何被用来构建 Linux 系统工具、库和服务的" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 Linux x86 x86_64 下使用 TSC，在其他平台上使用 MONOTONIC_COARSE 吊打 std, 精度突破 10ns !Repogithub.com/LemonHX/minsnt" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-27 21:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "史上最快 Rust 高性能计时库 minstant" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对 Rust 密码学感兴趣的同学可以关注 @DevXInitiative 和 #gorustlang。https://twitter.com/DevXInitiativeRead Morehttps://www.youtube.com/watch?v=SxrBSLe41N0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-27 21:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "第一届 Rust 密码学兴趣小组会议视频" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是由 Rust Landon 组织的一次线上会议，GMT+8 凌晨 2:00 开始。现在还可以免费注册哦。Register Nowhttps://skillsmatter.com/meetups/13508-ldn-virtual-talks-jun-2021-concordium-takeoverRead Morehttps://skillsmatter.com/meetups/13508-ldn-virtual-talks-jun-2021-concordium-takeover" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-27 21:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我们是如何在 Concordium 使用 Rust 的" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "自 paru 最初发布以来已经 250 天了，您可以在此处找到我关于它的原始帖子。对于那些不知道 paru 的人来说，它是一个“新的”AUR 助手。原本是对 yay 的重写，使用过 yay 或其他 pacman 包装 AUR 助手的人肯定会很熟悉。Paru 已经很受欢迎，到目前为止还有 30 位其他贡献者，我很高兴看到这些贡献者。文章链接，https://www.reddit.com/r/rust/comments/o87zdn/250_days_of_paru/Github 链接，https://github.com/Morganamilo/paru" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Morganamilo/paru" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-26 23:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "paru发布的第250天" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一段时间以来，我一直在研究分布式社交网络（协议 + 实现）这个想法。我今天刚刚发布了一个新版本，我想我已经准备好让人们试用它了。您可以在此处阅读完整的 README + 开发人员文档：文章链接，https://www.reddit.com/r/rust/comments/o80zh4/feoblog_v040_released_today/Github 链接，https://github.com/NfNitLoop/feoblog/blob/v0.4.0/README.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/NfNitLoop/feoblog/blob/v0.4.0/README.md" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-26 23:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "FeoBlog v0.4.0 今天发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cupcake 是一个高效的 Rust 库，用于 Fan-Vercauteren 同态加密方案的（附加版本），提供加密向量、添加/减去两个加密向量以及重新随机化密文的功能。Github 链接，https://github.com/facebookresearch/Cupcakehttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/facebookresearch/Cupcake" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-26 23:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cupcake 加法同态加密的Rust库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "字节跳动的小伙伴搞的，希望能帮助建设国内的 rust 生态，感兴趣的话可以试用，无任何限速（实际上是 1000Gbps）。地址：https://rsproxy.cn/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rsproxy.cn/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-25 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rsproxy.cn - 字节跳动新的 crates.io 和 rustup 的国内镜像源" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ISRG (Internet Security Research Group) 的另一个关注内存安全的项目(Prossimo) 宣布赞助 Miguel Ojeda 在 Linux for Rust 方面的工作。（知名的 Let's encrypt 是 ISRG 的另外一个项目）Miguel Ojeda 在今年 4 月 Linux maillist 上提交了让 Linux 内核支持 Rust 的 RFC，同时他一直在致力于让 Rust 成为 Linux 内核开发的第二语言，Linux for Rust 项目一直主要是由他在推动。链接：https://www.memorysafety.org/blog/supporting-miguel-ojeda-rust-in-linux/RFC：RFC for Rust support in the Linux kernelhttps://lkml.org/lkml/2021/4/14/1023Rust for Linux: https://github.com/Rust-for-Linux/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Rust-for-Linux/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-25 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ISRG 宣布支持 Miguel Ojeda 在 Linux for Rust 方面的工作" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "鹏城实验室和清华大学组织的2020年开源操作系统夏令营收到同学们的积极响应，参与夏令营的同学在今年的“2021全国大学生计算机系统能力大赛 - 操作系统赛”的初赛中都有不错的表现( https://mp.weixin.qq.com/s/Cb2SaonAAHDVNDli_80Bpw )，今年启元实验室、清华大学和CSDN等将继续组织“2021年开源操作系统夏令营”，希望能把对开源操作系统开发有兴趣的朋友团结在一起，形成一个活跃的开源社区。欢迎对开源操作系统有兴趣的任何人报名（需填写下面的报名问卷）参加。第一阶段： https://github.com/rcore-os/rCore/wiki/os-tutorial-summer-of-code-2021第二阶段： https://github.com/rcore-os/rCore/wiki/zcore-summer-of-code-2021报名问卷： http://oscourse2019.mikecrm.com/vzZqxgM" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-25 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2021年开源操作系统夏令营" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GTK4 的 rust 绑定正式发布，新功能，新官网，新的教程。链接：https://gtk-rs.org/blog/2021/06/22/new-release.html教程：https://gtk-rs.org/gtk4-rs/stable/latest/book/introduction.htmlhttps://github.com/folyd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gtk-rs.org/gtk4-rs/stable/latest/book/introduction.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-25 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gtk4-rs 发布: GTK4 的 rust 绑定" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果你想要一个标准库中transmute函数的安全替代，可以看看这个。Doc: https://docs.rs/totally-speedy-transmute/1.69.420/totally_speedy_transmute/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://docs.rs/totally-speedy-transmute/1.69.420/totally_speedy_transmute/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-24 23:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Totally Speedy Transmute：一个std::mem::transmute的安全替代crate" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rustc_codegen_gcc是rustc的GCC代码生成器，这意味着它可以被现有的rustc前端加载，但受益于GCC，因为它支持更多的架构，并可以获得GCC的优化。Read More: https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-1" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-24 23:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustc_codegen_gcc: 进展报告 #1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "终于，我可以适当地命名我的unsafe函数了。– Freeky 发表于 r/rusthttps://www.reddit.com/r/rust/comments/o1yy1p/announcing_rust_1530/h2488f5Read More：https://this-week-in-rust.org/blog/2021/06/23/this-week-in-rust-396/中文: https://blog.budshome.com/budshome/rust-guan-fang-zhou-bao-396-qi-(2021-06-23)" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.budshome.com/budshome/rust-guan-fang-zhou-bao-396-qi-(2021-06-23)" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-24 23:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周引语" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者使用 Rust 来编写一个简单的监视器, 来返回系统的状态.原文链接https://www.rotoclone.zone/blog/posts/raspberry-pi-monitoring" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-21 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 编写一个简单的监视器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文详细讲解了如果使用 Rust 来操作 mongo 和 redis, 并且使用 actix web 来构建一个简单的 web 应用.romankudryashov原文链接https://.com/blog/2021/06/mongodb-redis-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-21 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust中使用 mongoDB 和 redis" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "elfcat 可以从 ELF binary 中生成 HTML, 从而可以让你以一种非常生动的形式查看 ELF. 可以点击示例地址进行查看.示例地址githbub 地址http://ruslashev.github.io/elfcat/hello_world.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-21 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "elfcat: ELF visualizer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "增加 Run with root privileges/Run with Administrator privileges更多功能见 changelog.原文链接https://intellij-rust.github.io/2021/06/21/changelog-149.html--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-06-21 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "INTELLIJ Rust ChangeLog #149: Run with root privileges" }, "type": "text" }], "type": "title" } },]
