export const propertiesForNewPages = [{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"还没有提交问卷的小伙伴，继续填写一下问卷。我的两小时交换你的2分钟，可以吗？按订阅人数来看，目前的问卷填写率是58%。回头会把统计结果给大家分享，目前的统计结果很有意思，但是样本有点少，需要大家的配合。到时候把结果放出来，大家也可以对国内的Rust社区有一个了解。 来填问卷喽 https://wj.qq.com/s/2801182/f890docs.rshttps://docs.rs/之前IPv4 地址挂了， IPv6 可用临时访问地址： docsrs.brun.onehttps://docsrs.brun.one/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"通告三则"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本文介绍了WebAssembly线程提案，简要：\nWebAssembly的线程提案不是准备好一个线程库让你调用，而是指定了基本的线程构建块。\n线程提案中首先添加了原子指令。同时提供了i32.atomic.wait和atomic.wake指令来阻塞和唤醒线程，这就形成了一种底层的原语，比如可以用它来实现互斥锁。\n通过web worker实现并行。但是目前web worker共享资源的能力比较弱，只能通过发送消息。但是在Rust看来，js里的对象很少有可以直接Send的对象，在线程间发送对象总是需要clone。现在通过在线程间传递WebAssembly.Module，则可以极大降低clone的成本。\n利用SharedArrayBuffer 共享内存。\n一次性初始化内存。当前的wasm自动初始化内存在多线程情况下会导致不安全。所以必须使用一次批量申请内存的策略。多线程下，只能有一个线程负责初始化。将自动改为手动，模块必须通过memory.init指令手动初始化内存。\n以上是线程提案中的重点。线程和wasm-bindgen：\nwasm-bindgen工具由两部分组成：派生宏#[wasm_bindgen]和cli。 wasm-bindgen cli工具现在使用parity-wasm库来解析Wasm，该库极大地增强了cli的功能，并摆脱了LLVM的束缚，可以访问Wasm的完整功能集。\nwasm-bindgen可以在线程本地存储中注入全局变量，这个是LLVM/LLD当前无法做到的，但是wasm-bindgen做到了。 可以方便地将此变量添加到wasm模块中。\n通过定义ID为0的全局线程变量，来判断是不是主线程。如果是0则是主线程，则调用wasm的memory.init来批量分配内存，解决多线程下wasm自动内存分配带来的不安全问题。\n管理 WebAssembly.Memory。在多线程情况下，希望所有的模块都使用相同的内存实例。目前wasm-bindgen给出了一个临时方案。使用—no-modules参数，将模块的路径实例化，在创建内存的时候再进行实例化，然后将其实例化的模块分发给每个worker。 等线程提案稳定之后，会完善更多细节。\n演示实例：并行化光线跟踪 raytrace-parallel\n虽然wasm-bindgen现在已经可以制作演示实例，但实际上离真正可用还有一段距离，还有很多问题需要解决。 WebAssembly线程提案 https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md#atomic-memory-accesses Read More https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Rust WASM小组」多线程Rust和WASM"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"korqhttps://github.com/vertexclique/korq官网https://vertexclique.github.io/korq/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」K8S 的tail pod日志工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该文由寒霜引擎（Frostbite Engine）的高级渲染工程师所写。意味着该公司也使用Rust了。他在做三维网格GPU渲染的时候，用到了一个优化器meshoptimizer，该库提供了很多算法为GPU优化几何形状。https://github.com/zeux/meshoptimizer但它是C/C++实现，还没有Rust实现。所以他实现了一个meshopt。https://github.com/gwihlidal/meshopt-rs是通过Rust FFI对meshoptimizer做了Rust绑定。对于为什么使用FFI，而非纯Rust重写，他给出了理由：\n制作100%的Rust实现，还需要持续和C/C++版本的代码保持同步。因为这些C/C++的库还非常活跃。\n那些C/C++的库已经得到了很好的优化。\n使用FFI的时间成本要小于用Rust重新实现。尤其是当库提供C89接口时，无需处理符号解码。\n同时还介绍了一些工具， bindgen、cc以及用vscode+lldb Debug代码。 Read More https://www.wihlidal.com/blog/pipeline/2018-10-20-rust-mesh-optimizer/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「游戏」Rust网格优化器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者在实现 amethyst-editor-sync 库，通过IPC与amethyst的editor通信功能。https://github.com/randomPoison/amethyst-editor-sync注：该项目 不是官方项目。他在实现过程中发现孤儿规则的美妙之处，保证了trait一致性。Read Morehttps://davidlegare.ghost.io/rusts-orphan-rule/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」Rust的孤儿规则其实很不错"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者最近用自己实现的数据结构和RwLock和Mutex的性能进行比较，在自己的笔记本上，RwLock比他实现的快5倍，而Mutex快2倍。代码放到他公司的机器上，Mutex依旧快2倍，然而，RwLock慢了4000倍。通过研究发现：\n相同的测试，在macOS上RwLock执行0.01秒，而换linux机器执行需要40秒。\n通过阅读Rust RwLock源码，发现针对底层调用的rwlock原语，macos使用的FreeBSD的用户态组件 pthread_rwlock_rdlock，而Linux使用的是不同的结构PTHREAD_RWLOCK_PREFER_READER_NP。\n不同的底层原语意味着不同的操作系统对待读/写的策略不同。\nLinux上选择偏好读，读取会优于写入。而macOS/BSD上偏好写，写会优于读。\n作者的示例正好是测试写入速度，所以在macOS上，读取会优先让位给写入，写入会很快完成。而Linux正好相反，所以导致写入操作严重延迟。不过Linux上面可以更改 pthread_rwlock策略。\n结论：请根据不同的硬件环境去选择适合的数据结构。Read Morehttps://fy.blackhats.net.au/blog/html/2018/10/19/rust_rwlock_and_mutex_performance_oddities.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」Rust RwLock和Mutex性能有点古怪"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\n改进了2D流程\n引入了新的DrawSprite方法，60FPS可以绘制10w个精灵\n增强了网络系统\n实验性的编辑器支持，基于Electron构建\nRead Morehttps://www.amethyst.rs/blog/release-0-9/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「游戏」Amethyst 0.9发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"strsim-rshttps://github.com/dguo/strsim-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」字符串相似度测量工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"允许带有Touch ID的MacBook Pro使用Secure Enclave对服务器进行身份验证sekeyhttps://github.com/ntrippar/sekey"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」SeKey - 一种SSH代理"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"特点是：\n利用了宏和ZST\n更多的编译期操作，避免运行时\njson_in_typehttps://github.com/lovasoa/json_in_type#json_in_type"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「库」快速JSON编码器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Read Morehttp://gtk-rs.org/docs/gtk/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"gtk-rs现在增加了文档"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"愿景是建立一个类似于facebook的社交互联网。相似的项目（Rust实现）有：Plume-org/Plume， 基于ActivityPub协议的Blog引擎（WIP）。ActivityPub是一个去中心社交网络（decentralized social networking）的交互协议，已经成为W3C标准。目前比较知名的应用有Mastodon（长毛象，Ruby实现）。也可通过GitHub搜索相关项目topics/activitypubhttps://github.com/topics/activitypubaardwolf.socialhttps://aardwolf.social/源码：aardwolfhttps://github.com/Aardwolf-Social/aardwolf每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-24 12:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Aardwolf：Rocket实现的联盟社交网络"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"还没有提交问卷的小伙伴，继续填写一下问卷。我的两小时交换你的2分钟，可以吗？按订阅人数来看，目前的问卷填写率是50%。回头会把统计结果给大家分享，目前的统计结果很有意思，但是样本有点少，需要大家的配合。到时候把结果放出来，大家也可以对国内的Rust社区有一个了解。 来填问卷喽 https://wj.qq.com/s/2801182/f890IPv4 地址挂了， IPv6 可用临时访问地址： docsrs.brun.onehttps://docsrs.brun.one/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"通告两则"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本篇介绍了如何用Rust处理硬件中断，将学习到如何获取定时器中断周期以及如果从键盘获取输入。也能看到Rust的所有权对写操作系统产生什么有益的助力。Read Morehttps://os.phil-opp.com/hardware-interrupts/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「用Rust写操作系统V2系列」硬件中断"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本篇主要是阐述了Shifgrethor 的工作方式：将带有垃圾回收的Rust程序的内存分成了三个部分： 栈、托管堆（managed heap）和非托管堆（unmanaged heap）。（让我想到了.net的CLR，看来上一篇的新闻内容我理解有点问题，不过没关系，看这篇纠正就可以了）非托管堆： 是程序存储器的一部分，Rust程序员通常认为它就是堆，由内存分配器来分配内存，开发者可以自由调用，Rust里的Box分配的就是非托管堆的内存。托管堆： 提供了分配内存的API，但没有提供释放内存的API，由垃圾回收器来负责回收内存。这就是为什么它被成为「托管堆」其实托管堆和非托管堆也不是完全独立的内存，其实可以在非托管堆的基础上实现托管堆。比如，可以实现一个库，将内存分配到非托管堆，然后该库实现一个自动的垃圾回收器，然后这个GC维护一个托管堆。这也正是Shifgrethor 要做的。托管堆中的所有数据，实际上是存储在非托管堆的链表中，基本上是一堆Box。垃圾回收器依赖于这个链表，对数据进行标记，这就形成了一个保守的标记-清除的GC。标记阶段有两个重要的部分：\n生根（rooted）：非托管部分（包括非托管堆和栈）对托管堆的引用必须是rooted，这样GC才能知道从哪里去找actived 对象。有不同的生根策略，Shifgrethor 的比较独特。\n发芽（Tracing）：从根的部分，跟踪和其关联的所有对象。也就是说，从根开始，标记和其关联的所有引用。可以将其看作是一种图形跟踪算法。\n关于此GC的效率问题：\n使用链表存在着一些问题，比如内存位置不连续，会导致内存缓存访问不佳且成本更高。\n引入复制垃圾回收算法来解决这个问题。但是复制垃圾回收又为Rust引入了新的问题，将在后面的文章中介绍它。\n下一篇将阐述，Shifgrethor如何rooted。 Read More https://boats.gitlab.io/blog/post/shifgrethor-ii/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「研究项目」「系列文章」Shifgrethor II ：跟踪垃圾回收器的注意事项"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"此文是influxdata的开发者写的，他是一名Go程序员，然后最近开始学习Rust。本文记录了他的一些学习心得和过程。他学习过程不仅仅是看书，Go社区有本书叫《用Go实现解释器》，这本书里实现了一个语言，叫做Monkey 语言。然后他本身是Go程序员，所以在学习Rust的时候，通过这本书，用Rust实现了Monkey语言，文中有源码仓库地址。https://interpreterbook.com/ Read More https://www.influxdata.com/blog/rust-can-be-difficult-to-learn-and-frustrating-but-its-also-the-most-exciting-thing-in-software-development-in-a-long-time/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」学习Rust，痛并快乐着"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Mozilla工作人员 Lin Clark，最擅长的就是用卡通画来阐述技术思想，本篇就是他的新作。他发现很多人误以为WebAssembly当前发布的MVP（minimum viable product ，最小可行产品）版本就是WebAssembly的最终版本。非也，非也。事实上，WebAssembly还有很多能做的事情，目前大家掌握的只是技能树上的前几项。\n编译目标\n快速执行\n快速加载\n线性内存\n解锁成就： 在浏览器运行程序和游戏就像在本地机器上一样。\n线程，已完成提案。\nSIMD， 已经在非常活跃的开发阶段。\n64位地址， 有了一个好的计划。\n流式编译， Firefox在2017年已经支持，其他浏览器还在努力。并且firefox在2017年也增加了用于分层编译的baseline编译器，其他浏览器也在过去一年中添加了相同的架构。\n隐式HTTP缓存，就快登录Firefox了\n其他改进，正在讨论\n解锁成就：这些技能点实现以后，就会有更多重量级的应用程序进入浏览器。\n在js和wasm之间快速调用，目前在firefox已经解决了这个问题\n快速简单的数据交换， reference types和host bindings 提案已经完成，Rust工具链已经创建了一些工具，可以自动为开发者处理这些数据交换，可以暂时弥补提案功能的缺席。\nES模块集成，快要递交提案。\n工具链集成， Rust的wasm-pack很不错。\n向后兼容性， 利用wasm2js工具。\n解锁成就：生态系统中将得到很多wasm和js互操作的模块一种路线是：用wasm重写现在的很多js框架，比如react、vue、ember等另一种路线：编译到js的静态类型语言可以直接编译到wasm，比如scala.js、reason或elm对于这两种路线，webassembly都需要支持更多高级技能：\nGC。 目前正在进行两项提案，JS的Typed Objects和WebAssembly的GC。Typed Objects可以描述对象的固定结构，WebAssembly GC可以直接访问该结构。有了这两个东东，js和wasm就可以共享js对象。这个估计得明年才能标准化，还不一定实现。\n错误处理，处于研究和开发阶段。\nDebug， 目前浏览器的devtools有一点支持，但不理想。\n尾调用支持，提案正在进行。\n解锁成就： 达成js框架用wasm重写和编译到js的语言可以直接编译到wasm。网络中除了网页，还有一个非常重要的属性：链接。互联网有链接才能互联，但是，目前用户跳转到的链接内容，都是和提供其服务的机器设备重度依赖的。一个网站是否要为每个可能的设备提供不同版本的代码？ 当然不是，一个网站的源码只有一个。这里面涉及一个概念：可移植性。可移植性很好，你可以从不认识的人那里加载代码，不用管什么设备。但这里存在一个安全问题。利用wasm可以达成以下两点：\n可移植性。向用户提供代码，并且可以在能运行浏览器的任何设备上执行。\n安全沙箱。在wasm安全模型中运行代码，不会危机机器的安全。\n所以可以将wasm视为浏览器工具箱中的一个独立的工具。比如，可以使用wasm对Node.js中的一些本地扩展进行重写，比如Node.js 中用C实现的一些模块，就没必要依赖于机器，这就增强了Node.js代码的可移植性。但是目前wasm还无法访问系统资源，因此还需要更多技能：\n一个可移植的wasm系统接口，目前有一个package name maps的提案，可以用于将模块名称映射到加载模块的路径。这可能会得到浏览器和Node的支持，它们可以使用它来提供不同的路径，从而加载完全不同的模块，但使用相同的API。有了这个支持，就可以开始考虑接口的事了。这估计就需要更长的时间了。\n这些领域为什么要使用WASM？作者举个了例子， Fastly是一家提供CDN和边缘计算的公司，他们CTO如是说：wasm可以在安全、性能和规模上提供比系统进程更加强的功能。这就意味着需要一个新的技能：\n运行时，执行实现一个wasm编译器或解释器。\n目前CraneStation在建立一个通用的wasm运行时，wasmtime。https://github.com/CraneStation/wasmtime其他应用方向：\n可移植的CLI工具，可以用于不同的操作系统\n物联网\n区块链， （这个原文没说）\n长文预警！！！ Read More https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」WebAssembly的后MVP时代：技能树如何发展「卡通版」"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Read Morehttps://hgill.io/posts/auth-microservice-rust-actix-web-diesel-complete-tutorial-part-1/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Web框架」使用actix-web制作一个验证用户身份的微服务 Part 1"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"用Tor浏览器打开此链接http://tordex7iie7z2wcg.onion/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Web框架」用Rocket、Diesel和Future开发的Tor搜索引擎"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该库实现了很多字符串操作的方法，灵感来源 Voca.js 和 string.py。可以关注下voca_rshttps://github.com/e1r0nd/voca_rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具库」字符串操作集合"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该库可以在编译期提供断言功能static-assertions-rshttps://github.com/nvzqz/static-assertions-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」编译时断言"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"可以挖门罗币，也包括其他的某些数字货币powhasherhttps://github.com/kazcw/powhasher"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」Rust实现的挖矿工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":".wad一般是Quake、半条命、Doom等游戏的格式好像可以为智能手机上玩这三款游戏提供支持rs_wadhttps://github.com/bjt0/rs_wad"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「学习小项目」Rust实现的加载.wad文件的库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":" Read More https://joshlf.com/post/2018/10/18/rust-higher-kinded-types-already/每日新闻订阅地址：\nTelgram Channel ： https://t.me/rust_daily_news \n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-23 12:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Hack向」在Rust中实现一个HKT"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"「Rust每日新闻」持续更新也快一年了，现在想做个小调查，了解下读者群，为了在年底出一份「每日新闻」年度报告做准备。同时也为了将来可以更好地给大家提供内容。 大家有空填写一下，不涉及隐私。还没有提交问卷的小伙伴，填写一下问卷，也算是对我的支持吧，问题不多，只需1-2分钟。回头会把统计结果给大家分享，目前的统计结果很有意思，但是样本有点少，需要大家的配合。到时候把结果放出来，大家也可以对国内的Rust社区有一个了解。来投票喽https://wj.qq.com/s/2801182/f890"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-22 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Rust每日新闻」调查问卷"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"群友自己撸的一个树莓派的交叉编译环境的docker，有需要可以参考～ct-raspi3bp-rusthttps://github.com/geeestar/ct-raspi3bp-rust"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-22 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「交叉编译」树莓派交叉编译环境docker"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"五种计算Pi的方法https://www.wikihow.com/Calculate-PiRead Morehttps://www.reddit.com/r/rust/comments/9q63dk/trying_to_calculate_pi/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-22 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「练手小项目」如何计算Pi"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该工具提供了一个宏，支持在Rust里直接写GLSL语言。GLSL - OpenGL Shading Language 也称作 GLslang，是一个以C语言为基础的高阶着色语言。它是由 OpenGL ARB 所建立，提供开发者对绘图管线更多的直接控制，而无需使用汇编语言或硬件规格语言。Read Morehttps://phaazon.net/blog/glsl-quasiquote-0.2"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-22 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」glsl-quasiquote-0.2 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"termwmhttps://gitlab.com/jD91mZM2/termwm"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-22 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」Rust实现的终端浮动窗口管理器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"docs.rs现在归到了rust-lang-nersery组织下docs.rshttps://github.com/rust-lang-nursery/docs.rs每日新闻订阅地址：\nTelgram Channel ： https://t.me/rust_daily_news \n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-22 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」docs.rs 找到组织了"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在2018年10月15日，crates.io遭到了一次「伪装官方」的攻击事件。事件起始：\n有人伪造了一个用户名cratesio，然后以常用的简短的名字上传一些crate，里面除了Cargo.toml和README之外什么都没有。\n并且指示crates.io用户，如果想要这些名字，就去crates.io issues列表发issues。\n此用户上传crate的速度引发了GitHub的限制，导致所有软件的上传和下载速度减慢。\n官方应对：\n封禁该用户IP\n删除该用户上传的所有crate，将cratesio用户的页面定向为404\n该用户被举报到GitHub，封禁处理\n事件从开始到结束，一共经历了五小时。官方未来的措施：\n考虑到单个的正常用户不可能一次性上传很多crate，所以将会限制上传crate的数量和速率\n猜测该用户攻击行为的动机，很可能是因为之前crates.io上面的包名的「抢注」政策不满意。所以官方将在未来几周内讨论确定该政策的解决措施。\n无论动机如何，官方团队都不欢迎这种攻击行为，如果对政策不满意，可以提交RFC或给help@crates.io发邮件。避免使用这种恶意攻击行为。\n通过这次事件，官方团队也意识到应该多和社区进行沟通，并且会为社区的沟通制定更多的通道。\n Read More https://blog.rust-lang.org/2018/10/19/Update-on-crates.io-incident.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-20 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」crates.io的2018年10月15日事件始末"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"pulldown-cmark的作者新写了一个fearless-simd的库，他出于以下愿景来写这个库：\n更易于编写SIMD代码\n自动检测CPU级别并运行最佳代码\n不需要使用unsafe\n可以访问高级的SIMD原语\n可以跨多个体系结构移植\n使用范围有限\n专注于f32\n主要用于一维结构化数据\n没有尝试对齐的加载/存储，因为SIMD在未对齐的情况下更加高效\n该库还在达成以上愿望的路上 Read More https://raphlinus.github.io/rust/simd/2018/10/19/fearless-simd.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-20 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」迈向无畏的SIMD"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"用于在docs.rs上生成railroad语法图该插件是用 Rust库macro_railroad （[之前新闻介绍链接] (https://t.me/rust_daily_news/954)），和wasm共同制作的macro_railroad_ext 源码https://github.com/lukaslueg/macro_railroad_ext Read Morehttps://www.reddit.com/r/rust/comments/9pnk1w/show_reddit_a_browserextension_to_generate/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-20 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」Rust+WASM制作的浏览器扩展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该文作者实现了C++和Rust两种版本的同一个功能代码，发现C++更快一些，他想要寻求帮助，看看Rust到底慢在哪？感兴趣的，可以关注下。Read Morehttps://www.reddit.com/r/rust/comments/9pmm3n/difference_in_c_and_rust_performance_if_similarly/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-20 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「讨论」一段光线追踪代码的C++ 和 Rust两种实现的性能差异"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"derive_more 是一个提供了很多derive宏的第三方包。在新版本中新增了自动派生Display的功能Readmehttps://jeltef.github.io/derive_more/derive_more/display.htmlderive_morehttps://github.com/JelteF/derive_more"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-20 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「crate介绍」 很多派生宏 derive_more 0.13.0  发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该作者为了学习Rust，实现了一个CHIP-8仿真器chiprshttps://github.com/pwmarcz/chiprs\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n阿里云语雀订阅\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-20 10:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Rust学习」CHIP-8仿真器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"文章用Haskell来对比，阐述并评判了Rust中的函数式语言特性。Read Morehttps://www.fpcomplete.com/blog/2018/10/is-rust-functional"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-19 12:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」Rust是函数式语言吗？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"可用于检测未初始化内存的使用。之前在「我如何在流行的crate里发现漏洞」中介绍过的检测未初始化内存的工具，被作者用Rust重写了。之前新闻的链接 Read Morehttps://t.me/rust_daily_news/1308libdiffuzzhttps://github.com/Shnatsel/libdiffuzz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-19 12:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"libdiffuzz：面向安全的Memory Sanitizer替代品"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"通过Fressian，连通 Rust、wasm和cljsFressian是Clojure使用的数据格式， Fress是clojure.js实现的Fressian和wasm无缝转换的工具现在用Rust实现serde-fressian，通过serde_fressian::wasm 模块与fress.wasm命名空间进行交互，这样就实现了使用Rust编写的wasm模块，直接为cljs使用。Read Morehttps://pkpkpk.github.io/wasm%E2%A5%AAfressian%E2%A5%ADcljs.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-19 12:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"打通wasm <=> Fressian <=> cljs"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这篇文章介绍了 ：Read Morehttps://blog.scottlogic.com/2018/10/18/serverless-rust.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-19 12:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"基于 AWS Lambda 和 WebAssembly实现Serverless Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"可惜，没搞清楚这个小工具是干嘛的？ 有谁看明白可以告知一下。不知道是不是音频处理相关的。unit-spllitterhttps://github.com/Geemili/unit-splitter"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-19 12:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」unit-splitter"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Inkwell旨在通过安全地包装llvm-sys来帮助你编写自己的编程语言Inkwellhttps://github.com/TheDan64/inkwell"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-19 12:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」Inkwell：安全暴露LLVM的包装器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"git-anger-managementhttps://github.com/sondr3/git-anger-management"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-19 12:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」统计你git提交里的愤怒值"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"traitshttps://github.com/RustCrypto/traits\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n阿里云语雀订阅\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-19 12:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」用于描述加密原语的trait集合"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust官方核心人员withoutboats开发了一个内存安全的垃圾收集库。它只是一个研究项目，并不能实际使用。当然也可以用于学习目的，了解Rust的语言能力如何用于编码安全API中的复杂内存管理要求。从长远来看，shifgrethor很可能会成为可用的高性能的垃圾回收器。当然，该项目不太可能成为Rust项目的常用功能。也就是说，请不要理解为「Rust要加GC了」。shifgrethor的存在，只是为了要寻找一个实用的场景，用户可以使用GC来处理复杂的内存管理。比如涉及共享所有权的时候，可以使用动态的方式来管理内存。shifgrethor是一个精准的跟踪GC\n允许循环引用。不同于引用计数，这种GC不会导致内存泄漏。\n精准的GC。它可以确切地知道哪些数据是活跃的，哪些不是。\nShifgrethor允许完全自由引用\n可以解引用GC指针，可正常获得堆中的对象\nGC堆中的对象可以持有不在GC堆中对象的借用/引用，即使它们在栈上\nGC堆中的对象可以拥有栈中的对象。\n可以讲GC指针从栈上移动到堆上。\nGC是一种共享所有权，因此还需要内部可变性。shifgrethorhttps://github.com/withoutboats/shifgrethor博文 Readhttps://boats.gitlab.io/blog/post/shifgrethor-i/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-18 11:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「研究项目」「系列文章」shifgrethor：Rust实现的垃圾收集库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust虽好，但是Cargo太贪空间作者推荐了两个技巧节省空间：\n使用$HOME /.cargo\n使用semver crate\nReadhttps://llogiq.github.io/2018/10/17/space.htmlreddit还有更多讨论： Readhttps://www.reddit.com/r/rust/comments/9owc1o/more_space_for_cargo/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-18 11:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"为Cargo释放更多空间"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"rrhttps://github.com/bm371613/rr"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-18 11:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」rr：用于重构/重命名的CLI工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"可用于写智能合约特性：\n具有形式证明，可用于定理证明，Readme里还有一个证明a + b == b + a的示例\n无GC\n兼容EVM ，可以运行以太坊合约\n兼容GPU，可以编译为OpenCL/CUDA\n简单，2k行代码实现\n看上去目前还未完善，还有很多工作要做formalityhttps://github.com/MaiaVictor/formality"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-18 11:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「新语言」Rust实现的高效编程语言Formality"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该视频介绍了Rust生态系统中前100个crate文字总结：http://thume.ca/crates/Readhttps://watch.cloudflarestream.com/6cc794b568e4b4b19153355e247ff6dd"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-18 11:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「视频」Bay Rust Meetup上排名前100的crate介绍"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"刚在Ruby Summit China大会上讲完《Ruby的好朋友-Rust》，今天就看到了这个是Diesel作者用Helix来帮助提升ActiveRecord的属性映射性能 ​​​​Helix是Cargo作者带头实现的方便用Rust扩展Ruby的库rails/rails_fast_attributeshttps://github.com/rails/rails_fast_attributes"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-18 11:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「实验项目」rails/rails_fast_attributes： 使用Rust提升Rails性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"官方核心开发人员withoutboats开发了新的crate，pin-cell，类似于RefCell，但PinCell是针对pinned可变引用的内部可变类型。为什么PinCell很有用？从一个object到此object内部包含object的操作叫做「projection」，比如从结构体到其包含的字段，从Vec到其中的元素。Rust中可以按值、按引用、按可变引用来进行projection。讲pinned引用转换为某些类型的操作叫做「pin projection」，当前讲pinned引入到RefCell是不安全的，所以必须用PinCell来安全处理「projection」。Readhttps://boats.gitlab.io/blog/post/pin-cell/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-18 11:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」新包 pin-cell"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust SGX SDK由百度X-Lab维护，是为英特尔SGX enclaves开发安全可信计算应用程序的便捷框架。在此版本中，添加了对最新英特尔SGX SDK 2.3.1的支持，并且（世界上首次）启用了基于SGX远程证明的内存安全Enclave-Enclave / Untrusted-to-Enclave TLS通信。Readhttps://medium.com/baiduxlab/rust-sgx-sdk-v1-0-4-released-9c7d9056a888"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-18 11:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」Rust SGX SDK v1.0.4发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本文作者模仿阿西莫夫机器人三定律自创的叫信息学三定律（Three Laws of Informatics）（感觉叫编程三定律好多了）\n程序必须正确（Programs must be correct.）\n程序必须可维护，但不能违反第一条定律（Programs must be maintainable, except where it would conflict with the First Law.）\n程序必须高效，但不能违反前两条定律（Programs must be efficient, except where it would conflict with the First or Second Law.）\n（好像有点道理）本文很长，作者比较了众多语言，从编程语言发展历史，阐述了编程三定律背后的意义。从这个角度来看，Rust应该是目前唯一遵循此三定律的语言。Readhttps://medium.com/@schemouil/rust-and-the-three-laws-of-informatics-4324062b322b"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-18 11:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust与编程三定律"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Readhttps://falseidolfactory.com/2018/10/09/gfx-hal-part-2-vertex-buffers.html\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n阿里云语雀订阅\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-18 11:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「系列文章」Gfx-hal指南Part 2：顶点缓冲区（Vertex buffers）"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该文章介绍了如何通过编写FFI来使用Dynamsoft条形码阅读器，使用了bindgen库。rust-barcodehttps://github.com/yushulx/rust-barcodeReadhttps://medium.com/@yushulx/rust-programming-with-dynamsoft-barcode-reader-3d1e83004bba"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-17 12:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」Rust中调用Dynamsoft 条形码阅读器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Readhttps://dmerej.info/blog/post/ruplacer/ruplacerhttps://github.com/SuperTanker/ruplacer"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-17 12:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」ruplacer：查找并替换源文件中的文本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"envy是基于serde实现的环境配置工具。它通过序列化/反序列化的手段，可以将外部环境的参数转为Rust中的类型。看上去非常方便使用Readhttps://medium.com/@softprops/configuration-envy-a09584386705envyhttps://github.com/softprops/envy"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-17 12:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」envy： 新的配置工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Overview:\n总仓库数96M+\n总PR数 200M+\nM是million顶级开源项目前三位：\nVSCode\nreact-native\ntensorflow\n增长最快的开源项目：\nazure-docs\npytorch\ngodot\n最酷的新项目：\ndopamine\nDetectron\ncharts\n开源贡献最多的组织：\n微软\nGoogle\nRedHat\n顶级topic tag：\nreact\nandroid\nnodejs\n增长最快的topic：\nhacktoberfest\npythorch\nmachine\ndapp\n语言排名：\njavascript\njava\npython\n增长最快的语言：\nKotlin\nHCL\nTypeScript\nPowerShell\nRust\nReadhttps://octoverse.github.com/projects"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-17 12:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」Rust成为GitHub上增长最快的第五种编程语言"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"rav1ehttps://github.com/xiph/rav1e如果想参与Hacktoberfest 2018可以看这里https://github.com/xiph/rav1e/projects/6"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-17 12:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rav1e是用Rust编写的新AV1解码器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Readhttps://blog.cloudflare.com/cloudflare-workers-as-a-serverless-rust-platform/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-17 12:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"通过WebAssembly在Cloudless上玩Serverless Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"将继续开放一周，大家去填一下Readhttps://docs.google.com/forms/d/e/1FAIpQLSf9KCUs-8G87pHB08lM8-iXcDSY_VttOI0PvkKseHaZseCGGA/viewform"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-17 12:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"再推一下官方的网络服务调查问卷"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该文由aaron编写，描述了Tide中路由和提取的设计，结合了Rocket、Actix和Gotham等框架的创意。路由：从HTTP请求映射到endpoint，即，用于处理请求的一段代码。提取： endpoint如何在HTTP请求中提取数据。这文章只是一个草图。通过一个simple app来展示这种设计：上面代码代替App的复杂的后端，可以看作是这个简单app的内存数据库层接下来构建一个简单Web API：具体的endpoint实现：该函数签名等价于：其中每个参数都实现Extractor trait。Extractor trait中说明了如何从请求中提取数据。对于new_message，现在使用两个提取器：一个用于获取应用程序状态（数据库）的句柄，另一个用于提取主体（作为json编码的消息）。在函数体内，可以直接使用参数。提取器包装器类型实现了Deref和DerefMut。在需要所有权时可以使用.0来提取内部对象：最后将返回插入消息的标识符，Display(u64) 。Display类型是一个装饰器，用于将给定值序列化为vanilla HTTP 200，并通过Display trait来生成格式化的http body。更多示例看原文。设计目标：\n清晰地了解API和代码如何映射，将通过对路由和提取的分离和限制路由表达能力来做到这一点。\n将提取和respond序列更加符合人体工程学。通过利用trait来实现这一点。\n避免在核心中使用宏和代码生成。\n为中间件和配置提供一个干净的机制，让API非常适合可扩展和自定义\n路由：\n通过「table of contents」分离路由，可以方便查看整个应用程序的结构\n路由没有「fallback」机制，不能有两个相同的路由。\n仅通过URL和HTTP方法选择endpoint\n路由的语法：路由只允许两条路由重叠，其中一条要比另一条更具体。路由和资源是相匹配的：（ 有种Restful的风格）其中AppData是路由核心类型之一，核心类型包括：路由终止于Endpoints对于框架的使用者来说endpoint，是任意一个异步函数，其中每个参数都实现了Extractor，返回类型实现IntoResponse。这点和Rocket框架相似，但没有使用宏来实现。提取器 Extraction这更像actix-web，以下所有类型都实现了Extractor：最终endpoint必须返回能转换为Response的数据：下一篇文章将阐述中间件和配置API的设计Readhttps://rust-lang-nursery.github.io/wg-net/2018/10/16/tide-routing.html\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n阿里云语雀订阅\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-17 12:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」Tide中的路由和提取：首个草图"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"今天一天遇到两起评论，一条是带着阴阳怪气评论每周精选，一条是直接说我「标题党」，这让我有点不舒服。当然，我愿意相信对方也许并无恶意，只是用词不当。不过我也觉得有必要再次说明几点：特此说明"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-16 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「声明」"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"针对crates.io上面恶意发布crate的事情，官方将要处理了。原文https://internals.rust-lang.org/t/crates-io-incident-2018-10-15/8568"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-16 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"官方对crates.io 事件做出了回应"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"基于Rocket实现pi-hole可以阻止超过100,000个广告服务域官网https://pi-hole.net/原文https://pi-hole.net/2018/10/15/announcing-our-restful-api-contributions-welcome/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-16 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"广告黑洞Pi-hole 开源了Rust实现的Restful API"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\n统计git commit中的「咒骂」词语: git-anger-management\nRust语法糖集合，该库提供了作者编写的一些语法扩展，方便使用的宏: sugar-rs\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-16 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Rust练手小项目」"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"致力于改善医疗软件，拯救医生。 技术栈：Rust/node/react也包括特定领域机器学习和细粒度的应用安全挑战原文https://www.reddit.com/r/rust/comments/9ohzyd/jobs_commure_healthcare_software_startup_hiring/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-16 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Job」医疗初创项目招聘Rust工程师 「旧金山/全职/非远程/薪酬/股权」"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"由torrents.csv文件组成，并使用了ripgrep和acitx-web原文https://www.reddit.com/r/rust/comments/9oew87/torrentscsv_a_vetted_git_repo_of_torrents/torrents.csvhttps://gitlab.com/dessalines/torrents.csv"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-16 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一个经过审查的torrents种子服务"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"DFIR，是指Detection, Forensics, and Incident Response，检测、取证和应急响应，有助于网络安全分析。graplhttps://github.com/insanitybit/grapl"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-16 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Grapl：用于DFIR的图形化分析平台"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"SpiderOak公司的博文，SpiderOak是一个云端备份工具。该公司出了一个产品叫 Semaphor，它是可协作的加密群组IM软件。起因是因为SpiderOak团队需要一个安全的群组消息传递和文件共享解决方案，而没有电子邮件或现成协作工具带来的风险。 使用私有区块链加密开发。在Semaphor中发送的每条消息，都是Markdown文档，所以渲染性能对它们来说很重要。所以他们一直在寻找加速渲染性能的方法。最终他们想到一个方案，就是将WebAssembly集成到React组件中，取代react函数，所以他们提出了react-wasm-bridge 实验组件。它将props传递给Rust WebAssembly模块，并提供构建React渲染树的接口。https://github.com/SpiderOak/react-wasm-bridgeRust是个很自然的选择，因为Rust工具链很完善，比如有wasm-bindgen这样的工具。他们对Markdown渲染器的要求是：\n安全，解析用户的输入需要安全\n快速， 呈现消息展示是Semaphor中最频繁的操作\nRust+wasm方案改进后安全性：当前他们的Markdown渲染器用的是markdown-it，它与react一起工作并不安全，因为包含有HTML字符串，对目前的解决方案并不满意。因此新的解决方案必须没有HTML字符串，而是直接创建元素。因此通过Rust来构建React 元素树，并且wasm环境还是一个天然的沙箱，对于攻击者来说并没有那么有用。https://github.com/markdown-it/markdown-it性能：刚开始的实现方案性能并没有多少提升，后来针对它们的产品场景，将React中循环渲染构建dom的逻辑，转移到了Rust中，从而提升了性能。因为对于它们的产品来说，只需要渲染一次即可，im中的消息是不可变的，所以不需要重新渲染。最终的测试结果：react-markdown-wasmhttps://github.com/SpiderOak/react-markdown-wasm原文https://engineering.spideroak.com/2018/08/29/using-webassembly-to-speed-up-message-rendering/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n阿里云语雀订阅\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-16 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用WebAssembly加速Markdown渲染"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"开发团队：\n组建核心团队，负责整体管理和方向。\n引入新的贡献者团队，这些团队专注于引擎的特定领域，并授权写入权限。\n引入活跃策略。如果团队中有人在6个月内处于非活跃状态，将会被自动剔除团队。\n现在有四名活跃的成员。\n引擎核心：\n基于UDP协议的net-dev正在取得进展，它会独立于引擎之外，但会被用于引擎中的高级API。这意外着你可以独立使用net-dev库。\n3D渲染器正在完全重写，为了支持现代的渲染技术（Vulkan/Metal/DirectX12后端、VR等），正在招募相关经验的贡献者\n正在设计和原型化支持高级部署体系结构的新的资源管道，有助于集成专业级的工作流到引擎中。（使用构建时和部署时配置来节省运行时的计算负担），并减少开发人员和艺术家的资源管理负担。希望通过引擎实现高度可扩展的开发流程，即使在大型商业游戏上也是如此。\n实验性的Amethyst editor 发布，用于创建游戏原型\n下一步将推出0.9版本，该版本将助力于2D游戏开发人员\n原文https://www.amethyst.rs/blog/dev-news-10-2018/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-15 13:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Amethyst游戏引擎的最新进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者通过实现一个SUBLEQ解释器来测试const fn最近稳定的最小化子集mini-const-fn的可能性。SUBLEQ是一种单指令集计算机，由其唯一指令SUbtract和Branch（如果小于或等于0的分支）组成。指令 subleq a, b, c 将会执行 mem[b] = mem[b] - mem[a]; if mem[b] <= 0 { goto c; }，也就是，减并且小于等于0跳转，并且该指令是图灵完备的。其中a、b、c都是地址，mem[b] = mem[b] - mem[a];求减法，后面的分支进行控制挑战，可以实现通用的计算。wiki： https://en.wikipedia.org/wiki/One_instruction_set_computer当前Rust稳定的const-fn最小子集，包含的内容比较少，比如，包括算术运算符，结构/元组/数组创建和访问。 不允许任何种类的控制流构造，如if，match，while，for或loop。在实现过程中得到如下事实：\nconst fn中仅仅允许使用生命周期和Sized作为泛型限定，比如还不能指定T: Copy\n函数指针在const fn中是 unstable状态\nconst fn目前还不支持let绑定和重新分配可变变量\n循环可以通过递归调用const fn来实现\nconst fn count(i: i32) -> i32 {count(i+1)}比如实现无限的计数循环，但不能指定分支条件。最终的解决方案是，手动展开循环。结论：const fn的最小子集是否图灵完备？答案是：\n是的。因为可以用它实现图灵完备的SUBLEQ\n不是。 只能执行有限数量的迭代。\n也许。找到一种方式可以从循环或递归中提前中止（即使找到了中止的方法，仍然只有96次迭代的最大值，因为const fn求值器不允许超过96个栈帧）\n一个有趣的事实subleq函数可以看做一个不动点迭代器（Fixed Point iterator）。原文https://www.reddit.com/r/rust/comments/9o6vzo/constfn_compiletime_subleq_interpreter/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-15 13:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"const fn编译时SUBLEQ解释器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"副标题：A Practical Guide To Rust 卷1官网https://thedarkula.gitlab.io/code-artistry/book/PDFhttps://thedarkula.gitlab.io/code-artistry/book/VolumeI.pdf"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-15 13:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"免费书籍推荐：CODE ARTISTRY BOOK"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是「我想要一个2D图形Crate 」文章相关的后续讨论贴，该文作者总结了此次讨论中的几个具体的主题。原文https://nical.github.io/posts/rust-2d-graphics-01.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-15 13:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"继续讨论Rust中的2D图形"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"kubernetes-rusthttps://github.com/ynqa/kubernetes-rust"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-15 13:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"K8s的Rust客户端"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"wellehttps://github.com/rylev/welle\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n阿里云语雀订阅\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-15 13:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Welle： ApacheBench的Rust实现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该文作者说，从理论的角度，其实很难理解Go语言现在的成功。Go语言设计的非常糟糕。一旦深入了解Go，你会发现，它应该是构建于上世纪80年代的语言，而非21世纪。然而，任何一个使用Go的人，都会告诉你，这是一门很好的语言。作者说，如果他被困在只有三门语言的小岛上面，他希望Go是其中之一。Go为什么好？Go有几个重要的功能掩盖了它的不好。\ngo get工具轻松下载包\n静态编译使得各种环境下移植代码比较容易\n本机异步IO机制可以方便写出高性能网络代码\n内置通道在go程之间轻松实现相对安全的数据\n标准库和生态系统包含开发人员的可能需要的大多数库\n说白了Go是专门为开源库、大规模并行和网络时代专门设计的语言。反观Rust，正好是在Go完全失败的场景中拿下了高地\nCargo胜过了go get\nRust马上也会有高性能的异步并发\n而且还支持天生线程安全的多线程编程，基于线程的通道\n标准库和Go一样丰富\nGo和Rust之间的性能差距会越来越大 （当然是Rust快）\nGo效应\n一旦async/await合并到Rust中，我们可以称Rust是超越Go的优秀语言。Rust支持的并发方式非常全，还默认线程安全\nRust和Rust的编程概念越来越多地进入到现实世界，那么新手进入的壁垒会越来越低\nRust中的生命周期已经过了关键的时候。\nGo受欢迎的程度飙升的原因也会适用于Rust，Rust的甜蜜点可能马上要到来了\n等异步开发稳定之后，Rust社区会涌入大量的网络服务开发者，洪水将至。原文https://medium.com/@george3d6/the-success-of-go-heralds-that-of-rust-73cb2e4c0500"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-13 23:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Go的成功预示着Rust的成功"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://blog.rust-lang.org/2018/10/12/Rust-1.29.2.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-13 23:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 1.29.2 稳定版发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"ndarray-csv，一个用于在CSV文件和2D数组之间进行转换的Rust crate。该文记录了作者实现该库时候的一些思考原文https://paulkernfeld.com/2018/10/13/ndarray-csv-reflections.html\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n阿里云语雀订阅\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-13 23:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"关于实现ndarray-csv 的思考"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该文作者说，当前Rust的生态中有一个明显的缺失：跨平台的2D图形抽象库该作者对比梳理了生态系统中现有的图形库，佐证了他的说法。通过此文也可以了解一下当前Rust 图形库的现状。原文https://raphlinus.github.io/rust/graphics/2018/10/11/2d-graphics.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-12 18:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"我想要一个2D图形crate"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://blog.travis-ci.com/2018-10-11-windows-early-release?utm_source=reddit&utm_medium=web&utm_campaign=windows_early_release"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-12 18:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Travis CI现在支持Windows下Rust的构建环境"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"无需访问硬件即可测试，Rust牛逼。C++做嵌入式有这方面库吗？恕我孤陋寡闻embedded-hal-mockhttps://github.com/dbrgn/embedded-hal-mock"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-12 18:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「嵌入式Rust」embedded-hal的mock测试库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这个组织更新代码挺积极原文https://www.reddit.com/r/rust/comments/9nazzz/rustcrypto_announcing_digest_v08/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-12 18:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RustCrypto 发布 digest v0.8"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该库产生一个反序列化漏洞，可能导致栈溢出。已在新发布的版本中修复。原文https://users.rust-lang.org/t/rustsec-advisory-for-trust-dns-proto-affecting-server-resolver-and-client/21179"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-12 18:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"trust-dns-proto Bug 通告"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者分享了他修复一个Clippy Crash问题的经验感兴趣可以看看，对于了解Clippy的机制也有一定帮助原文https://phansch.net/2018/10/10/fixing-a-clippy-crash/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-12 18:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"修复Clippy Crash的问题"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者在玩某大型视频游戏的时候，想到要了解其中市场交易的数据，所以通过actix-lua来处理一些实时数据。actix-lua是一个库，使用Lua编程语言为actix提供安全的脚本环境。该文简单介绍了actix-lua的优势。最后，作者说：用actix-lua比玩游戏还过瘾，以后不玩游戏了。原文https://devpoga.org/post/parsing-streaming-data-actix-lua/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-12 18:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用Rust和Lua分析流数据"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者罗列了Cbindgen当前的几个问题，并探讨相关的解决办法，感兴趣可以看看原文http://dreamingofbits.com/post/future-directions-for-cbindgen-rust-ffi/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-12 18:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cbindgen (rust-ffi)的未来方向"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://www.reddit.com/r/rust/comments/9n6xx8/fdfind_is_available_in_debian_unstable/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n阿里云语雀订阅\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-12 18:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"debian unstable上可以使用fd-find 了"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"steveklabnik 写了这篇博文，主要是因为看到了类似这样的言论：手动内存管理比GC要做更多的工作，当然这样是为了提高性能或使用更多底层资源的权衡。所以Rust在什么时候或在什么场景使用要取决于你自己。steveklabnik认为这是对Rust 无GC的一种误解。GC算法目前比较常用的有分代回收，比如Ruby里就用到分代垃圾回收技术。但是还有一种与GC相关的概念，那就是「逃逸分析（escape analysis）」，这是一种优化技术。简而言之，就是在函数内定义的对象，如果从不在函数外使用，则将其存在栈上，否则，如果函数外有使用，就将其放到堆上。比如Java，比如Golang，都使用了逃逸分析。Go在一定程度消除了堆和栈的区别，因为Go在编译的时候进行逃逸分析，来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上。这也是Go没有采用分代GC的原因，因为逃逸分析的存在，分代GC也带不来多少优势。你可以把逃逸分析看成是分代GC的更强版本，任何放到堆上的对象，可以算是老一代对象。目前，普通有个观点就是GC是运行时。既然人们把语言一分为二，动态和静态，那么为什么不能把GC也一分为二，分成动态和静态呢？ 在这方面C++做了很多的工作。Rust语言站在C++的基础上，继续开创静态GC这条路。在某些方面，你可以把Rust借用检查看作是一种更强大的逃逸分析。就像是TypeScript里存在的渐进式类型（gradual typing）那样（TypeScript允许你同时使用动态类型和静态类型，有助于让学习者逐渐适应静态类型），你也可以把Rust里提供的这些内存自动化管理的功能看作是一种渐进式GC。所以，Rust的GC，实际上是一种静态式GC，不要再以传统的观念来看待GC，也不要以传统的系统级语言看待Rust，以为Rust也是纯手动管理内存，实际上Rust的自动内存管理是非常先进的。注： 以上并非翻译，只是对文章表达意思的总结，详细请看原文原文https://words.steveklabnik.com/borrow-checking-escape-analysis-and-the-generational-hypothesis"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-11 11:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 有静态的Garbage Collector"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"并且开源，可以作为一个actix-web框架全栈学习案例bible.rshttps://bible.rs/GitHub Bible.rshttps://github.com/DSpeckhals/bible.rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-11 11:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Bible.rs | 使用Actix Web和Diesel编写的在线《圣经》网站"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://gankro.github.io/blah/rust-layouts-and-abis/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-11 11:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"关于Rust中类型布局和ABI的笔记"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"德国的工业4.0据说很猛，从这meetup主题可见一斑。原文https://slowtec.de/posts/2018-10-09-rust-in-der-industrie.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-11 11:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"德国Rust线下meetup主题：在工业和自动化中使用Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Cubic Curves是贝赛尔曲线(Bézier Curve)的基础，一个三位空间曲线通过转换投影到2D平面的曲线。Andrea Pessino是曾开发 《战神：奥林匹斯之链》 和《 战神：斯巴达之魂》 的业界大厂 Ready at Dawn Studios 的CTO。视频https://www.youtube.com/watch?v=rXjkXqI2Yyc\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-11 11:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「油管」Andrea Pessino 展示Rust实现的三次参数曲线(Cubic Curves)"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"steveklabnik 写了这篇博文，主要是因为看到了类似这样的言论：手动内存管理比GC要做更多的工作，当然这样是为了提高性能或使用更多底层资源的权衡。所以Rust在什么时候或在什么场景使用要取决于你自己。steveklabnik认为这是对Rust 无GC的一种误解。GC算法目前比较常用的有分代回收，比如Ruby里就用到分代垃圾回收技术。但是还有一种与GC相关的概念，那就是「逃逸分析（escape analysis）」，这是一种优化技术。简而言之，就是在函数内定义的对象，如果从不在函数外使用，则将其存在栈上，否则，如果函数外有使用，就将其放到堆上。比如Java，比如Golang，都使用了逃逸分析。Go在一定程度消除了堆和栈的区别，因为Go在编译的时候进行逃逸分析，来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上。这也是Go没有采用分代GC的原因，因为逃逸分析的存在，分代GC也带不来多少优势。你可以把逃逸分析看成是分代GC的更强版本，任何放到堆上的对象，可以算是老一代对象。目前，普通有个观点就是GC是运行时。既然人们把语言一分为二，动态和静态，那么为什么不能把GC也一分为二，分成动态和静态呢？ 在这方面C++做了很多的工作。Rust语言站在C++的基础上，继续开创静态GC这条路。在某些方面，你可以把Rust借用检查看作是一种更强大的逃逸分析。就像是TypeScript里存在的渐进式类型（gradual typing）那样（TypeScript允许你同时使用动态类型和静态类型，有助于让学习者逐渐适应静态类型），你也可以把Rust里提供的这些内存自动化管理的功能看作是一种渐进式GC。所以，Rust的GC，实际上是一种静态式GC，不要再以传统的观念来看待GC，也不要以传统的系统级语言看待Rust，以为Rust也是纯手动管理内存，实际上Rust的自动内存管理是非常先进的。注： 以上并非翻译，只是对文章表达意思的总结，详细请看原文原文https://words.steveklabnik.com/borrow-checking-escape-analysis-and-the-generational-hypothesis"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-11 11:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 有静态的Garbage Collector"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"并且开源，可以作为一个actix-web框架全栈学习案例bible.rshttps://bible.rs/GitHub Bible.rshttps://github.com/DSpeckhals/bible.rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-11 11:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Bible.rs | 使用Actix Web和Diesel编写的在线《圣经》网站"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://gankro.github.io/blah/rust-layouts-and-abis/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-11 11:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"关于Rust中类型布局和ABI的笔记"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"德国的工业4.0据说很猛，从这meetup主题可见一斑。原文https://slowtec.de/posts/2018-10-09-rust-in-der-industrie.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-11 11:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"德国Rust线下meetup主题：在工业和自动化中使用Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Cubic Curves是贝赛尔曲线(Bézier Curve)的基础，一个三位空间曲线通过转换投影到2D平面的曲线。Andrea Pessino是曾开发 《战神：奥林匹斯之链》 和《 战神：斯巴达之魂》 的业界大厂 Ready at Dawn Studios 的CTO。视频https://www.youtube.com/watch?v=rXjkXqI2Yyc\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-11 11:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「油管」Andrea Pessino 展示Rust实现的三次参数曲线(Cubic Curves)"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"cranelift是Rust实现的代码生成器https://github.com/CraneStation/cranelift原文https://www.reddit.com/r/rust/comments/9mvnrk/in_firefox_nightly_an_option_has_arrived_to_use/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-10 11:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Firefox Nightly现在可以选择使用Cranelift编译wasm"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Googe Doc问卷https://docs.google.com/forms/d/e/1FAIpQLSf9KCUs-8G87pHB08lM8-iXcDSY_VttOI0PvkKseHaZseCGGA/viewform嵌入式工作组报告 - 13简要：\nconst_fn的最小子集min_const_fn即将在Rust 1.31中稳定，允许在嵌入式环境中使用const_fn。\nrust-industrial-io crate启动开发，允许Rust使用Linux Industrial（工业） I/O子系统，意味着可以操作工业传感器和执行器（加速度传感器、陀螺仪、IMUs(惯性测量单位)、电容-数字转换器(CDCs)、压力、温度和光线传感器、磁力计传感器、电能功率计、旋变数字转换器等）\ncortex-r-rt开始开发，用于Cortex-R处理器的运行时库。\nembedded-hal  嵌入式硬件抽象框架已经支持Rust  1.30-beta。\nkeypad，平台无关的键盘驱动程序\nbluenrg和bluetooth-hci蓝牙相关的库\n更多内容 https://rust-embedded.github.io/blog/2018-10-09-newsletter-13/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-10 11:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"来参与Rust网络服务工作组的Web服务调查问卷"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该文作者在医疗设备领域工作，几乎完全是用C++。为了改变节奏，作者一直致力于学习Rust。并且在今年年初选择Rust进行嵌入式开发。作者的核心项目是让两台无线设备通过蓝牙通信，因为没有比较标准的蓝牙相关crate，所以作者自己实现了两个crate，填补了蓝牙领域crate的空白：\nbluenrg，是用于BlueNRG-MS设备的no-std Rust驱动。\nbluetooth-hci，是一个实现了蓝牙规范的框架，默认支持4.1蓝牙版本，也具有4.2和5.0的功能。\n本文介绍这两个库的用法。原文https://219design.com/bluetooth-low-energy-with-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-10 11:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"嵌入式Rust：开发蓝牙设备"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这哥们在试图把Emacs 的C 代码移植到Rust ，项目为remacs，完成度1/3。主要是移植Emacs嵌入式Lisp环境中使用C代码实现的Lisp函数。本文主要介绍了迁移过程中的一些经验，包含bindgen的使用。原文http://db48x.net/rust-remacs-2018/remacshttps://github.com/wilfred/remacs\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-10 11:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"继续Emacs的迁移工作"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"JavaScript和WebAssembly这两个语言之间函数调用是出了名的慢，但是最近这种情况已经得到了改善。在最新版本的Firefox Beta中，JS和WebAssembly之间的调用比非内联JS到JS函数调用要快。万岁！🎉在最新的在Firefox Nightly工作中，一共优化了两个方向的调用从JavaScript到WebAssembly，从WebAssembly到JavaScript，而且还优化了WebAssembly调用内置函数的性能。所有的优化都是为了减轻浏览器引擎的工作压力。这些改进一共分为两组：\n减少登记（Reducing bookkeeping），减少了调用栈帧\n切断中介（Cutting out intermediaries），函数调用采用尽可能直接的方式\n一、如何优化WebAssembly到JavaScript的调用？\n浏览器引擎需要处理的内容包含两种：字节码（解释器生成）和机器码（JIT生成），这就好比是两片独立的大陆\n引擎需要在这两片「大陆」之间穿梭，以便统筹所有需要的信息。为了组织其工作，引擎有两个文件夹来记录这些信息。（比如SpiderMonkey引擎中，这些文件夹叫做activations）\n每次切换到不同的「大陆」，引擎都会启用新的文件夹，问题是，要启动一个文件夹必须通过C++调用，这就增加了成本。\n再最初增加WebAssembly支持的时候，相当于是给引擎增加了第三块「大陆」\n所以，WebAssembly调用js的过程就多了两个阻碍： 创建了不必要的文件夹和增加了C++调用成本\n优化手段： 将JIT-JS「大陆」和WebAssembly「大陆」合并在一起。\n二、如何优化JavaScript到WebAssembly调用？\n即便在JIT编译之后，js和webassembly都使用机器码，但还存在一些问题。比如调用js动态类型。\nwasm是静态类型，不希望付出运行时开销，当js获取的参数是动态的，也就是说，它把参数放到堆内存（装箱），wasm不知道该如何处理它\n所以在传给wasm之前，引擎会将装箱的参数值取出来，存到寄存器里，要做到这一点，还是需要C++。即便不需要C++，但这个过程也是没法取消的。\n优化手段： （使用C++ stub 代码）去掉了「中介（trampoline）」，当javascript调用webassembly时，装箱的值就被取出来放到了合适的位置，等待wasm直接使用。\n三、更快的JavaScript到WebAssembly调用：单态（Monomorphic）调用单态调用是指每次都调用相同的函数。在js中，存在每次都使用完全相同类型的参数来调用该函数。如果可以编写代码以便JavaScript始终将相同的类型传递给相同的WebAssembly导出函数，那么您的调用将非常快。实际上，这些调用比许多JavaScript到JavaScript调用要快。在未来，可能会为JavaScript添加内联WebAssemly的支持。四、如何优化WebAssembly到内置函数的调用内置函数是浏览器提供的函数，如Math.random。有些内置函数是JS本身实现的，这种叫做自托管。有些是C++实现的，不同的浏览器引擎，有不同的实现，这方面并不统一。如果是自托管的内置函数，WebAssembly调用的时候就能用到前面说的优化，但是遇到C++实现的函数，则又回到了解放前。为此，专门为这样的内置函数构建了一条特殊的直达「通道」，允许在WebAssembly调用C++实现的内置函数时，使用该特殊通道，增加性能。目前只支持Math相关的内置函数，这是因为WebAssembly只支持整数和浮点数。但是对于dom处理等内置函数来说则效果不佳，因此调用相关函数的时候必须使用js，这就是wasm-bindgen所要做的。但是WebAssembly的一些实验性支持类型也会逐渐登录浏览器，一旦这些类型稳定，那么WebAssembly就可以不经过js直接调用那些内置函数了。所以当前的优化工作，在未来也会适用于其他内置函数。但是仍然有一些内置的函数需要使用js，这些函数的问题由host-bindings来解决。以上。原文https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast-%F0%9F%8E%89/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-09 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"JavaScript和WebAssembly函数调用性能提升"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本文比较了Haskell的bracket函数和RAII，并且阐述了bracket模式带来的问题（可能导致释放后还能使用的问题）和修复方式原文https://www.snoyman.com/blog/2018/10/raii-better-than-bracket-pattern"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-09 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RAII优于Haskell的bracket模式"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是一种新的流数据流模型，可用于构建长期，低延迟的应用程序，例如Web应用程序。MIT、Norwegian大学等联合出品。Noria是使用Rust实现的。https://github.com/mit-pdos/noria「论文」https://www.usenix.org/conference/osdi18/presentation/gjengset"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-09 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Noria：用于高性能Web应用程序的dynamic, partially-stateful data-flow"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者写了一个库，用来快速检查Rust标准库中数据结构的Bug。https://github.com/blt/bughunt-rust作者发现了什么bug吗？ 发现很多方法能在分配内存时发生恐慌。 Rust官方已经发了RFC 2116准备进行修复。https://github.com/rust-lang/rfcs/blob/master/text/2116-alloc-me-maybe.md原文 https://blog.troutwine.us/2018/10/08/hunting-for-bugs-in-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-09 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"寻找Rust中的Bug"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"氧化（Oxidizing），目前在Rust社区是一个流行的词。原文https://tech.blue-yonder.com/oxidizing-python-speeding-up-urlquoting-by-using-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-09 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"氧化Python： 用Rust加速10倍"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"待遇： 旧金山| 130 - 175K +股权| 基础设施和HPC | 全职/现场基于机器视觉，自动结帐，构建零售业未来。从头设计系统，可以部署到数百万零售商，已经在旧金山开设了测试商店。目前正在寻找Rust工程师。多好的工作呀！！！原文https://www.reddit.com/r/rust/comments/9ml170/job_create_high_performance_rust_systems/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-09 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Job」创建高性能的Rust系统「非远程」"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者基于Global Allocator尝试构建自己的内存分配器，然而他在这个过程挖掘了一个工具：Heaptrack。可以用它来高亮内存的使用情况来帮助理解。Heaptrack是linux下的一个工具（Mac和win可用），可以跟踪内存使用情况，并给出可视化报告。本文就是介绍如何使用Heaptrack跟踪Rust代码中内存分配情况。最终他得出结论：永远不要写自己的内存分配器，尽可能地使用heaptrack这种工具来优化代码吧。原文https://speice.io/2018/10/case-study-optimization.htmlheaptrackhttps://github.com/KDE/heaptrack"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-09 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Heaptrack案例研究"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"GStreamer是Linux世界中多媒体编程的首选框架，尤其用于嵌入式，但是传统都是C/C++来编写GStreamer的应用程序和插件。不幸的是，这种效率是以安全为代价的。即便是最熟练的C/C++开发人员也会在内存管理方面犯错，结果可能是灾难性的。线程安全是多媒体解决方案的核心，但是用C/C++极难实现。在本次视频演讲中，Zeeshan介绍了使用GStreamer的Rust绑定如何安全、简单地编写多媒体应用程序。原文https://media.ccc.de/v/ASG2018-172-fearless_multimedia_programming\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-09 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「视频」无恐惧多媒体编程"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者受Rust 宏2.0的启发，探索这种声明性语法在运行时搜索模式并替换为实际代码调用的可能性。原文http://blog.lambdaverse.org/comacro/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-08 11:14"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"声明性Rust静态分析"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"此次发布是一个较大的更新原文https://dev.to/tomhoule/announcing-graphql-client-05-56cm"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-08 11:14"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"graphql-client 0.5发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"虽然是旧文，但是内容还是值得学习原文https://deterministic.space/elegant-apis-in-rust.html#more-method-name-conventions\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-08 11:14"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"翻到一篇老文：使用Rust构建漂亮API接口的指南"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"与play不同的是，它还可以选择往期版本的Rust网址https://www.godbolt.org/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-06 11:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Compiler Explorer  ： 一个类似于play的Rust在线执行环境"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"曾经GSoC 2017的一个项目Vulkan-CPU，之前是C++实现，停滞一年之后，作者宣布用Rust重写它，新项目名字是Kazan。kazanhttps://github.com/kazan-3d/kazan"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-06 11:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Kazan：使用Rust重写"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"getverhttps://github.com/phynalle/getver"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-06 11:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"getver：命令行获取指定crate的最新版本号"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://www.reddit.com/r/rust/comments/9ljmbj/golangs_lstat_faster_than_rust_fsmetadata/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-06 11:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"关于Golang lstat() 比Rust的 fs::metadata()快的讨论"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"来看看这位作者怎么说的？简要：\n默认参数虽然方便，但是没有「显式」的好处，在开发者协作方面不太好\nRust使用Default类型和「..」语法配合，语义上更加明确，可读性大大提高\n原文https://medium.com/@softprops/default-values-copy-that-ae43831781f3"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-06 11:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"为什么Rust不支持默认参数？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://medium.com/@jacob.lerche/writing-rust-nifs-for-your-elixir-code-with-the-rustler-package-d884a7c0dbe3"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-06 11:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用Rustler为Elixir代码编写nif"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://medium.com/@hdevalence/merlin-flexible-composable-transcripts-for-zero-knowledge-proofs-28d9fda22d9amerlinhttps://github.com/dalek-cryptography/merlin\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-06 11:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Merlin：基于STROBE的可组合零知识证明消息记录（transcript）"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者亲自做了基准测试：\nnom:\n-  canada.json: 60,734,229 ns/iter (+/- 17,775,618)\n-  data.json: 23,937 ns/iter (+/- 9,992)\npest:\n\ncanada.json: 35,041,472 ns/iter (+/- 5,454,302)\ndata.json: 14,665 ns/iter (+/- 2,041)\n\n\n\ncanada.json: 35,041,472 ns/iter (+/- 5,454,302)\ndata.json: 14,665 ns/iter (+/- 2,041)\n以上是没有将json转换为Rust的类型，当然Pest比nom快。但是如果用nom4然而不转换为Rust类型会是什么结果呢？\npest:\n\ncanada.json: 35,041,472 ns/iter (+/- 5,454,302)\ndata.json: 14,665 ns/iter (+/- 2,041)\n\n\nnom_spans (returning slices instead of converting to Rust types):\n\ncanada.json: 20,623,381 ns/iter (+/- 1,952,297)\ndata.json: 10,757 ns/iter (+/- 1,462)\n\n\n\ncanada.json: 35,041,472 ns/iter (+/- 5,454,302)\ndata.json: 14,665 ns/iter (+/- 2,041)\n\ncanada.json: 20,623,381 ns/iter (+/- 1,952,297)\ndata.json: 10,757 ns/iter (+/- 1,462)\n这个才是公平的测试，因为Pest并不会转换为Rust类型。显然这种情况下nom更快。（火药味十足啊）原文https://unhandledexpression.com/general/2018/10/04/no-pest-is-not-faster-than-nom.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-05 11:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"nom作者：不，Pest没有nom快"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者写了简单的代码对最近截至2018年10月3日有超过10万次下载的crate进行统计，得出以下结果：看来Alex是Rust社区的顶梁柱啊原文https://words.steveklabnik.com/who-authors-the-most-popular-crates-on-crates-io"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-05 11:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"crates.io上流行的crate的作者都是谁 ？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"特点：\n100%静态，避免任何运行时开销\n以宏声明来构建状态机\n纯状态、事件和转换\n作者学习Rust的一个项目，值得学习。比如里面使用了最新的syn 0.15，API有所改变，正好看看最新的用法smhttps://github.com/rusty-rockets/sm"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-05 11:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"SM:  静态状态机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"前两天刚介绍过，是一个易于使用的Linux本地存储管理工具。在他们决定放弃Btrfs支持之后，Stratis已经开发了两年，用于提供下一代Linux存储。 Stratis提供ZFS和Btrfs之类的功能和许多其他新功能，而上周标志着它的第一个稳定版本。很快就可以向Fedora用户提供Stratis 1.0用于评估，并且它很快就会出现在其他发行版中。 Stratis组件依赖于Linux 4.14 +，Python 3和Rust 1.25+。 但值得一提的是，Stratis D-Bus API还不稳定。stratisdhttps://github.com/stratis-storage/stratisd原文https://groveronline.com/2018/10/stratis-1-0-released/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-05 11:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Red Hat 静态存储项目 Stratis 1.0 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本文介绍了C/C++/Rust下如何在面向WebAssembly体系下进行动态内存分配，并分别比较了它们的工具链。结论是：Rust的编译器和动态内存分配器wee_alloc的组合是明显的赢家，其生成的WebAssmebly代码非常精简，可以用在任何WebAssembly环境中。主要是因为Rust工具链没有其他的依赖。像Clang这种工具链依赖于emscripten，就导致无法在通用的WebAssembly环境中使用。原文https://frehberg.wordpress.com/webassembly-and-dynamic-memory/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-05 11:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"WebAssembly和动态内存"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者在两个项目中使用它，读取140GB左右的文件easy_readerhttps://github.com/ps1dr3x/easy_reader"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-05 11:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"EasyReader：一个专用于读取大型文件的库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Tokio作者准备重整文档，现在需要社区帮助原文https://tokio.rs/blog/2018-10-doc-blitz/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-05 11:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Tokio文档计划"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://www.cattlegrid.info/the-undergarden-text-adventure-rust-2-objects"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-05 11:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust文字冒险游戏  2"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Jack： 实际上Parity里并没有那么多unsafe代码。事实上，在我加入之前，到处都是unsafe，你知道，我们必须要压榨出最大的性能。因为C++开发者喜欢这种「安慰剂」般的优化。Sean： “我不需要对它进行运行时检查”Jack: 没错。Sean:  “我不想恐慌”Jack:  恐慌或缓慢，你都不想要。我的意思是，未定义行为是非常不可琢磨。但是在某一个同事加入之后，他开始删除这些unsafe代码，从那时起，我们就开始越来越多地删除unsafe代码。现在就变得安全多了。当然也有一些unsafe hack，比如底层有些内容是需要性能，实际上现在无法对其优化。比如我们有个hash算法，必须将两个数组连接在一起。我们将两个数组放到一个结构里，然后将其替换为C，然后在C中将两个数组连接，再转回Rust的一个数组。因为这样，明显更快。但这样的代码也没有太多。Anatoly： 没错，但是，谁能在一天内完成所有代码呢？（ 表达罗马并非一天建成的意思）Jack： 我希望是一天。Anatoly： 我的下一个问题是和安全相关的。比如，C和Haskell。我发现现代类型系统实际上也没有增加太多的东西，就像是多了很多简单标签的C。在使用这些高级抽象类型的时候，怎么样证明这些代码的意义？比如这些类型的抽象目的是为了给你提供一些保证和确定性，你从哪里看到这些效果？Greg： 我认为它们会更加方便你编写代码。比如刚开始需求简单的时候，并不知道要用到哪些类型，那么就可以编写一个泛型的数组，这可以帮助我们跳出困境。但是，随着需求越来越多，我只需要简单的包装类型，就可以改造泛型数组。再加上类型检查，我认为这是一个有用的保障。Jack：我认为你这是一种类型驱动开发的做法。Greg：是的。「待续」\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-05 11:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Solana 、Zcash 和Parity 三家会面讨论为什么Rust适合区块链开发 」连载3"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该贴作者买了一本《Hands-on Concurrency with Rust》，对其很不满，发了一个吐槽贴，详细看内容和讨论吧。原文https://www.reddit.com/r/rust/comments/9l2rmk/meta_beware_of_books_published_by_packt_low/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-04 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「吐槽」小心Packt发布的书籍：低质量的内容，非常明显未经审查"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"提升了性能，引入了更多的wasmPest是一个Rust实现的通用解析器，类似于正则表达式，但是它提供了解析复杂语言的增强表达。性能测试以解析json为例，要好过nom官网https://pest.rs/pesthttps://github.com/pest-parser/pest"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-04 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Pest 解析器 2.0发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"此文是作者对Webapp.rs项目过去四个月的总结，结论就是，该项目的状态可以为想使用Rust进行全栈Web开发的用户提供了一个良好的开端。原文https://medium.com/@saschagrunert/lessons-learned-on-writing-web-applications-completely-in-rust-2080d0990287webapp.rshttps://github.com/saschagrunert/webapp.rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-04 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"完全使用Rust编写Web应用的经验和教训"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Ruukh是一个前端Web框架，受到VueJS和ReactJS的启发。看起来不错原文https://sharadchand.com/2018/10/03/ruukh-framework.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-04 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"介绍Ruukh框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"twiggy是.wasm二进制文件的代码大小分析器cargo install -f twiggy原文https://www.reddit.com/r/rust/comments/9l67p0/announcing_twiggy_030/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-04 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Twiggy 0.3发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"号称 Constant Time Encoding，是一种timing-safe的方式，可以抵御某种相关攻击（ timing attacks）。原文https://www.reddit.com/r/rust/comments/9l3plw/ann_subtleencoding_01_constanttimeish_base64_and/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-04 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"subtle-encoding ：用于 Base64 和 hexadecimal 解码和编码的库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"旨在处理具有数十亿个术语的表达式，占用数TB的磁盘空间。它是Form的精神继承者，它广泛用于理论粒子物理学。 reFORM目前处于早期开发阶段，但很多功能已经存在。FORM是一个符号操纵系统(C/C++实现)。 它从文件中读取符号表达式，并对它们执行符号/代数转换。 答案以文本数学表示形式返回。 作为其标志性功能，FORM中考虑的表达式的大小仅受可用磁盘空间的限制，而不受可用RAM的限制。FORM的原作者是荷兰亚原子物理研究所NIKHEF的Jos Vermaseren。不错，Rust可以应用于理论物理研究了原文https://www.reddit.com/r/rust/comments/9kr80h/announcing_reform_a_symbolic_manipulation_toolkit/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-04 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"reFORM：一个符号操纵工具包"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Jack： 我基本上也认为那是我喜欢的Rust概念。因为即便是Haskell，它具有惊人的抽象能力，也不得不分离安全和不安全的东西。在函数名称上加unsafe，比如“unsafe_perform_io”，这有点像是「在我的脑子里创造了一个鼻子恶魔（Nasal demons，未定义行为的幽默同义词）」。「鼻子恶魔一词的来源考证：在Usenet组comp.std.c上识别C编译器遇到未定义构造时的任何意外行为的简写。 在1992年初关于该组的讨论中，经常评论“当编译器遇到给定的未定义构造时，让恶魔飞出你的鼻子是合法的”（暗示编译器可以选择任意奇怪的方式来 在不违反ANSI C标准的情况下解释代码。 其他人后来提到了“鼻子恶魔”，很快就成立了。 」Greg：确实如此，那是Prelude中的函数，所以你几乎无法避免，甚至是一个一无所知的Haskell新手。如果你尝试读取文件，那么意味着你就会做一个不安全的操作，几年之后肯定会咬你一口。Anatoly：是的Greg和我一起做过一个Haskell项目。Jack：我认为，Haskell有很多好的东西，但也存在很多搬起石头砸自己的脚的东西。现在有很多语言都在尝试寻找更好的方法来避免自讨苦吃。Rust就是其中之一。不要乱用其他语言，不要把它变成一个崇拜的东西。只有Rust，Rust是唯一的好语言。 （没看原视频，估计这段是在调侃，其他人也在附和：yeah 、yeah…）Anatoly: 你们写过一篇博客叫「why Rust」？Sean & Jack： 是的，没错。Greg：是的。Jack： 是Greg写的？我还以为是Dmitri。Anatoly： 所以，现在Rust改进了很多编程人体工程学，你认为它会做的更好吗？你现在还有机会嘲讽Rust。Jack： 有一点得提。比如，你没有理由说Rust不支持在栈上做事，但是当前，你还必须得在堆上进行操作。比如我们做WebAssembly相关工作的时候，就必须在运行时处理一些东西。比如我有很多静态字符串，想要在栈上将它们串成一个长的静态字符串，这就无法做到，只能在堆上。因为，Rust应该能做到支持将静态的字符串在编译期创建关联组合为长的字符串，而不是在运行时。所以现在必须有一个分配器，最好在编译期就执行该操作。并且就安全性而言，Rust没有任何理由做不到这一点。当然，另一个问题是不能在trait中定义一个可以返回trait的函数（「trait in trait」），这就为Rust损失了一个利好。Anatoly： 就像Haskell里的存在类型？Jack：是的。Greg：trait里的存在类型？意味着trait能实现可以返回不同类型的方法？（此处口齿不清，记录的也咋地，大概猜测说的是Rust不能在trait中定义一个可以返回trait的函数）Jack： 心智模型大概是，你应该有一个关联类型，并且该关联类型不同的实现。Greg：所以你不得不指定一个trait？Jack：没错。所以有两种不同的设计。一种，你明确的关联类型，然后就输入 『等于某个trait』（type = trait），另一种就是隐式的，自动为你创建一个相关类型。但无论哪种方式，都是属于心智模型。你会经常碰到这种情况，Rust中的大部分方法都是trait方法。Sean：是的。Jack：所以，你不能返回一个「trait in trait」，这实际上是一个非常普遍的问题。如果你想在栈上做一些事情就会碰到这个问题。Sean：我同意这两点。就语言特性而言，我们真的碰到了从没遇到过的波折。碰巧这两个特性也正在开发中。Grag：是的，Amen。Rust开发者一定会爱你们，「他在抱怨一个月前就发布的东西」。 （大笑）（省略 一段和听众探讨的环节）Sean：我有点想知道，Parity有多少Unsafe代码？「待续」\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-04 12:52"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Solana 、Zcash 和Parity 三家会面讨论为什么Rust适合区块链开发 」连载2"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://medium.com/solana-labs/solana-at-portland-dev-meetup-72e4dc7ad32c「Solana 、Zcash 和Parity 三家会面讨论为什么Rust适合区块链开发 」连载1\nSolana是一种高性能区块链\nZcash是一种加密货币\nParity是一个核心的区块链基础公司，以太坊相关\n内容里涉及的人物我不清楚他们具体谁是对应哪家公司，但可能通过聊天内容猜的出来。正文：Anatoly:   我的Rust经历实际上是来自于上一份工作，在Dropbox的时候，用Rust编写压缩相关的工作。当时，没有使用标准库的内存分配器，自己实现了一个类型安全的沙箱。非常酷。但是在开始这个项目之前，Rust并没有吸引我。我用了两周时间使用C语言，但是当用到一些外部库的时候，还得写makefile，手动下载这些库，比较麻烦。所以，我决定尝试一下Rust。就在那一刻，“Holy shit, this is amazing.”。我才觉醒到，这是一个和C语言一样快的语言，并且还给了我Haskell般的类型安全。Rust击中了我，这真的很酷。Jack： Rust击中我并不是因为速度或者其他因素。那是很久以后的事了，就像我现在才非常关心编写正式的Rust代码，才发现Rust中真正有趣的东西。（慢热）但是最初的时候是因为我之前写C#，总是碰到运行时错误。因为这种动态类型，完全没有经过类型检查。我都无法列出遇到过的运行时错误数量了，感觉随便一个简单的操作都能碰到错误。给我的感觉是，这根本不像是编程，因为我还得处理这些运行时的错误（代码里感觉像多了很多“废话”，不精炼）。但是Rust就没有这种感觉。我喜欢Rust的人体工程学，比如包管理、类型安全和Null指针安全等。Anatoly： Sean呢？Sean： 是的，对我来说也是一样的。速度，可以说是一个我为什么用Rust工作的合理的解释。我可以说，“哦，好吧，它非常快，而且很容易合作，而且非常容易审核”等等。但实际上，当我第一次学习Rust的时候，我的感觉是，“我再次爱上了编程”。因为我不太想再次求助于Haskell了（在某些情况下）。当然，Haskell很棒。Jack：Haskell有太多的return废话了。Sean： Rust将我的编程心智模型和程序思维恰到好处的结合了起来，我太喜欢这些概念了。当我第一次使用Rust的时候，它和现在有很大不同，还有垃圾回收之类的内容。但是过去这几年发生了变化，随着时间的推移它会更加优雅。我想这就是为什么我非常喜欢它的原因之一，就是我看到它的改进比原来越来越好。Greg： 这些年我涉足了很多不同的编程语言。C、C++、Haskell、Python等。而且每一次，我都尽力在每个项目上只选择两种语言。我会说，“好吧，如果我想做这些高级的东西，我会选择Python，如果我想选函数式类型的东西，我会选Haskell，当我想做一些底层的东西，我会选C++”。我在这些跨语言交互过渡中被折磨了多次。这真的非常艰难，尤其是涉及垃圾回收的时候，实际上不可组合。然后，C++那里没有垃圾回收也没有安全性可言。如果你用C++给Python写个插件，突然间你的程序就崩溃了。它不应该崩溃，对吗？但它就是崩溃了。因此，Rust对我来说，就是一股新鲜空气。我现在使用Rust这一种语言就可以完成整个软件堆栈的绝大部分功能，而不必切换语言了。Jack： 我认为C++其实也不是完全不安全的。它还是安全的，但它的安全只存在于简单的情况下，但是当处理复杂的情况，就不安全了。表现就像安全性是一个谎言一样。Greg： 你是指未定义行为吧？Jack： 是的。Greg： 所以，假设你的程序有一个整数溢出，它只是在你正在使用的编译器中出现，但是在语言定义中并没有定义整数溢出的情况，这就是未定义行为。你的编译器允许是允许做任何事情的，任何事情。当然，它也许不会出现在你正使用的编译器中。然后你升级编译器，它就崩溃了。或者它在其他人的库中发生崩溃，因为它们有整数溢出，这就很烦。Jack： 我的意思是，像Linux内核禁用了空指针检查优化（-fno-delete-null-pointer-checks ， GCC会默认把空指针检查优化掉）。这是因为曾经有一个错误，是编译器将空指针检查优化掉了，也就是说，把空指针检查给删除了。这就导致Linux内核的安全性大大降低，所以Linux内核要禁止这种优化。当我想到Rust，只要Rust的不安全规则是正确的，那么建立在这些不安全上面的一切也是正确的。（就像Linux禁止空指针检查优化那样，建立不安全规则，在这个规则之上构建安全）Sean：是的，所以说Rust实际上是有一层抽象的屏障，将安全作为第一等概念，因为"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-03 12:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"从今天开始，「每日新闻」会增加一些试验内容，选择翻译一些文章，时间有限，选择连载的方式。"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该文作者一直致力于将Rust应用于CUDA。目前他还不建议用Rust应用于CUDA，但是他认为现在已经有了稳定的基础。该文记录了PTX链接器和相关构建脚本，因此可以在Rust里可靠地构建CUDA内核，这是朝Rust的GPGPU迈出重要的一步。GPGPU 相关前文https://bheisler.github.io/post/state-of-gpgpu-in-rust/原文https://bheisler.github.io/post/ptx-builder-and-linker/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-03 12:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"将CUDA Path Tracer 移植到ptx-builder/linker"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Witnet去中心Oracle网络协议（Witnet Decentralized Oracle Network protocol）的第一个开源实现，是witnet-rusthttps://github.com/witnet/witnet-rustWitnet协议将智能合约连接到任何在线数据源，例如股票价格，天气预报，以及其他区块链，该协议由被称为目击者的分布式矿工节点运行，这些节点可以检索并向智能合约提交数据从而获得代币奖励，建立一个分布式的，不可更改的，抗审查的数据档案。witnet-rust 包括了一些区块链组件，比如持久化区块链的存储引擎等， 2019年会发布测试网络。感兴趣的可以看看。原文https://medium.com/witnet/witnet-monthly-report-september-2018-20cb85b61a88"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-03 12:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"witnet 月报"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"公司（很可能没有公司）在悉尼，但是你可以在全球任何地方工作。 但可能只是临时工，并且可能只提供1-2个月的工资。 不过想参与到编译器和分布式开发的开源项目的人，也可以关注下。原文https://www.reddit.com/r/rust/comments/9kx94z/job_compilers_distributed_systems_engineers_in/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-03 12:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「远程工作」编译器和分布式系统工程师"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\nstratisd，易于使用的Linux存储管理工具\nimageflow，高性能图片处理Web服务器\nsalsa， 通用的增量计算框架\n\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-03 12:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"GitHub趋势榜今日新上榜项目"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"简要：\nwasm-pack大版本发布\nweb-sys crate发布\n《Programming WebAssembly with Rust 》Kevin Hoffman正在为Pragmatic Programmers图书出版商撰写一本关于Rust和Wasm的书\nSFHTML5聚会的视频录制和幻灯片，都是关于wasm的，幻灯片地址\nrustfmt编译为wasm，用于在浏览器中格式化代码\nOlin，服务端wasm平台\nP64Lang解析器和解释器作为wasm模块运行\nwasm-bindgen如何促进Rust和JavaScript之间的互操作\n详细内容请看： 原文https://rustwasm.github.io/2018/10/01/this-week-in-rust-wasm-008.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-02 11:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust和WebAssembly本周报告 008"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://www.cattlegrid.info/the-undergarden-text-adventure-rust-1-sections"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-02 11:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"系列文章：用Rust实现文字冒险游戏 1"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"lolbench编译了Nightly Rust下大约350个基准测试。 然后运行它们并高亮显示标准库中的潜在性能回退和编译器的输出。该项目的目的是想要监督Rust的性能朝越来越快的方向发展lolbenchhttps://github.com/anp/lolbenchlolbench数据站点https://blog.anp.lol/lolbench-data/原文https://blog.anp.lol/rust/2018/09/29/lolbench/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-02 11:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"lolbench： 自动检测Rust的性能回退"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在活动期间内（整个十月份），选择要参加活动的GitHub开源项目，并为其提交5个PR，前5w人即可获得T恤（任何时区的人都可参与）。Rust的参赛项目是Xi-editor活动网站https://hacktoberfest.digitalocean.com/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-02 11:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"GitHub和DigitalOcean联合举办的Hacktoberfest活动"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"XGBoost据说是机器学习界的「快刀」，现在有了Rust绑定，那就是「小李飞刀」了rust-xgboosthttps://github.com/davechallis/rust-xgboost"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-02 11:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Xgboost的Rust绑定"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Cardano Rust项目为使用Rust编程语言编写的第三方开发人员创建了Cardano加密原语的工具箱。它是IOHK的第一个开源项目，提供钱包和节点功能库 ，以及Ada的钱包，Ada是最精确设计的加密货币。 IOHK的工程师旨在通过开源库向更多开发人员开放Cardano，并鼓励全球社区建立这一资源。这个开源库为更广泛的第三方开放了Cardano区块链。他们将能够构建钱包应用程序，将新的或现有的产品集成到平台中，并加速Cardano系统的分散化。原文https://cardanorust.iohkdev.io/官网https://www.cardano.org/zh/team-3/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-02 11:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Cardano Rust项目开源工具包"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"示例https://medium.com/gitpod/bring-your-own-docker-image-to-gitpod-52db1aa861de原文https://www.reddit.com/r/rust/comments/9keom4/use_a_dockerfile_to_define_your_rust_online/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-02 11:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Gitpod现在支持Dockerfile"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"「今天上班的公交人明显得少了很多。大家相视而笑，互相点头示意，但眼神坚定。因为他们知道，只有共和国最优秀的人才，各部门最重要的岗位，才会在这个时间出现在这个车里。很多拖着行李箱的人羞愧的低下了头，他们知道自己是党和国家的寄生虫。但是没有人责备他们，毕竟每个人的能力有限，与其让他们继续工作，不如放他们回家过国庆节长假！」"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"祝大家国庆快乐！"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"允许生成没有Rich标头的可执行文件link-patcherhttps://github.com/mthiesen/link-patcher"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"微软链接器补丁"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"支持Rust，可以编译到汇编，方便代码调试rmsbolthttps://gitlab.com/jgkamat/rmsbolt"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用于Emacs的godbolt编译器实现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"thumbcloudhttps://github.com/flofriday/thumbcloud"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"文件共享服务器Thumbcloud发布新版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"nitoxhttps://github.com/YellowInnovation/nitox"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"基于Tokio的异步NATS客户端"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"允许从diesel项目中导出迁移文件diesel-setup-depshttps://github.com/Diggsey/diesel-setup-deps原文https://www.reddit.com/r/rust/comments/9kayaz/export_diesel_migrations_from_library_crates/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"新库diesel-setup-deps"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"以60fps渲染尽可能多的 bunny sprites 来对Amethyst做基准测试看看release和debug的差距amethyst-bunnymarkhttps://github.com/cart/amethyst-bunnymark"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"游戏引擎Amethyst基准测试"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"群友分享读写锁小tip"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"UEFI(Unified Extensible Firmware Interface)，是硬件初始化完，操作系统启动之前的核心应用。原文https://medium.com/@gil0mendes/an-efi-app-a-bit-rusty-82c36b745f49\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用Rust创建一个UEFI应用程序"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"「今天上班的公交人明显得少了很多。大家相视而笑，互相点头示意，但眼神坚定。因为他们知道，只有共和国最优秀的人才，各部门最重要的岗位，才会在这个时间出现在这个车里。很多拖着行李箱的人羞愧的低下了头，他们知道自己是党和国家的寄生虫。但是没有人责备他们，毕竟每个人的能力有限，与其让他们继续工作，不如放他们回家过国庆节长假！」"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"祝大家国庆快乐！"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"允许生成没有Rich标头的可执行文件link-patcherhttps://github.com/mthiesen/link-patcher"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"微软链接器补丁"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"支持Rust，可以编译到汇编，方便代码调试rmsbolthttps://gitlab.com/jgkamat/rmsbolt"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用于Emacs的godbolt编译器实现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"thumbcloudhttps://github.com/flofriday/thumbcloud"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"文件共享服务器Thumbcloud发布新版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"nitoxhttps://github.com/YellowInnovation/nitox"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"基于Tokio的异步NATS客户端"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"允许从diesel项目中导出迁移文件diesel-setup-depshttps://github.com/Diggsey/diesel-setup-deps原文https://www.reddit.com/r/rust/comments/9kayaz/export_diesel_migrations_from_library_crates/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"新库diesel-setup-deps"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"以60fps渲染尽可能多的 bunny sprites 来对Amethyst做基准测试看看release和debug的差距amethyst-bunnymarkhttps://github.com/cart/amethyst-bunnymark"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"游戏引擎Amethyst基准测试"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"群友分享读写锁小tip"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"UEFI(Unified Extensible Firmware Interface)，是硬件初始化完，操作系统启动之前的核心应用。原文https://medium.com/@gil0mendes/an-efi-app-a-bit-rusty-82c36b745f49\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-10-01 12:43"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用Rust创建一个UEFI应用程序"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"「谎话跑得飞快，真相在后面蹒跚而行（falsehood flies, and the truth comes limping after it）」作者用这句话来描述基准测试，原因有二：\n难以量化系统的性能\n即使获得了正确的结果，实际上也是在系统上下文是正确的\n所以作者此文并不是另一个基准测试。测试结果简要概括：CPU L1  缓存命中率 ： Rust 96.9％， C 77.9％， L2缓存Rust表现也比较稳定，但C就不行了作者又进一步探索了，到底是Rust语言的优势，还是数据结构的优势？结论：\nRust的基础数据结构表现非常好，测试结果的差异大部分是数据结构的差异。\n但因为Rust的所有权机制，迫使开发者不得不仔细优化这些数据结构的实现\nRust是强大的抽象又不损失性能，这并不意味着Rust总是能胜过C，但是你可以通过这篇文章，对Rust有一个正确的看待了。原文 http://dtrace.org/blogs/bmc/2018/09/28/the-relative-performance-of-c-and-rust/[延伸阅读 ](Rust中BTreeMap实现机制  http://cglab.ca/~abeinges/blah/rust-btree-case/)"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-29 13:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"C和Rust的相对性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该文作者准备和https://pragprog.com/合作，正在写一本书《Programming WebAssembly with Rust》。目前进度已完成 2／3，可以关注下原文https://medium.com/@KevinHoffman/programming-webassembly-with-rust-the-book-7c4a890fcf97"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-29 13:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"书籍预告：  Programming WebAssembly with Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"支持async/await和 Handlebars模板渲染Tower Web当然还要准备和Warp合并，但在合并之前，作者希望达到一个完成度比较高的抽象。原文https://medium.com/@carllerche/tower-web-0-3-async-await-and-template-support-e0bb8ed47941"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-29 13:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Tower Web 0.3  发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这样方便与别人协作，直接使用你的配置。即便你使用的是rustfmt默认的配置，也需要放一个空的rustfmt.toml文件，它表示你是希望跟你协作的人也使用rustfmt。大家怎么看？ 我觉得有道理。原文https://www.reddit.com/r/rust/comments/9jl6a9/pro_tip_if_you_use_cargo_fmtrustfmt_use_a/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-29 13:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「专业提示」在使用cargo fmt/rustfmt的时候请使用rustfmt.toml 文件"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"知乎专栏https://zhuanlan.zhihu.com/p/45647326\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-29 13:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何在流行的Rust Crate中发现漏洞"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"基于gtk-rs，跨平台process-viewerhttps://github.com/GuillaumeGomez/process-viewer"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-28 12:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust实现的进程查看器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"prettytable-rshttps://github.com/phsym/prettytable-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-28 12:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"提供格式化表格打印的库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\nTAP-Rust， Test Anything Protocol (TAP) 的Rust实现\npacked_simd，是对此RFC的实现，可移植的打包SIMD矢量类型\n\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-28 12:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"GitHub趋势榜今日新上榜项目"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"web-sys是对所有Web API的绑定，包括：\ndom操作\nWebGL\nWeb Audio\n定时器\nfetch\n等等\n未来还会支持WebAssembly的Host Binding，解锁dom操作的性能另外js-sys功能也100%完成了，它是对所有ECMAScript API的原生绑定，与web-sys不同的是，js-sys是手工编写，而非WebIDL。原文里还包含了两个demo原文https://rustwasm.github.io/2018/09/26/announcing-web-sys.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-27 11:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"官方通告：web-sys crate发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Newsboat是一个C++实现的RSS/Atom feed 阅读器，目前作者有用Rust重写的计划感兴趣的可以关注下，应该有学习价值原文https://github.com/newsboat/newsboat/issues/286"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-27 11:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Newsboat准备用Rust重写"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"简要：\nusers.rust-lang.org  论坛现在加入了Embedded 分类\n可以使用Rust的1.30-beta版本在stable上构建嵌入式二进制文件\neeprom24x crate发布，用于EEPROM存储芯片的嵌入式兼容驱动器\nTrangar 基于 他自己用Rust实现的ArtNet协议，控制了56个照明设备\n还有很多基于embedded-hal实现的驱动发布\n原文https://rust-embedded.github.io/blog/2018-09-25-newsletter-12/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-27 11:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"嵌入式工作组报告 12"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"是一个rust-gdb的hook，提供了一个宏，可以帮助开发者快速使用GDB进行调试。所以只支持Linuxdebug-herehttps://github.com/ethanpailes/debug-here「油管」 某线下meetup 视频 ： Python和Rust在生产环境的集成视频https://www.youtube.com/watch?v=IJBmqPzE6qY\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-27 11:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"新库：debug-here"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"修复了str::repeat那个安全问题原文https://blog.rust-lang.org/2018/09/25/Rust-1.29.1.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-26 13:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 1.29.1 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"还包含了一个jupyter 的内核来支持Rust在Google的仓库里，但不知道算不算Google的项目evcxrhttps://github.com/google/evcxr指南https://github.com/google/evcxr/blob/master/evcxr_jupyter/samples/evcxr_jupyter_tour.ipynb"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-26 13:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一个Rust REPL实现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"大家有什么看法原文https://www.reddit.com/r/rust/comments/9ixmnn/unsafe_is_a_misnomer/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-26 13:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「讨论」有人批判unsafe这个词用的不恰当"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这哥们用Rust花了6小时写了一个简单的音乐播放器，记录了他的整个过程。他想要表述的这种感觉应该是： 用Rust写完代码，没有任何问题，直接上生产，然后忘记它。原文https://vorner.github.io/2018/09/25/Directly-To-Production.html代码 https://github.com/vorner/playlist_mgr"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-26 13:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"编码六小时，直接投入生产"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://blaztinn.gitlab.io/post/simulating-recursion-with-generators/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-26 13:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用生成器来模拟递归"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"BPF 的全称是 Berkeley Packet Filter，顾名思义，这是一个用于过滤(filter)网络报文(packet)的架构。extended BPF(eBPF)，源于 BPF 的全新设计。一方面，它已经为内核追踪(Kernel Tracing)、应用性能调优/监控、流控(Traffic Control)等领域带来了激动人心的变革；另一方面，在接口的设计以及易用性上，eBPF 也有了较大的改进。redbpfhttps://github.com/redsift/redbpfingraindhttps://github.com/redsift/ingraind"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-26 13:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust实现的eBPF工具包发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"wasm-pack 0.5版本发布，这是迄今为止发布的最大的一个版本。截止今天，终于有了一套Rust和WebAssembly梦寐以求的工作流程。简要：\n拥有了独立网站，包含了在线的文档\n支持js模块\n0.5版本已经将wasm-pack打造成一个集成构建工具，引入了新的命令wasm-pack init 、wasm-pack test和wasm-pack publish\n还有其他很多新的功能，详细请看Changelog https://github.com/rustwasm/wasm-pack/blob/master/CHANGELOG.md原文https://rustwasm.github.io/2018/09/24/the-biggest-wasm-pack-release-yet.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-26 13:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"wasm-pack 大版本发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\n禁止 unsafe\n提供高级抽象，关注可用性\n不是要替代Ring或RustCrypto这样的库\n现在不适合用于生产\norionhttps://github.com/brycx/orion原文https://brycx.github.io/2018/09/25/orion-pure-rust-crypto-lib.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-26 13:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"orion 纯Rust加密的另一种尝试"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"目标是作为数据操作和数据库通用的语言tablamhttps://bitbucket.org/tablam/tablam/src/952b8391d613?at=default\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-26 13:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用Rust实现的实验性关系语言"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文https://www.reddit.com/r/rust/comments/9imvmc/thruster_050_major_release_with_improved/thrusterhttps://github.com/trezm/thruster"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-25 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Web框架Thruster发布0.5"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"讨论了一个经典的问题：Rust如何处理循环数据？ 答案是，不需要循环。当使用带有GC的语言，比如js，可以这么写：希望有多个服务，并且可以彼此通信，通过创建directory来存储这些服务对象。directory里存储的对象都可以互相访问。但是将此代码修改为Rust时，就会陷入困惑：创建Directory时，Service还不存在，所以使用Option。但是初始化directory之后，Service就永远不可能为None。最大的问题是，该如何管理内存？因为Service1有可能会引用到Service2。使用Arc或原子类型和锁，可以改善，但还不是最好的办法。可以使用Sender<Message>类型来解耦，不要通过共享内存来通信，要通过通信来共享内存。Sender是指Channel中的Sender，利用Channel来实现一个Actor模型，每个service就是一个Actor，Actor之间通过发送消息来相互调用。Niko使用std::sync::channel来演示这种思想，然后使用Arc、Mutex和ConVar实现了一个简单的自定义Channel。完整代码https://play.rust-lang.org/?gist=9fc3d90b50e8af1470a0d488fb3993b9&version=stable&mode=debug&edition=2015原文http://smallcultfollowing.com/babysteps/blog/2018/09/24/office-hours-1-cyclic-services/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-25 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Niko办公时间：循环服务"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"编写无锁数据结构就会出现ABA问题。比如在编写无锁栈的时候：前 1 - 13步，实际上在栈顶的A值已经发生过了变化。但是到第15步进行CAS操作的时候，将A值换为B，CAS操作没有分辨出A值实际上已经不是之前的A。所以就发生了ABA问题。ABA问题的本质是内存回收。对于上面的问题，A被弹出以后，就不应该被释放，因为还有B在用着它，也不能被线程N 重用。所以一般使用 险象指针（hazard pointers，HP）来阻止释放还被其他线程使用的指针。 将来crossbeam-epoch也打算支持险象指针。所以作者基于这种思想实现了一个crate： lockfreehttps://docs.rs/lockfree/0.2.0/lockfree/该库提供了一些无锁数据结构，以及提供API为每个线程都增加一个删除队列，解决ABA问题原文https://bzim.gitlab.io/blog/posts/incinerator-the-aba-problem-and-concurrent-reclamation.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-25 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"ABA问题和并发回收"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者是为了参加某个机器人比赛，基于Raspberry PI 3，用Rust编写机器人固件原文https://blog.florencepaul.com/creating-a-robot-for-eurobot-part-1-context"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-25 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「系列文章」为Eurobot创建机器人：第1部分"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Smithy，一个用Rust编写的Web开发框架，可以编译为WebAssembly，它的目标是让你使用惯用的Rust来编写前端代码。开始准备alpha版本了。新版本使用了wasm-bindgen提供的js-sys和web-sys\nsmithy\njsx_compiler\nwasm_website_frontend\n原文https://medium.com/@robert.balicki_2494/smithy-progress-update-how-i-decreased-webassembly-bundle-size-by-90-e7fe194b2f58使用Runner来运行小的Rust代码片段$ cat print.rsprintln!(\"Hello, World!\");$ runner print.rsHello, World!runner对代码片段默认会有main函数包装：// file.rslet mut f = File::open(\"file.rs\")?;let mut buf = String::new();f.read_to_string(&mut buf)?;println!(\"{}\",buf);还可以直接运行代码：$ runner -i \"(0..4).map(|n| 2*n)\"0246总之，就像是一个方便的终端版的playgroundrunnerhttps://github.com/stevedonovan/runner原文https://stevedonovan.github.io/rustifications/2018/09/23/runner.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-25 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Smithy进度更新：我如何将WebAssembly 打包尺寸减少90％"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"先关注下hegemonhttps://github.com/p-e-w/hegemon\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-25 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"[WIP]Rust编写的模块化系统监视器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-24 12:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"祝大家中秋快乐！！！"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该教程是在iOS上面使用Rust构建应用教程，这个系列应该还会包含安卓，可以关注一下原文https://github.com/mtak-/rust-on-mobile/blob/master/examples/ios/example01.md"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-24 12:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 移动开发"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"GLM（OpenGL Math）是一个流行的线性代数库，主要聚焦于计算机图形。nalgebra-glm从GLM中汲取灵感，为简单的图形应用定义了一个简单易用的API。原文https://www.patreon.com/posts/21589538"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-24 12:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"nalgebra-glm发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\nSolana是一种高性能区块链\nZcash是一种加密货币\nParity是一个核心的区块链基础公司，以太坊相关\n文章里包含了视频，以及视频的文字实录。有空我把它翻译出来。原文https://medium.com/solana-labs/solana-at-portland-dev-meetup-72e4dc7ad32c"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-24 12:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文预警」Solana 、Zcash 和Parity 三家会面讨论为什么Rust适合区块链开发"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"加密挑战 https://cryptopals.com/cryptopals-rusthttps://github.com/aopicier/cryptopals-rust"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-24 12:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用Rust解决加密挑战"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"rsgethttps://github.com/otavio/rsget"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-24 12:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust实现类似于wget的下载器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"issues donehttps://github.com/rustwasm/wasm-bindgen/issues/275#issuecomment-422993593\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-24 12:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rustwasm项目组js-sys 绑定全局JS接口的工作已经完成了"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"官方目前正在申请CVE，目前官方已经修复此漏洞，将在9.25发布Rust 1.29.1中稳定此修复。标准库中的str :: repeat函数允许重复字符串固定次数，返回最终的字符串。最终字符串的容量通过相乘来计算字符串的长度，这个计算可能会溢出。str :: repeat的其余实现包含不安全的代码，它依赖于具有计算容量的预分配Vec。在整数溢出时，预分配容量将小于实际需要的容量，然后在分配的缓冲区之外写入，导致缓冲区溢出。这个漏洞和VecDeque那个类似。受影响的版本虽然str :: repeat函数自1.16.0以来一直存在于Rust中，但是这个漏洞被引入标准库中是在2018年5月10日发布的1.26.0稳定版中。原文https://blog.rust-lang.org/2018/09/21/Security-advisory-for-std.html事后诸葛亮：查看了一下修复的代码，问题主要是在 slice::repeat方法中。修复代码就简单了，加检查就好，整数溢出即panicRust修复源码位置https://github.com/rust-lang/rust/blob/master/src/liballoc/slice.rs#L434"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-22 13:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"str::repeat曝安全漏洞"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文http://smallcultfollowing.com/babysteps/blog/2018/09/21/office-hours-0-debugging-with-gdb/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-22 13:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Niko工作时间：使用GDB调试Rust代码"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者在工作中使用sklearn（一个Python第三方提供的非常强力的机器学习库）的内置工具进行余弦相似度查询，并行性不足，并且会产生很多OOM（内存不足）错误。他们还使用了Gensim和一些其他工具，往往会使用大量内存。最终他厌倦了这一切，拿起了Rust，装备了Serde，序列化了查询所用的JSON矩阵，架起了Rayon，最终得到了一个成功的并行故事。 480G的内存只用了不到3G。原文https://www.reddit.com/r/rust/comments/9hwqt9/powered_by_rayon/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-22 13:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rayon的力量"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"可以算作一个FFI和Unsafe的教程原文https://travisf.net/capstone-rs-unsafety-adventure"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-22 13:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"在FFI中进行不安全的冒险"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"通过gfx-rs支持了macOS原文https://www.reddit.com/r/rust/comments/9hntah/rpcs3_emulator_progress_report_august_2018_with/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-22 13:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RPCS3 仿真器进度报告"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者要为新项目选择语言，考量了诸多语言的特点，最终选了Rust。可以看看他的思考过程。原文https://packnback.github.io/blog/programming_languages/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-22 13:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一次项目编程语言选择之旅"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"用于检测C++代码中 悬空指针/迭代器/ string_views / spans /等常见情况。估计是跟Rust学的原文https://herbsutter.com/2018/09/20/lifetime-profile-v1-0-posted/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-22 13:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"C++ Lifetime profile v1.0 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"可以帮助开发者将Cargo.toml中所有使用通配符标注的crate替换为最新版，包含依赖项cargo-stabilizehttps://crates.io/crates/cargo-stabilize"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-22 13:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"新库 cargo-stabilize"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"原文http://releases.llvm.org/7.0.0/docs/ReleaseNotes.html\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-09-22 13:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"LLVM 7.0发布了"},"type":"text"}],"type":"title"}},]
