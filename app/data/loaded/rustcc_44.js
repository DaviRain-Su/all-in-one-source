export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "经过大量的重构之后，librsvg现在可以在Rust中完成所有CSS解析和匹配，无需使用libcroco。另外，CSS引擎来自Mozilla Servo，因此它应该能够处理比librsvg以前复杂得多的CSS。第一次在librsvg中引入CSS解析是2002年。为了支持当时CSS2的一小部分，它的体积被设计的尽可能的小。Librsvg处理CSS样式表的方式不是逐行进行语法分期，取而代之的是将各个部件组成一个整体。不知何时起，g_strsplit()成为了你最好的朋友。基本的解析算法是打开一个样式表，如下所示：从librsvg在以往遇到的各种问题中，开发团队得知“ CSS的支持太有限”，感觉使用CSS功能的SVG要么是手写的，要么是由诸如数据绘图软件之类的自定义程序自动生成的。插图程序倾向于在每个SVG元素中明确列出所有样式属性，并且不使用CSS。但在librsvg 2.47.1中将不再需要libcroco！详细信息前往博客网页查看。https://people.gnome.org/~federico/blog/css-in-librsvg-is-now-in-rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-12 22:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "由Mozilla Servo提供的CSS 由原本的librsvg支持升级到对Rust的支持" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "async-std是Rust的标准库到异步世界的移植。它运行速度十分快，使用体验也更良好。async-std1.0最终发布。正如开发者在第一个公告博客中所承诺的那样，稳定版本与Rust 1.39发行版相吻合，该发行版增加了async/.await。我们要感谢周围的活跃社区async-std帮助发布了该版本。async-std的1.0版本指示所有相关的API均已就绪，将来会在这些稳定的基础上增加功能。前往博客网页了解更多。https://async.rs/blog/announcing-async-std-1-0/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-12 22:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-std 1.0发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文章的目标读者是已经对Vantage Rust经验丰富，并且希望涉足异步生态系统中的程序员。就像标题所示，这本书与其说是关于如何使用异步Rust，还不如说是试图对幕后工作原理有一个扎实的理解。有效的使用异步rust应该是一个自然而然地开始。因此，我们将尝试回答由任何足够复杂的技术引起的常见基本问题：\n我们如何以及为什么要这样做？\n构成堆栈的层是什么？\n它们各自的作用是什么？\n他们以什么样的方式工作以及为什么需要这样的方式？\n它们如何配合在一起？\n这种方法的优点和缺点是什么？\n整体执行模型的语义是什么？\n内存中的所有内容如何表示？\netc...\n在回答所有这些问题的方式上，我们会遇到很多抽象的问题，一开始看起来完全像是变魔术。在阅读本书之后，人们将能够：A）深入研究任何任意复杂的异步代码库，B）悉知编译器可能向它们抛出的任何错误消息。本文章英文全文前往GitHub查看。https://github.com/teh-cmc/rust-async/blob/master/README.md\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-12 22:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "推荐文章：揭开异步Rust的神秘面纱" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "全文大纲如下：1 The Anatomy of a Platform2 The Anatomy of a Type2.1 Size2.2 Alignment2.3 Offsets2.4 Layout2.5 ABI2.6 The Layouts/ABIs of Builtins2.7 Specifying Layouts and ABIs3 Extended Random Notes3.1 The C Integer Hierarchy3.2 Endianness3.3 Segmented Architectures3.4 Calling Conventions3.4.1 Problem and Motivation for Calling Conventions3.4.2 Some Examples of Calling Conventions感兴趣的读者可以浏览原文：https://gankra.github.io/blah/rust-layouts-and-abis/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gankra.github.io/blah/rust-layouts-and-abis/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-11 21:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于Rust中的类型布局和ABI的注意事项" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rabbithole-rs是一个类型化、用户友好的JSON:API类型的系统，具有易于使用的宏系统来帮助您对数据建模。Read more：https://github.com/UkonnRa/rabbithole-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/UkonnRa/rabbithole-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-11 21:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rabbithole-rs - JSON API数据建模" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ptail是一个小工具，它会截断进程的输出。 与tail -f不同，它在终端中显示的行数不会超过指定的数量。如果您正在将命令作为Shell脚本的一部分执行并且不希望显示完整而冗长的输出就会特别有用。Read more：https://github.com/orf/ptail\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/orf/ptail" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-11 21:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ptail - 让进程的输出固定行数" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文地址https://shaneutt.com/blog/rust-fast-small-docker-image-builds/这篇文章我会介绍如何为Rust应用创建小且快速的Docker镜像。我将会从创建一个小的测试应用开始，然后不断构建迭代Dockerfile。https://www.rust-lang.org/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为Rust应用构建小而快速的镜像" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "确保你已经安装了下面的应用：\nrustup v1.14.0+\ndocker v17.06.2+\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "环境要求" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用rustup进行设置，确保你使用了最新的稳定版Rust。创建一个myapp的新项目" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "起步: 创建demo应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "以下是我们用于docker构建的起点，在当前目录中创建一个名为Dockerfile的文件：https://docs.docker.com/engine/reference/commandline/build/同样创建一个.dockerignore的文件写入以下内容：你可以尝试构建并运行应用：如果一切都能工作的话，你可以在控制台看到Hello, world!。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "起步: 初始化dockerfile" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "当我写这篇文章的时候, Rust 包管理器 cargo 有一个issue是 它还没有 一个dependencies-only的选项，来单独构建依赖。https://github.com/rust-lang/cargocargo缺少这样单独构建依赖的选项使得我们在每次改动src下面的内容时都会对重新构建依赖项，但我们只想在Cargo.toml或者Cargo.lock文件改变是重新构建依赖项，比方说添加或者更新依赖时。另一个问题是，虽然rust:latest Docker映像非常适合构建，但它的映像相当大，容量超过1.6GB。https://hub.docker.com/r/library/rust/tags/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我们初次构建的问题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "为了避免这些问题并且开启docker构建缓存让构建变得更快，首先我们开始改动Cargo.toml来添加一个依赖：我们添加rand包作为项目依赖，它提供了方便地生成随机数的工具。现在如果运行：它将构建rand依赖关系并将其添加到缓存，但是更改src / main.rs将使下一次生成的缓存无效：请注意，此次构建必须再次重建rand依赖项。在等待Cargo的only-dependencies构建选项时，在将任何代码复制到构建环境之前，我们可以通过将Dockerfile更改为默认的src/main.rs来克服此问题：上面的Dockerfile中的以下行将导致Cargo构建时仅重建我们的应用程序：所以如果我们编译的话:然后我们对src/main.rs做一点小小的改动：我们将会发现接下来docker构建应用只会在我们的应用逻辑改变时重新构建，而依赖项目则被缓存起来用来快速构建。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "改进构建流程避免src改动重新构建依赖项" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust:latest镜像具有构建项目所需的所有工具，但大小超过1.6GB。我们可以使用Alpine Linux（一种出色的小型Linux发行版）来改善镜像大小。https://hub.docker.com/r/library/rust/tags/Alpine团队提供了一个只有几兆字节大小的docker映像，并且仍然具有一些用于调试的shell功能，并且可以用作Rust构建的小型基础映像。https://hub.docker.com/_/alpine/使用多阶段docker构建，我们可以使用rust:latest来完成构建工作，但是只需将应用复制到基于alpine:latest的最终构建阶段即可：https://docs.docker.com/develop/develop-images/multistage-build/现在如果你运行:你可以看到这些东西:" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "减小镜像体积" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果你尝试使用docker run --rm -it myapp运行以上示例，则可能会遇到类似以下错误：如果您熟悉[ldd](https://en.wikipedia.org/wiki/Ldd_(Unix)则可以运行以下命令，以查看我们缺少应用程序的共享库：在上面的例子中我演示了如何通过避免每次src/main.rs改动重新构建依赖提升构建速度，以及如何将镜像大小从1.6GB+减少到几兆字节，然而我们的构建还是不能生效，因为我们需要针对MUSL Libc进行构建，这是一个轻量级、快速的标准库，在alpine:latest中是默认库。https://www.musl-libc.org/除此之外，我们还希望确保我们的应用程序以容器内的非特权用户身份运行，从而遵守最小特权原则。https://en.wikipedia.org/wiki/Principle_of_least_privilege" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "下一步：跟进、修复并进一步完善我们的构建" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "要针对MUSL libc进行构建，我们需要安装x86_64-unknown-linux-musl 构建目标，以便可以将Cargo标记为使用--target为其构建。我们还需要标记Rust以使用musl-gcc链接器。https://doc.rust-lang.org/rustc/targets/built-in.htmlrust:latest镜像预安装rustup。 rustup允许我们使用rustup target add $NAME安装新的构建目标，因此我们可以像这样修改Dockerfile：请注意以下行，它显示了我们为MUSL Libc构建应用程序的新方式：重新构建应用程序并运行它：如果一切正常，你应该再次看到应用已被更新了！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为MUSL Libc构建" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "为了遵循最小特权原则，我们创建一个名为myapp的用户，避免用户以root用户的身份运行应用。将Final Stage docker build阶段更改为以下内容：更新src/main.rs:现在构建并运行应用:如果一切正常，你应该会看到应用已再次更新，现在应用以用户myapp运行。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "以非特权用户身份运行" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在我们构建应用程序的完整Dockerfile如下所示：从这里观看我的演示，有关使用Skaffold在DC / OS上将Rust部署到Kubernetes。利用该演示中的一些技术，你可以将应用程序自动部署到Kubernetes，以使用Skaffold在本地minikube系统上进行测试。https://github.com/shaneutt/dcos-k8s-rust-skaffold-demoHappy coding!\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-10 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "最后" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "DWARF（Debugging With Attributed Record Formats）是一种debugging文件格式，它是ELF(Executable and Linkable Format)格式的补充。https://en.wikipedia.org/wiki/DWARFChrome DevTools支持DWARF，意味着通过它，你可以对C/C++/Rust源码生成堆栈，设置断点和调试，而无需生成源映射。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-09 18:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Chrome DevTools支持DWARF" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Executor的特点：\n#![no_std]\n处理多个spawn并行化运行\n简单易学\n更多信息参见Githubhttps://github.com/richardanaya/Executor/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-09 18:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Executor：Web Assembly中的Async-Await" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "cargo-wharf是一个构建Rust crates的Docker镜像生成器。更多信息参见Githubhttps://github.com/denzp/cargo-wharf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-09 18:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-wharf alpha.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "iou是liburing库的wrapper，这为用户提供了一个惯用的Rust接口，用于与Linux内核的io_uring接口进行异步IO交互。https://docs.rs/iou/0.1.0/iou/更多信息参见Githubhttps://github.com/withoutboats/iou--https://rust.cc/section?id=ce0fe0fb-1ac6-413a-b535-59e4a8e74b6c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-09 18:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "iou" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Sulis - a Turn-Based RPG 類似SLG戰棋RPG的遊戲Veloren 類似我的世界PF Sandbox 3D橫向格鬥遊戲Antorum 類似我的世界Read morehttps://rust-gamedev.github.io/2019/11/07/newsletter-003.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-08 20:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust GameDev #3" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "對C++使用者來說，使用Rust就像呼吸到新鮮空氣一樣！且學習成本並沒有想像中的高，還算蠻友善的，新手不太需要老手幫忙就可以獨立作業。Rust與C的交互不難，但與C++的交互目前還在研究中。目前微軟的工程師對於Rust的想法都是比C++好用太多了。Read morehttps://msrc-blog.microsoft.com/2019/11/07/using-rust-in-windows/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-08 20:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "微軟工程師開始用rust開發作業系統底層元件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "解法：Read morehttps://www.reddit.com/r/rust/comments/dt6u0s/joined_futures_will_run_concurrently_not_in/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-08 20:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "有人問join_all並沒有平行執行，怎麼解決？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目前使用SDL2 的UI庫之後會全面改成 GFX 跟 winitRead morehttps://github.com/KenSuenobu/rust-pushrod/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-08 20:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pushrod 0.4.12 GUI庫更新了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "看來 1.39 就可以使用了這個週末打算出 1.0這是一個第三方的仿原生標準庫的異步庫Read morehttps://async.rs/blog/async-std-0-9-12-async-await-is-ready/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-08 20:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-std 0.99.12: async/.await 準備好了！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Allen" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Nushell(简称Nu)是一种新的shell，它采用现代的、结构化的方法来处理命令行。它可以与来自文件系统、操作系统和越来越多的文件格式的数据无缝地工作，使构建强大的命令行管道变得很容易。详情请见：http://www.jonathanturner.org/2019/11/nushell-0_5_0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-06 21:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Nushell 0.5.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Allen" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "“Skulpin”结合了Skia和Vulkan来绘制gpu加速的2D图形。Skia是Chrome、Sublime Text和谷歌的新UI框架Flutter使用的相同的2D渲染库。这个crate设置一个窗口，初始化Vulkan，并将Skia画布传递给回调以进行绘制。Skia API易于使用，支持形状、文本和位图。详情请见：https://github.com/aclysma/skulpin\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-06 21:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Skulpin - 可以非常简单绘制2D图形" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rustls-native-certs可以使rustls在作为TLS客户端运行时使用平台的本机证书存储。https://github.com/ctz/rustlsWindows、macOS和Linux都支持此功能：\n在Windows上，证书是从系统证书存储中加载的。schannel是用来访问Windows证书存储区的API。\n在macOS上，证书是从钥匙串加载的。用户、管理员和系统信任设置将合并在一起。security-framework 是用来访问密钥库的API。\n在Linux和其他类似UNIX的操作系统上， openssl-probe用于检测系统CA捆绑软件的文件名。\n该库使用以下签名公开了一个函数：成功后，将返回rustls::RootCertStore在此平台上找到的带有根证书的快照库的加载程序，并用std::io::Error显示此功能以平台特定的方式失败的情况。前往GitHub了解更多。https://github.com/ctz/rustls-native-certs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-05 20:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustls-native-certs：为rustls集成操作系统证书库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "配置使用TOML。以下是一个示例配置文件，该文件将所有设置均设置为其默认值。根据您的操作系统，再从不同几个位置提取配置文件。前往GitHub了解更多。https://github.com/chrisbouchard/klondike-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-05 20:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "klondike-rs：用Rust编写的经典纸牌命令行小游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pixels终于发布了。作为创建硬件加速的像素帧缓冲区的最简单方法，声明的对象和与类似包装箱的比较可在自述文件中找到。例如以下的案例中那样，pixels可以满足目前大部分的需求。https://crates.io/crates/pixels这是运行简单的CHIP-8测试程序的解释器（在macOS上运行）的屏幕截图：这相当于1-bpp显示器，分辨率为64x32像素。在此屏幕截图中，显示（由GPU）缩放为原始大小的50倍。模拟器是像素缓冲区的绝佳用例。使用pixels设置纹理四边形并将其流式传输到GPU非常容易。前往GitHub了解更多。https://github.com/parasyte/pixels\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-05 20:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pixels：硬件加速的像素帧缓冲器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一篇来自官方的博客，围绕着2020年Rust的发展将如何这个话题进行的，同时也希望社区中的所有人给出一些建议这个话题的运作方式如下：\n在Rust社区中写一篇博客文章，介绍他们希望2020年Rust开发的样子。\n核心团队阅读所有帖子，并撰写“Roadmap RFC”以提出正式建议。\nRFC由所有人审核，进行注释，进行调整并最终被接受。\n该RFC是接受或推迟2020年RFC的指南。如果提案符合我们想要完成的主题，我们会采纳它，但是如果不适合，就把它推迟到下一年。\n这个过程需要时间，并且在2020年之前还不能完全完成。\n我们将在12月1日审阅这些帖子。这使您有一个月的时间来思考2020年的Rust并撰写一些东西。\n我们的目标是在之后的一两周内制作RFC草案\n根据RFC收到的评论数量的不同，我们可能要等到一月初才接受它。\n更多详情大家可以去直接阅读原文，就不一一翻译了，希望国内的Rustaceans也积极参加呀原文链接：https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html这里月泉在给大家推荐几个国外Rustaceans写的对2020年Rust希望的博文供大家参考~https://blog.turbo.fish/rust-2020/https://blog.dend.ro/my-rust-2020-wishlist/https://omarabid.com/rust-2020https://beyermatthias.de/blog/2019/11/01/rust-2020-libraries-libraries-libraries/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://beyermatthias.de/blog/2019/11/01/rust-2020-libraries-libraries-libraries/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-04 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2020年Rust的发展由你来定！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust有非常好的错误消息以及非常具有同理心的编译器界面而闻名，如果出现问题，Rust编译器会尽力帮助您解决问题，这篇文章主要是谈谈调试错误的运行时相关的内容。文章不长，感兴趣的可以看看Read more：https://blog.yoshuawuyts.com/runtime-diagnostics/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.yoshuawuyts.com/runtime-diagnostics/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-04 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RUNTIME DIAGNOSTICS（运行时诊断）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cargo是一个很好的包管理器，但有一些局限性，该工具提供了其他选项用于避免其中的一些限制。InstallationUsage--each-featureRepo：https://github.com/taiki-e/cargo-hack" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/taiki-e/cargo-hack" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-04 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-hack - 解决Cargo限制的工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该库与JSX之类的技术相比，它更加面向结构，并且大量借鉴了SwiftUI。示例Repo：https://github.com/richardanaya/view\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/richardanaya/view" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-04 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "view - 在Rust中构建View的宏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "详细信息可以参考Rust Bloghttps://blog.rust-lang.org/2019/11/01/nll-hard-errors.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-02 19:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "完成向新借用检查器的过渡" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Githubhttps://github.com/thepowersgang/mrustc" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-02 19:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mrustc 0.9：可选的Rust编译器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Safety-dance，人们可以在这里交流有关审核核心Rust中的不安全代码，并在可行时替换为安全代码的地方。Githubhttps://github.com/rust-secure-code/safety-dance" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-02 19:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "safety-dance：从热门的crates中删除不必要的不安全代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Bayard v0.1.0发布，作为概念证明（PoC），它是在Tantivy和tikv/raft-rs之上构建的用Rust语言编写的全文搜索服务程序。Githubhttps://github.com/mosuka/bayard--https://rust.cc/section?id=ce0fe0fb-1ac6-413a-b535-59e4a8e74b6c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-02 19:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bayard：Rust语言编写的全文搜索服务程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #feature2019年接近尾声，2020年你对Rust有什么想法呢？写一篇博客然后在Twitter@rustlang，或者在Reddit r/rust频道上发表，总之让Rust团队看到你的想法，Rust核心团队会看你的博客，然后撰写“路线图RFC”以提出正式建议。提案会被每个人看到，评论，调整直到被接受。如果提案满足Rust2020年的发展主题，Rust核心团队会采用它，否则就会推迟到下一年。Read Morehttps://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-01 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2020年，你期待的Rust是什么样子" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #pi以前发过这个项目，10月27号第二版合并到了主分支。resphttps://github.com/rust-embedded/rust-raspi3-OS-tutorials/tree/rewrite_for_v2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-01 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust for raspberry pi 教程2.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #c++Pavel Yosifovich 在NDC大会的分享《Rust for C++ developer》，国内有很多相似的话题，比如知乎专栏C++工程师的Rust迁移之路。https://twitter.com/zodiaconRead Morehttps://www.youtube.com/watch?v=k7nAtrwPhR8&t=12s" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-01 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust for C++ developer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rusttwitter 比较火的一篇文章，作者第一篇关于Rust的文章，仔细研究Rust所有权机，结合形象的内存结构图片，帮助读者深入了解。推荐阅读。Read Morehttps://blog.thoughtram.io/ownership-in-rust/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-01 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "仔细研究Rust Ownership" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "与 c++ 相比，这个分享是关于使用 Rust 语言来编写安全、并发和优雅的代码。油管地址：https://www.youtube.com/watch?v=k7nAtrwPhR8" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-31 22:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "给 C++ 开发者的 Rust 分享" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们接受几乎所有与 Rust 相关的想法:语言特性、工具需求、社区项目、生态系统需求等等。如果和 Rust 有关，我们都想听一听。现在摆在我们面前的一个大问题是:会有 Rust 2021 版本吗？如果是有的话，2020年将是做大量相关工作和计划细节的一年，那么这个版本的大致方向如何?官博：https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html更多请看：https://readrust.net/rust-2020/相关优秀博文：https://cetra3.github.io/blog/rust-2020/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-31 22:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于 Rust 2020" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个通过充分利用 SIMD 使得速度更快的基础计算机图形、线性代数库。为此，它使用了一种 “SoA” (数组结构)架构，这样每个 Wec (wide-vec)实际上都包含了4 个 Vec 的数据，并将同时对所有4 个 lane 进行任何操作。这样做可能比 “AoS” (结构数组)布局快很多(10倍)，就像所有当前的 Rust 线性代数库所做的那样，这取决于您的工作负载。但是，必须仔细设计算法以充分利用这一点，而且这样做说起来容易做起来难，特别是当你的算法涉及到重要的分支时。查看更多请看：https://github.com/termhn/ultravioletreddit 讨论：https://www.reddit.com/r/rust/comments/dpknd1/ultraviolet_a_crate_to_do_lots_of_linear_algebra/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-31 22:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ultraviolet一个更快的、处理大批量线性代数库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个系列博文，对于想好好利用 Rust 动手做一些实践的同学来说是个不错的推荐。效果图：参与讨论：https://www.reddit.com/r/rust/comments/dovmnl/building_a_3d_led_cube_display_using_embedded_rust/博客原文：https://dflemstr.io/posts/music-visualization-5/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-31 22:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【嵌入式】使用 Rust 构建三维 LED 立方" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Allen" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你希望 Rust 在 2020 年有哪些新的开发，欢迎提交意见。包括：Rust 语言特性，相关工具的需求，社区项目，生态需求等等，只要跟 Rust 相关就可以提。2020 年一个比较重要的问题是：是否该推出 Rust 2021版本了？如果需要的话，那将会需要很多相关的工作和详细计划。另外这个版本的主题会是什么呢？\nRust 2015: Stability\nRust 2018: Productivity\nRust 2021: ?\n欢迎将你的想法邮件发送给 community@rust-lang.org 进行参与，或者通过发送 tweet 并且添加 #rust2020 标签进行参与。详情请见：https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-30 21:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 2020 年开发意见征集" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Allen" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "可以在浏览器地址栏中搜索 std 文档和 crates，支持 Chrome 和 Firefox 浏览器，只需要输入关键字 rs 然后敲击 Tab 或者 Space 按键就能激活查询功能。详情请见 Github: https://github.com/Folyd/rust-search-extension\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-30 21:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-search-extension: 快速查询 std 文档的浏览器插件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "支持 2D 以及 3D 的流体模拟。提供多种类型的流体模拟，并且可以和 nphysics 引擎配合使用。了解更多https://salva.rs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-29 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "基于 Rust 的流体模拟引擎 Salva" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "async_std 团队度假回来了，然后就发布了这个船新版本。其中备受期待的就是 \"async channels\"，这是 channel::bounded 的异步实现。下面是一个小例子：https://users.rust-lang.org/t/async-std-v0-99-11-released/34099" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-29 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-std v0.99.11 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有了 cargo-wasi之后，把 Rust 代码转化为 WASI 的操作就更丝滑了。WASI 是 WebAssembly 在 Web 外的系统接口。https://github.com/alexcrichton/cargo-wasi\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-29 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "\"cargo-wasi\" - 用于构建 wasm32-wasi 的 Cargo 命令" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章是在阅读完Boat关于异步析构函数的文章后，坐着想写一篇有关于trait的async fn的想法。这篇文章中，暂时没有给出具体实现的建议，但是列出了目前问题所在，感兴趣的阅读下原文吧，就不在此翻译了。Read more：http://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "http://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-29 09:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么 async fn in traits 不好实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果您的公司拥有大量存储库，而您的工作涉及在许多存储库之间跳转，那么git-workspace可以通过以下方式为您节省一些时间：\n与Github，Gitlab.com或Gitlab轻松同步\n保持项目的名称一致并使用正确的路径📁\n自动为fork设置上游️\n将已删除的存储库移至归档目录💾\n允许您立即访问任何存储库\n在所有项目上并行执行git fetch\nRepo：https://github.com/orf/git-workspace" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/orf/git-workspace" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-29 09:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "git-workspace - 同步多个提供商的个人和工作git仓库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "CLI pong的克隆，使用crossterm和specscrate在终端上打乒乓球的一款小游戏Repo：https://github.com/Noah2610/pong-cli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Noah2610/pong-cli" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-29 09:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pong-cli - 在终端上打乒乓球" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust的跨平台UI窗口小部件库，使用OpenGL作为其渲染引擎。从许多GUI库中汲取灵感Repo：https://github.com/KenSuenobu/rust-pushrod/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/KenSuenobu/rust-pushrod/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-29 09:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-pushrod - 用于Rust的跨平台3D渲染GUI小部件库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read morehttps://github.com/seanmonstar/warp/commit/5c269562a823c5340f3dfc14bdd11af592c03dea" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-27 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用commit範例教你使用async與std::future::Future" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目前可以使用 sqlite, postgres, mysqlRead morehttps://github.com/ivanceras/rustorm" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-27 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustorm 0.15" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "他想異步地對數據庫執行各種操作如果使用了 async_trait 這個庫等同於這會有一些問題變成 impl Trait in traits 要 GATs generic associated typehttps://github.com/rust-lang/rfcs/blob/master/text/1598-generic_associated_types.md他這邊要實作就要用用生命週期的原因是異步fn總是捕獲所有參數因此我們返回的任何類型都將＆self作為回傳的一部分，因此它必須包含生命週期。如果您要編寫通用代碼，則可能需要將生成的結果指定為Send。像這樣要避免問題 #1 跟 #2, async-trait 讓 async fn返回dyn Future而不是impl Future。要避免問題 #3, async-trait 你可以選用 Pin<Box<dyn Future + Send>> （您選擇用“Send”）。 這幾乎是最常用的默認值。這個問題解法非常複雜，小編我難以完全理解，請有興趣的人可以去看看。Read morehttp://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-27 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "為什麼async函數很難寫？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read morehttps://www.wezm.net/technical/2019/10/useful-command-line-tools/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-27 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "圖形化介紹各種好用的cmd工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "即將進 nightly 版本Read morehttps://github.com/rust-lang/rust/issues/49146#issuecomment-546614359" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-27 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "const fn 中使用 if 跟 match" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Zstandard是由Facebook的Yann Collet開發的一個無失真資料壓縮演算法。該名稱也指其C語言的參考實現。第1版的實現於2016年8月31日Read morehttps://github.com/KillingSpark/zstd-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-27 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "zstd 壓縮演算法實作" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "實作1實作2論文https://github.com/senderista/sorted-vec\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-27 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "已序陣列  插入/移除 時間複雜度 O(√N)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "filite是一个简单，轻巧且独立的pastebin，URL shortener和文件共享服务，可以托管文件，重定向链接并存储文本。Githubhttps://github.com/raftario/filite" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-26 22:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "filite：简单，轻巧且独立的pastebin，URL shortener和文件共享服务" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "此crate包括：\nVector时钟实现\n基于“Scalable and Accurate Causality Tracking for Eventually Consistent Stores”论文的Vector实现\nGithubhttps://github.com/kavirajk/clock" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-26 22:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "clock：Rust实现的逻辑时钟" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "更多信息https://www.wezm.net/technical/2019/10/useful-command-line-tools/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-26 22:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "常用命令行工具的图解指南" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如何通过五个简单的演进步骤在Rust中构建计时器？更多信息https://medium.com/programming-servo/programming-servo-the-incredibly-shrinking-timer-7283ae2a2669--https://rust.cc/section?id=ce0fe0fb-1ac6-413a-b535-59e4a8e74b6c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-26 22:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Servo编程：不可思议的缩减计时器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "可以直接幫你編譯c程式然後直接執行這樣就可以把c當腳本一樣執行了Read morehttps://github.com/igor-petruk/scriptisto" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-25 22:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Scriptisto 一個語言無關的輔助程式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本專題集合了Rust生態中令人興奮（據專題作者描述）的工具和動態。Read morehttps://rust-fosdem.github.io/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-25 22:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust devroom：一個研討會在 2020/02/02 星期日 布魯塞爾，比利時" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read morehttps://blog.rust-lang.org/inside-rust/2019/10/24/pnkfelix-compiler-team-co-lead.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-25 22:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "歡迎pnkfelix作為編譯器團隊的共同負責人！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "這些hackfest的目標是改善Rust與GNOME庫之間的交互。會出現在新版的 gtk-rsRead morehttps://blog.guillaume-gomez.fr/articles/2019-10-24+GNOME%2BRust+Hackfest+%236+in+Roma" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-25 22:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust+GNOME hackfest" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我的理解是像C++裡的泛型偏特化以下面的例子為例可以特化為任何實作Display trait的類型或是直接針對 String 做特化行為Read morehttps://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-25 22:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "例子學習：基於Autoref的穩定特化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "問題原因docs.rs需要先將構建的文檔存儲在文件系統上，然後再將其上傳到數據庫，並且要在/opt/docs-rs-prefix/documentations目錄中進行。docs.rs從來沒有清除過該目錄，因此隨著時間的流逝，它愈來愈大，直到無法執行。雖然我們有寫定期清除臨時目錄的代碼，但是從未設定過清除引起中斷的目錄的代碼。解法由於該目錄不包含任何需要保留的資料，因此我們直接清除，然後重新啟動了服務器。事後處理要有通知硬碟使用到90%了，每次建構失敗也要有通知。Read morehttps://blog.rust-lang.org/inside-rust/2019/10/24/docsrs-outage-postmortem.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-25 22:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "docs.rs 出問題後的事後處理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "簡單來說問題出在記憶體配置演算法的差距結果就是時間的只要三分之一Read morehttps://medium.com/@rajasekar3eg/fastspark-a-new-fast-native-implementation-of-spark-from-scratch-368373a29a5c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-25 22:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "FastSpark Apache Spark 的新實現" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "zhanglianghui" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者通过几个月的尝试在探索用 Rust 实现 Apache Spark 的可行性，发现优化结果非常显著。初步的 bechmark 显示在非常好的情况下会有 6 至 8 倍的速度提升，平均情况下针对 Dataframe 有 2 至4 倍的提升，作者正在呼吁社区为项目贡献代码。详细的 bechmark 性能分析报告查看 https://medium.com/@rajasekar3eg/fastspark-a-new-fast-native-implementation-of-spark-from-scratch-368373a29a5c项目链接：https://github.com/rajasekarv/fast_spark" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-23 21:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "FastSpark: 用 Rust 从零实现的更新更快的 Apache Spark" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "zhanglianghui" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Crossterm 是一个命令行终端操作库，可以用来改变颜色、移动光标、读取和解析输入数据、调整终端大小的跨平台工具。在 0.12.1 这个新版本中，所有的子包都被合并到 crossterm 中，并且这些被归档或者启用。另外还修复了许多的 bug，更新了一些 features 是的可以在跨平台上面使用。包下载链接：https://crates.io/crates/crossterm/0.12.1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-23 21:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Crossterm 0.12.1 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "zhanglianghui" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "splines 是一个数学工具包，是的样本差值变得更加容易，通过控制一些关键点来分段定义数学曲线。3.0.0 版本的主要更新是，采样现在要求 Linear<T>的键值为Interpolate<T>，这可以用于缓解一些插值模式(特别是贝塞尔)。包更新链接：https://github.com/phaazon/splines/blob/master/CHANGELOG.md#300" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-23 21:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "splines-3.0.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "zhanglianghui" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "详细分析了 Rust 编译比较慢的原因及时间到底花在了哪里。报告链接：https://wiki.alopex.li/WhereRustcSpendsItsTime\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-23 21:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustc 编译的时间花在了哪里" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nBandot是一款基于polkadot建立的发币抵押稳定币。目前已获得基金会的grant，相信也是中国第一款波卡生态的稳定币获奖项目，为了支持项目去中心化发展，现在开始招募开源代码贡献者。唯一要求就是喜欢参与开源项目开发的。\n \n奖励：\n根据开发者对于源码的贡献程度，我们会拿出部分DOT给予奖励。\n \n感兴趣的伙伴可以直接和我联系微信：csschan1120\n\n诸位Rust同仁，你想用Rust 写系统软件（OS，Hypervisor等 ）吗？如果是，同时你具有一定OS或虚拟化或JVM/编译器等方面的经验，请加入蚂蚁金服系统部吧？简历传送shoumeng.ysm@antfin.com或者微信32713933。我们正在做一些好玩的东西（比如https://github.com/occlum/occlum），欢迎一起来。我们在招p7，p8，p9。\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-22 23:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "开源rust开发者招募" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对于从事大量处理大量视频、图形和实时要求的广告素材编码合同的人来说，RLSL一直是最令人兴奋的项目之一。用Rust编写图形和计算着色器的想法非常完美。Embark也看到了游戏开发者在此方面的潜力，这在很大程度上是有意义的。仅在CPU和GPU之间共享Rust代码的功能就非常有用。观看介绍文稿了解更多https://docs.google.com/presentation/d/1_cB-sxUusYVoCYdXnqwAg2u3-lrqBfgrUj205ytxYaw/edit#slide=id.g631c26ea71_2_10" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-22 23:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RLSL：SPIR-V编译器的精髓" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GNvim和Neovim GUI旨在提供丰富的代码编辑体验，从而避免不必要的Web膨胀。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-22 23:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Neovim的GUI" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n不需要electron，在GTK上编译。\nLigatures\n自定义光标工具提示功能。\n实现了许多nvim外部功能\n登陆GitHub了解更多https://github.com/vhakulinen/gnvim" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-22 23:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "特点" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n对cfg属性的初始化支持。现在，该插件可以评估cfg属性中的一些表达式。\n\n宏调用中的代码改进Edit | Extend Selection和View | Type Info操作。如果将宏调用中的一段代码扩展为完全相同的代码，则相应的动作将以与宏调用之外的代码相同的方式起作用。\n\n\n为拼写检查器加入了Rust专用词典。它应该在一些常用的Rust关键词上修正错误肯定警告注释deref。可以在Preferences | Editor | Spelling设置面板中配置拼写检查器词典\n\n\n改善外部库的外观。\n\n为拼写检查器加入了Rust专用词典。它应该在一些常用的Rust关键词上修正错误肯定警告注释deref。可以在Preferences | Editor | Spelling设置面板中配置拼写检查器词典改善外部库的外观。点击这里查看更多更新内容https://intellij-rust.github.io/2019/10/21/changelog-108.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-22 23:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "INTELLIJ RUST更新日志" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有没有一款工具，提供一个在线面试板，能够让优秀的技术人员现场编程，与面试官探讨交流代码，从而迅速展示能力，做到真正的 “屁话少说，放码过来”。站在企业的角度，最怕的是用传统的问答手段招到一个面试还不错的技术人员后，两个月后发现他无法胜任，又得请他离开，这期间的成本高的可怕。基于上述种种，我们创造了 ShowMeBug。2019.10.21更新后，ShowMeBug支持 C# 和 Rust 面试环境登陆ShowMeBug官网了解更多https://www.showmebug.com\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-22 23:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ShowMeBug -- 超级好用的实时编程环境程序员面试助手" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个Rust编程语言中设计模式和习惯用法的开源仓库。Repo：https://github.com/rust-unofficial/patterns" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-unofficial/patterns" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-21 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "patterns - Rust的设计模式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这次是一个很长的问题，!首先，我们将讨论Linux进程的一些细节，然后像往常一样，通过一些代码示例回顾以下场景:\n等待子进程的终止；\n等待孙子进程终止；\n捕捉父进程终止。\n更多细节可以阅读原文：https://iximiuz.com/en/posts/dealing-with-processes-termination-in-Linux/?utm_medium=reddit&utm_source=r_rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://iximiuz.com/en/posts/dealing-with-processes-termination-in-Linux/?utm_medium=reddit&utm_source=r_rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-21 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Linux中处理进程终止(带有Rust的例子)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个导航工具，我称之为“堆栈跟踪流”。对于已经运行的进程，它允许您研究堆栈跟踪是如何变化的——哪些函数调用了哪些函数，调用的顺序是什么。它允许您在外部编辑器中打开感兴趣的函数。它还支持对不感兴趣的视图函数进行隐藏。Repo：https://github.com/baranowski/stacktraceflow" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/baranowski/stacktraceflow" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-21 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "stacktraceflow - StackTraceFlow数据可视化工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ggez是一个Rust库，可轻松创建游戏。更具体地说，ggez是一种轻量级的跨平台游戏框架，用于制作2D游戏。它旨在基于LÖVE游戏框架（的原始版本）实现API。这意味着它包含基本的和便携式的2D绘图，声音，资源加载和事件处理，但是更好的细节和性能特征可能与LÖVE不同。Repo：https://github.com/ggez/ggez" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ggez/ggez" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-21 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ggez - 轻松地创建一个游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个SS的Rust实现版本，懂的都懂，不便做过多描述Repo: https://github.com/shadowsocks/shadowsocks-rust\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/shadowsocks/shadowsocks-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-21 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "shadowsocks-rust - SS科学上网" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有人觉得现在 Rust 最大的弱点就是 GUI 体验不够好, 所以想以 Rust 为第一语言开发一个 UI 框架。 目前正在招募成员如果对这个工作组感兴趣可以继续了解一下https://github.com/ruiwg/about-us" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-20 21:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust UI 工作组" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在这篇文章中， 作者以一个 JS 开发者的角度对比 JS 和 Rust，并以此来介绍 Rust 的一些特性。 同时作者也推荐 web 开发者了解一下 Rust WebAssembly 。https://dev.to/codegram/rust-for-js-developers-1im9" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-20 21:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "写给 JS 开发者的 Rust 入门教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "国外小姐姐 Amy K 绣的 Ferris 十字绣，看起来还挺可爱的https://twitter.com/wanderingelf14" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-20 21:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 吉祥物十字绣" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "此次的更新主要是对 const generics 可靠性的优化。包括：\n扩展测试包\n解决了类型推断的问题\n解决了在宏中使用 const generics 的一些问题\n......\nRead Morehttps://github.com/rust-lang/rust/issues/44580#issuecomment-544155666\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-20 21:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "const generics 最新进展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "博文是使用具有不稳定特性的 Rust 1.40 nightly (518deda77)编写的。某些不稳定的功能可能已经改变或删除。模拟器是好东西，他们帮助保存游戏，改进游戏，并帮助使游戏更容易访问。最重要的是，制作仿真器是一种宣泄和满足技术挑战!更多实现请看原文：https://kyle.space/posts/i-made-a-nes-emulator/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-19 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 rust 实现 NES 模拟器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个库是简单的持久性通用 HashMap/kv 存储，使用Persy 索引 API。它目前处于测试状态。使用示例 1：示例 2：了解更多请看：https://github.com/zserik/perkv" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-19 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "perkv - 可持久化的 kv 存储(基于 Persy 0.7)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目前 fancy-regex 更新到了 0.2.0版本，这是一个构建在 regex crate 之上的库。它使用了一个混合的regex实现来支持一组相对丰富的特性。它增加了对高级特性的支持，比如向前/向后查找和回溯，这些特性在纯粹基于nfa的实现中是不受支持的(例如 RE2)。了解更多请看:https://github.com/fancy-regex/fancy-regex" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-19 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "fancy-regex：用于具有查找和反向引用的正则表达式的纯 rust 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现场视频：https://t.co/fC9fnERyvd?amp=1\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-19 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "巴塞罗那 rust 工作组 ppt 分享" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read morehttps://www.reddit.com/r/rust/comments/djb77f/docsrsstdcorealloctestproc_macro_now_redirects_to/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-18 23:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "現在內建的crate doc可以快速指向官網" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "這是一個使用hash並在編譯時生成查表的庫。Read morehttps://github.com/sfackler/rust-phf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-18 23:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-phf v0.8.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用rust寫的一個Reddit like的網站框架Read morehttps://github.com/dessalines/lemmy/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-18 23:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Lemmy" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "啟動 5個 node Kubernetes 的 cluster 只要40秒Read morereddithttps://github.com/saschagrunert/kubernix" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-18 23:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "kubernix" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read morehardwarehttps://droogmic.github.io/microrust/index.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-18 23:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "中學的機器人課，rust線上文件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "這是一個rustc的腳本在 .cargo/config  寫下你的指令然後 cargo xtask task-nameRead morehttps://github.com/matklad/cargo-xtask/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-18 23:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "xtask" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "給喜歡openapi的朋友Read morehttps://github.com/alamminsalo/ram\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-18 23:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Unveiling ram - 一個 openapi code 產生器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rudr是一个开放应用模型（Open Application Model，OAM）的实现，它允许用户轻松地在任何Kubernetes集群上部署和管理应用程序，使应用程序开发者和运营者相分离。Githubhttps://github.com/oam-dev/rudr" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-17 20:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rudr：Rust中Kubernetes的OAM插件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "通过“left-pad index”（最近下载次数/crate的大小），计算哪些第三方crates是良好的，作为加入标准库的候选者。基于此，已有一个关于matches宏的PRhttps://github.com/rust-lang/rust/pull/65479更多详情https://internals.rust-lang.org/t/calculating-which-3rd-party-crates-are-good-candidates-for-std-inclusion-via-left-pad-index/11129/2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-17 20:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust标准库的候选者" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "“依赖关系很糟糕”的结果是，库作者开始从其依赖库中复制和粘贴代码，以使它们的依赖关系计数变小。如果你认为拥有更多依赖项会使你的构建速度变慢......实际上可能会使你的构建速度更快。[参考文章](https://blog.rust-lang.org/2019/09/26 /Rust-1.38.0.html#pipelined-compilation)更多信息https://threadreaderapp.com/thread/1184601079096303616.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-17 20:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Twitter关于依赖的讨论" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Raygon，Rust编程语言编写的一个高性能CPU路径跟踪器，它包括路径跟踪，双向路径跟踪和VCM。文中介绍了一些已实现或改进的功能，并显示了一些最新渲染，然后讨论了Raygon的未来以及如何提供帮助。更多信息https://github.com/raygon-renderer/readme/blob/master/blogs/month-1.md--https://rust.cc/section?id=ce0fe0fb-1ac6-413a-b535-59e4a8e74b6c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-17 20:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Raygon进展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "zhanglianghui" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果没有安装过，可以通过get rustup安装，如果已经安装过 Rustup，可以采用以下方式更新：https://rustup.rs/这个版本的亮点是对profiles的支持，能够获得您需要的所有组件的最新可用信息，以及对rustup doc命令的改进。可以通过changelog查看所有更改的列表。https://github.com/rust-lang/rustup.rs/blob/master/CHANGELOG.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-17 10:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rustup 发布 1.20.2 版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "zhanglianghui" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这次发布了几个核心的并发宏，引入了异步版本的Path和PathBuf，并且增加了近100个其余的提交。示例：从文件系统中异步读取目录：协作地重新调度执行程序上的当前任务：创建一个时间间隔数据流：详情请查看 Githubhttps://github.com/async-rs/async-std/releases/tag/v0.99.10" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-17 10:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-std v0.99.10发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "zhanglianghui" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "David Beazley用Python实现了一个WASM解释器，然后运行Rust编译的WASM游戏，这个例子是一个非常好的WASM内部介绍。更多请查看 YouTubehttps://www.youtube.com/watch?v=r-A78RgMhZU" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-17 10:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用 Python 实现的解释器运行 Rust 编译的 WASM 游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "zhanglianghui" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Onefetch是一个用 Rust 实现的命令行工具，它直接在终端上显示关于Git项目的信息。Onefetch支持近50种不同的编程语言。详情查看GitHub Onefetchhttps://github.com/o2sh/onefetch\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-17 10:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Onefetch 终端展示 Git 项目信息的命令行工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在v0.2我们实现了所有运算符和可视线程的安全性之后，RxRust现在可以通过调度程序跨线程传递任务。这样，所有用户提供的闭包都必须满足Send + Sync + 'static，甚至永远不需要使用调度程序和多线程。现在，我们移除了bounds的Sync，Send和'static，并添加了新的特性IntoShared。这样可以为本地线程实现运算符，并实现IntoShared将其转换为线程安全的运算符。默认情况下，RxRust始终使用单线程版本以获得最佳性能，如果需要在线程中传递IntoShared对象，则使用RxRust 将本地对象转换为线程安全的对象。重要变化移除 RxFn 和 RxValue\n\noperators: 移除 Multicast\n\n\nobservable: 移除 ObservableOnce\n\n\nobservable: observable::from_vec 和 observable::from_range 函数整合到 宏observable::from_iter! .\n\n\nobservable: observable::empty函数变为宏observable::empty! .\n\n\nobservable: observable::of 函数变为宏 observable::of! .\n\n\nobservable: observable::from_future函数变为宏 observable::from_future!\n\n\nobservable: observable::from_future_with_err 函数变为宏observable::from_future_with_err!\n\n\nobservable: observable::interval 函数变为宏observable::interval! \n\noperators: 移除 Multicastobservable: 移除 ObservableOnceobservable: observable::from_vec 和 observable::from_range 函数整合到 宏observable::from_iter! .observable: observable::empty函数变为宏observable::empty! .observable: observable::of 函数变为宏 observable::of! .observable: observable::from_future函数变为宏 observable::from_future!observable: observable::from_future_with_err 函数变为宏observable::from_future_with_err!observable: observable::interval 函数变为宏observable::interval! 详细信息前往GitHub查看https://github.com/M-Adoo/rxRust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-15 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RxRust v0.3更新发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n\n编译速度更快。 提前将宏编译为Wasm，可以节省该宏的所有下游用户的时间，他们不必自己编译宏逻辑或其依赖项。\n\n\n隔离性。 Watt是100％安全的代码，具有零依赖性。在此环境中代码运行时，宏与外部世界的唯一可能的交互限于话费token和生成token。不管宏本身可能包含多少不安全代码！由于Rust编译器或标准库中存在模块错误，因此宏除了随机播放令牌外不可能做任何其他事情。\n\n\n确定性。 从系统构建的角度来看，由Wasm支持的宏具有以下优点：可以将其视为从输入到输出的纯粹确定性函数。隐式依赖（例如通过文件系统）是不存在的，构建系统对隐式依赖不可见或不考虑隐式依赖。\n\n编译速度更快。 提前将宏编译为Wasm，可以节省该宏的所有下游用户的时间，他们不必自己编译宏逻辑或其依赖项。隔离性。 Watt是100％安全的代码，具有零依赖性。在此环境中代码运行时，宏与外部世界的唯一可能的交互限于话费token和生成token。不管宏本身可能包含多少不安全代码！由于Rust编译器或标准库中存在模块错误，因此宏除了随机播放令牌外不可能做任何其他事情。确定性。 从系统构建的角度来看，由Wasm支持的宏具有以下优点：可以将其视为从输入到输出的纯粹确定性函数。隐式依赖（例如通过文件系统）是不存在的，构建系统对隐式依赖不可见或不考虑隐式依赖。详细信息前往GitHub查看https://github.com/dtolnay/watt" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-15 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Watt：由wasm支持的proc宏（概念验证），编译时间几乎为零" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "调度程序的作用是调度工作。一个应用程序被分解为多个工作单元，我们将它们称为任务。当任务可以进展时，它是可运行的；而在外部资源上被阻塞时，该任务将不可可运行（或空闲）。任务是独立的，因为任何数量的可运行任务都可以同时执行。调度程序负责在运行状态下执行任务，直到它们过渡回空闲状态为止。执行任务意味着需要为任务分配CPU时间（一种全局资源）。有许多不同的建模调度程序的方法，每种方法各有利弊。Tokio的第一个工作窃取调度程序于2018年三月问世，这是基于许多前者不正确的假设的首次尝试。有关Tokio的更多信息前往官方博客查看https://tokio.rs/blog/2019-10-scheduler/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-15 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使Tokio调度程序快10倍的方法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust London很荣幸地宣布本月特别的LDN对话。 我们将欢迎爱尔兰都柏林的Terminus DB团队。TerminusDB是为数据人员构建的开源数据库。 它是专门为网络时代设计的模型驱动的图形数据库。TerminusDB大大减少了构建任何共享，操作或编辑数据的应用程序所需的时间和精力。他们将展示TerminusStore，它们的快速三重存储-由主语，谓语和对象组成的数据，其中对象可以是某些值或节点，是在Rust中实现的。我们还将举行Florian Doyan的联合主题演讲，该人是Rust London社区成立时间最长，经验最丰富的成员之一。议程：\n欢迎与交流•新闻和公告\n演讲者：加文·门德尔·格里森博士\n演讲嘉宾：Florian Doyan\n演讲者：Matthijs van Otterdijk\nCloudflare在威斯敏斯特地铁站附近的办公室接待我们。提供比萨饼和饮料。Read more: https://www.meetup.com/Rust-London-User-Group/events/265590044/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.meetup.com/Rust-London-User-Group/events/265590044/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-14 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust十月伦敦会谈" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RxRust是响应式编程扩展使用在你的cargo.toml添加以下内容示例Repo: https://github.com/M-Adoo/rxRust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/M-Adoo/rxRust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-14 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RxRust - Rust响应式编程扩展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "安全地回收内存，同时避免编译器优化，此crate实现了一种可移植的方法，可确保不会被编译器“优化”的技术来安全地将内存回收。\ncrates.io: https://crates.io/crates/zeroize/1.0.0\ndocs.rs: https://docs.rs/crate/zeroize/1.0.0\nGitHub: https://github.com/iqlusioninc/crates/tree/develop/zeroize\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-14 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "zeroize v1.0.0 - 仅使用稳定的编译器内部函数即可安全地将内存回收-WASM友好" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该库为标准库的std::fmt::Display特性提供了一个方便的派生宏。编译器支持：需要rustc 1.31+示例Repo：https://github.com/yaahc/displaydoc\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/yaahc/displaydoc" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-14 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "displaydoc - 派生宏，用于通过文档注释和字符串插值实现显示特性" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pcap-file发布V1.0版本。它为PCAPNG添加了阅读器和流解析器，为PCAP添加了流解析器。更多信息https://crates.io/crates/pcap-file" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-13 13:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pcap-file V1.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "amethyst-imgui发布V0.5.3版本。更多信息https://github.com/amethyst/amethyst-imgui/releases/tag/0.5.3" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-13 13:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "amethyst-imgui V0.5.3" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这项工作通过更改仅包含编译libstd的步骤，最小化rust-std dist组件。更多信息https://github.com/rust-lang/rust/pull/64823不过这影响了一些编译目标，为解决它，请通过Github issue报告你发现的任何其他问题！https://github.com/rust-lang/rust/issues/65335" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-13 13:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "最小化rust-std组件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "当前，可以使用use module::*，导入模块中所有内容，并且可以使用use Trait as _导入trait的所有实现。但是，将use module::* as _，当前会报错。该RFC旨在改变这一点，实现导入模块中所有trait的所有实现的含义。参与更多https://github.com/rust-lang/rfcs/pull/2782--https://rust.cc/section?id=ce0fe0fb-1ac6-413a-b535-59e4a8e74b6c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-13 13:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "[RFC] 实现全部导入" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #videoRust初学者的福音，siscia 在YouTube上发布了Rust教学视频的第一集。期待他能出更多优秀的视频，丰富社区中Rust的学习资料。https://www.youtube.com/channel/UCr0hPyQ5Fh9IWcKfxxJJDAgRead Morehttps://www.youtube.com/watch?v=jKNGZIAtzgs&feature=youtu.be" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-12 19:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "你想要的Rust视频教程【更新中】" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #crateChange Log:\nLazy propagation\nLazy requirement validation\nApp::write_help takes &mut self now\nApp::override_usage No longer implies \\t which allows multi lined usages\nIn usage parser, for options [name]... --option [val] results in ArgSettings::MultipleOccurrences but --option [val]... results in ArgSettings::MultipleValues and ArgSettings::MultipleOccurrences. Before both resulted in the same thing\nAllow empty values no longer default\nUseValueDelimiter no longer the default\nMultiple delima fixed (vals vs occurrences)\nAbility to mutate args once they've been added to an App\nApp::args and App::arg are more generic\nCan unset global settings\nInstead of adding arg with long --help or --version you can use App::mut_arg to override things\n\nCaution, must fully override\nNo longer forces auto-handle of help/ver however if still desired AppSettings::NoAuto{Help,Version}\n\n\n\nCaution, must fully override\nNo longer forces auto-handle of help/ver however if still desired AppSettings::NoAuto{Help,Version}\n关于废弃/新增的API和数据结构的变化，请看点击下面链接。Read Morehttps://github.com/clap-rs/clap/blob/master/v3_changes.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-12 19:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "clap 3.0快要发布了，新特性一览" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #videoJon Gjengset在YouTube上发布了Rust TCP的视频（直播写码），只看前三十分钟就能收获满满，适合想学习中高级Rust知识的同学。https://www.youtube.com/channel/UC_iD0xppBwwsrM9DegC5cQQRead Morehttps://www.youtube.com/watch?v=bzja9fQWzdA" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-12 19:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust TCP视频教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#crate #crypto有231个Rust Crate使用了这个未维护的Rust加密包rust-crypto，这个包自2016年就没维护过了，作者也没有回应，RustSec推荐大家用这些包替代它。https://crates.io/crates/rust-crypto/reverse_dependenciesRead Morehttps://rustsec.org/advisories/RUSTSEC-2016-0005.html\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-12 19:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 加密包" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "上禮拜有po過了 但作者做了一些更新Read morehttps://curiosityoverflow.xyz/posts/linda/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-11 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用rust寫http server part1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "A one stop shop for all things related to COM programming in Rust.Read morehttps://github.com/microsoft/com-rs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-11 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "重磅：微軟發布了一個操作 com 体系的crate" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "減少memcpy的呼叫次數減少回傳值得大小優化類型檢查與特徵解析 讓與法術的節點變少Read morehttps://blog.mozilla.org/nnethercote/2019/10/11/how-to-speed-up-the-rust-compiler-some-more-in-2019/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-11 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2019年rust怎麼編譯得更快的" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "這是一個28kb的輕量庫作者只提供了最簡單底層的apiRead morehttps://github.com/psychon/x11rb\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-10-11 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust 的 x11 binding" }, "type": "text" }], "type": "title" } },]
