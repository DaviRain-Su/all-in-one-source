export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 Rust 代码使用 SIMD CPU 指令优化，学习如何快速检查编译器的汇编程序输出，以及修改 Rust 代码以生成更快程序的方法。其中 SIMD 是单指令多数据 Single Instruction Multiple Data 的缩写。博客文章，https://nickwilcox.github.io/blog/autovec/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://nickwilcox.github.io/blog/autovec/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-17 13:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "利用 Rust 的自动向量化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "async-graphql，是用 Rust 语言实现的 GraphQL 服务端库。教程，https://async-graphql.github.io/async-graphql/zh-CN/introduction.htmlGithub 链接，https://github.com/async-graphql/async-graphql示例，https：//github.com/async-graphql/exampleshttps://github.com/async-graphql/examples基准测试，https://github.com/async-graphql/benchmark" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/async-graphql/benchmark" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-17 13:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-graphql" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个视频是 Jonathan Turner 教 Jason Turner 有关 Rust 基础知识的直播视频。Jonathan 是 NuShell 的作者，而 Jason 是一位 C++ 专家。视频链接，https://www.youtube.com/watch?v=EzQ7YIIo1rYhttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=EzQ7YIIo1rY" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-17 13:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "[视频] Rust 基础知识" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "裡面討論了 let, const,  std::include_str!等等不同關鍵字的用法Read morehttps://github.com/paulkernfeld/global-data-in-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-17 13:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust全域變數教學" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "這是一個用Rust實作的closures可以讓你把C寫的比較好用？Read morehttps://github.com/Xaeroxe/c-closures-rs/tree/master/example" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-17 13:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "C closures" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "這裡面講解了Rust各個重大的功能更新。Read morehttps://blog.rust-lang.org/2020/05/15/five-years-of-rust.html\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-17 13:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 五年了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "deno.land 中的有很大一部分核心代码是使用 Rust 实现的，现在 deno 已经正式发布 1.0 版本啦 🎉🎉🎉https://deno.landDeno 是一个新的运行时，用于在 Web 浏览器之外执行 JavaScript 和 TypeScript。Deno 也有许多 Rust API，比如说 deno_core 和 rusty_v8 crate。这些 API 将继续行迭代。更多信息请看官网介绍：https://deno.land/v1。deno 开源代码仓库：https://github.com/denoland/deno" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-15 10:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Deno 1.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "已经有几种通用运行时可用于在 Rust 程序中运行 Wasm【如：https://github.com/bytecodealliance/wasmtime】。 这些运行时为您提供了一个可以运行任意代码的虚拟机，这与细节区分应用程序运行于哪个平台是有区别的。详细请看博文：http://adventures.michaelfbryan.com/posts/wasm-as-a-platform-for-abstraction/?utm_source=users-forum&utm_medium=social&utm_campaign=wasm-platform-for-abstraction" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-15 10:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何使用 WASM 作为抽象平台" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个系列博客，在作者的上一个博客中，他使用 tmq（https://github.com/cetra3/tmq） 实现了作业队列。 本篇博客作者将使用 tokio-serde 而不是 tmq 来构建具有较小库占用空间的作业队列。详情请看：https://cetra3.github.io/blog/implementing-a-jobq-with-tokio/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-15 10:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Tokio-Serde 实现作业队列" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "NuShell 是 Rust 编写的传统 Unix 与现代开发相结合的 Shell，更多细节请看博文https://notamonadtutorial.com/nushell-the-shell-where-traditional-unix-meets-modern-development-written-in-rust-caf92c2c7c98" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-15 10:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "实访 NuShell 作者" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "This guide explains how you can use \"global data\" in Rust. When I say \"global data,\" I mean data that is loaded near the start of the program and is accessible in almost all of the program.Possible use cases for global data:\nApp configuration, e.g. weapon characteristics for a game\nMaking data available everywhere without needing to pass it as an argument through all functions (apply this carefully!)\nGenerating Rust code from external data\nDatabase connections... or other network resources?\nA logger, maybe\n地址：https://github.com/paulkernfeld/global-data-in-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-15 10:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Rust 中使用全局数据" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ASAP: As Static As Possible memory managementhttps://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-908.pdf剑桥大学计算机实验室技术报告，《ASAP：静态优先内存管理》" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-908.pdf" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-13 03:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "剑桥大学技术报告 - 《ASAP：静态优先内存管理》" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Make LLVM fast againhttps://nikic.github.io/2020/05/10/Make-LLVM-fast-again.html因为有报告显示LLVM V10编译Rust语言性能居然降低了10%。虽然LLVM的主要目的是编译Clang的C/C++，但是还有有必要让LLVM跑起来更快才行。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://nikic.github.io/2020/05/10/Make-LLVM-fast-again.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-13 03:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "让LLVM再次更快起来" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "2 Easy Ways To Test async Functionshttps://blog.x5ff.xyz/blog/async-tests-tokio-rust/技术文章描述测试Rust异步函数的两种简单的方法。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.x5ff.xyz/blog/async-tests-tokio-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-13 03:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "测试Rust异步函数的两种简单的方法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Writing A Wayland Compositor In Rusthttps://wiki.alopex.li/WritingAWaylandCompositorInRustWayland是Linux的下一代API，用于取代X11图形库和UI。Wayland的排版器叫Way Cooler.Wayland is Linux’s next-gen API to replace X11 for graphics and user interaction, so this was pretty cool, two next-gen technologies playing nice together.几年前曾经有过Way Cooler放弃Rust语言而改回用C语言做编程语言的事情：https://way-cooler.org/blog/2019/04/29/rewriting-way-cooler-in-c.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://way-cooler.org/blog/2019/04/29/rewriting-way-cooler-in-c.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-13 03:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust语言写Wayland排版器 - 下一代Linux的X11图形库和UI界面的组件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Comparing the safety and performance of operations in Rust and C++https://www.viva64.com/en/b/0733/C++ Is Faster and Safer Than Rust: Benchmarked by YandexYandex的Benchmarked分析结果显示：C++比Rust语言更快更安全。大家可以直接仔细看测评报告原文。这篇文章有意思。更像是站在 C++ 这边的一个高级程序员对 Rust 的吐槽（似贬实褒，找出 Rust 目前可能不足的地方）。内容目录如下：\nMyth 1. Rust's arithmetic is no safer than C++'s\nMyth 2. The only strong point of Rust is object lifetime analysis\nMyth 3. Rust's function calls touch memory without good reason\nMyth 4. Rust is slower than C++\nMyth 5. C → C++ — noop, C → Rust — PAIN!!!!!!!\nMyth 6. unsafe turns off all Rust checks\nMyth 7. Rust won't help you with C libraries\nMyth 8. Rust's safety isn't proved\nConclusion\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.viva64.com/en/b/0733/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-13 03:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust语言和C++语言安全性和性能操作对比" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "LLVM 10 has performance regressions with Rusthttps://lists.llvm.org/pipermail/llvm-dev/2020-May/141482.html[llvm-dev] 7-8% compile time slowdowns in LLVM 10[llvm-dev] LLVM 10 对Rust语言的编译性能衰退，同样的输入代码编译时间慢了7-8%。--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://lists.llvm.org/pipermail/llvm-dev/2020-May/141482.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-13 03:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "LLVM 10 对Rust语言的编译性能衰退" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust concurrency: the single-writer principlehttps://medium.com/@polyglot_factotum/rust-concurrency-the-single-writer-principle-applied-aada2cdc6fb0?source=friends_link&sk=cafc8dcf8babf4ec95b1b62ccde7e54bRust concurrency: the single-writer principleAn example of applying the single-writer principle to a concurrent Rust system.Rust分布式并发编程：single-writer原则，这篇文章解释怎么应用这个原则并给出代码例子。https://medium.com/@polyglot_factotum/rust-concurrency-the-single-writer-principle-applied-aada2cdc6fb0?source=friends_link&sk=cafc8dcf8babf4ec95b1b62ccde7e54bhttps://github.com/gterzian/single-writer" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/gterzian/single-writer" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-12 18:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust concurrency: the single-writer principle" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Multer: Async multipart/form-data parser for Rusthttps://github.com/rousan/multer-rsMulter: Rust语言的Async multipart/form-data编译器Rust语言的可以编译Async multipart/form-data content-type的编译器Multer: Async multipart/form-data parser for RustAn async parser for multipart/form-data content-type in Rust.It accepts a Stream of Bytes as a source so that It can be plugged into any async Rust environment e.g. any async server.Github: https://github.com/rousan/multer-rsDocs: https://docs.rs/multer/1.0.0/multer/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://docs.rs/multer/1.0.0/multer/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-12 18:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Multer: Rust语言的Async multipart/form-data编译器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Concurrency In Rust; Can It Stack Up Against Go's Goroutines?https://qvault.io/2020/05/11/concurrency-in-rust-can-it-stack-up-against-gos-goroutines/Go语言一个最主要的原因是因为它可以让分布式并发编程更简单，更快，更高效。随着rust语言的流行，我们来看看rust语言在分布式并发编程上怎么超越Go语言的Goroutines！One of the primary goals of the Go programming language is to make concurrency simpler, faster, and more efficient. With Rust growing in popularity let’s see how its concurrency mechanisms stack up against Go’s." }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://qvault.io/2020/05/11/concurrency-in-rust-can-it-stack-up-against-gos-goroutines/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-12 18:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust分布式并发编程; 能比Go语言的Goroutines牛吗?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Writing Python inside your Rust code — Part 3https://blog.m-ou.se/writing-python-inside-rust-3/《Writing Python inside your Rust code》 — Part 3《在Rust语言中写Python代码》 — Part 3--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.m-ou.se/writing-python-inside-rust-3/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-12 18:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Rust语言中写Python代码 — Part 3" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #denoNode.js 是一个JavaScript的运行环境，最初由Ryan Dahl开发，后来Ry退出一段时间后搞了Deno，这是一个基于Rust开发的TypeScript的运行环境，解决Node.js设计上的缺陷，并引入了新的特性，点击链接了解更多。Read Morehttps://zhuanlan.zhihu.com/p/37647644" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-11 13:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Deno 到底是什么？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nhttps://ferrous-systems.github.io/teaching-material/\nhttps://tourofrust.com/index.html\nhttps://github.com/rust-lang/rustlings\nhttps://github.com/rust-unofficial/patterns\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-11 13:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一些对Rust初学者更实用的资源" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #lamba\n精简了许多功能\nhttp模块实现了async/await标准\n下面是一个severless  lambda示例" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-11 13:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Aws lamba Rust运行时更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust@electro 用Rust控制自己键盘的背景灯，实现了一个弹性键盘球的灯光效果Read Morehttps://twitter.com/flukejones/status/1257825660669583361Repohttps://github.com/flukejones/rog-core\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-11 13:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust实现一个弹性键盘球" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章是针对异步编程的初学者的，文中包含了一个 Rust 异步编程的简短示例，使用的是 tokio runtime。作者希望通过这篇文章帮助人们更好地了解何时以及如何在 Rust 中进行异步编程。博客文章，http://jamesmcm.github.io/blog/2020/05/06/a-practical-introduction-to-async-programming-in-rust/#en" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "http://jamesmcm.github.io/blog/2020/05/06/a-practical-introduction-to-async-programming-in-rust/#en" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-10 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust异步编程，一篇实用的介绍文章" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Vorner 认为使用 SIMD 技术提高 Rust 程序的性能，可以促使更多的人使用 Rust 语言。但目前已有的库（stdsimd，packed_simd，simdeez，faster）尚不能满足在常规代码中容易地使用 SIMD，因为他提出了自己的一个计划。计划原文，https://vorner.github.io/2020/05/08/simd-library-plans.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://vorner.github.io/2020/05/08/simd-library-plans.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-10 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于 SIMD 库的计划" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rustacean Station 做的一期音频节目，介绍关于 Rust 1.42 & 1.43 新增的功能。音频链接，https://rustacean-station.org/episode/014-rust-1.42-1.43/https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rustacean-station.org/episode/014-rust-1.42-1.43/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-10 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.42 & 1.43 新增功能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "沒有生命週期，但有靜態記憶體管理Read morehttps://github.com/doctorn/micro-mitten" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-10 01:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "微型 類rust的腳本語言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "這是一個可以排列windows視窗的輔助程式demo: https://i.imgur.com/ugPMvlA.mp4Read morehttps://github.com/tarkah/grout" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-10 01:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "grout" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "這邊整理了蠻多庫的Read morehttps://www.hobofan.com/rust-interop/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-10 01:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "整理rust與其它語言合作的專案" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read morehttps://github.com/matheuslessarodrigues/verco\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-10 01:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "verco: Git/Hg tui 專注於鍵盤快捷鍵" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "清华大学操作系统课(RISC-V)以 RISC-V 为 CPU 平台实例，讲解操作系统中如何管理和协调应用程序对计算机系统中软硬件资源的使用。其中第 21 章讲异步编程，包含 Rust 异步编程的优秀设计。学堂在线课程主页：https://next.xuetangx.com/course/thu08091002729/3175284" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-07 22:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "清华大学操作系统课程推荐" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "随着 Rust 越来越受欢迎，在系统编程领域，Rust 正受更多开发者青睐。Rust OSDev主要是使用 Rust 进行操作系统开发相关的系列博客，rust-osdev.com 最近发起了 This Month in Rust OSDev 博文，回顾了在刚刚过去的四月份，社区中使用 Rust 进行系统编程开发的一些纪要。更多请看：https://rust-osdev.com/this-month/2020-04/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-07 22:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本月的 Rust OSDev" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自 Rust 嵌入式社区的实验项目，在嵌入式环境(Cortex-M edition)上实践 async fn/.await，目标是做到：no-global-alloc, no-threads runtime。目前该项目处于初期实验阶段，项目地址：https://github.com/rust-embedded-community/async-on-embedded" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-07 22:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "嵌入式 async" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "KAS GUI 是一个工具箱抽象系统，一种通用的 GUI 工具箱。项目地址：https://github.com/kas-gui/kas" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-07 22:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "KAS GUI" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-06 19:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【Rust日报】2020-05-05 - 窥探Zoom, Lambda部署, slip, rust struct　" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Zooming in on Observability with Rust and eBPFhttps://blog.redsift.com/labs/zooming-in-on-observability/网络安全大神Peter Parkanyi用Rust程序和eBPF来\"窥探\"Zoom程序的内容。最近Zoom因为新冠病毒而大火一把，而且又因为美国政府担心Zoom的服务器绕中国一圈再回到美国引发安全顾虑又大火一把。这个博文值得关注。https://blog.redsift.com/author/peter/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.redsift.com/labs/zooming-in-on-observability/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-06 19:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust程序和eBPF来\"窥探\"Zoom程序的内容。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "A sample webapp project which deploys on AWS Lambdahttps://github.com/bachrc/rust-aws-lambda一个可以部署AWSLambda服务的简易webapp。因为得到SilentByte的启发：https://silentbyte.com/writing-aws-lambda-functions-in-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://silentbyte.com/writing-aws-lambda-functions-in-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-06 19:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个可以部署AWSLambda服务的简易webapp" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Notes on Parsing in Rusthttps://blog.wesleyac.com/posts/rust-parsing学习笔记：用Rust来写编译程序。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.wesleyac.com/posts/rust-parsing" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-06 19:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "学习笔记：用Rust来写编译程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "slip 0.1.0: protect your error strings against reverse-engineeringhttps://hub.docker.com/r/michaelfbryan/mdbook-docker-imageslip 0.1.0: 保护你程序的错误代码字符串被逆向工程获取。安装：使用，直接产生秘密字符串：系统环境变量设置：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://hub.docker.com/r/michaelfbryan/mdbook-docker-image" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-06 19:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "slip 0.1.0: 保护你程序的错误代码字符串被逆向工程获取。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Type-level Programming in Rusthttp://willcrichton.net/notes/type-level-programming/Type-level Rust编程。英文的学习笔记，大家自己欣赏哈～" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "http://willcrichton.net/notes/type-level-programming/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-06 19:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Type-level Rust编程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Github Actions to build Rust Binaries Automaticallyhttps://github.com/zackify/flydb/blob/master/.github/workflows/build-binary.ymlGithub自动编译Rust二进制代码的配置文件的一个例子：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/zackify/flydb/blob/master/.github/workflows/build-binary.yml" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-06 19:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Github自动编译Rust二进制代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Understanding rust lang - structs noteshttps://www.staszewski.me/rust-struct-notes/波兰小伙子Kamil Staszewski 的Rust语言学习笔记。https://github.com/staszewski什么是struct：struct可以让我们创建有内容的数据结构，struct数据结构的写法有点类似Typescript语言中的interface接口，当然很多别的编程语言的接口的实现也很类似：要实现一个struct我们就要给它创建一个实例，我们依照它的定义用K/V方式给它赋值：至此，我们还不能直接用println!宏来打印出来，否则会遇到Player doesn't implement std::fmt::Display: Player cannot be formatted with the default formatte这样的错误。因为这里struct还没有实现它的trait，这就需要我们参照官方文档自己来实现一个。我们可以加这样的注释#[derive(Debug)]也可以用缺省的格式:?，或者在println!宏里面用花括号来表示缺省格式。然后我们可以试一试：https://doc.rust-lang.org/std/fmt/trait.Display.html#examples怎么更新数据：也可以直接给实例的某个键赋值，不过要记得加上mut关键字保证数据结构的实例可以更改：给数据结构struct添加函数（方法）：rust语言添加函数非常方便，首先它又一个可以自引用的语法&self，这个跟JS的this和Python的self非常类似。我们必须用impl关键字并加上数据结构的名字来'实现'实例，记住我们在函数内部用&self来应用数据机构本身：作者的GitHub：https://www.github.com/staszewski" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.github.com/staszewski" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-06 19:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust语言学习笔记：理解structs" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-06 19:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "michaelfbryan/mdbook-docker-image - A docker image with mdbook and several common pluginshttps://hub.docker.com/r/michaelfbryan/mdbook-docker-imagemdbook-docker-image是一个一个打包了mdbook和很多常用plugins的Docker Image，包含如下应用库：\nmdbook\nmdbook-linkcheck\nmdbook-mermaid\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://hub.docker.com/r/michaelfbryan/mdbook-docker-image" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-05 12:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "michaelfbryan/mdbook-docker-image - 一个打包了mdbook和很多常用plugins的Docker Image" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "The Safety Boat: Kubernetes and Rust - Rust at Microsoft [Microsoft Security Response Center]https://msrc-blog.microsoft.com/2020/04/29/the-safety-boat-kubernetes-and-rust/最近DeisLabs发布了一款新的软件叫Krustlet。这款工具软件可以在目前很流行的开源容器管理软件Kubernetes上运行WebAssembly模块。Kubernetes已经被很多开发商广泛的应用在云服务软件中，但是主要是由GO语言编写成的。我们常常听说很多系统级别的Rust语言编程例子，但是很少听到用Rust语言写云计算软件。这个就是一个尝试。https://deislabs.io/详情可以参考Krustlet官网：https://deislabs.io/posts/introducing-krustlet/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://deislabs.io/posts/introducing-krustlet/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-05 12:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "The Safety Boat: Kubernetes and Rust - Rust at Microsoft" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "kibi 0.2.0: a text editor in ≤1024 lines of Rust, now compatible with Windowshttps://github.com/ilai-deutel/kibi这个可配置的文本编辑器支持UTF-8，步进搜索，语法加亮，行数显示等很多功能。只用了不到1024行Rust语言代码，最小化的依赖库。Kibi现在兼容Linux，MacOS和Windows 10(beta).这个项目受一个用C语言写成的Kilo文本编辑器的启发，可以在网上找到两者比较发现更多的功能。欢迎开源参与，不过要记住1024行代码的限制。https://github.com/antirez/kilo安装Cargo就可以完成：应用：一些快捷键：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ilai-deutel/kibi" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-05 12:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "kibi 0.2.0: 一个用≤1024行Rust代码编写的文本编辑器, 现在也兼容Windows啦！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "UWisconsin course on Haskell and Rusthttps://pages.cs.wisc.edu/~justhsu/teaching/current/cs538/calendar/Rust语言编程已经进入美国大学正式课程。详情请看大学官网：https://pages.cs.wisc.edu/~justhsu/teaching/current/cs538/calendar/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://pages.cs.wisc.edu/~justhsu/teaching/current/cs538/calendar/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-05 12:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "威斯康星大学开设Haskell和Rust语言编程课" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-05 12:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "此 crate 用于产生跨越 FFI 边界且无范型的 Rust 闭包。其中结构体Closure是用 C 代码定义的通用闭包类型，可以在 Rust 中创建。crate 链接，https://crates.io/crates/c-closures" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/c-closures" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-02 23:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust FFI c-closures" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "minisudo，一个类 Unix 操作系统的小型 sudo 式特权提升（Privilege escalation）。用户可以在 TOML 文件/etc/minisudo-rules.toml中指定运行哪些程序的规则。示例：Github，https://github.com/ogham/minisudo###【视频】了解 Rust 字符串该视频适用于Rust的“高级初学者”，熟悉所有权和字符串的概念，但尚未牢牢掌握它们。Youtube 链接，https://www.youtube.com/watch?v=7I11degAElQ&feature=youtu.be--https://rust.cc/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=7I11degAElQ&feature=youtu.be" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-02 23:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "minisudo" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "微软的 Rust/WinRT 项目已经在 GitHub 开源：https://github.com/microsoft/winrt-rs。Rust/WinRT 遵循 C++/WinRT 建立的传统，即使用标准语言和编译器为 Windows 运行时构建语言投影，从而为 Rust 开发人员调用 Windows API 提供了舒服的惯用方式。更多详情请看原文：https://blogs.windows.com/windowsdeveloper/2020/04/30/rust-winrt-public-preview/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-02 16:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "微软 Rust/WinRT 预览版发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个短篇幅系列博文，分为两部分，在第一部分中，你将学习如何：在 Rust 中创建快速的 REST API 和将其连接到 PostgreSQL 数据库。而在第二部分中，我们将比较我们的应用程序和 Go 应用程序的性能。感兴趣的朋友请看原文教程：https://docs.qovery.com/guides/tutorial/create-a-blazingly-fast-api-in-rust-part-1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-02 16:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "评测 Rust vs Go REST API 性能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Typestate 是在编程语言的类型系统中对状态机进行编码的概念。尽管不是特定于 Rust，但在 Rust 编程的中也有很多地方探讨了 typestate。Typestate可以归结为四个想法：\n每个状态都表示为唯一类型。\n状态转换仅可用作相应状态类型的方法。\n进行状态转换将返回新状态类型的状态机。\n状态转换会使旧状态无效。\n如下，这是一个 send-then-receive channel 状态机：这种模式对于简单的有限状态机有效，其中确定下一个状态的逻辑很简单。本篇博文中，我将探讨确定下一个状态不是那么简单的情况。在此过程中，我们将讨论类型级编程，或者如何使用 Rust 的类型系统对类型的计算进行编码。本篇博文中的部分目标是在实践中显示类型级编程的价值。这些相同的机制已经用于更深奥的目的，例如表明 Rust 的类型系统已经实现 Turing，但我认为类型级编程确实可以帮助我们设计更好的系统！更多请查看原文：http://willcrichton.net/notes/type-level-programming/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-02 16:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 的 Type-level 编程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个版本用 Rust 实现了如下两个曲线算法。• p256: NIST P-256• k256: secp256k1 (as used by Bitcoin, Ethereum, etc)" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-02 13:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "发布：RustCrypto: p256 和 k256 v0.2.0: 纯 Rust NIST P-256 和 secp256k1 曲线算法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个思路很清奇——用属性宏来实现尾递归调用优化。类似于下面这个样子：优化后的代码为：仓库：https://github.com/samsieber/tco--Edit by Rust 日报小组 Mike" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-05-02 13:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tco: 用过程宏实现的尾递归优化能力" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "native-windows-gui ：Rust 轻量级的 windows GUI 工具包。代码使用样例：https://github.com/gabdube/native-windows-gui" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/gabdube/native-windows-gui" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-30 00:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "1 - windows GUI 工具包" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "受困于 Rust 项目编译后二进制包过大，尤其是对于嵌入式开发就更是一个问题了。作者受到 Tiny Rocket以及Minimizing Rust Binary Size的启发，在这篇博客中介绍了他是如何给GStreamer 压缩体积的。https://jamesmunns.com/blog/tinyrocket/https://www.collabora.com/news-and-blog/blog/2020/04/28/reducing-size-rust-gstreamer-plugin/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.collabora.com/news-and-blog/blog/2020/04/28/reducing-size-rust-gstreamer-plugin/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-30 00:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2 -【博客】减小 Rust GStreamer 插件的体积" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对2048游戏的轻量级 Rust 实现https://github.com/adrienball/2048-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/adrienball/2048-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-30 00:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "3 - 2048-rs" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "sonos 是一个家庭无线音响系统的品牌，这个库可以通过代码来控制 sonos。https://www.sonos.com/zh-cn/home样例：https://docs.rs/sonor/0.1.2/sonor/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://docs.rs/sonor/0.1.2/sonor/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-30 00:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "4 - sonor : 可以控制 sonos 的 crate" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【Rust日报】2020-04-28 - gRPC, Streamer, Colorus" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Intro to gRPC with Rusthttps://dev.to/anshulgoyal15/a-beginners-guide-to-grpc-with-rust-3c7o这个小哥Anshul Goyal写了一个关于gRPC入门的教程，有兴趣学习的同学们可以看看。很不错！内容提纲：\nIntroduction\nProtocol Buffer\nRust and gRPC\nCreating a Server\nCreating a Client\nStreaming in gRPC\nAuthentication\nConclusion\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://dev.to/anshulgoyal15/a-beginners-guide-to-grpc-with-rust-3c7o" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust语言gRPC入门" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cargo Bloat Action: Track Rust binary sizes across builds/pull requests using Github Actionshttps://github.com/orf/cargo-bloat-action/跟踪Github上进行了cross builds/pull操作的Rust二进制大小" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/orf/cargo-bloat-action/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cargo Bloat Action: 跟踪Github上进行了cross builds/pull操作的Rust二进制大小" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Colorous: new color scheme library for charts and mapshttps://github.com/dtolnay/colorous这个Rust语言库包提供了各种颜色色系的库，包括： sequential, diverging, Cyclical, Categorical这些颜色库是常见的额d3-scale-chromatic继承过来的。每一种颜色使用起来都很简单，通过indexi/n或者通过连续的浮点数就可以表示0 ≤ t ≤ 1：https://github.com/d3/d3-scale-chromatic\npub fn eval_rational(&self, i: usize, n: usize) -> Color\npub fn eval_continuous(&self, t: f64) -> Color\n代码例子：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/dtolnay/colorous" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Colorous: 一个用于图标和地图的颜色色系库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "(Almost) Lockless Stream Bufferinghttps://mcfelix.me/blog/shared-buffers/Tags: Rust Discord Audio Concurrency(几乎) 不用锁的Stream Buffering编程，文章讲述如何高效的分享（或保持）bytestreams。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://mcfelix.me/blog/shared-buffers/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "(几乎) 不用锁的Stream Buffering编程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "List of Rust streamershttps://github.com/jamesmunns/awesome-rust-streamingRust语言辅助学习网络直播清单，网络上比较出名的streamers包括：\n\nDavid Pedersen\n\nYouTube Channel:https://www.youtube.com/channel/UCDmSWx6SK0zCU2NqPJ0VmDQ\nTwitch Channel: https://www.twitch.tv/davidpdrsn\nGitHub,\nTwitter\nCLI Tools, Teaching\n\n\n\nFerris Streams Stuff\n\nYouTube Channel - https://www.youtube.com/channel/UC4mpLlHn0FOekNg05yCnkzQ)\nTwitch Channel -  https://www.twitch.tv/ferrisstreamsstuff\nGitHub - https://github.com/yupferris\nTwitter - https://twitter.com/ferristweetsnow\nEmulators, Demoscene\n\n\n\nFerrous Systems\n\n\nYouTube Channel - https://www.youtube.com/c/FerrousSystemsGmbH\n\n\nGitHub - https://github.com/FerrousSystems,\n\n\nTwitter - https://twitter.com/ferroussystems,\n\n\nWebsite - https://ferrous-systems.com/\n\n\nQ&A sessions, Embedded, Compiler contributions, Tooling\n\n\n\n\nJames' Office Hours\n\nYouTube Channel: https://www.youtube.com/channel/UCb48C4qqcXQpRugPbdwigZQ\nOld YouTube Channel: https://www.youtube.com/c/JamesMunns/\nGitHub: https://github.com/jamesmunns\nTwitter: https://twitter.com/bitshiftmask\nBlog: https://jamesmunns.com/\nEmbedded, CLI tools\n\n\n\nJon Gjengset\n\nYouTube Channel: https://www.youtube.com/c/JonGjengset/\nTwitch Channel: https://www.twitch.tv/jonhoo\nGitHub: https://github.com/Jonhoo\nTwitter: https://twitter.com/jonhoo\nWebsite: https://thesquareplanet.com/\nTeaching, Databases, Concurrency\n\n\n\nRyan Levick\n\nYouTube Channel: https://www.youtube.com/channel/UCpeX4D-ArTrsqvhLapAHprQ\nTwitch Channel: https://github.com/jamesmunns/awesome-rust-streaming/blob/master/twitch.tv/ryanlevick\nGitHub: https://github.com/rylev\nTwitter: https://twitter.com/ryan_levick\n\nTeaching, Web Assembly\n\n\nYoshua Wuyts\n\nYouTube Channel: https://www.youtube.com/yoshuawuyts\nTwitch Channel: https://www.twitch.tv/yoshuawuyts\nGitHub: https://github.com/yoshuawuyts/\nTwitter: https://twitter.com/yoshuawuyts\nBlog: https://blog.yoshuawuyts.com/\nAsync, Web, API Design\n\n\n\nBrandon Falk\n\nYouTube Channel: https://www.youtube.com/user/ga" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ferrous-systems.com/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust语言辅助学习网络直播达人清单" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Setup Anaconda, Jupyter, and Rust for Rust Notebookshttps://shahinrostami.com/posts/programming/rust-notebooks/setup-anaconda-jupyter-and-rust/Anaconda, Jupyter, and Rust 设置教程" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://shahinrostami.com/posts/programming/rust-notebooks/setup-anaconda-jupyter-and-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Notebooks：Anaconda, Jupyter, and Rust 设置教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "smol (@stjepang) - A small and fast async runtime for Rusthttps://github.com/stjepang/smol这个运行环境库扩展了rust语言标准类库 并结合了异步机制，仅用1500行代码写成！请大家阅读文档 并参考提供的例子这样就可以开始自己动手写具有异步运行机制的程序了。https://docs.rs/std这个运行库的异步实现机制在Linux/Android上用epoll在macOS/iOS/BSDkqueue在Windows上用wepoll分别用不同的底层技术实现。https://en.wikipedia.org/wiki/Epoll功能：\n异步TCP，UDP，Unix domain sockets，自定义的file descriptors.\n\"Send!\"执行器采用本地线程。\nWork-stealing执行器能对各种不同的workloads(负载)自适应。\n阻塞执行器可以用在包括文件，进程和标准I/O上。\n执行任务可以取消\nUserspaces Timers计时器\n代码例子：需要在examples文件夹中来运行，具体例子执行如下 --https://github.com/stjepang/smol/blob/master/examples兼容性：看这些例子可以明白smol是怎么可以跟别的异步运行库混用的，包括：  async-std,tokio, surf, reqwesthttps://github.com/stjepang/smol/blob/master/examples/other-runtimes.rs其中有一个非常重要的功能可以无缝的集成全部使用tokio作为依赖的库包，它创建一个global tokio运行库并在smol里面直接设置内容，可以通过下面的方式激活这个功能：下面是文档生成方式：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/stjepang/smol" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 14:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "smol - 一个快捷有短小精悍的Rust异步运行环境库)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Teleforking a process onto a different computer!https://thume.ca/2020/04/18/telefork-forking-a-process-onto-a-different-computer/一个用rust语言实现的细思极恐的Teleforking远程启动进程功能。大家围观，不要拿来做坏事哈！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://thume.ca/2020/04/18/telefork-forking-a-process-onto-a-different-computer/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 14:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "细思极恐的Teleforking - 在另外一个计算机\"远程启动\"一个计算进程！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cheating Higher Ranks with Traits。https://leshow.github.io/post/cheat_rank_n/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://leshow.github.io/post/cheat_rank_n/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 14:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用rust语言的Traits数据结构实现高阶排序\"欺骗\"！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-28 14:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rustRepohttps://t.co/srS6tcAyNy?amp=1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-27 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2020 年关于Rust你需要了解的" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #pythonPart 1https://blog.m-ou.se/writing-python-inside-rust-1/Part 2 可以Rust代码的Python代码中使用Rust变量了。（禁止套娃）https://blog.m-ou.se/writing-python-inside-rust-2/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-27 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Rust中写Python" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个版本的看点事：\n文件拖拽事件\n访问剪切板\n检查快捷键的工具方法 (ctrl, alt, etc.)\n非循环动画\nColor 类16进制的构造方法\nRepohttps://github.com/17cupsofcoffee/tetra" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-27 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tetra 0.3.5 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rustRepohttps://ferrous-systems.com/blog/zero-sized-references/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-27 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "嵌入式 Rust 设计模式： 零大小引用（Zero Sized References）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust这个版本的看点是：\n增加了 SSE（Server-Sent event） 的支持\n重构了中间件模块\n下个版本可能会增加 websocket 的支持Repohttps://github.com/http-rs/tide/releases/tag/v0.8.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-27 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tide 0.8 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #extensionRead Morehttps://rustcc.cn/article?id=a90f7216-f6bd-472e-8e4b-f368557c0c78\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-27 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Search Extension 0.9发布！支持搜索任意第三方crate的文档了！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "教程在这里，https://hoj-senna.github.io/ashen-aetna/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://hoj-senna.github.io/ashen-aetna/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-25 21:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个关于3D图形、Rust、Vulkan、ash的教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "DataFusion 是 Rust 原生的内存查询引擎，它是 Apache Arrow 项目的一部分。Apache Arrow 发布 v0.17.0 的文章，https://arrow.apache.org/blog/2020/04/21/0.17.0-release/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://arrow.apache.org/blog/2020/04/21/0.17.0-release/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-25 21:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "DataFusion" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "YouTube 视频，https://www.youtube.com/watch?v=2mwwYbBRJSo--https://rust.cc/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=2mwwYbBRJSo" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-25 21:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "[视频] 关于所有权，闭包和线程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章提出一種參考方式可以在嵌入式系統使用讓你可以在嵌入式系統中節省記憶體的使用Read morehttps://ferrous-systems.com/blog/zero-sized-references/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-25 15:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "嵌入式Rust模式-零空間參考" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新特色 Fallible endpoints新特色 Server-Sent Events新特色 Static file servingRead morehttps://github.com/http-rs/tide/releases/tag/v0.8.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-25 15:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tide 0.8.0 發佈了！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Nicholas 記錄了他們過去增加編譯速度的一些方法Read morehttps://blog.mozilla.org/nnethercote/2020/04/24/how-to-speed-up-the-rust-compiler-in-2020/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-25 15:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何在2020年加速Rust編譯器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 团队非常高兴地宣布 Rust 的新版本 1.43.0 发布，这个版本是相当小的的一个版本,没有新的主要功能。该版本提供了一些新的稳定的 API，以及一些编译器的性能改进以及与宏相关的小功能，请看请看官博参阅详细的发行说明，以了解本文未涵盖的其他更改：https://blog.rust-lang.org/2020/04/23/Rust-1.43.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-24 10:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.43.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家可能对 stanford 的 cs140e 课程还有印象，现在他的“高阶版”来了。佐治亚理工学院 OS lab 开设了 CS-3210 课程，主要内容是设计和实现操作系统的核心组件。地址：https://tc.gts3.org/cs3210/2020/spring/info.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-24 10:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "CS-3210 课程推荐" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Mimalloc 是 Microsoft 构建的通用的，面向性能的分配器【https://github.com/microsoft/mimalloc】。mimalloc_rust 是围绕 mimalloc 分配器的嵌入式全局分配器包装器，github 地址：https://github.com/purpleprotocol/mimalloc_rustreddit 上参与讨论：https://www.reddit.com/r/rust/comments/g6m1hp/rust_mimalloc_v0119_has_just_been_released/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-24 10:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Mimalloc v0.1.19 版本更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个标题不是重点，重点是 rebuilderd 是一个 rust 程序 _。相关讨论：https://www.reddit.com/r/linux/comments/g6fo99/arch_linux_announces_independent_verification_of/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-24 10:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Arch Linux 宣布使用 rebuilderd 对二进制软件包进行独立验证" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用 TcpStream 时，资源类型必须引用运行时才能起作用。鉴于 Tokio 在当前进程中可以运行任何数量的运行时，资源类型必须具有某种策略，通过它可以选择正确的运行时。当前，这是通过使用本地线程来跟踪当前运行时来完成的。 在许多情况下，一个进程仅包含一个运行时。 尝试从运行时之外使用资源时会出现问题。 在这种情况下，尚不清楚资源类型应使用哪个运行时，并且会引发 panic。如果你遇到相关问题，请围观：https://github.com/tokio-rs/tokio/issues/2435" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-24 10:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于 tokio 库的 runtime not found 问题的讨论" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust UI 工具库 OrbTk 发布新版本.  OrbTk的目标是快速、易用以及跨平台. 灵感来自于Flutter、React、Yew.Read Morehttps://github.com/redox-os/orbtk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-23 13:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "1 - OrbTk 0.3.1-alpha2" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "gfx-rs 是一个致力于低 GPU 编程的 Rust 项目.  wgpu-rs是基于 gfx-rs 并且更安全、更可用并且可移植性更强.https://github.com/gfx-rs/gfxRead Morehttps://gfx-rs.github.io/2020/04/21/wgpu-web.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-23 13:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2 -【博客】在 web 中使用 wgpu-rs" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "reddit 上有人发帖为 ron 疯狂打 call. 在他业余的项目中他一直被 JSON 的一些限制所困扰：\nmap 中的 key 必须是字符串\n不可以添加评论\n最后一个 item 之后不能跟逗号\nron 很好的解决了这些问题.https://crates.io/crates/ronRead Morehttps://www.reddit.com/r/rust/comments/g5rlt5/thank_you_for_ron_rusty_object_notation/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-23 13:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "3 - 感谢 ron 的作者" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read Morehttps://tc.gts3.org/cs3210/2020/spring/lab.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-23 13:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "4 - 佐治亚理工学院 CS-3210 课程实验：用 Rust 为树莓派写一个操作系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Wired Logic - a pixel-based digital circuit simulator running in a browser (Rust compiled into WASM).受wired-logic启发，wired-logic-rs是一个基于像素的数字电路模拟器，核心技术采用Rust和WebAssemblyhttps://github.com/martinkirsche/wired-logicwired-logic-rs 是怎么工作的呢？系统先对图像进行扫描，然后采集一个线路，电能源，和各种晶体管，收集成一个集合，然后对这些集合元素运行模拟仿真程序，只要确保模拟的状态不会重复就算是模拟成功。然后再把模拟仿真结果渲染在一个GIF格式的图像上。手动编译步骤：点击进入模拟例子-Goto the Online Simulatorhttps://iostapyshyn.github.io/wired-logic/更多请阅读-Read More in Project Githubhttps://github.com/iostapyshyn/wired-logic-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-21 01:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "1 - Wired Logic - 运行在浏览器上的基于像素的电子元件模拟器（用Rust语言编译成WASM)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Multiversion 0.5.0, now \"production ready\"Multiversion - 是Rust语言支持多版本函数的属性宏.https://crates.io/crates/multiversion什么是function multiversioning?大部分的CPU架构都有自己独特的指令集支持一些额外的功能。最常见的例子包括x86/x86-64上的SSE & AVX，NEON上的ARM/AArch64指令集扩展Single Instruction, Multiple Data(SIMD)。这些指令集扩展可以给某些特殊的函数提升大量的运行速度。这些特殊的功能是不能胡乱的编译到一个不支持这些特殊功能CPU的可执行文件里去的，那样往往会造成系统崩溃。Function multiversioning是一种特殊的编译方法，通过编译包含特殊功能支持的不同版本的函数能够在运行时runtime检测到这些特殊的功能并匹配不同的版本的可执行函数。Function multiversioning功能：\n动态调控，启用运行时CPU功能检测\n静态调控，避免嵌套式的重复功能检测（但允许行内嵌套）\n支持所有类型的函数，包括generic和async类型的函数\n例子：用clone属性宏来实现多版本函数，类似GCC的target_clones用multiversion和target属性宏来实现多版本函数.更多信息请点击crates官网说明-Read Morehttps://crates.io/crates/multiversion" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-21 01:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2 - Multiversion 0.5.0, 多版本函数宏，现在已经\"可以跑生产系统\"了。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "下面链接是长达40多页纸的调查报告（可能国内用户需要科学上网才能下载）\nDEVELOPER ECONOMICS:\nSTATE OF THE DEVELOPERNATION\n18th EDITION, PUBLISHED APRIL 2020\n根据2019年第四季度对超过17000名软件开发人员进行的抽样调查的趋势报告\nActive Rust developers estimated at 0.6 million (pdf, page 10)https://s3-eu-west-1.amazonaws.com/vm-blog/uploads/2020/04/DE18-SoN-Digital-.pdf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-21 01:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "3 - 软件开发者经济学：现在估计全球有60万活跃Rust程序员。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "How to install rust on Windows 10 (native)https://estada.ch/2020/4/19/installing-rust-on-windows-10-native/下面是快速安装Windows 10 2004的步骤：\nC++ Tools\n测试看看是否安装成功：然后你应该可以得到一个编译的过程并看到结果显示\"Hello, world!\"如果遇到类似cargo command not found的错误，你需要检查一下你的%PATH%看看是否设置好。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-21 01:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "4 - 如何在Windows 10系统环境安装原生Rust编程环境" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust bindings for Apache Sparkhttps://github.com/ballista-compute/ballista/tree/master/rust/examples/apache-spark-rust-bindings这里例子演示使用Ballista Rust DataFrame API运行一个Apache Spark的查询请求.Rust Client:https://github.com/ballista-compute/ballista/tree/master/rust/examples/apache-spark-rust-bindings#rust-client例子程序使用Ballista's的[Rust DataFrame](https://github.com/ballista-compute/ballista/blob/master/rust/src/dataframe.rs).创建一个逻辑查询计划，对一个CVS文件做聚合查询：当代码执行的时候collect()函数会将逻辑计划编码成protobuf格式，然后发送给在spark_settings设置中设置了服务端口并运行了Ballista Spark Executor执行器的远程服务器节点。上面的例子程序将执行显示如下结果：Spark ExecutorBallista的Spark执行器Spark Executor在收到客户端发送过来的使用protobuf格式编码的逻辑查询计划请求后翻译成如下的Spark执行计划：https://github.com/ballista-compute/ballista/tree/master/rust/examples/apache-spark-rust-bindings#spark-executor上面的例子是用到了Apache Arrow Flight协议，想了解更多请参阅SparkFlightProducer代码实现。https://arrow.apache.org/blog/2019/10/13/introducing-arrow-flight/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-21 01:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "5 - Apache Spark的Rust语言绑定" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Upgrade Rust's Android SDK to API level 16 #71123https://github.com/rust-lang/rust/pull/71123" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-21 01:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "6 - Rust语言Android SDK升级到API level 16了！(直接从level 14升级)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-21 01:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust用Rust + WASM编写的RISC-V processor仿真器，在浏览器里运行Linux。另外d0iasm 正在写一本关于用Rust实现RISC-V processor仿真器的书，https://twitter.com/d0iasm想学习计算机体系结构的同学可以来看看。RepoRead Morehttps://github.com/takahirox/riscv-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-20 13:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust + WASM编写的RISC-V处理器仿真器。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#graphicspart 3part 2part 1https://www.falseidolfactory.com/2020/04/16/intro-to-gfx-hal-part-3-vertex-buffers.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-20 13:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "基于gfx-hal的Rust图形学教程-第三部分" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #blockchain这是使用Go语言follow 《Rust开发区块链》的后续文章，内容涵盖基本功能以及设计决策，并做了两种语言的快速比较。Read Morehttps://lalot.ai/simple-blockchain-written-in-go" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-20 13:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我们在用Go开发区块链！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #graphicsRead Morehttps://bitshifter.github.io/2020/04/12/mathbench-build-timings/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-20 13:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "对常用于Rust游戏开发的数学库进行构建时间比较" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust.cc 搬国内来了，现在域名是 rustcc.cn。访问以前的域名会重定向过来。但是原来的rss好像不会收到更新了。大家使用过程中有什么问题，请直接与Mike老师联系。详细通告在这里，https://rustcc.cn/article?id=b1ccded3-0d45-4005-837c-ad54cf55ef54以及 rustcc 源回来了，欢迎大家内测。详细信息在这里，https://rustcc.cn/article?id=f5d0773e-9086-48de-aae6-f2a66a83ce35" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rustcc.cn/article?id=f5d0773e-9086-48de-aae6-f2a66a83ce35" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-19 10:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "消息：rust.cc 搬国内了，新域名是 rustcc.cn，国内访问速度大增" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者实现了一个 python! 宏，结合pyo3（一个流行的python api的rust ffi 绑定），可以让你在 Rust中编写python代码。教程是他如何编写该库。 学习宏、FFi 可以参考该库。文章，https://blog.m-ou.se/writing-python-inside-rust-1/代码，https://github.com/fusion-engineering/inline-python" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.m-ou.se/writing-python-inside-rust-1/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-19 10:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "系列轻教程：在 Rust 中写 Python 代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "The survey was available in 14 different languages and we received 3997 responses.该调查以14种不同的语言提供，我们收到了3997份回复。Overall our users indicated that productivity is still an important goal for their work (with or without using Rust). The results show the overriding problem hindering use of Rust is adoption. The learning curve continues to be a challenge - we appear to most need to improve our follow through for intermediate users - but so are libraries and tooling.总体而言，我们的用户表示，生产力仍然是他们工作的重要目标（无论是否使用Rust）。 结果表明，阻碍使用Rust的首要问题是采用率。学习曲线仍然是一个挑战 - 我们似乎最需要提高对中级用户的关注度 - 库和工具也是如此。详细结果文章链接，https://blog.rust-lang.org/2020/04/17/Rust-survey-2019.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2020/04/17/Rust-survey-2019.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-19 10:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 2019 调查问卷结果出炉" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Logos，旨在创建快速的 Lexers。此次 v0.11 版本有许多重大更改，具体参见下面链接。Github Release，https://github.com/maciejhirsz/logos/releases/tag/v0.11.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/maciejhirsz/logos/releases/tag/v0.11.0" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-19 10:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Logos 发布 v0.11" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Boa 是个 JS 引擎，新版本v0.7，大部分工作是重写解析器，新解析器速度快了67%，Github Changelog，https://github.com/jasonwilliams/boa/blob/master/CHANGELOG.md--https://rust.cc/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jasonwilliams/boa/blob/master/CHANGELOG.md" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-19 10:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Boa 发布 v0.7，快乐" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read morehttps://github.com/sunshowers/borrow-complex-key-example/blob/master/README.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-18 02:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Hash 查找不用分配記憶體的方法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用於從用戶提供的測試用例生成regex的工具Read morehttps://github.com/pemistahl/grex" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-18 02:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "grex 1.1.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "是一個製作單頁網頁的rust frameworkRead morehttps://github.com/aclueless/spair" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-18 02:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "spair: Single Page Application in Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read morehttps://github.com/rust-lang/rust/pull/71123\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-18 02:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust's Android SDK 更新到 API level 16" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自 MongoDB 官方支持的 MongoDB Rust 驱动程序，该客户端库可用于与 Rust 应用程序中的 MongoDB 部署进行交互。同时 BSON 的支持取决于社区支持的 bson 库。（目前为 alpha 版本）https://docs.rs/bson仓库 GitHub 地址：https://github.com/mongodb/mongo-rust-driver" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-16 21:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MongoDB 官方 Rust Driver" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "mini-redis 是使用 Tokio 构建的 Redis 客户端和服务器的惯用实现。目前还没有实现完全，该仓库更加丰富了 Tokio 的生态。仓库地址：https://github.com/tokio-rs/mini-redis" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-16 21:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mini-redis" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Reddit 上的网友发起的一则讨论，他在进行基准测试以优化某些代码的时候，发现基准测试结果难以理解。感兴趣的朋友可以去参与讨论：https://www.reddit.com/r/rust/comments/g29kz8/reliable_benchmarks/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/g29kz8/reliable_benchmarks/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-16 21:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "可靠的基准测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "μfmt 是替代 core::fmt 的更小，更快，更轻松的选择，项目地址：https://github.com/japaric/ufmt" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-16 21:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "μfmt 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "详情：https://yew.rs/docs/v/zh_cn/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://yew.rs/docs/v/zh_cn/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-16 00:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Yew 中文文档" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "详情：https://github.com/real-logic/aeron" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/real-logic/aeron" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-16 00:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "aeron：高效可靠的UDP和IPC信息传输模块" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "详情：https://blog.mozilla.org/nnethercote/2020/04/15/better-stack-fixing-for-firefox/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.mozilla.org/nnethercote/2020/04/15/better-stack-fixing-for-firefox/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-16 00:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【博客】Better stack fixing for Firefox" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "详情：https://jason-williams.co.uk/a-possible-new-backend-for-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://jason-williams.co.uk/a-possible-new-backend-for-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-16 00:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【博客】一个可能的 Rust 新后端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "BobQ" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Ruma is dead, long live Ruma! April 10, 2020作者：Jonas Plattehttps://www.ruma.io/news/ruma-is-dead-long-live-ruma-2020-04-10Ruma是一组由Matrix homeserver服务器，客户端和支持库组成的由Rust语言开发的软件组。Matrix是一个开放的在线通讯协议。关于这个项目的基本情况可以访问项目主页。今天有点伤感的宣布：https://matrix.org/\nRuma，也就是项目的homeserver服务器端，不再继续开发了。\nRuma项目未来将继续开发支持库包，确保这些库还能继续支持Ruma服务器及各种应用。\n如果你还对现在的Ruma homeserver开发感兴趣，可以考虑看看Conduit\n这是用了Ruma支持库写的不一样的Ruma Homeserver实现。\nhttps://paytonturnage.gitbook.io/valora/https://github.com/turnage/valoraValora是一个能作画的画笔，写的可视化构建可以：https://github.com/turnage/valora\n通过rng种子管理可以做到不断重复\n不通过改变大小就可以任意产生任意精度的像素。\n严格的类型安全的颜色语法，确保打印的时候不会有色差\n适应各种不同的硬件\n用Rust语言开发，几乎不会出错！\n大家可以试试下面的教程：然后在main.rs里面加入下面的代码：运行就可以看到计算机创作的精美图案了：大家试一试！第一次编译的时候需要的时间稍微长点，当valora开始运行的时候，你就可以看到一个不断变化大小的红圈！https://github.com/flutter-rs/flutter-rs用rust和Flutter开发桌面版应用。需要安装的软件：\nRust\nFlutter sdk\n开发步骤：\n安装cargo flutter命令\ncargo install cargo-flutter\n\n\n从模版创建新项目\ngit clone https://github.com/flutter-rs/flutter-app-template\n\n\n采用cli hot-reloading开发:\ncd flutter-app-template\ncargo flutter run\n\n\n发布：最后要发布应用程序，只需运行：cargo flutter --format appimage build --releasehttps://github.com/jonhoo/openssh-rs/https://bitshifter.github.io/2020/04/12/mathbench-build-timings/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://bitshifter.github.io/2020/04/12/mathbench-build-timings/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-14 01:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【Rust日报】2020-04-13 Ruma｜Flutter RS｜Valora｜Rust SSH｜mathbench｜" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "BobQ" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-14 01:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "From 日报小组 BobQ" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust新增Apollo Federation网关协议的支持，用rust写基于graphql接口的微服务成为可能！改变用rust来写graphql只能做做玩具项目的现状。。。Read Morehttps://github.com/sunli829/async-graphql" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-13 13:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-graphql 1.8.0发布了！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#graphql油管视频教程，该up主还做了一系列actix相关的视频教程，虽然看视频学的比较慢，但是很适合初学者。Read Morehttps://www.youtube.com/watch?v=aEAz5DHhpLo&feature=youtu.be" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-13 13:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Actix 和 Juniper 构建简单的 GraphQL API" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #error_handingRead Morehttp://sled.rs/errors" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-13 13:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何在正确性至关重要的Rust项目中进行错误处理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #graphicsWGPU是一个基于 gfx-hal 的 WebGPU 原生实现。Repohttps://github.com/gfx-rs/wgpu/blob/master/CHANGELOG.md#v05-06-04-2020" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-13 13:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WGPU-rs 1.5 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust作者一直在思考Rust的更改频率。有些人断言，Rust如今保持相当静态，还有一些人说Rust的变化仍然太大。 在这篇博客中，作者对这个问题进行数据驱动的分析，拿事实数据说话。Read Morehttps://words.steveklabnik.com/how-often-does-rust-change\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-04-13 13:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 改变的有多频繁？" }, "type": "text" }], "type": "title" } },]
