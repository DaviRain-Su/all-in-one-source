export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我的bootloader程序项目的下一个构建块已经准备好了！Nt-apiset 是用 Rust 编写的用于 Windows10及更高版本的 API Set Map 文件的解析器。API Set是名称以“ API-”或“ ext-”开头的 PE 可执行文件的依赖项，例如 API-ms-win-core-sysinfo-l1-1-0。它们不作为真正的 DLL 文件存在。相反，当加载 PE 可执行文件时，将检查操作系统的 API Set Map 文件，以确定属于依赖项的实际库文件(在本例中为 kernelbase.dll)。最著名的 API Set Map 文件是 apisetschema.dll。文章链接，https://colinfinck.de/posts/nt-apiset-a-rust-parser-for-windows-10-api-set-map-files/Github 链接，https://github.com/ColinFinck/nt-apiset" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ColinFinck/nt-apiset" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-10 23:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "nt-apiset: 一个用于 WindowsAPI  API Set Map文件 的 Rust 解析器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "mds是一个命令行工具，可以：Github 链接，https://github.com/dj8yfo/meudeus" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/dj8yfo/meudeus" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-10 23:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mds v0.18.3" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "fclones，高效的重复文件查找器和删除器这个repository包含两个相关 Rust 项目的源: fclone 和 fclone-gui。Github 链接，https://github.com/pkolaczk/fcloneshttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/pkolaczk/fclones" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-10 23:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 gtk4-rs 和 relm4编写的具有 GUI 的重复文件查找器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Nickel 1.0 是用 Rust 开发的配置语言。它在某种程度上是一种通用但特定领域的语言，专门用于生成配置（例如，通常评估为 YAML 或 JSON），但比纯序列化格式更具表现力，使配置可重用、可维护等正确（特别是选择加入静态类型和运行时合同）。它适用于任何类型的配置，对用例会相当大且复杂用例很有好处。详情：https://www.tweag.io/blog/2023-05-17-nickel-1.0-release/reddit 讨论：https://www.reddit.com/r/rust/comments/144b9hf/announcing_nickel_10_a_configuration_language/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.tweag.io/blog/2023-05-17-nickel-1.0-release/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-10 12:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "配置语言 Nickel 1.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Fyrox 0.30 已经发布，Fyrox 是一个用 Rust 编写的现代游戏引擎，它可以使用原生编辑器轻松创建 2D 和 3D 游戏，就像 Godot。0.30 是该引擎从一开始就发布的最大版本。此版本主要侧重于动画、编辑器、音频和生活质量改进，动画系统得到了显着改进，现在创建现代游戏开发中随处可见的复杂动画应该容易得多。详情：https://fyrox.rs/blog/post/fyrox-game-engine-0-30/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fyrox.rs/blog/post/fyrox-game-engine-0-30/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-10 12:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fyrox 游戏引擎 0.30 更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "嵌入式设备的异步硬件抽象层，使用示例项目地址：https://github.com/matthunz/async-halhttps://github.com/Jancd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/matthunz/async-hal" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-10 12:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-hal 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "freeCodeCamp 近期发布了一份长达 13 个小时的 Rust 课程。这个 Rust 课程面向初学者设计，内容全面，涵盖 Rust 的核心概念和理论基础。freeCodeCamp 是一个非营利组织，旨在通过交互式学习网站、在线社区论坛、聊天室、在线出版物和本地组织等方式帮助全世界的人免费学习编程。Learn Rust Programming - Complete Course 🦀 ：https://www.youtube.com/watch?v=BpPEoZW5IiY" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=BpPEoZW5IiY" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-09 00:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "视频：来自 freeCodeCamp 的 Rust 课程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Graydon Hoare 在 2022 年演讲的一份 PDF，用 107 页的篇幅介绍了 Rust 的基本内容和优缺点，以及内存安全和其他有必要的内容。Graydon Hoare 是 Rust 最初的设计者。他在 2006 年加入 Mozilla，最初是参与 Firefox 浏览器的开发。Rust for \"modern\" C++ devs ：http://venge.net/graydon/talks/RustForModernCPPDevs.pdf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "http://venge.net/graydon/talks/RustForModernCPPDevs.pdf" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-09 00:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "演示文稿：为现代 C++ 开发者准备的 Rust 指南" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 498: https://this-week-in-rust.org/blog/2023/06/07/this-week-in-rust-498https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/06/07/this-week-in-rust-498" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-09 00:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 498" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "WebAssembly 是一种二进制指令格式，旨在成为一种低级虚拟机，可以在 Web 浏览器中以接近本机的速度运行代码。它不特定于网络，也可以在其他平台上运行。WebAssembly 代码可以从各种编程语言编译而来，例如 C、C++、Rust、C# 等。Wasmer 是一个轻量级且快速的 WebAssembly 运行时，可以在各种平台上运行 WebAssembly 模块，包括 Windows、Linux 和 macOS。Wasmer 支持多种编程语言，包括 C、C++、Rust 等。首先，我们将使用 C++ 创建一个简单的“加法”函数，它将两个整数作为输入并返回它们的和。在这段代码中，我们将使用 Rust 中的 add 函数。使用外部“C”是为了使函数“add”不被编译器破坏。我们将不得不在我们的 Rust 代码中使用相同的名称。以下是将代码编译为 WebAssembly 的更新命令：完成执行后，您应该能够看到文件 add.wasm。我们会将这个 Web 程序集加载到我们的 Rust 项目中。让我们使用创建一个简单的 Rust 项目在 Cargo.toml 中添加如下依赖替换main.rs中的以下代码当您运行 cargo run 命令时，如果一切顺利，您应该会看到以下内容:.我们可以看到该函数在控制台应用程序中可用。现在让我们看看如何在浏览器中使用它。尽管这个例子很简单，但从概念上讲，它为“一次编写，到处运行”开辟了新的含义。Webassembly 作为一项技术仍处于初期阶段。它帮助我们弥合编程语言和平台之间的鸿沟。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-08 11:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 C++ 编写通用库并在 Rust 中使用它 (WASI)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Motus是一个命令行应用，帮你轻松生成安全密码。它的用户界面非常简单、优雅，跟 1Password 的密码生成器一样，让你感觉很舒服。Motus 默认会把生成的密码复制到你的剪贴板，用起来非常方便。ReadMore: https://github.com/oleiade/motus" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/oleiade/motus" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-07 09:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "motus 一个非常简单的命令行密码生成工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们目前正在研究支持 gccrs 中的内置过程宏，这是 Rust 宏领域中我们尚未探索的领域。过程宏是一种特殊类型的宏，与“常规”宏一样，接收一列标记并返回一个新的标记。有多种工具用于处理这个标记列表，从 proc_macro crate 提供的类型开始，到复杂的 crate（例如 syn）结束，这些 crate 允许您解析这些标记输入。与常规宏不同，过程宏通过外部函数调用而不是直接在编译器中调用和扩展。它们被编译为单独的二进制文件，编译器将调用该文件。过程宏的输入被序列化为标记流，通过动态过程调用发送到宏。然后需要反序列化返回的标记流并将其集成到 AST 中。此外，过程宏处理的标记与编译器的标记不同：它们包含特定信息，具有不同的稳定性保证和不同的 API。它们在 proc_macro crate 中定义，我们需要重新实现这个 crate 以支持过程宏。要在我们的编译器中实现这些宏，需要我们广泛研究官方实现。由于我必须花费大量时间查看 rustc 的内部结构以及使用适当的 -Z 命令调用编译器时产生的奇怪输出，所以我想分享一些有趣的经历。🧙‍♀️ReadMore: https://cohenarthur.github.io/2023/06/05/rust-derives.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://cohenarthur.github.io/2023/06/05/rust-derives.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-07 09:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Looking at Rust builtin derives" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Quickwit是一个分布式搜索引擎，可用于搜索日志、对话、网页等数据。它旨在以超级高效的方式处理PB级数据。当然，所有的代码都是使用Rust 🦀编写的。这个版本包括以下内容：\n与Elasticsearch/Opensearch兼容的API\nGrafana插件\n无模式数据的聚合功能\n等等……\nReadMore: https://github.com/quickwit-oss/quickwit" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/quickwit-oss/quickwit" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-07 09:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Quickwit 0.6发布了！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一本关于 Rust 的最佳实践指南的电子书，其中包含了很多 Rust 编程的技巧和建议。这篇指南分为多个章节，涵盖了 Rust 编程的各个方面, 他分别从 类型, 概念, 依赖, 工具 等几大类上阐述了 35 种提高 Rust 代码编写的技巧.原文链接https://www.lurklurk.org/effective-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-05 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Effective Rust: 35种提升Rust代码的方法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章介绍了如何使用 C++ 和 Rust 编写通用库，并在 WASI（WebAssembly System Interface）上运行。WASI 是一种 WebAssembly 的扩展，它提供了一种标准的方式来访问系统资源，例如文件系统、网络和进程。原文链接https://medium.com/@shyamsundarb/writing-universal-libraries-using-c-and-consuming-it-in-rust-wasi-80ad1174e0c9" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-05 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Rust 中使用 C++ 编写的通用库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Digital Extinction 是一款3D即时战略（RTS）游戏。故事设定在人类和人工智能为生存而战的不久的将来.他是开源和永久免费的, 它可以在Linux，Windows和潜在的其他平台上运行。 使用 Rust 和 Bevy 开发完成.github地址https://github.com/DigitalExtinction/Game" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-05 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Digital Extinction: Rust实现的开源3D RTS 游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "内核开发人员Fujita Tomonori在周日发送了一组补丁，为网络设备驱动程序提供了Rust抽象以及最初的Rust虚拟驱动程序, 这为 Linux 网络设备驱动程序的 Rust 抽象奠定了基础，以便 Rust 代码可用于构建新的网络设备驱动程序. 不过到目前为止，网络子系统中尚未发布 Rust 的实际硬件设备驱动程序。原文链接https://www.phoronix.com/news/Linux-Rust-Network-Patches--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-05 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "实验性补丁: 为使用 Rust 编写网络驱动 做铺垫" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "科普文，也就是作者的笔记。刚开始学习Rust的同学可以学习一下。https://mbinjamil.dev/writings/rust-memory-management/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://mbinjamil.dev/writings/rust-memory-management/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-05 11:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "blog: Rust如何通过不需要GC实现内存管理。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "LSP（language service provider）在开发者重度依赖的东西。Meta正在利用AI来加强它的能力。这个牛逼了啊。AI在编译器中的应用，已经开始了。https://arxiv.org/abs/2305.12050" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://arxiv.org/abs/2305.12050" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-05 11:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Meta 在用Rust实现一个基于LLM学习的支持多语言的LSP" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Nanocl是一个容器和虚拟机编排系统。说它是Kubernetes还为时尚早。但是看起来这是一个很严肃的项目，开个头总是好的。https://github.com/nxthat/nanocl" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/nxthat/nanocl" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-05 11:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Nanocl - Kubernetes的Rust替代品" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "效果看这里：https://user-images.githubusercontent.com/24411704/243218924-9f7bab7b-26ec-47d1-b51e-74006dfa7b0d.mp4Egui生态发展很快，第三方组件越来越多了。发展看好。https://github.com/coderedart/egui_overlay" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/coderedart/egui_overlay" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-05 11:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Egui_overlay - Egui上的透明层" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "也就是广泛使用了类型系统来保证图形编程的安全，同时是零成本抽象的，底层仍然是OpenGl等。看起来很有意思。https://leod.github.io/rust/gamedev/posh/2023/06/04/posh.html--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://leod.github.io/rust/gamedev/posh/2023/06/04/posh.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-05 11:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Posh - 类型安全的图形编程库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "femtoGPT 是纯 Rust 实现的最小化 GPT（Generative Pretrained Transformer）。对 LLM 着迷，并想了解这些模型在深层次上如何工作的人来说，femtoGPT 是一个很好的开始。GitHub 链接，https://github.com/keyvank/femtoGPT" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/keyvank/femtoGPT" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-03 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "femtoGPT，纯 Rust 实现的最小化 GPT" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 的 #[cfg()] 属性是一个强大的工具，用于在编译时根据指定条件有条件地编译代码。 它可以对包含或排除代码的哪些部分进行细粒度控制，从而产生更高效和优化的程序！ 通过混合使用条件和组合器，开发人员可以针对不同的平台、功能和编译配置定制他们的代码库。博客原文链接，https://blog.parker-codes.dev/posts/rusts-cfg-attribute" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.parker-codes.dev/posts/rusts-cfg-attribute" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-03 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "博客：Rust cfg 属性是如何工作的？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Arroyo v0.3.0 专注于提高系统的灵活性和 SQL 支持的完整性，具有 UDF 支持、DDL 语句以及自定义事件时间。 Web UI 也有许多实质性改进，包括错误报告、监控和底层基础设施改进。Arroyo v0.3.0 链接，https://github.com/ArroyoSystems/arroyo/releases/tag/v0.3.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ArroyoSystems/arroyo/releases/tag/v0.3.0" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-03 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "分布式流处理引擎 Arroyo 发布 v0.3.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "WebAssembly 代表一个机会，可以利用过去 40 年的操作系统研究、编译器开发和行业经验，并将其组合成一种既连贯又易于理解的形式。 作者希望这篇文章可以提供一些关于 WebAssembly 和 WASM 是什么以及事情发展方向的见解。博客原文链接，https://blog.yoshuawuyts.com/what-is-wasi/https://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.yoshuawuyts.com/what-is-wasi/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-03 23:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "博客：WASI 是什么？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-02 21:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【Rust日报】2023-06-02  Rust 1.70.0 稳定版发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 团队很高兴地宣布 Rust 的新版本 1.70.0。 Rust 是一种编程语言，它使每个人都能构建可靠、高效的软件。如果你通过 rustup 安装了以前版本的 Rust，你可以通过以下方式获得 1.70.0：rustup update stable   关于1.70.0 有关新特性，建议访问：What's in 1.70.0 stablehttps://blog.rust-lang.org/2023/06/01/Rust-1.70.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-02 21:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.70.0 稳定版发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "LLM-chain 是一组 Rust crate，旨在帮助您更有效地使用大型语言模型。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-02 21:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "推荐一个用 Rust 创建 llm工具链的项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 reddit社区看到一个小讨论：What editor are you using for Rust?   在这里也问下社区的uu们👀  从公号来的朋友可在rustcc.cn该帖下留言https://rustcc.cn/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-02 21:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "发起一个小讨论：What editor are you using for Rust?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Arti是一个用rust编写的下一代Tor客户端。阅读更多：torproject forumhttps://forum.torproject.net/t/arti-1-1-5-is-released-onion-services-rpc-and-a-security-patch/7821" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-02 21:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Arti 1.1.5 is released." }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "flutter-rust-app-template 该模板，为想要同时拥抱 Flutter 和 Rust 强大功能的开发人员提供即时功能。阅读更多：Reophttps://github.com/cunarist/flutter-rust-app-template" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-02 21:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个“链接”flutter和rust的新模板：flutter-rust-app-template" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RTIC (Real Time Interrupt-Driven Concurrency，实时中断驱动并发)是一种用于cortex-m处理器的硬件加速RTOS，为编写并发嵌入式应用程序提供了一种新的简便方法。阅读更多：Repohttps://github.com/rtic-rs/rtic" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-02 21:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RTIC releases v2.0.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Sniffnet是一种网络监控工具，可帮助您轻松跟踪互联网流量。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-02 21:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Sniffnet：一个rust网络监控工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "@fasterthanlime 对最近社区风波的回应： https://fasterthanli.me/articles/the-rustconf-keynote-fiasco-explained同时也是最近风波的整合本，包括社区里其他人的声明，以及事件的背景，参与事件的主体之间的关系，事件发生的原因等内容都包含在内，特别长，希望有人后续能翻译一下，摘选了其中的一段：在开源社区中，透明度、治理和反思非常重要。项目的声誉和成功与社区成员之间的信任和合作息息相关。如果社区成员感到不被尊重或不被听取，他们可能会失去信任，并不再参与项目。因此，公开和透明的讨论和决策过程对于维护社区的健康和成功至关重要。另外，Bevy的作者@cart在推特上也发表了自己的看法:我之所以使用 Rust，是因为市场上没有其他语言类似于它。其他“类似”的语言（如 Zig、Go、C++、Jai 等）的特性完全不同。Rust 社区是我参与过的最好的开发者社区，尽管偶尔会出现一些小问题。是的，存在治理问题。我很高兴我们现在正在进行这样的讨论，以便改进事情。但我绝对不会离开。没有其他技术栈能像 Rust 一样为我服务。那些不关心 Rust 社区利益的人（或者不再关心）正在利用这个机会散布恐慌信息。我相信从长期来看我们会证明他们是错误的。但是要明确的是：指出治理问题的人并没有在散布恐慌信息。开源治理是一项混乱的业务。在构建 Bevy 社区时，我犯了不少错误，未来可能还会犯更多错误。我对所有参与其中的人都充满同情。我们已经走到了这一步，这本身就让我非常乐观。很难在一条推文中表达清楚，但简单来说：一名 RustConf 演讲者被 Rust 领导人（这是一个非正式和松散定义的权力结构，对更广泛的社区来说基本上是不透明的）挤掉了主题演讲的位置。许多人都在问“为什么会发生这种情况”和“我们应该做些什么来改变”。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fasterthanli.me/articles/the-rustconf-keynote-fiasco-explained" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-01 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于最近社区风波的一些回应" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 497: https://this-week-in-rust.org/blog/2023/05/31/this-week-in-rust-497/🦀️最后，今天是六一儿童节，祝各位大朋友、小朋友儿童节快乐🎉" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/05/31/this-week-in-rust-497/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-06-01 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 497" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "tui-rs 是一个广受欢迎的构建终端用户界面和仪表板的 rust 库，有很多有趣的项目 基于 tui-rs 进行开发。https://github.com/fdehau/tui-rs其原维护者由于一些个人原因无法继续开发，因此，fdehau 基于 tui-rs 项目的一个积极维护的分支，fork 了一个名为 ratatui 的库，并于近日发布了 0.21.0 版本（tui-rs 目前的最高版本为 0.20.1）。需要注意的是，自 0.21.0 版本以来，ratatui 需要 rustc 1.65.0 或更高版本才能正确编译。\ntui-rs 原作者关于不再积极维护的声明\nratatui github 链接\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-30 20:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ratatui：tui-rs 的社区维护版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "self_cell 提供了一系列宏，可以在 stable Rust 中创建安全使用的自引用结构，而不会泄漏结构内部生命周期。它是 no_std 的，不使用 proc-macros，经过了 miri 测试，且通过了经验丰富的 Rust 用户的社区代码审查。由于不使用 proc-macros 并且没有依赖关系，其编译时间也很快。其近日发布了 1.0 版本。与之前的 0.10 版本相比，1.0 版本并没有什么太大的不同。作者曾告诉自己，如果一整年都没有出现重大问题或需要更改 API 的需求，他将发布 1.0 版本。现在这一年已经过去了，作者仍然对API感到满意，也没有进行任何API更改。自从作者过去发布关于该项目的文章以来，他已经彻底改进了实现和API，并解决了缺乏文档的主要问题。\n文档\n社区代码审查\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-30 20:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "self_cell 发布 1.0 版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章讲述了为什么大型科技公司喜欢使用Rust编程语言。Rust的特性是吸引开发人员的一个重要原因，例如并发编程在Rust中得到了有效的实现，允许程序员编写高效的可以并行运行的代码。此外，Rust还提供了内存安全性和线程安全性，这使得它成为一种非常有用的编程语言。原文链接https://analyticsindiamag.com/why-big-techs-are-pushing-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-29 17:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么大型科技公司在推行Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章讲述了如何在Rust中扩展模式匹配。他提到了Rust中模式匹配的一些限制，例如只能匹配一些内置类型。他还介绍了如何使用宏来扩展模式匹配，以及如何使用状态机来扩展模式匹配原文链接https://blog.yoshuawuyts.com/pattern-extensions/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-29 17:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "扩展Rust的模式匹配" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "最近Rust 又陷入了风波, 这篇文章讲述了 Rust 审查团队集体辞职的事情, 以及其中一些人的行为和态度, 引起了大家的广泛讨论.总之,希望 Rust 越来越好!原文链接https://gist.github.com/fasterthanlime/42da9378768aebef662dd26dddf04849#rust-the-wrong-people-are-resigning如果你不知道最近Rust发生了什么, 可以看下 为什么我离开Rust 这篇文章.https://www.jntrnr.com/why-i-left-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-29 17:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "错误的人正在辞职" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该视频介绍了五种 Rust 中常用的编程技巧, 有的技巧值得借鉴.油管视频https://www.youtube.com/watch?v=BU1LYFkpJuk--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-29 17:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "五种更好的 Rust 编程方式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "tcp-chat通过TCP进行通信，该项目的目的是了解并行性和底层网络通信。前端工具：Solid、Tauri、Vite后端工具：Rust、Tokio、SerdeGitHub: https://github.com/gatomod/tcp-chat" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/gatomod/tcp-chat" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-29 16:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tcp-chat：构建在TCP上的简单快速轻量的聊天工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "功能包括：\n序列化 （serde） 支持\n异步函数绑定支持\n人性化的函数和用户数据方法绑定\n人性化的堆栈值操作，无需关注堆栈细节\n高效：无辅助堆栈，支持引用类型转换\n内置绑定到最常用的 rust std 函数和类型\n多线程支持\nGitHub: https://github.com/metaworm/ezlua" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/metaworm/ezlua" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-29 16:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ezlua：Rust的Lua绑定" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "轻量的错误处理库。使用示例：GitHub: https://github.com/inventhq/failsafe-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/inventhq/failsafe-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-29 16:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "failsafe-rs：错误处理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本地启动：WASI:Wasm:GitHub: https://github.com/bokuweb/r2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/bokuweb/r2" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-29 16:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "r2：RISC-V模拟器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Disintegrate 提供了一种从事件流构建域对象的替代方法。在支持传统聚合的同时，Disintegrate引入了一种新方法，允许在建模业务规则时具有更大的灵活性和适应性。通过利用事件流作为基础，Disintegrate使开发人员能够构建模型来捕获业务事件的本质，而无需在聚合中对同一事件进行多版本。这减少了重复和复杂性，从而产生更清晰和更易于维护的代码。GitHub: https://github.com/disintegrate-es/disintegrate" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/disintegrate-es/disintegrate" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-29 16:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "disintegrate" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我很高兴宣布diesel 2.1，Diesel是一个用Rust构建的安全，可扩展的 ORM 和Query Builder。此版本包含几个新特性并改进了现有特性。文章链接，https://diesel.rs/news/2_1_0_release.htmlGithub 链接，https://github.com/diesel-rs/diesel" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/diesel-rs/diesel" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-27 17:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Diesel 2.1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我经常处理与其他系统对话的系统。从技术上讲，这把他们放在分布式系统的类别，但与数据库或类似复杂的东西不同，它通常是某种 PC (笔记本电脑、网络服务器) ，与某种嵌入式系统(USB 设备、传感器)通话。无论复杂性如何，这些系统都需要相互通信以实现某些目标: 获取传感器数据、更改配置值等。对于许多像这样的简单情况，我们可以把这些系统看作一种“相位锁定”——它们是两个同时从一种状态状态到另一种状态的系统。这篇文章探讨了我发现的一种技巧，我认为它很有用。文章链接，https://onevariable.com/blog/phase-locked-state-machines/Github 链接，https://github.com/jamesmunns/trait-machine" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jamesmunns/trait-machine" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-27 17:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "相位锁定状态机" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "通过这篇文章的媒介，我想传播我的新开源Rust项目。先说一下，我不是一个好的作家，我也不知道如何像大多数人一样详细阐述我的文章，但我会提供所有相关信息和解释。什么是 Websurfx? 它为什么存在？Websurfx 是一个开源的元搜索引擎，它是 Searx 的替代品，它尊重隐私，同时也确保安全和速度文章链接，https://www.reddit.com/r/rust/comments/13t0z29/websurfx_an_opensource_alternative_to_searx_that/Github 链接，https://github.com/neon-mmd/websurfxhttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/neon-mmd/websurfx" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-27 17:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Websurfx-Searx 的一个开源替代品" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "安装：使用：https://github.com/rust-cross/cargo-xwin" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-cross/cargo-xwin" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-27 15:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-xwin - 在Linux上或MacOS上跨平台编译到Windows" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "TI-89是德州仪器生产的科学图形计算器。https://github.com/nptnl/solvation" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/nptnl/solvation" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-27 15:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在TI-89科学图形计算器上跑Rust代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一套系统，用于存储 metrics和app logs。使用Rust实现，性能很高。具有很强的平行扩展能力。Ingest Metrics and Logs — Query and Insights — Scale and Save $$可用来代替：Prometheus + ELK。https://github.com/infinohq/infino" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/infinohq/infino" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-27 15:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "infino - Rust 实现的监控平台" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust实现的内核，基于egui渲染。上层提供py API。主要是给科学工作者分析数据用。https://github.com/rerun-io/rerun" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rerun-io/rerun" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-27 15:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rerun - 图形和数据可视化套件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Fish Folk 是一个正在开发和不断扩展的多人游戏捆绑包，使用 Rust 和 Bevy 构建，所有内容都在 GitHub 上开源。Fish Folk 支持智能关卡编辑器，并具备本地多人分屏合作和跨平台在线游戏功能。Fish Folk 由多个游戏组成，目前包括：\nJumpy（2D 平台动作游戏）\nPunchy（2D 格斗游戏）\nBomby（2D 炸弹竞技场）\nBallsy（2D 球类运动）\nFish Folk - GitHub ：https://github.com/fishfolk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/fishfolk" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-26 01:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "游戏：Fish Folk" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Scientific Computing in Rust 2023 是关于科学计算的研讨会，将会在 2023 年 7 月 13 日 和 14 日举办。该研讨会由 Rust 社区中的科学计算专家和相关 crate 的维护者组织，以线上会议的形式进行并可以免费参加。Scientific Computing in Rust 2023 ：https://scientificcomputing.rs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://scientificcomputing.rs/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-26 01:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Scientific Computing in Rust 2023" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 496: https://this-week-in-rust.org/blog/2023/05/24/this-week-in-rust-496/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/05/24/this-week-in-rust-496/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-26 01:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 496" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Lavagna 是一款协作黑板软件，旨在用于在线会议期间创建简单的草图。它有一个（可选的）极简UI，以避免画图时分心。您可以使用键盘或可选的工具栏控制颜色和线条宽度。那么，第二版有什么变化呢？\n将应用程序从基于 pixels crate的架构移植到了强大的 bevy 游戏引擎上\n增加了缩放和平移功能，现在可以在无限平面上创建无限的草图\n支持wasm，因此您可以直接在浏览器中使用它\n在线演示 https://lavagna.devand.dev/?collab-url=wss://lavagna-server.devand.dev/demo那么二进制文件大小呢？ 通过应用 Unofficial Bevy Cheat Book 和 Minimizing Rust Binary Size 文章中的一些技巧，我成功将整个 wasm 二进制文件压缩到不到10M，当使用gzip压缩时，大小仅为2.8M。请随意尝试，无论是在Web（在此处）还是在本地（在发布页面中的链接）。非常欢迎您提供反馈！如果您想创建新房间，只需更改演示 URL 中的 collab-url 参数或在本地版本中设置 --collab-url 命令行参数即可。ReadMore: https://github.com/alepez/lavagna" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/alepez/lavagna" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-23 21:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "lavagna v2 发布了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在这篇博客文章中，我深入比较了异步和多线程编程在流行语言（如 Rust、Go、Java、C#、Python、Node.js 和 Elixir）中的内存消耗。一段时间以前，我需要比较几个计算机程序在处理大量网络连接时的性能。我发现这些程序的内存消耗存在巨大差异，甚至超过了20倍。有些程序的内存消耗仅略高于100 MB，而另一些在处理1万个连接时则达到了将近3 GB。不幸的是，这些程序非常复杂，而且功能也不同，因此很难直接比较它们并得出有意义的结论，因为这不是苹果与苹果之间的比较。这启发我想到创建一个合成基准测试。我在各种编程语言中创建了以下程序：启动 N 个并发任务，每个任务等待10秒钟，然后在所有任务完成后程序退出。任务数量由命令行参数控制。在 ChatGPT 的帮助下，我可以在几分钟内编写出这样的程序，即使在我不常用的编程语言中也可以。为了方便起见，所有基准测试代码都可以在我的 GitHub 上找到。https://github.com/pkolaczk/async-runtimes-benchmarksReadMore: https://pkolaczk.github.io/memory-consumption-of-async/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://pkolaczk.github.io/memory-consumption-of-async/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-23 21:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "需要多少内存才能运行100万个并发任务？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果你对这个主题不熟悉，这个介绍可能对你来说有点不清楚。为了更好地了解这是什么，让我们深入了解一些低级细节。当你在终端中运行时，cargo需要一堆配置值来确定它想要做什么；例如“我是否向编译器传递附加标志？”，“我使用哪个链接器？”，“默认优化级别是什么？”等等。它会在当前目录、每个父目录和一个特殊路径 ~/.cargo/config 中查找配置文件。此外，cargo还想要保留先前构建的crate、下载的源文件、凭证令牌等的缓存。所有这些文件都将存储在路径如 /.cargo/git、/.cargo/credentials 等的位置。cargo还保留了rust工具链（cargo本身、rustfmt、rustc等）和所有全局安装的二进制文件，这些文件都在 ~/.cargo/bin 中。该目录通常在首次安装后添加到$PATH中，因此在运行了之后，你可以像运行任何其他命令一样直接从终端运行 somerustprogram。目前，你可以通过设置环境变量 $CARGO_HOME 来更改 ~/.cargo 部分。如果你设置了CARGO_HOME=/foo/bar ，那么你的全局配置文件将在 /foo/bar/config 中，你的凭证文件将在/foo/bar/credentials 中，等等。但是，没有办法“拆分”cargo home。没有办法说：“我希望配置文件在一个文件夹中，临时文件在另一个文件夹中，二进制文件在另一个文件夹中。”然而，这正是一些用户想要的！特别是在Linux上，有一个越来越流行的标准叫做XDG基本目录：XDG_CONFIG_HOME：应写入用户特定配置的位置（类似于/etc）。默认应为$HOME/.config。XDG_CACHE_HOME：应写入用户特定非必要（缓存）数据的位置（类似于/var/cache）。默认应为$HOME/.cache。XDG_DATA_HOME：应写入用户特定数据文件的位置（类似于/usr/share）。默认应为$HOME/.local/share。XDG_STATE_HOME：应写入用户特定状态文件的位置（类似于/var/lib）。默认应为$HOME/.local/state。（非标准，但流行的）XDG_BIN_HOME：应写入用户特定可执行文件的位置（类似于/usr/bin）。默认为$HOME/.local/bin。（Mac、Windows和其他操作系统有自己的惯例，我不太熟悉。）关于这些惯例真正带来了多少好处存在争议。有些人真的不在意，有些人则坚信它们。人们提到的一些好处包括：\n减少主目录的混乱，使查找相关文件更容易。\n将所有配置文件集中在一个易于备份的 ~/.config/ 文件夹中，没有混乱。\n将所有缓存文件集中在一个易于销毁的 ~/.cache文件夹中。\n将所有本地二进制文件放在一个单独的文件夹中，这个文件夹“保证”（你的发行版可能不同意）包含在默认的$PATH中。\n遵循标准路径使与类似Flatpak这样的沙盒框架合作更加容易（尽管在实践中似乎不那么整洁）。\n更抽象的好处，例如让分析和备份工具更好地理解你的文件结构。\nWindows不使用XDG路径，而是有自己的标准路径，并且很少使用点文件。对于用户来说，使用点文件可能会令人困惑和烦恼。\n作为一个经常需要重新安装环境的人，前两点对我很重要：我真的希望应用程序开发人员停止为所有数据使用自己特殊的顶层文件夹，这样当我尝试将我的配置移植到新的笔记本电脑/PopOS安装程序/等等时，我必须跟踪并手动复制它们。曾经我认为NixOS可能是解决方案，但是，嗯，它并没有实现。此外，我列出的所谓好处强烈依赖于网络效应：只有开发人员编写符合 XDG 假设的应用程序，人们才会编写更多基于 XDG 假设的工具；开发人员将更有动力编写符合 XDG 标准的应用程序，如果这样做有生态系统的好处。这可能会导致令人沮丧的情况，其中一些 major 项目的维护者会相互拖延并指责对方说：“如果 X 没有费心去做，我为什么要费心做？”不过，2023年，我会说支持已经进展到足以清楚地表明生态系统正在朝着广泛支持的方向发展（尽管进展缓慢）。ReadMore: https://poignardazur.github.io/2023/05/23/platform-compliance-in-cargo/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://poignardazur.github.io/2023/05/23/platform-compliance-in-cargo/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-23 21:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一份关于 cargo 目录是否符合平台标准的报告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是由 Android 团队开发的为期三天的 Rust 课程。该课程涵盖了 Rust 的全部范围，从基本语法到高级主题，如泛型和错误处理。最后一天还包括 Android 特定的内容。该课程的目标是教授 Rust。并且假设你对 Rust 一无所知，最终希望：\n让你全面了解 Rust 的语法和语言。\n使你能够修改现有程序并在 Rust 中编写新程序。\n向你展示常见的 Rust 习惯用法。\n原文链接https://google.github.io/comprehensive-rust/welcome.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-22 18:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "google推出了新的 Rust 课程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文探讨了异步和多线程编程在 Rust、Go、Java、C#、Python、Node.js 和 Elixir 等流行语言中的内存消耗比较。文章分别给出了 10k, 100k,1m 任务情况下各种语言内存的消耗对比.从结果上看, Rust tokio 有巨大的内存优势.原文链接https://pkolaczk.github.io/memory-consumption-of-async/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-22 18:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "100万并发任务各种语言需要多少内存" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Müsli 是 Rust 的一种灵活、快速、通用的二进制序列化框架，与 serde 类似.本文介绍了一种名为 \"Abductive Diagnostics\" 的技术，它可以帮助开发人员更快地诊断和解决代码中的问题。该库提供了一种新的方式来生成诊断信息，以帮助开发人员更快地找到问题所在.原文链接https://udoprog.github.io/rust/2023-05-22/abductive-diagnostics-for-musli.html--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-22 18:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Müsli 的诊断学" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Helix 是个文本编辑器：新版本功能：\n为 LSP 引用请求添加一个配置选项，用于排除声明（＃6886）。\n根据文件扩展名和 shebang 启用语言注入（＃3970）。\n通过最近的访问对缓冲区选择器进行排序（＃2980）。\n在选择器中异步执行语法高亮显示（＃7028）。\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-21 22:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Helix 23.05发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目前还没有发布在crates，可以通过GitHub安装：使用示例：GitHub: https://github.com/pnevyk/gryf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/pnevyk/gryf" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-21 22:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "方便、通用、正确和高性能的图数据库：gryf" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "crumsort比pdqsort（Pattern-defeating quicksort）快33%。pdqsort是一种混合排序，下图是与C++标准库的对比：下图是crumsort与pdqsort的对比（均匀分布的随机 u32）GitHub: https://github.com/google/crumsort-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/google/crumsort-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-21 22:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust的crumsort" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GitHub: https://github.com/sotanakamura/winui-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sotanakamura/winui-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-21 22:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust+Windows+UI 3 App" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Inko 是一种用于构建并发软件的编程语言，其本机代码编译器是用 Rust 编写的，并使用 LLVM 作为其后端。 生成的机器代码链接到一个小型运行时库，该库也是用 Rust 编写的。Inko 适用于各种应用程序，例如 HTTP 服务器、命令行应用程序、数据库、静态站点生成器等。新版本 v0.11 的主要改进是使用 LLVM 的本机代码编译器替换字节码解释器。https://llvm.org/更多信息参见 Inko 0.11.0 released，https://inko-lang.org/news/inko-0-11-0-released/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://inko-lang.org/news/inko-0-11-0-released/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-20 23:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Inko 语言发布 v0.11" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ast-grep 是一种基于 AST 的工具，用于按模式代码搜索代码。可以像编写普通代码一样编写模式。它将匹配具有相同语法结构的所有代码。 可以使用 $ 符号和大写字母作为通配符，例如 $MATCH，匹配任何单个 AST 节点。 将其视为 REGEX .，但它不是文本。作者根据 Bevy 迁移指南中的代码片段创建了一个搜索查询和重写模式，例如将 add_system_to_stage 更改为 add_system。详细内容参见文章链接，https://betterprogramming.pub/migrating-bevy-can-be-easier-with-semi-automation-here-is-how-1f6e21858e79" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://betterprogramming.pub/migrating-bevy-can-be-easier-with-semi-automation-here-is-how-1f6e21858e79" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-20 23:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何使用 ast-grep 自动化迁移 Bevy 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "artemis 的主要目标是帮助用户收集和解析端点上的取证(forensic)数据。 通常在想要调查端点上的可疑或恶意活动时执行。GitHub 链接，https://github.com/puffycid/artemis在线文档，https://puffycid.github.io/artemis-book/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://puffycid.github.io/artemis-book/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-20 23:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "artemis，跨平台的数字取证解析器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "最小完美哈希函数 (MPHF, Minimal Perfect Hash Function) 是从密钥集 K 到集合 {0, 1, …, |K|−1} 的双射。ph 是用于构建 MPHF 的最先进、最高效的 Rust 库。ph 库包含两个 MPHF 的实现：FMPH 和 FMPHGO。GitHub 链接，https://github.com/beling/bsuccinct-rshttps://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/beling/bsuccinct-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-20 23:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ph，基于完美哈希数据结构的 Rust 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust实现的 Cascade information reconciliation protocol for Quantum Key Distribution (QKD)  量子键分布？好像是密码学相关的。隔行如隔山，小编也不懂这个具体是干啥的。感兴趣的同学可以前去研究。https://github.com/gftea/cascade-protocol" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/gftea/cascade-protocol" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-19 12:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cascade-protocol" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "全异步支持，支持主流的 Mssql, MySql, Postgres, Sqlite，简单易用。https://github.com/weldsorm/welds不过小编心中这个也很好用：sql_builderhttps://docs.rs/sql-builder/3.1.1/sql_builder/index.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://docs.rs/sql-builder/3.1.1/sql_builder/index.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-19 12:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "welds - 基于sqlx之上的ORM框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "网络尖刀！Rust实现。界面现在越来越华丽了。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-19 12:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "sniffnet v1.2发布了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "易于配置，界面好看。https://github.com/mrjackwills/havn" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mrjackwills/havn" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-19 12:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "havn - 快速端口扫描工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "因此，Bevy开发的游戏，编译成wasm后，在网页上可以调用WebGPU实现高效的大型3D效果了。https://bevyengine.org/news/bevy-webgpu/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://bevyengine.org/news/bevy-webgpu/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-19 12:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy主分支添加了对WebGPU的支持" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pgx是一个用于在 Rust 中开发 PostgreSQL 扩展的框架，并力求尽可能地惯用和安全。pgx 支持 Postgres v10-v14。主要特征:\n带有 cargo-pgx 的完全托管的开发环境;\n\n\n自动架构生成\n完全用 Rust 实现扩展；\n将许多 Rust 类型自动映射到 PostgreSQL；\n动生成的 SQL 模式（或通过 手动生成cargo pgx schema）；\n包含带有 extension_sql 的自定义 SQL！ & extension_sql_file!\n\n\n安全第一\n将 Rust panic!s 转换为 Postgres ERRORs 中止交易，而不是进程；\n内存管理遵循 Rust 的 drop 语义，即使面对 panic！ 和 elog（错误）；\n#[pg_guard] 程序宏确保以上；\nPostgres 基准是 Option where T: FromDatum；\nNULL 数据安全地表示为 Option::::None。\n\n自动架构生成完全用 Rust 实现扩展；将许多 Rust 类型自动映射到 PostgreSQL；动生成的 SQL 模式（或通过 手动生成cargo pgx schema）；包含带有 extension_sql 的自定义 SQL！ & extension_sql_file!安全第一将 Rust panic!s 转换为 Postgres ERRORs 中止交易，而不是进程；内存管理遵循 Rust 的 drop 语义，即使面对 panic！ 和 elog（错误）；#[pg_guard] 程序宏确保以上；Postgres 基准是 Option where T: FromDatum；NULL 数据安全地表示为 Option::::None。等等...那我们怎么使用呢？首先安装cargo-pgrx子命令并初始化开发环境：该init命令下载当前支持的 PostgreSQL 版本，将它们编译为~/.pgrx/，然后运行initdb​​. 也可以使用现有的（用户可写的）PostgreSQL 安装，或安装版本的子集这将为扩展包创建一个新目录。新扩展包括一个示例，因此您可以继续并立即运行它。这会将扩展编译为共享库，将其复制到指定的 Postgres 安装，启动该 Postgres 实例并将您连接到与扩展同名的数据库。一旦 cargo-pgrx 将我们带入 psql，我们就可以加载扩展并对示例函数执行 SELECT。\nhttps://github.com/tcdi/pgrx\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-18 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pgx -- 用于在 Rust 中开发 PostgreSQL 扩展的框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文说明了我们如何在 Rust 中构建一个 CLI 应用程序，它是 grep 的一个非常基本的实现。 这个应用程序将有 2 种操作模式：从标准输入管道输入并搜索它们，以及读取文件并搜索它。 该程序的输出将是与搜索词匹配的行，其中包含突出显示的词。 本文涵盖了终端中的 stdin 操作、检测终端何时处于 tty 模式与 pipe 模式、执行简单的文件 I/O、创建非消耗性构建器、管理结果以及构建简单的 CLI 界面等主题。我们正在构建的应用程序设计非常简单。 它让我们准备好接下来使用像 termion 和 tui 这样的 crates 来构建更复杂的 TUI 应用程序。\nhttps://developerlife.com/2022/03/02/rust-grep-cli-app/\nhttps://github.com/r3bl-org/r3bl_rs_utils\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-18 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Rust 中构建一个简单的 grep CLI 应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Self-replace 是一个 Rust 库，它提供了一个有用的解决方案，帮助解决在 Windows 系统下实现二进制文件自卸载操作的难题。在 Windows 上，可执行文件无法直接被删除，这使得自卸载操作变得十分困难。Self-replace 的解决方案非常巧妙，通过创建副本并在关闭时生成该副本以实现替换操作，从而实现自卸载。此外，该库还提供了替换操作，使得 Rust 程序员可以更轻松地实现单一可执行工具的自更新和自卸载操作。通过使用 Self-replace，程序员可以更好地管理和维护他们的软件，使得软件更新和卸载变得更加轻松愉快。https://docs.rs/self-replace/latest/self_replace/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-18 20:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "self-replace：解决 Windows 上二进制文件自卸载的难题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Müsli 是 Rust 的一个二进制序列化库，具有出色的性能和灵活性。它提供多种格式，以用于不同的场景，并支持多种模式，以在不同的目的下对同一数据模型进行编码和解码。该库使用 derives 来生成 Encode 和 Decode 实现，以优化性能。尽管它使用了一些不安全的代码来实现最大效率，但是严格的测试可以确保内存安全。初步测试表明，Müsli 可以与其他 Rust 序列化库相媲美。此外，Müsli 的格式可以根据被序列化的数据提供大小优势。详情请看：https://github.com/udoprog/musli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-18 20:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Müsli 一个实验性的二进制序列化框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 495: https://this-week-in-rust.org/blog/2023/05/17/this-week-in-rust-495/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-18 20:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 495" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pacdef 原先是在 Arch Linux 上用 python 实现的一个 pacman 包管理器，之后用 rust 重写，并且支持了以下多种包管理器：可以通过下面的配置文件声明各个包需要的安装项，pacdef 会保证声明的内容会被正确安装。pacdef 还支持分组功能，可以将需要的包按照其用途分组，声明在不同的文件中，从而更加易于管理github项目地址https://github.com/steven-omaha/pacdef" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-16 22:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pacdef: 一个多功能的声明式 linux 包管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个新发布的 crate，与 modular-bitfield 有些类似，在保证了性能的前提上，在易用性和类型安全上做出了一定的改进，对新手更加友好。这篇博客中介绍了 bilge 的基本使用，以及其与 modular-bitfield 的对比，感兴趣的可以进一步阅读。https://hecatia-elegua.github.io/blog/no-more-bit-fiddling/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-16 22:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "bilge: 一个更符合人体工程学的 bitfield 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "serredis 是一个底层的 RESP(redis Serialization Protocol)库，其遵循了 RESP 的基本定义，在支持基础的 strings,integers, arrays 的基础上，还提供了 collection 类型，从而支持更加复杂的数据类型。seredies crates.io 主页https://docs.rs/seredies/latest/seredies/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-16 22:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "seredies: 借助 serde 实现的 Redis 协议库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "分片、并发的迷你redis，支持http接口。使用：默认地址和端口：127.0.0.1:6379。设置key：获取key：GitHub: https://github.com/lorenzoc25/rudis" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/lorenzoc25/rudis" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-15 23:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rudis" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "适用于Linux的多后端声明式包管理器。支持的后端：GitHub: https://github.com/steven-omaha/pacdef" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/steven-omaha/pacdef" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-15 23:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pacdef" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用actix-web重写ChatGPT后端。GitHub: https://github.com/arguflow/ai-editor" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/arguflow/ai-editor" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-15 23:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ai-editor" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章讨论了 Rust 中的 Tokio 库中的 FuturesUnordered 类型和惊群效应问题。FuturesUnordered 类型是一个异步任务的集合，它可以并行执行这些任务。但是，如果这些任务中的任何一个在同一时间准备好执行，它们将同时运行，这可能会导致性能问题。文章提供了一些解决方案，例如使用 FuturesOrdered 类型或使用 Tokio 的协作调度器来避免这个问题。原文链接https://blog.polybdenum.com/2023/05/15/tokio-futuresunordered-and-the-thundering-herd-problem.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-15 18:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio, FuturesUnordered 和 惊群效应" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "bitcode 是一个位 编码器/解码器, 目前发布 0.4版本.github地址https://github.com/SoftbearStudios/bitcode" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-15 18:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "bitcode: 位 编码器/解码器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "gpg-tui 是一个 GnuPG 的终端用户界面，它旨在通过提供一个界面来简化密钥管理操作，例如列表/导出/签名，并提供命令行回退以进行更复杂的操作。它并不试图成为 gpg 提供的所有功能的全面界面，但它试图为密钥管理带来更多的交互式方法。github 地址https://github.com/orhun/gpg-tui--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-15 18:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gpg-tui" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "列出系统 USB 总线和设备; 一个试图保持兼容性的 lib 和现代跨平台的lsusb，但也添加了新的特性。包括macOS的system_profiler SPUSBDataType编译器模块和用于非macOS系统 libusb profiler。该项目开始作为一个几乎不使用的的 lsusb 脚本的快速替代品，是我的年度 Rust 项目Github 链接，https://github.com/tuna-f1sh/cyme" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/tuna-f1sh/cyme" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-13 23:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cyme：列出系统usb总线和设备" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用 Rust 编写的基于 tui 的串行终端。文章链接，https://www.reddit.com/r/rust/comments/13g4g1u/my_first_project_tuicom_a_tui_based_serial/Github 链接，https://github.com/ggsvr/tuicom" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ggsvr/tuicom" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-13 23:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我的第一个项目! TuiCOM: 一个基于 TUI 的 Rust 串行终端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Faer 是在纯 Rust 中实现底层线性代数例程的crate的集合。目标是最终提供一个功能齐全的线性代数库，重点关注可移植性、正确性和性能。文章链接，https://www.reddit.com/r/rust/comments/13ggs7k/faer_09_release_low_level_linear_algebra_library/Github 链接，https://github.com/sarah-ek/faer-rshttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sarah-ek/faer-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-13 23:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "faer 0.9 release: low level线性代数库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章讲了Azure如何朝安全的多租户，机密计算前进。以及如何使用Rust逐步替换C/C++的过程。并且，这个过程会一直持续下去，直到底层安全紧要的部分完全被绣花。https://azure.microsoft.com/en-us/blog/microsoft-azure-security-evolution-embrace-secure-multitenancy-confidential-compute-and-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://azure.microsoft.com/en-us/blog/microsoft-azure-security-evolution-embrace-secure-multitenancy-confidential-compute-and-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-12 18:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "微软Azure的安全进化之路" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "所说在产品线上已经用了3年了。包括但不限于：proxy / reverse proxy / load balancer / nat traversal.https://github.com/bytedance/g3" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/bytedance/g3" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-12 18:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "g3 - 字节开源的代理项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "很多人很关心slint的商业协议，现在它们准备添加第三种：royalty-free (permissive)https://github.com/slint-ui/slint/discussions/2706" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/slint-ui/slint/discussions/2706" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-12 18:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "slint准备添加一种授权协议" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "教学文章：从第一行代码教你怎么实现。https://www.notapenguin.blog/posts/rust-event-systems/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.notapenguin.blog/posts/rust-event-systems/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-12 18:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust构建一个事件系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ast-grep 是一个由 Rust 编写的实用工具，利用 AST 进行代码搜索、Lint 和重构。一个典型的使用场景是：需要大量重复机械修改的情况，例如升级库或 API 破坏性更改。该工具专注于轻量级和用户友好，并提供致力于提供交互式的编辑体验。Website - AST-GREP: Write Code to Match Code: https://ast-grep.github.io/Online playground: https://ast-grep.github.io/playground.htmlGitHub - ast-grep/ast-grep: https://github.com/ast-grep/ast-grep" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ast-grep/ast-grep" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-12 02:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "实用工具：ast-grep" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\"flatty\" 提供了直接映射 Rust 类型、无需包装或解包的扁平消息缓冲区。如果一个类型占用单个连续的内存区域，那么它就属于 \"flat\"（扁平）类型。如果你既需要将对象以二进制格式存储或发送、又想要免于序列化或者反序列化访问其内容，就可以尝试使用这一 crate 。GitHub - agerasev / flatty: https://github.com/agerasev/flatty" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/agerasev/flatty" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-12 02:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "实用 Crate ：flatty" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 494: https://this-week-in-rust.org/blog/2023/05/10/this-week-in-rust-494/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/05/10/this-week-in-rust-494/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-12 02:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 494" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一套工具。目前支持这些模型：\nGPT-2\nGPT-J\nLLaMA: LLaMA, Alpaca, Vicuna, Koala, GPT4All v1, GPT4-X, Wizard\nGPT-NeoX: GPT-NeoX, StableLM, Dolly v2 (partial, not the same tensor names?)\nBLOOM: BLOOMZ\nhttps://github.com/rustformers/llm" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rustformers/llm" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-11 23:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "llm - 使用Rust在CPU上运行大模型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Beginning with Rust 1.71 (slated for stable release on 2023-07-13),从 musl  1.1.24 升级到了musl 1.2.3.https://blog.rust-lang.org/2023/05/09/Updating-musl-targets.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2023/05/09/Updating-musl-targets.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-11 23:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "从Rust 1.71开始，musl编译目标依赖的musl版本升级了。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/salvo-rs/salvo/blob/main/examples/oapi-generics/src/main.rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/salvo-rs/salvo/blob/main/examples/oapi-generics/src/main.rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-11 23:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Salvo 0.41.0 发布，初步支持 openapi" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一篇讲解Rust中的类型 Coherence 的文章，非常细致，推荐阅读：https://ohadravid.github.io/posts/2023-05-coherence-and-errors/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ohadravid.github.io/posts/2023-05-coherence-and-errors/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-11 23:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Coherence in Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "其实并不复杂，但是作者对工作善于记录，善于表达的方式，值得一学。https://michellelim.dev/writing/measure-time-spent-in-app/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://michellelim.dev/writing/measure-time-spent-in-app/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-11 23:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我们如何用Rust构建自己的时间跟踪算法" }, "type": "text" }], "type": "title" } },]
