export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rustup install betarustc +beta --versionrustc 1.30.0-beta.2 (7a0062e46 2018-09-19)原文https://internals.rust-lang.org/t/rust-2018-rc1-is-available/8435" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-21 10:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "同志们！Rust 2018 RC1 来了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "曾开发 《战神：奥林匹斯之链》 和《 战神：斯巴达之魂》 的业界大厂 Ready at Dawn Studios 的CTO开始学习Rust原文https://www.reddit.com/r/rust/comments/9hiomn/xpost_from_rust_gamedev_ready_at_dawns_cto_on/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-21 10:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Dawn Studions CTO开始了学习Rust之旅" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这哥们在用Rust做一个音乐合成器原文https://raphlinus.github.io/synthesizer/2018/09/19/synth-update.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-21 10:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "音乐合成器进度更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://www.manning.com/livevideo/rust-in-motion" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-21 10:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Manning直播： Rust in Motion" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "搞不懂这是干嘛，也许是它们内部用到的crateGitHubhttps://github.com/clipos/assets_crates-io" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-21 10:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "法国网络安全局的Clip OS项目索引了部分Rust crate" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用有序的Bucket构造的树形多级Hash Table来实现无锁MapDOChttps://docs.rs/lockfree/0.2.0/lockfree/map/struct.Map.html原文https://www.reddit.com/r/rust/comments/9hbl5s/a_lockfree_map/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-21 10:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个无锁Map" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "基于combine crateresshttps://github.com/FreeMasen/ress\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-21 10:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust实现的JS扫描及词法分析器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://exphp.github.io/2018/09/16/lockout-part-1.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "系列文章 ： 探索Rust生命周期" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "可以在Kubernetes 1.9+ 集群测试 linkerd 2.0Linkerd 2.0 数据板块 由Rust 实现，P99延迟小于 1ms，控制板块由Go实现原文https://blog.linkerd.io/2018/09/18/announcing-linkerd-2-0/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "linkerd 2.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://bsoptei.github.io/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用函数组合自定义智能指针" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://jonathansteyfkens.com/rust/graphics/compute/2018/09/15/my-recommended-cg-crates.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "计算机图形相关的crate推荐列表" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://matthewkmayer.github.io/blag/public/post/postgres-tls/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "postgres 和 r2d2_postgres使用TLS建立连接池" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "代码是Rust实现  https://github.com/rylev/Rustdoku文章里使用Ruby代码（作者称之为伪代码）讲解算法思路原文https://blog.ryanlevick.com/posts/sudoku-solver-generator/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "数独求解器和发生器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自某个Conf大会的分享。作者花了400个小时，用Rust实现了一个Ruby分析器。为什么说励志呢：做之前：\n他不懂Ruby\n他不懂Rust\n不想利用周末业余时间做开源就辞职了\n做之后：Ruby和Rust都懂了，还找到一个三个月的赞助。 事实证明，你要有一个开源的心，没有什么是不可能的。原文https://www.deconstructconf.com/2018/julia-evans-build-impossible-programs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "励志：构建不可能的程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在汇编语言级别，不需要担心混淆整数和指针。对于高级语言来说，高程度的抽象也会将指针和整数完全隔离，不容易混淆。但是对于C/ C++/ Rust这样的语言，需要注意整数和指针的区别。该文章是一篇论文的预告文，具体的区别估计还在论文中有详细描述。原文https://blog.regehr.org/archives/1621论文 http://www.cs.utah.edu/%7Eregehr/oopsla18.pdf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "整数和指针之间有什么区别？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该文作者尝试挑战孤儿规则非常hack的技术：features gate和条件编译配合突破孤儿规则原文https://phaazon.net/blog/orphans-problem" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "尝试解决孤儿问题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "sclhttps://github.com/Keats/scl" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SCL：Rust实现的一种简单配置语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://www.reddit.com/r/rust/comments/9hf2qy/the_future_of_rusts_backwards_compatibility/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「讨论」Rust向后兼容性的未来" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文http://venge.net/graydon/talks/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust之父Graydon早期的几个分享slides" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Daniel" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文http://venge.net/graydon/talks/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 22:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "考古：Rust的作者Graydon Hoare关于Rust的最初两个slide" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Daniel" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "视频与文字脚本（英文）https://www.deconstructconf.com/2018/julia-evans-build-impossible-programs在本文中，作者介绍了为什么选择Rust来编写这个profiler" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 22:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust编写一个Ruby profiler" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Daniel" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://docs.rs/lockfree/0.2.0/lockfree/map/struct.Map.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 22:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个无锁的HashMap" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Daniel" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://github.com/Keats/sclParser基于Rust，特色是一个SCL文件可以include另外的SCL配置文件" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 22:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SCL 一个新的配置文件格式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Daniel" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ress，很快作者将基于ress，编写一个ES6的AST parser：resphttps://github.com/FreeMasen/ress" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-20 22:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "基于Rust的ES6 tokenizer ress发布0.4.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者记录了他和Rust的长篇「爱情」故事。长达十年的追逐，从不屑到爱，祝愿这份「爱情」天长地久。原文http://dtrace.org/blogs/bmc/2018/09/18/falling-in-love-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-19 13:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "爱上Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://www.archlinux.org/packages/community/x86_64/alacritty/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-19 13:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Archlinux 提供了 alacritty终端仿真器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rushhttps://github.com/psinghal20/rush" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-19 13:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个实验性的Rust实现的shell" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是来自于Flare 服务团队（已经在每日新闻里出镜多次的存储引擎）的文章，介绍了他们在生产级将C# 和Rust集成的宝贵经验。本文很长，图文并茂，需耐心阅读。有时间我会翻译一下。原文https://blog.getseq.net/rust-at-datalust-how-we-integrate-rust-with-csharp/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-19 13:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust如何与C#集成" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://medium.com/@rbalajis25/a-simple-worker-in-rust-974816a6a74f" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-18 13:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "简单的worker实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "增加了对Warp和Hyper集成支持\njuniper\nwarp支持\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-18 13:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust实现的Juniper GraphQL server库发布 0.10" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用Rust编写的OpenGL终端仿真器Alacritty已经在版本0.2.0中支持滚动原文https://jwilm.io/blog/alacritty-lands-scrollback/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-18 13:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Alacritty现在支持滚动翻页" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nrust-memchr，libc memchr（在某一内存范围中查找一特定字符）的Rust安全接口\nlighthouse， 轻量级以太坊2.0客户端\nslotmap，在Rust 2018 Conf闭幕演讲中提过的slotmap，是分代索引模式的践行库\nrelm，之前介绍过，基于GTK+，受Elm语言启发的GUI库\n\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-18 13:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GitHub趋势榜今日新上榜的项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该文来自于RustConf 2018闭幕演讲文稿，但并非是对文章的全文翻译，只是我在阅读过程中的梳理和总结。原文https://zhuanlan.zhihu.com/p/44657202" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-17 14:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【RustConf 2018闭幕演讲文稿】使用Rust进行游戏开发的正确姿势" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://www.vandenoever.info/blog/2018/09/16/browsing_your_mail_with_rust_and_qt.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-17 14:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust和Qt编写邮件查看器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新版本改为使用failure crate进行错误处理原文https://github.com/tantivy-search/tantivy\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-17 14:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust全文搜索引擎Tantivy 0.7发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是steveklabnik发布的一个新的crate，使用了分代索引模式基于Vector来建立链表，确保引用的正确性。并且是100% Safe Rust。这种方式可以避免循环引用。\n原文\nindexlist\n但是和这个库比怎么样呢？  generational-arenahttps://github.com/fitzgen/generational-arena该库Readme中罗列的ABA问题，indexlist是否避免了呢？" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-15 16:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "indexlist: 基于Vector的双向链表" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://blog.ryanlevick.com/posts/rust-pass-value-or-reference/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-15 16:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust：传值还是传引用？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者希望Rust也参与，大家踊跃应战吧！原文https://nextjournal.com/sdanisch/the-julia-challenge" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-15 16:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Julia挑战赛" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://github.com/BurntSushi/ripgrep/pull/1054" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-15 16:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Ripgrep 现在ubuntu上可用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "官方steveklabnik写文章来驳斥社区中「unsafe代码可以关闭借用检查器」这种说法，并给予了详细的解释。原文https://words.steveklabnik.com/you-can-t-turn-off-the-borrow-checker-in-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-15 16:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "你不能在Rust中关闭借用检查" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://stackoverflow.com/questions/tagged/rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-15 16:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "StackOverflow已经累计了超过1万个Rust相关问题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个smallvec的包装，用来跟踪所有容量的变化，记录到一个文件中，以便事后总结。原文https://llogiq.github.io/2018/09/13/smallvec.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-15 16:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Smallvectune ：测量SmallVec的足迹" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文比较了泛型和关联类型，帮助你更好的理解关联类型原文https://medium.com/codechain/rust-associated-type-2281dbf98229\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-15 16:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust关联类型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://zhuanlan.zhihu.com/p/44499068" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-14 11:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一场由逻辑漏洞引发的「血案」" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这次是一个小版本发布，在1.30和1.31版本中会有更多更新内容。该版本中重要的更新是cargo fix和cargo clippy，而非语言特性。原文https://blog.rust-lang.org/2018/09/13/Rust-1.29.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-14 11:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.29 稳定版发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本周，Vulkan®已成为世界上第一个为其相关GLSL™和SPIR-V™编程语言提供正式内存模型的图形API。使Vulkan开发人员能够更好地控制着色器如何在并行执行环境中同步访问内存.那估计gfx-rs也要马上跟进了吧原文https://www.khronos.org/blog/vulkan-has-just-become-the-worlds-first-graphics-api-with-a-formal-memory-model.-so-what-is-a-memory-model-and-why-should-i-care" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-14 11:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Vulkan刚刚成为世界上第一个具有正式内存模型的图形API" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "WebRender是一个基于GPU的实验性网页内容渲染器，用Rust编写。现在默认为桌面Windows 10 w / Nvidia GPU上的用户启用。原文https://www.reddit.com/r/rust/comments/9fhxz2/webrender_an_experimental_gpubased_renderer_for/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-14 11:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WebRender将开始在部分Firefox Nightly用户上启用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Serde作者发布了新的Miniserde库，这个新库和Serde在设计目标上是不同的\n最小化设计，不像serde那样适用范围更广泛，只限JSON、仅限结构体、不能定制\n只序列化String，确保序列化总是成功。\n没有单态、没有递归、没有反序列化失败的错误消息。\n在一些不需要serde那么复杂的场景之下，也许miniserde更有用miniserdehttps://github.com/dtolnay/miniserde" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-14 11:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Miniserde发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对wasm-bindgen 和 stdweb关系迷惑的朋友可以看看官方的回答原文https://github.com/rustwasm/team/issues/226#issuecomment-417801729" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-14 11:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "澄清wasm-bindgen 和 stdweb关系" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust核心团队领导者Niko开启了「Rust官方时间」，旨在为初学者答疑解惑。详情参考下面链接。原文http://smallcultfollowing.com/babysteps/blog/2018/09/12/rust-office-hours/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-14 11:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "niko开启「Rust官方时间」" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "过去的六周，网络工作组做了些什么？\nWG-Net  愿景发布\nTide框架构建开启\nFutures 0.3-alpha-4 现在可用\n在考虑Pin API？Pin Api\ntower-web 相关\n会议记录\n原文https://internals.rust-lang.org/t/the-networking-working-group-newsletter-01/8391" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-14 11:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "网络工作组报告 1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rusty-modular-arithmetichttps://github.com/NyxCode/rusty-modular-arithmetic" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-14 11:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "有意思的小项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nSekibanki， 另一个actor库\nNazrin，提供OwningLock 和 PeekingLock两个主要的结构，用于共享数据的读写访问\n原文https://www.reddit.com/r/rust/comments/9fj4o8/published_two_crates_to_github/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-14 11:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "两个新库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该版本集成了futures 0.2 （？？怎么不用0.3），使用libcurl的多接口与自定义异步事件循环交互。原文https://www.reddit.com/r/rust/comments/9fent6/chttp_version_020_an_http_client_released/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-14 11:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cHTTP发布了0.2版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RUSTUP_DIST_SERVER=https://dev-static.rust-lang.org rustup update stableReleases notehttps://github.com/rust-lang/rust/blob/stable/RELEASES.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-13 10:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.29.0 预发布测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者开篇说他学习一门语言不喜欢长时间看书学习，还是喜欢直接上手。当他碰到编译器错误的时候，再去翻Rust book。这种学习方法可还行？不过看文章总结的还行。原文https://erik.doernenburg.com/2018/09/rust-my-first-impressions/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-13 10:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "对Rust的第一印象" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该库是模拟.NET Cryptostream类的Rust实现，基于rust-openssl，完全可配置。cryptostreamhttps://github.com/neosmart/cryptostream介绍博客https://neosmart.net/blog/2018/transparent-encryption-and-decryption-in-rust-with-cryptostreams/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-13 10:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cryptostream：读写流适配器，用于即时加密和解密" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该文主要是探讨wasm-bindgen的用法，看看数字（因为wasm只能理解数字类型）和字符串类型如何转换，并且会介绍wasm-bindgen内部结构。推荐阅读。原文https://blog.ryanlevick.com/posts/wasm-bindgen-interop/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-13 10:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust和JS交互" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目前是WIP状态，可以关注下selenium-rshttps://github.com/saresend/selenium-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-13 10:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "selenium-rs： selenium webdriver的Rust客户端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在expr很长的情况下投票结果\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-13 10:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "你选哪种写法？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "网络服务工作组今年的目标是改进网络开发：通过建立Tide（潮汐）框架，来改进基于async/await网络相关crate的生态系统。之所以取名为Tide（潮汐），意指“涨潮使得所有的船都得以上升”，也就是中国的那句成语，水涨船高。（开个玩笑，withoutboat怎么办？）总目标是提升Rust中所有web开发和框架之间的共享、兼容和改进。Tide的愿景：\n加强提供核心网络功能中充当「体力活」的crate，要确定并改进、标准化一批像http、url这样的基础库。\n在这些基础库之上构建一个严肃的框架。理想情况下，只要可行就使用现成的crate，如果不合适，就自己创造一些小的、独立的crate。\n这些均会记录到Tide的书中。并且这些工作都将是开放的，本篇文章就是这一系列的第一篇博文，如果你想参与这项工作的任何方面，请访问Discord上的WG-net-web频道！初始主题：基础服务API。大多数语言生态系统最终都有一个关键的界面来讨论Web服务：Ruby有Rack，Python有WSGI，Java有Servlets等等。拥有这样的接口意味着你可以从底层Web服务器中分离Web框架。还可以提供可用于任何服务器和框架的通用底层中间件。现在tower-web已经开始这部分工作。简而言之，这种Service trait建模是通用的。但当前的问题是：路由策略。当前路由策略一共有三种：Endpoint-centric 路由。是Rocket和tower-web的方式。就是利用属性，比如#[get(\"/\")]，将对应函数设置为endpoint。Table-of-contents路由，是Gotham, Rouille, 和 Actix Web采用的方式。比如这种方式有助于处理多个endpoint的问题，但是它比前一种策略更重一些，并且从请求信息中提取信息可能没那么灵活。就是Wrap采用的方式。在某种程度上，也可以称为无路由方法。endpoint和应用中其他函数没有什么区别。一切皆filter，你可以通过组合filter来构建你的服务。现在谈这种方式的优缺点还有点早，所以这里没谈。（无关个人喜好）Tide中的路由是什么方式？Tide倾向于 Table-of-contents路由，因为它比endpoint-centric路由更容易模块化和扩展，比自由式路由更容易理解。在下一篇文章中，将深入研究Rust中的 Table-of-contents式路由中出现的一些API设计问题，并研究模块化和共享的途径。（小声BB： 预计2019年Rust在Web领域的应用将爆发。。。）原文https://rust-lang-nursery.github.io/wg-net/2018/09/11/tide.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-12 12:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【重要】涨潮了： 建立开放的模块化Web框架Tide" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章是Flare开发者在构建Flare这个复杂软件过程中，思考的一些Rust代码库相关的细节。\n使用JetBrains CLion开发Rust\n目前是使用Nightly版本，但指定了edition = 2018，但目标是等待stable Rust 2018。虽然目前使用了一些unstable 特性，但是越来越少了，Rust 2018版本对他们来说，已经非常适合使用。\n依赖库。 可以到这里找到他们使用的依赖库。比较出名的有failure、serde、lazy_static、libc、rand等。\n源码组织。 遵循Rust的传统，将项目构建为单独的crate。文章中包含了相关模块介绍。\n管理unsafe代码。 它们在项目根模块添加了#![deny(unsafe_code)] ，但是自己实现了一个unsafe_block!宏：\n\n在编写unsafe代码的时候使用这个宏，这就使得不安全的代码更具有审计性，达到了统一管理的目的。这个实践很棒。\n管理cross-cutting concerns代码。 cross-cutting concerns来自于AOP的一个术语，叫横切关注点。这里其实是指那些在代码中复用的一些「工具类」函数或类型。代码越复杂，这种东西就会越多，需要好好管理它们。文章作者使用std_ext模块来统一管理这些「工具」\n开发中可能会经常为结构体中增加新字段来解决一些问题，但有时候新加的字段，在一些方法里并没有被使用。所以 利用#![deny(unused_variables)]属性来限制结构体，如果出现这种在方法里没有被使用的字段，则会报错。从而提醒开发者，仔细考虑这个需求。\n还有很多值得探索的地方; 包括与.NET互操作，跨平台打包，测试和模糊测试。\n看得出来，Rust语言本身为开发大型复杂应用提供了很多工具。期待后续文章。原文https://blog.getseq.net/rust-at-datalust-how-we-organize-a-complex-rust-codebase/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-12 12:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【重要】如何组织复杂的Rust代码库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "crossbeam源码分析系列文章。crossbeam是官方核心成语Aaron编写的并发库，提供了mpmc channel、scoped thread、并发数据结构、扩展了标准库的原子类型、以及其他的一些工具。文章里介绍的是crossbeam库中Michael-Scott非阻塞队列(lock-free)算法的Rust实现，MS-queue算法主要依赖于CAS原子操作。原文https://zhuanlan.zhihu.com/p/44104743" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-12 12:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust源码分析：crossbeam之ms_queue(1)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "出到了第五篇原文https://brionv.com/log/2018/08/29/parallelizing-png-compression-part-1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-12 12:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "并行化PNG压缩系列文章" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://mnt.io/2018/09/11/from-rust-to-beyond-the-c-galaxy/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-12 12:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "From Rust to beyond系列： 与C交互" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章罗列了常用的trait，非常适合初学者原文https://stevedonovan.github.io/rustifications/2018/09/08/common-rust-traits.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-12 12:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "常见的Rust trait" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nmtpng 并行化PNG 编码器\ncoreutils  Rust重写的GNU coreutils\n\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-12 12:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一些库的介绍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "简要：\nrustc现在支持4个Cortex-R编译目标，现在只需要使用rust-toolchain就行\nJames Munns在RustConf 2018上发表了演讲，内容涉及嵌入式系统的基础知识，以及Rust的Zero Cost Abstractions如何与裸机系统完美匹配的嵌入式项目\natsamd21-rs现在已经支持Arduino MKRZERO开发板\nExploring Rust on Teensy系列文章 第四章正在构思，该系列将专注于使用futures-rs来表示DMA传输\n更多内容请查看原文原文https://rust-embedded.github.io/blog/2018-09-09-newsletter-11/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-11 11:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "嵌入式工作组报告 11" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "mdproofhttps://github.com/Geemili/mdproof" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-11 11:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mdproof： markdown转换到PDF" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "集成了futures和tokiocoronahttps://www.reddit.com/r/rust/comments/9epiwg/announcing_corona_040/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-11 11:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "corona ： 又一个栈式协程库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "完全用Rust实现，基于nom，支持no_std 。 这个厉害了。demo https://www.polaris64.net/resources/programming/p64lang_wasm/p65lang_rusthttps://github.com/polaris64/p64lang_rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-11 11:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "可以作为wasm模块使用的编程语言P64Lang" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个问题确实需要考虑了PDFhttps://arxiv.org/pdf/1809.02161.pdf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-11 11:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「论文」优化编译器的未来方向" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://coaxion.net/blog/2018/09/gstreamer-rust-bindings-0-12-and-gstreamer-plugin-0-3-release/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-11 11:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GStreamer Rust 绑定 0.12 和 GStreamer Plugin 0.3  发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "timetrackhttps://github.com/JoshMcguigan/timetrack" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-11 11:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "timetrack 通过监控文件系统自动跟踪你项目花了多长时间" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "感兴趣可以了解下，原文里包含了一系列如何使用Rust构建语言虚拟机的教程iridium-vmhttps://blog.subnetzero.io/project/iridium-vm/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-11 11:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Iridium是指用Rust编写的语言VM" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者思考的这个问题，正好也是我疑惑的。一般来说，系统编程包含两个概念：\n底层编程，用于处理机器的各种细节\n系统设计，创建和管理复杂的各种组件\n作者回顾从计算机起源对系统编程的定义进行了回顾：系统编程这个词起源于20世纪70年代，在《系统编程语言》（Bergeron1 et al.1972）中作者说：“系统程序是一组集成的子程序，它们一起构成一个大于其各部分之和的整体，并超过一些大小和/或复杂度的阈值。。。”，该定义的一个关键思想是：倡导将底层语言与系统语言分离。这个阶段认为系统应该是为用户服务。20世纪90年代中期，随着动态类型脚本语言的兴起，编程语言发生了重大的变化。Perl、Python、Ruby等，于是就有了高级语言和系统编程语言的二分法（Ousterhout 1998），系统编程用于创建组件，脚本用于将它们粘合在一起。也就是这个时候，静态类型和垃圾回收语言也开始兴起，Java和C#，虽然它们被认为不是传统的系统编程语言，但是Ousterhout中提到：“在正在形成的互联网中，Java被用于系统编程”2010年开始，这个边界变得模糊了起来。Dropbox用Python也构建了大型的可扩展系统，JS也逐渐成为主流，可以构建复杂的UI系统，并且JIT编译器也开始流行，使得脚本语言也可以和传统系统编程语言拼一下性能。Julia、Swift和Go这样的新的编程语言也在推进垃圾回收语言的性能边界。Bjarne Stroustrup（C ++的创建者），Rob Pike（Go的创建者），Andrei Alexandrescu（D开发人员），和Niko Matsakis（Rust开发人员）。当被问及“2014年什么是系统编程语言”时，他们说（编辑转录）：\nNiko Matsakis：具有高延迟需求，高安全性要求，以及服务器端的各种需求。\nBjarne Stroustrup：系统编程出自你必须处理硬件的领域，然后应用程序变得更加复杂。你需要处理复杂性。如果您遇到任何重大资源限制问题，那么您就处于系统编程领域。如果您需要更精细的控制，那么您也在系统编程领域。决定它是否是系统编程的是约束。你的内存不足吗？你没时间了吗？\nRob Pike：当我们第一次宣布Go时，我们称它为系统编程语言，我有点遗憾，因为很多人认为它是一种编写操作系统的语言。我们应该称它为服务器端语言，现在我明白我们拥有的是云基础架构语言。系统编程的另一个定义是在云中运行的东西。\nAndrei Alexandrescu：我有一些试金石用于检查某些东西是否是系统编程语言。系统编程语言必须能够允许您在其中编写自己的内存分配器。你应该能够将一个数字伪造成一个指针，因为这就是硬件的工作原理。\n那么系统编程是关于高性能的吗？资源限制？硬件控制？云基础架构？从广义上讲，似乎C，C ++，Rust和D类别中的语言在它们与机器的抽象级别方面有所区别。这些语言公开了底层硬件的细节，如内存分配/布局和细粒度资源管理。Rust语言特点是将好的软件设计和工程性原则应用于底层的编程，这方面极具创新性。所以到底什么是系统编程语言？作者认为，系统编程语言应该是特指底层编程语言，因为系统设计的领域太广，它不能有自己的命名，将这两个概念分清楚比较好。原文http://willcrichton.net/notes/systems-programming/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-10 14:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "到底什么是系统编程？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "添加了futures和异步处理函数\ngio_futures\ngio_features_await\n原文http://gtk-rs.org/blog/2018/09/09/new-release.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-10 14:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gtk-rs新版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://os.phil-opp.com/blog_oshttps://github.com/phil-opp/blog_os原文https://hackaday.com/2018/09/08/pun-intended-bare-metal-attracts-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-10 14:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust写OS内核正在编写第二版" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "通过Rust编译为wasm32-unknown-unknown来提供HTTP服务源码https://github.com/Xe/olin/tree/master/cwa/olinheroku demohttps://olin-http-example.herokuapp.com/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-10 14:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Olin：服务器端WebAssembly平台 -" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://github.com/BurntSushi/ripgrep/releases/tag/0.10.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-08 13:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Ripgrep 0.10.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "运行于网页rustfmt-wasmhttps://alexcrichton.github.io/rustfmt-wasm/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-08 13:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "wasm实现的rustfmt" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "tower-web 0.2.2发布。基于tower stack构建的HTTP Web框架。 这篇文章主要介绍tower-web的中间件。如果要实现一个记录日志的中间件，需要：\n实现LogService，处理日志记录，实现Service trait\n实现LogMiddleware，将日志记录添加到中间件堆栈中， 实现Middleware trait\nResponseFuture ，如果中间件需要响应请求时可以采取的操作。\ntower-web的中间件计划提供标准化的服务。接下来会把中间件提取出独立的库，然后考虑tower-web和wrap合并的计划。log示例https://github.com/carllerche/tower-web/tree/master/src/middleware/log原文https://medium.com/@carllerche/tower-web-expanding-the-middleware-stack-f9bf55bfa109" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-08 13:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tower Web： 扩展中间件堆栈" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "sonneriehttps://github.com/njaard/sonnerie" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-08 13:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个简单的时间序列数据库实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该公司业务是自动化恶意软件分析。 需要使用Rust来重构现有软件性能敏感的部分。可惜不接受远程。原文https://www.reddit.com/r/rust/comments/9dmc35/job_offer_rust_developer_at_vmray/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-08 13:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「德国」VMRay正在招聘Rust开发人员！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "effluxhttps://github.com/whitfin/efflux\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-08 13:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Hadoop Streaming 和 MapReduce的Rust绑定" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RustConf+2018 @ YouTubehttps://www.youtube.com/results?search_query=RustConf+2018" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-07 12:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustConf 2018视频已上传油管" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在浏览facebook的时候使用此插件，后台脚本会收集看到的广告。该扩展程序会向用户展示这些广告，并要求他们决定这些广告是否属于政治广告。在服务端，我们使用这些评级来训练一个朴素的贝叶斯分类器，然后自动评估我们收集的其他广告。该扩展程序还要求服务器提供分类器认为是政治性的最新广告，以便用户可以看到他们没有看到的政治广告。我们小心翼翼地通过不向我们的后端服务器发送识别信息来保护用户的隐私。该项目后端基于Rust，现在整个项目开源，包括前端的浏览器插件，可以作为一个生产案例。facebook-political-adshttps://github.com/propublica/facebook-political-ads" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-07 12:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Facebook政治广告收集器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该文章主要探讨了Futures和Tokio的运行时模型，值得阅读adventures-futures-tokio-rusthttp://bryangilbert.com/post/code/rust/adventures-futures-tokio-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-07 12:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust的冒险：Futures 和 Tokio" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "提供了一个新的解析API，可以在语法无效的宏输入情况下智能地报告错误。这个解析API很重要。因为在下周发布的Rust 1.29中将稳定 函数调用式的过程宏（functionlike!(...) ）。到目前为止，过程宏只能用作自定义派生，编译器为此保证语法上有效的输入，因此错误报告不是宏的责任。但是对于函数调用式的宏，调用者可以胡乱往里塞东西，所以必须需要有这样一个错误提示的功能。随着向新解析API的过渡，syn将放弃使用nom样式的解析器组合子宏，转而使用普通的Rust函数和控制流。也就是说，从0.15开始，就没有syn::synom::Synom这个trait了，只有syn::parse::Parser了。原文https://github.com/dtolnay/syn/releases/tag/0.15.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-07 12:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "syn库发布了0.15" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://zhuanlan.zhihu.com/p/43959766\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-07 12:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 TiKV 构建分布式类 Redis 服务" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "官方主要考虑这些问题：rustc如何帮助实现真正优秀的IDE体验？要达到这个目标，还需要考虑更多的子问题\nrustc如何才能更加易于维护和使用？\n如何发展rustc的贡献者\n如何提高rustc创新的步伐\n如何解析和支持过程宏\n如何将rustc暴露为更多的库\nmatklad 一直在重构libsyntax2的工作，将会非常适合过程宏和IDE还需要改进rustc的增量编译支持，以配合IDE的响应时间。更进一步提取像Chalk（trait系统）和Polonius（NLL借用检查器）这样的库，将rustc中复杂的问题，提取为单独的库，这些库倾向于遵循具有核心共享代码块以及进行单元测试的包装器的模式。但目前Chalk和Polonius还未投入使用。是否可以将MIR抽出来成为独立库？ 还有很多问题需要考虑。对于RLS来说，未来可能考虑使用查询系统（Query System），希望有更快的响应时间，还必须考虑如何确保RLS得到良好的维护。该帖子评论区还有很多Niko的想法，感兴趣可以去阅读原文https://internals.rust-lang.org/t/2019-strategy-for-rustc-and-the-rls/8361" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-06 12:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【官方讨论】2019年Rustc和RLS战略" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 2018决定对模块系统进行简化，目前官方在测试它的两种形式：\nAnchored paths，其中use语句始终以外部包名称或关键字开头。 从子模块导入需要一个self::前缀\nUniform paths，use语句也可以以本地项目名称开头\n具体可以在Edtion Guide里查看.https://rust-lang-nursery.github.io/edition-guide/rust-2018/module-system/path-clarity.html原文https://users.rust-lang.org/t/module-system-changes-are-going-into-fcp/20171 跟踪issues https://github.com/rust-lang/rust/issues/53130#issuecomment-418824862" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-06 12:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "模块系统更改已经进入FCP阶段" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Travis允许在.travis.yml中设置cache：cargo以启用Rust项目的缓存缓存很棒：它避免了必须一直重建所有依赖项，从而加快构建速度。travis文档说明了缓存：请注意，我们的缓存不是网络本地，它仍然绑定到网络带宽和DNS解析。这会影响您可以存储在缓存中的内容。如果您在缓存中存储大于几百兆的存档，则不太可能看到速度大幅提升。作者查看了他本地的缓存，大概有4.2G，可想而知，他的Travis缓存大概有5-7个GB之多。主要是因为Travis里缓存了target/ 和 .cargo/这些目录文件。缓存逐渐变大一般是两个原因：\nrustc是增量编译，其过程会产生大量的构建「副产品」，这些「副产品」会由Travis缓存，这些东西基本上没有用，但会积累。\n过时的依赖库积累。有的库发了新版本，旧版本依旧会被Travis缓存。\n解决办法：\ntarget /不值得缓存\n〜/.cargo/bin/  值得缓存\n〜/ .cargo / registry / 不值得缓存\n所以修改.travis.yml文件作者经过这样设置，Travis缓存下降到只有68M。这个经验不一定适合你的项目，请看情况而定。原文https://levans.fr/rust_travis_cache.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-06 12:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "请务必小心Travis的Rust缓存" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "可视化Python程序中耗费时间的部分，而无需重新启动程序或以任何方式修改代码，也不会以任何方式中断正在运行的程序。py-spyhttps://github.com/benfred/py-spy" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-06 12:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Py-Spy: Python程序的抽样分析器。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "LanguageClient-neovimhttps://github.com/autozimu/LanguageClient-neovim\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-06 12:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "NeoVim/Vim的LSP支持" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新工具和项目：\n用Rust实现的Jczsolve Sudoku Solver（数独求解器），并编译到了wasm，在线示例\nWasabi，WebAssembly的动态分析框架\ngreenwasm， Rust实现的wasm规范（上面已介绍），即wasm引擎\n另外还需要人手去做贡献，具体问题查看下面链接原文https://rustwasm.github.io/2018/09/04/this-week-in-rust-wasm-007.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-05 17:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust和WebAssembly 本周报告第7期" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文讲解LLVM优化的工作机制，值得仔细品读原文https://blog.regehr.org/archives/1603前置知识相关文章 https://blog.regehr.org/archives/1605" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-05 17:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "LLVM如何优化函数" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nexa，替代ls的命令行工具，目测会和bat一样流行\nparity-ethereum，快速、鲁棒、轻量的以太坊EVM和WASM客户端，基于Rust 1.28构建\nrust-protobuf，Rust Protobuf实现\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-05 17:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GitHub趋势榜今日上榜项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "cortex-m-quickstarthttps://github.com/rust-embedded/cortex-m-quickstart\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-05 17:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「嵌入式」Cortex-M开发模板" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "spirithttps://github.com/vorner/spirit使用教程教程https://vorner.github.io/2018/09/03/Announcing-Spirit.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-04 12:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "新库 spirit：帮助创建Unix守护进程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust实现的熔断器（circuit breaker），可以防止一个应用不断地去尝试一个很可能失败的操作。failsafe-rshttps://github.com/dmexe/failsafe-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-04 12:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "新库failsafe-rs" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该公司构建的日志服务Seq5，最近引入了Rust，实现了Seq Native Storage。它是一种新的跨平台，特定于日志数据的存储引擎。该文章记录了他们公司的技术栈，以及为什么需要重新构建存储引擎，以及从Rust中得到了什么？原文https://blog.getseq.net/rust-at-datalust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-04 12:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Datalust公司使用Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "sqlparser-rshttps://github.com/andygrove/sqlparser-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-04 12:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust实现的ANSI Sql词法分析器和解析器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nRPCS3是一个开源的Sony PlayStation 3仿真器，经过gfx-rs团队的努力，现在可以在RPCS3中渲染游戏。\nDolphin是最近两款任天堂视频游戏机的模拟器：GameCube和Wii。\n原文https://gfx-rs.github.io/2018/09/03/rpcs3-dolphin.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-04 12:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在gfx-portability的Metal后端上运行RPCS3和Dolphin" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://gitlab.com/nifker/text-editor" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-04 12:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "又一个文本编辑器实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "PRhttps://github.com/rust-lang-nursery/rustc-guide/pull/190/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-04 12:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "编译器之书新增了MIR借用检查章节内容" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "比较学术的文章，作者试图在现有Rust实现基础上来探讨实现Monad抽象的可能性原文https://varkor.github.io/blog/2018/08/28/feasible-functors-in-rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-04 12:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust中可行性函子的探讨" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文测量了 内存中提取和L1缓存中提取的速度。使用Rust的内联汇编功能，而不是编写纯汇编代码。结论：从缓存中进行数据访问可以节省大约190个处理器周期。 结果当然会随处理器架构而变化。 Debug和Release模式方面没有太大区别，因为汇编代码没有被编译器优化。原文https://nitish.ch/notes/time-difference-between-l1-cache-fetch-and-memory-fetch/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-04 12:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "L1 缓存和内存提取的时间差" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "通过重构将trait对象改为使用枚举，进一步使用宏来消除重复代码原文https://singpolyma.net/2018/09/rust-factory-without-box-trait-object/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-04 12:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "案例：Rust代码重构" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "周日的新闻会合并到「本周精选」中" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-03 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "通告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "前奏： 为了解决C10K问题\n线程 ，太昂贵\nReactor模式， Node.js使用的事件驱动库libuv就是Reactor模式，核心是提供了一个event-loop\nNode.js语言设计 :\n纯事件驱动\n事件编程是其主要范式\n为脚本语言构建并发编程无阻塞基础设施，基于libuv\n单线程\nRust语言设计：\n系统级编程语言，可直接和操作系统打交道\nFutures + mio = tokio\nTokio实现了Reactor模式\n原文https://www.youtube.com/watch?v=1DQylQ_tYy8&feature=youtu.be" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-03 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【油管】Rust和Node.js语言设计： 关于Async编程的两个故事" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "完全使用Rust实现，功能简单但强大，而且安全。性能超过dash，虽然和Redox一起发布，但是也可以用于其他*nix平台ionhttps://gitlab.redox-os.org/redox-os/ion" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-03 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ion：来自Redox的强大Shell" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://linux.pictures/tag:programming" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-03 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Logo 风格设计图" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这段代码是否可以运行？请按你的直觉说出答案。熟悉Rust的人，都知道，这个可以运行，因为其实是数字类型实现了ToString trait。impl<T: fmt::Display + ?Sized> ToString for T但是作者对此表示惊奇，还对比了Java、Python、C的处理原生类型的方式他生成了相关调用的汇编代码：这篇文章让我看到了一个学习Rust的反例： 以传统编程语言的思维去学习Rust。我真想建议他，要不然先看看trait ？ 事实上已经有朋友在评论里告诉他了。原文https://speice.io/2018/09/primitives-in-rust-are-weird.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-03 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "不可思议的Rust原生类型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文介绍了Servo中使用的通用worker事件循环组件 WorkerEventLoopMethods原文https://medium.com/programming-servo/programming-servo-a-generic-worker-event-loop-400a6f113a60" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-03 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Programming Servo系列博文： 通用的worker事件循环" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://tutorialedge.net/rust/learning-generics-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-03 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "学习Rust的泛型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://www.youtube.com/watch?v=B5xYBrxVSiE&feature=youtu.be" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-03 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「油管 Hello Rust系列」Go vs Rust： 并发与竞态条件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "问题： 给定Rc <Vec <u32 >>的所有权，我们可以编写一个返回impl Iterator <Item = u32>的函数吗？以下方案是错的：等价于：Rc<Vec<u32>>的问题在于，只拥有Vec<u32>的所有权，只能获得&Vec<u32>的引用，并且其生命周期只永远不会超过Rc<Vec<u32>>，所以导致，永远无法在数据上返回迭代器。要编写这个函数，我们需要找到一些方法将数据的所有权返回给调用者，同时仍然产生一个迭代器。这里正好因为当前Rc里的长度是固定的，可以使用这个技巧应用于其他类型。但要注意使用clone，还是所有权的问题。未来如何扩展语言来解决这些问题？\n支持自引用。自引用可以解决类似的问题，延长生命周期的使用。等NLL工作结束以后，就会考虑自引用如何在Rust中建模的问题了。\n辅助值。 基于辅助值可以实现这样的函数签名fn iterate<T>(data: Rc<Vec<T>>) -> impl Iterator<Item = ＆'aux T> ， 生命周期参数可以借助辅助值aux来给予。\n原文http://smallcultfollowing.com/babysteps/blog/2018/09/02/rust-pattern-iterating-an-over-a-rc-vec-t/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-03 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Niko博文 Rust模式系列：为Rc<Vec<T>> 构建迭代器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "The voxel world of Veloren, written in Rust and rendered using gfx-rs\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-03 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用gfx-rs实现的Veloren像素游戏世界" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "之前介绍过，由美国百度产品，最近发布的0.7版本，并加上了这个介绍页面mesalink.iohttps://mesalink.io/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-01 16:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Mesalink  : 内存安全的OpenSSL兼容TLS库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://klausi.github.io/rustnish/2018/08/31/benchmarking-a-rust-web-application.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-01 16:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "对Rust Web应用程序进行基准测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Demohttps://github.com/richardanaya/aws-lambda-api-rust顺便附上一个aws-lambda的Rust crate，其中包含了很多crate，可以将Rust中编写的程序直接作为AWS Lambda中的函数运行。上面demo中基本调用该craterust-aws-lambdahttps://github.com/srijs/rust-aws-lambda感谢 @黑化的齿轮  补充前因： https://so-wh.at/entry/2018/01/21/173709这个日本人最早研究了下aws lambda的go协议，然后搞出了纯rust的poc" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-01 16:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "aws lambda api 和Rust的完整Demo" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "azulhttps://github.com/maps4print/azul" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-01 16:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "azul ： 桌面GUI框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "基于《Ray tracing in one weekend》一书的代码实践（这本书在2018年，我见到第三次了）raynhttps://github.com/termhn/rayn\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-09-01 16:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rayn光线追踪渲染器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该会议是非技术性的，主要是讨论工作组进展看来要提上日程了原文https://github.com/rust-rfcs/unsafe-code-guidelines/blob/master/meeting-notes/20180308.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-31 13:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Unsafe 代码导读会议总结" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://github.com/trustnote/rust-trustnote/blob/master/RaspberryPi.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-31 13:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "基于树莓派构建TrustNode Rust SDK指南" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "librsvg作者发现该库出了两个Bug，泄漏了所有的SVG节点。主要问题出在Unsafe代码中。该库中使用了Rc：作者使用GDB监控了Rc的引用计数，最终检查出了内存泄漏的地方并得以修正。原文https://people.gnome.org/%7Efederico/blog/debugging-reference-leak-in-rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-31 13:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "调试Rust中的Rc <T>引用泄漏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果你是PHP开发者，可以看一看原文https://www.smashing-bugs.tk/software-development/rust/2018/08/27/on-rust-from-a-php-developer.html\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-31 13:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一名PHP开发人员对Rust的思考" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Flatbuffer是Google出品的高效跨平台序列化库，适用于游戏和其他内存受限的应用程序。PRhttps://github.com/google/flatbuffers/pull/4898" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-30 12:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "有人给Flatbuffer提交了Rust绑定的PR" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://www.reddit.com/r/rust/comments/9bdebh/simplematrix_v01_a_simple_ndimensional_matrix/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-30 12:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "simple-matrix：一个简单的N维矩阵库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "简要：\n嵌入式工作组开辟了新的Blog，可以RSS订阅\nNightly Rust已切换到lld用于Cortex-M的链接器\n对cortex-m，cortex-m-rt和cortex-m-quickstart进行了更新\n已支持aarch64-unknown-none！现在可以为64位ARM体系结构编写裸机Rust代码\nembedded-hal生态系统库又有一些新的release库\n原文https://rust-embedded.github.io/blog/2018-08-28-newsletter-10/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-30 12:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "嵌入式工作组第10期报告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者记录和分析了他在反序列化网卡地址时碰到的问题，并给出了解决方法原文https://noyez.gitlab.io/post/2018-08-28-serilize-this-or-that-into-u64/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-30 12:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Serde反序列化网卡地址为u64类型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "raphlinus是Xi-Editor的2号贡献者，在Google工作了11个年头，现在决定开启新的旅程，计划做一个音乐合成游戏？？？但他还会继续在Xi-Editor中投入精力。可不敢说「Xi-Editor的主力开发都走了，要凉了」之类话噢原文https://raphlinus.github.io/personal/2018/08/28/a-new-adventure.htmlxi-editorhttps://github.com/google/xi-editor" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-30 12:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Xi-Editor的2号贡献者将离开Google" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "TrustNote是开源stackful协程库May的作者黄旭东供职的区块链公司，感兴趣的也可以关注下原文https://medium.com/trustnote/trustnote-rust-sdk-v0-3-0-is-released-b2ea72d68d0f" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-30 12:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "TrustNote Rust SDK 0.3发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个开源组织号称要链接所有的区块链，里面有几个开源项目是Rust实现的，可以关注下原文https://github.com/coblox" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-30 12:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Coblox 链接所有的区块链" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Notify是Rust实现的跨平台文件系统通知库cargo-watch、cobalt等工具都使用了它原文https://github.com/passcod/notify\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-30 12:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Notify发布4.0.6" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "看了下，主要是增强了三方面：\n错误处理\n错误值\n泛型\n大致翻看了一下，看来Go 2的设计也是深受Rust的影响。一、错误处理方面，引入了 handle err {}来简化之前的 if err !=nil {}之类的写法。这个受到Rust Result错误处理的启发，这样的好处就是可以把错误处理和业务逻辑区分开来二、错误值， 主要是增强错误检查和错误格式化。草案中加入了下面两个接口通过实现此接口，可以自定义错误类型和错误格式。不由得想到了Rust里的Error trait。三、泛型Go2泛型也是深受Rust影响，比如草案中的代码contract声明了一种泛型约束，上面Equal表示，必须输入相等的类型。在Set 里使用 T Equal，表示对Set这个泛型进行Equal约束。这让我想起了Rust的trait bound。更多细节https://go.googlesource.com/proposal/+/master/design/go2draft.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-29 11:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Go 2 草案发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "今天，云原生计算基金会（CNCF）接受了TiKV进入CNCF Sandbox， 用于早期和持续发展的云原生项目。TiKV是一个由国内PingCAP公司开源的分布式事务键值数据库，基于Rust实现，由Raft（通过etcd）提供支持，并受到Google Spanner设计的启发，提供简化的调度和自动平衡，而不依赖于任何分布式文件系统。原文https://www.cncf.io/blog/2018/08/28/cncf-to-host-tikv-in-the-sandbox/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-29 11:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「国产软件之光」TiKV 进入了CNCF" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "android-sparsehttps://crates.io/crates/android-sparse" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-29 11:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Android sparse文件格式的Rust实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://mnt.io/2018/08/28/from-rust-to-beyond-the-asm-js-galaxy/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-29 11:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "From Rust to beyond系列：asm.js" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Gitpod是一个在线IDE，可以从任何GitHub页面启动。 只需在任何GitHub-URL前加上“https：//gitpod.io#”，或使用我们的浏览器扩展名为GitHub页面添加一个按钮。Gitpod介绍https://medium.com/gitpod/gitpod-gitpod-online-ide-for-github-6296b907a886" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-29 11:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Gitpod - GitHub的在线IDE支持Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新的改进有：\n将Rust的设置该成了独立的面板\n不突出显示保留字\n如果trait没有在当前范围内，则相应的方法调用会被高亮显示\n原文https://intellij-rust.github.io/2018/08/27/changelog-81.html\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-29 11:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "intellij-rust更新日志" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "基于Rust Nightly版可用，目前仍为实验性支持，不过是个很好的开始原文https://tokio.rs/blog/2018-08-async-await/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-28 10:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio已经开始支持async/await了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "亚马逊是RustConf 2018的金牌赞助商，来自多个AWS团队的成员参加了该会议。包括EC2 Nitro，CloudWatch和Amazon Linux。亚马逊已经在多个地方使用了Rust。AWS推荐了一个Rust SDK ：  https://rusoto.org/不出意外，AWS也会是RustConf 2019的金牌赞助商原文https://aws.amazon.com/blogs/opensource/rustconf-2018/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-28 10:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "亚马逊AWS对Rust的好评" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 氧化 sourmash系列文章第二篇，将代码库转换为Rust的过程在Rust社区中称为“氧化（Oxidizing）”原文https://blog.luizirber.org/2018/08/27/sourmash-wasm/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-28 10:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "氧化 sourmash ：WebAssembly" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://hur.st/blog/2018/08-25-password-generation-in-ruby-and-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-28 10:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Ruby和Rust 合作编写密码生成工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "面对十万行代码的巨型Rust应用，该如何调试代码，才能快速定位问题？\n最简单的，println!输出日志。但是这种方法在面对程序崩溃或内存泄漏时则不起作用。此时则需要更强大的工具，比如Linux中的GDB、macOS中的LLDB、Windows中VS调试器。\n本文主要探讨GDB，该工具和LLDB很相似，命令几乎相同。\n作者（ms是国人）在本文中着重介绍了GDB，基本上这是一个GDB入门教程。原文https://medium.com/coding-neutrino-blog/programming-servo-the-debug-way-5db01f09b7f4" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-28 10:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Programming Servo： 如果调试代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\ntarpc  Google出品的Rust RPC框架\nsccache， 一个共享编译缓存库，可以在远程云平台（比如AWS）缓存编译结果\nnoaa-apt， NOAA APT 图片解码器（WAV文件）\n\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-28 10:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GitHub 趋势榜新上榜项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://github.com/bwasty/vulkan-tutorial-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-27 12:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Vulkan指南" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "shceme.rshttps://github.com/isamert/scheme.rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-27 12:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust实现的scheme解释器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "包含了四种不同的风格原文https://isaacg1.github.io/posts/programmatically-generated-artwork/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-27 12:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust程序生成艺术图稿" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "MOPhttps://www.reddit.com/r/rust/comments/9abuys/announcing_mop/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-27 12:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「机器学习」 模块化的单一或多目标优化求解器 MOP 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://github.com/mozilla/application-services" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-27 12:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Firefox的应用服务使用Rust和Kotlin" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这些crates的在同一时间被创建，并且描述完全相同，并且留有“WIP. Contact me if you want to use this name!”的消息。这都是什么鬼？ 占这玩意能挣钱吗？原文https://www.reddit.com/r/rust/comments/9aaanw/cargo_crate_name_reservation_spam/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-27 12:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "crates.io有大量crates名字被占用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对Redis仓库进行统计为例：\ntokei  32.7 ± 1.4  30.0…36.2\nscc  50.5 ± 1.3  48.3…53.3\nloc  29.4 ± 5.0  23.3…45.9\ncloc  1288.4 ± 6.3  1276.1…1296.5\n原文https://github.com/Aaronepower/tokei/blob/master/COMPARISON.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-27 12:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "代码统计工具性能测试比较" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Partial-Mapped Crossover (PMX)是遗传算法中的一种交叉算子，叫部分映射本文主要是使用Rust (wasm)和JS，结合PMX算子来解决经典的旅行商问题原文https://blog.x5ff.xyz/blog/ai-rust-javascript-pmx/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-27 12:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Rust/ WASM 和JS中使用PARTIALLY-MAPPED (PMX)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "LLD 是LLVM新的内建链接器原文https://www.reddit.com/r/rust/comments/9a7te2/nightly_rust_is_switching_to_use_lld_llvms_new/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-26 12:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Nightly Rust选择使用LLD作为ARM微控制器的默认链接器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tokei是Rust实现的高性能代码统计工具原文https://github.com/Aaronepower/tokei/blob/master/CHANGELOG.md#800" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-26 12:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokei 8.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "lib_xch v0.9.1  发布原文https://www.reddit.com/r/rust/comments/9abw4t/lib_xch_v091_a_powerful_chemical_equation_balancer/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-26 12:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "强大的化学方程式平衡器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "steveklabnik1 回应I believe that the estimate is “within a few weeks”." }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-26 12:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustConf 2018 主题分享什么时候可以在线观看？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://llogiq.github.io/2018/08/25/synstruct.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-26 12:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用synstructure轻松编写过程宏 proc_macro_derive" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用纯lua构建web框架原文https://github.com/poga/actix-lua/tree/master/examples/lua-web" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-26 12:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "actix-lua 使用案例： actix-lua-web" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "访问控制列表（ACL）是Microsoft Windows安全模型不可或缺的一部分。 除了控制对安全资源的访问之外，它还用于沙盒，事件审计和指定强制完整性级别。 在编程操作ACL也非常痛苦，特别是在Rust中。 今天，帮助工具来了 - 我们发布了windows-acl，一个Rust crate，简化了在Windows上访问控制列表的操作。原文https://blog.trailofbits.com/2018/08/23/introducing-windows-acl-working-with-acls-in-rust/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-26 12:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "介绍windows-acl：在Rust中使用ACL" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新增了很多API\n异步上下文执行文件系统操作\n并发改进\n计时器改进\n原文https://tokio.rs/blog/2018-08-incremental-improvements/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-25 10:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio 0.1.8发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该公司发布了KDB+的Rust绑定。可以使用该公司的kdb+平台，来创建可以在消费级硬件上以数十GB /秒的速率处理数据的应用程序。KDB+ 简介kdb+ 号称 最强的内存数据库之一。列式存储的特性，使得对于某个列的统计分析操作异常方便。全球顶尖的投行，高盛，摩根，国内的国信等证券公司也开始使用，在延迟性上有着苛刻要求的金融领域，kdb+可谓一家独大。当然在优秀的性能背后，超高的费用也是必不可少的，貌似单核价格在3w+美刀以上?...kdb+:\n单体架构，轻松支持 billion以上数据\n分布式扩展，无性能损耗\n超低延迟+高并发支持\n列式存储+内存数据库\n灵活的Q语言，内置非常多的统计计算方法。\n(来源：知乎)原文https://blog.redsift.com/labs/rust-meet-q/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-25 10:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RedSift公司：当Rust遇见q" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目前Rust标准库早已有了内部可变的抽象，本文主要探讨，为什么no_std嵌入式开发也需要内部可变抽象原文http://blog.kjeka.com/rust/programming/tmcl/2018/08/24/interior-mut/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-25 10:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「嵌入式」为什么Rust核心库中需要内部可变抽象" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "将代码库转换为Rust的过程在Rust社区中称为“氧化（Oxidizing）”原文https://blog.luizirber.org/2018/08/23/sourmash-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-25 10:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "氧化 sourmash ：Python和FFI" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "capnp  vs protobuf原文https://github.com/ChrisMacNaughton/proto_benchmarks" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-25 10:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust序列化性能测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "actix-luahttps://github.com/poga/actix-lua" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-25 10:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "actix-lua 为Actix提供安全的lua脚本环境" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "11.24-11.25原文https://blog.rustfest.eu/next-stop-rome\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-25 10:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustFest大会将在罗马召开" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://falseidolfactory.com/2018/08/23/gfx-hal-part-1-resizing-windows.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-24 10:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gfx-hal指南 Part 1:  Resizing Windows" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用cargo-make原文https://dorianpula.ca/2018/08/22/to-make-or-not-to-make-using-cargo-make-for-rookeries-v0-12-0/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-24 10:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "To Make or Not to Make ?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Deno是Node.js之父的新项目，一个TypeScript运行时，已经完全用Rust重写，现在发布0.1语言成分：\nRust: 21.1%\nPython 16.5%\nC++ 14.1%\nC 1.1%\n原文https://www.reddit.com/r/rust/comments/99qd2s/deno_a_typescript_runtime_has_been_rewritten_in/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-24 10:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Deno 发布 0.1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://medium.com/@chyyran/calling-c-natively-from-rust-1f92c506289d" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-24 10:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust中调用C#" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本论文介绍了如何扩展SMACK验证器来支持Rust语言。SMACK 软件验证工具链。工具链提供了一个模块化和可扩展的软件验证生态系统将编译器前端源语言详细信息与后端分离验证算法。它通过翻译LLVM编译器中间表示到Boogie中间验证语言来实现这一目标。（说实话我也没看懂是验证啥，谁懂可以告诉我一下，谢谢）\nsmack软件验证器  \nPDF\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-24 10:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "论文：为Rust增加SMACK验证器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该仓库的PDF文件介绍了该游戏的玩法，目前只给出了Windows版本。\n将自己的.dll 文件注入到某个线程中，然后实现API Hook\n使用detours-rs库来实现detour hook\n可以关注下，后续也会发linuxPDFhttps://github.com/FabianB1998/Rust-Hacking/blob/master/document.pdf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-24 10:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 黑客游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pyo3是一个零配置的打包工具，可以将带有pyo3的crate方便构建到Python中，也可以在pypi上发布它。（这灵感好像是来自于wasm-pack）pyo3-pack意味着取代setuptools-rust。 它支持在Windows，Linux和Mac上构建用于python 2.7和3.5+的轮子，包括类似于audithweel的工具，并且可以像twine一样将轮子上传到pypi。原文https://www.reddit.com/r/rust/comments/99o0i7/announcing_pyo3pack_publish_crates_with_pyo3/相关博文  https://blog.schuetze.link/2018/07/21/a-dive-into-packaging-native-python-extensions.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-24 10:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pyo3-pack发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "及更多内容原文https://www.reddit.com/r/rust/comments/99ltpr/more_on_the_rls_and_a_10_release/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-24 10:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RLS 1.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "两个任务：\n确保在Rust中编写安全软件很容易\n确保Rust项目的基础结构是安全的\n「感觉有点必要，但至少得等到明年了吧，目前官方有专人在研究miri自动检测unsafe的UB，还在研究中」原文https://internals.rust-lang.org/t/proposal-security-working-group/8282" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-24 10:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「提案」建立Rust 安全工作组" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "（感觉推荐过一遍呢？）rapidushttps://github.com/maekawatoshiki/rapidus" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-24 10:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust实现的玩具JS 引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "它的主要目的是帮助Rust应用程序使用Apple的原生Objective-C框架。不要在生产环境使用它，目前是试玩。objrshttps://gitlab.com/objrs/objrs/tree/master\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-24 10:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Objective-Rust：Rust和Objective-C的邪恶联盟" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该文作者介绍了两个工具：\ncargo-watch 可以根据源码的改变自动构建doc\nhttp 可以生成文档的静态服务，也可以用cargo doc —open代替\n原文http://benjamincongdon.me/blog/2018/08/22/Live-Refreshing-Cargo-Docs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-23 15:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo doc 文档实时刷新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust比特币库原文https://github.com/rust-bitcoin/rust-bitcoin/blob/master/CHANGELOG.md#0140---2018-08-22" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-23 15:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-bitcoin 0.14发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用Rust编写webassembly库原文https://mnt.io/2018/08/22/from-rust-to-beyond-the-webassembly-galaxy/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-23 15:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「系列文章」 From Rust to beyond 第二篇" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "可以通过wasm为聊天内容加密解密，然后实现在公共聊天室里进行私密对话的功能原文https://www.reddit.com/r/rust/comments/99j576/wasm_reactjs_socketio_fun_a_public_chat/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-23 15:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WASM + React.js + Socket.io 编写的公共聊天加密程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该文是scc作者，在尝试使用Rust重写scc的学习心得scc是一个go实现的代码行数统计工具原文https://boyter.org/posts/reading-files-quickly-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-23 15:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust快速读取文件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "出于统一Pin类型的考虑（现在又是PinMut，又是PinBox，将来还会有PinRc、PinArc等），可能会制作一个组合Pin类型，如果要改的话，也只是API的改变，不会对Pin模型做出根本性变化。原文https://boats.gitlab.io/blog/post/rethinking-pin/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-23 15:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "withoutboats对Pin API的重新思考" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 语言核心开发人员Niko Matsakis 的Rust教程系列，目前出了五期，这里是第一集熟肉，野喵Up主翻译。B站视频https://www.bilibili.com/video/av30066131" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-23 15:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Into Rust (1) - 为什么你应该使用 Rust 语言?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Notes是Notes by Firefox，专门为Firefox 浏览器推出的便签 笔记 功能，目前已经发布了专属的Android 版本，可以脱离Firefox 浏览器单独使用。原文https://medium.com/firefox-test-pilot/notes-now-uses-rust-android-components-4809af1e4172" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-23 15:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Notes现在使用Rust和「Android组件」" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://github.com/polachok/gdax/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-23 15:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "futures 0.3 + tokio 的Demo" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://github.com/yoshuawuyts/changelog\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-23 15:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "新库：changelog帮助Rust开发者自动化生成changelog" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "const generics是什么？相信有不少人在标准库源码里看到数组实现trait，只是实现到长度为32的数组，也就是说有32个impl，而且都是手工编写。并不能为所有长度的数组实现那些trait。这正是因为当前还不能在const类型上使用泛型。如果支持const generics，将可以实现下面的代码：可以为所有长度的数组实现triat Foo。 那么数组的人体工程学将会得到很大的提升。帖子里也有人给出了其他的例子，可以看看。he Great Generics Generalisation这个合并，仅仅是实现const generics的一个基础，前方的路还很长吧原文https://www.reddit.com/r/rust/comments/98wa88/the_great_generics_generalisation_a_stepping/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-22 11:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "通往const generics 的里程碑The Great Generics Generalisation刚刚被merge" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 1.3到1.21中VecDeque :: reserve（）中的缓冲区溢出允许任意代码执行之前新闻里报道过，这个漏洞早已被修复，只是Rust官方没有发布CVE，在那个小哥的努力下，这个CVE算是补上了吧。原文https://cve.mitre.org/cgi-bin/cvename.cgi?name=%20CVE-2018-1000657" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-22 11:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "CVE-2018-1000657：" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "PRhttps://github.com/rust-lang/rust/pull/53562" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-22 11:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "这个PR有意思" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "heaven-on-earthhttps://github.com/NyxCode/heaven-on-earth" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-22 11:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "heaven-on-earth：自动从r/EarthPorn下载地球美图" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "TagniFi（https://www.tagnifi.com）是一家金融数据公司。提供通过API，网络和Excel提供的标准化财务数据。正在寻找一个远程Rust contractor来帮助完成各种项目。更多信息：TagniFi是从Rust 1.0开始，以脚本的形式使用它来监视/测试产品的各个方面。在了解Rust以后，现在决定加大投资力度，计划在整个产品中使用Rust，从后端/ API到Web前端。现在寻找一位工程师来帮助实现这一目标。可以远程工作，位置和时间不是工作的障碍。可能会让您处理的项目示例：抓取html页面以提取非结构化数据并将其解析为结构化表单，设计/开发与postgres数据库通信的API，以高性能方式访问财务数据，或使用WASM实现数据可视化Web组件。如果您对该职位感兴趣或有任何疑问，请通过jobs@tagnifi.com或daveb@tagnifi.com联系。原文https://www.reddit.com/r/rust/comments/994fcg/job_tagnifi_is_looking_for_a_rust_engineer/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-22 11:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "[远程] TagniFi 正在招聘Rust工程师" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章里有办公室美图，顺便它们也在招人：https://paritytech.io/jobs/原文https://medium.com/paritytech/engineering-at-parity-what-its-like-c0e5c8a17870" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-22 11:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Parity工作是什么体验？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这系列文章是讲Rust如何与其他语言交互\nWebAssembly\nASM.js\nC\nPHP\nNodejs\n原文https://mnt.io/2018/08/21/from-rust-to-beyond-prelude/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-22 11:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「系列文章」 From Rust to beyond前奏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://galois.com/blog/2018/08/c2rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-22 11:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "C2Rust项目的更多介绍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新版本Rand 0.5正准备发布，作者对以往的版本变化做了一个梳理原文https://www.reddit.com/r/rust/comments/87qy40/history_of_the_rand_crate/\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-22 11:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rand crate的发展历史" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文https://newrustacean.com/show_notes/news/rust_1_28/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-21 10:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "PodCast：聊聊Rust1.28" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "代码https://github.com/vi/tokio-stdin-stdout" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-21 10:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio异步读写示例" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ChaosBot" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你怎么看原文https://internals.rust-lang.org/t/a-working-group-for-rust-game-development/8240\n( 每日新闻备份地址 )\nTelgram Channel ： https://t.me/rust_daily_news \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2018-08-21 10:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于建立Rust 游戏开发 工作组的讨论" }, "type": "text" }], "type": "title" } },]
