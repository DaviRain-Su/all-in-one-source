export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "主要有以下特性：\n支持 brotli、deflate 和 gzip 编码的请求和响应。\n内置访问日志和 API 的指标。\n简单的 API 以获取当前的指标 - 以 JSON 和 Prometheus 格式。\n内置 OOR（Out of rotation API）以将服务器从轮换中移出。\n内置服务器健康 API。\n基于非常简单且快速的匹配模式的路由。\n比 actix 和其他现有的 Web 服务器快得多。\n支持可选的守护进程服务，在服务器启动时启动并在服务器关闭时停止。\n内置服务器关闭处理。\nGitHub: https://github.com/hyper-fast/hyper-fast" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/hyper-fast/hyper-fast" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-10 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "hyper-fast：基于Hyper和Rust的HTTP Server" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新增：\n添加了用于重置终端的 panic 钩子（#106）。\n为参数波浪线扩展添加了测试。\n添加了在Alpine Linux上安装的说明。\n已更改：\n允许部分配置文件（#116）。\n将最低支持版本（MSRV）设置为1.70.0。\n默认启用颜色。\n更好地集成了 panic 处理。\n在变更日志中跳过依赖项版本升级。\n在发生 panic 时恢复光标。\nGitHub: https://github.com/orhun/gpg-tui/blob/master/CHANGELOG.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/orhun/gpg-tui/blob/master/CHANGELOG.md" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-10 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gpg-tui 0.10.0发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个纯 Rust 编写的 Lua 解释器和运行时，它接收一个 Lua 字符串，将其编译为字节码，并运行到完成，返回一个可以轻松解包成本地类型的 Value 对象。该运行时是基于堆栈的，就像早期版本的 Lua 一样。垃圾回收正在开发中，但目前 RC（引用计数）用于包装复杂对象，如表，只是不要创建一个链表。GitHub: https://github.com/Auxnon/silt-lua" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Auxnon/silt-lua" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-10 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "silt-lua：lua解释器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "特性：\n为了避免UI阻塞的异步IO操作。\n可自定义的按键绑定（默认为vi风格）。\n可通过shell命令进行扩展和配置。\n使用 src/config.rs 来配置tfm，就像dwm、st和dmenu一样。\nGitHub: https://github.com/jiaoshijie/rust-tfm" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jiaoshijie/rust-tfm" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-10 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tfm：终端文件管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n通过写一个ray tracer学习Rust：https://the-ray-tracing-road-to-rust.vercel.app/\n5天Rust教程：https://mo8it.com/blog/teaching-rust/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-10 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Arroyo 是一个流处理引擎。Arroyo 0.5 添加了一个高性能事务文件接收器，解决了数据仓库摄取的等待问题。简而言之，Arroyo 现在可以将流式 SQL 查询的结果以 Parquet 和 JSON 格式写入 S3 等对象存储中。Arroyo 博客文章链接，https://www.arroyo.dev/blog/streaming-to-s3-is-hard" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.arroyo.dev/blog/streaming-to-s3-is-hard" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-09 19:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Arroyo v0.5，高效地将流式数据传输到 S3" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章作者认为：异步 Rust 与“普通” Rust 相比更难理解，为开发者增加了更多新的挑战。而 Zde-G 则认为：Rust 的优点和缺点都在于它是一种“不出意外”的语言，它不喜欢把问题掩盖起来，并假装复杂的事情实际上非常简单。.........讨论链接，https://www.reddit.com/r/rust/comments/16dk9ya/async_rust_is_a_bad_language/博客文章链接，https://bitbashing.io/async-rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://bitbashing.io/async-rust.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-09 19:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "异步 Rust 很糟糕？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Turborepo 是个 JavaScript 和 TypeScript 代码库的高性能构建系统。目前团队正在将其从 Go 移植到 Rust，而 Zig 是一种新的系统编程语言，它快速、简单，最重要的是与 C 具有良好的互操作性，有自己的 C 编译器 zig cc。了解 Turborepo 团队如何使用 Zig 将 Rust-Go-Rust 交叉编译到 6 个平台。https://turbo.build/repo博客文章链接，https://vercel.com/blog/how-we-continued-porting-turborepo-to-rusthttps://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://vercel.com/blog/how-we-continued-porting-turborepo-to-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-09 19:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Turborepo 移植中 Zig 的使用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Servo 项目由 Mozilla Research 于 2012 年创建，是除编译器本身之外的首个主要 Rust 代码库，自此成为实验性网络引擎设计的标志。Servo 的主要组件已被集成到 Firefox 网络浏览器中，其若干解析器和其他底层库也已成为 Rust 生态系统的基础。作为一个有前途的、现代的、开放的网络引擎，Servo 可用于使用网络技术构建应用程序和沉浸式体验，2020 年，Servo 的管理权从 Mozilla Research 转移到了 Linux 基金会。2023 年，在 Linux 基金会欧洲成员 Igalia 的领导下，Servo 重新活跃起来，目前已有一支工程师团队致力于该项目。今天，我们很高兴地宣布 Servo 项目正式加入 Linux 基金会欧洲分会。详情请看：https://www.igalia.com/2023/09/07/The-Servo-project-is-joining-Linux-Foundation-Europe.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.igalia.com/2023/09/07/The-Servo-project-is-joining-Linux-Foundation-Europe.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-08 19:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Servo 项目将加入欧洲 Linux 基金会" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "从本质上讲，Tauri 的 2.0 版本主要是移动端的更新，但 2.0 版不仅限于移动端。详情请看：https://beta.tauri.app/blog/roadmap-to-tauri-2-0/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://beta.tauri.app/blog/roadmap-to-tauri-2-0/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-08 19:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tauri 2.0 的 Roadmap" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Hugging Face 为 Rust 创建了一个新的极简机器学习框架，还创建了用于创建企业代码助手的 SafeCoder。详情请看：https://thenewstack.io/candle-a-new-machine-learning-framework-for-rust/https://github.com/Jancd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://thenewstack.io/candle-a-new-machine-learning-framework-for-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-08 19:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Candle：适用于 Rust 的全新机器学习框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rustic 是一个用 Rust 实现的快速,加密,去重的备份工具, 它可以读写 restic 的 repo 格式,在大多数情况下可以替代 restic。它支持主要操作系统(Linux, MacOs, BSD)。rustic 当前还在测试阶段, 一些功能还在开发中。Github 主页: https://github.com/rustic-rs/rustic ↗" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rustic-rs/rustic" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-07 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustic - 快速,加密,去重备份工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tauri 1.0 于 2022 年 6 月发布,它允许开发者使用 HTML, CSS 和 JavaScript 构建 app,并具有 Rust 的安全性和性能。Tauri 2.0 的一个重要特性是支持移动端(iOS 和 Android)。此外还有:\n强大的插件系统\nSwift 和 Kotlin 绑定\n当前 Tauri 2.0 还在测试阶段,预计 2024 年初会推出稳定版本。欢迎测试和提供反馈。详见:https://beta.tauri.app/blog/roadmap-to-tauri-2-0/ ↗" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://beta.tauri.app/blog/roadmap-to-tauri-2-0/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-07 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tauri 2.0 路线图" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Reddit 社区进行了一次 Rust 相关博客的汇总,列出了一些值得关注的博客。部分博主:\n\nNiko Matsakis\n\n博客:https://smallcultfollowing.com/babysteps/ ↗\n简介:Rust 核心团队成员,Rust 语言的主要设计师和实现者之一。\n\n\n\nRalf Jung\n\n博客:https://www.ralfj.de/blog/ ↗\n简介:Rust 核心团队成员,Rust 语言内存模型和不可变性的主要设计师。\n\n\n\nAlexis Beingessner\n\n博客:https://gist.github.com/Gankra/ ↗\n简介:Rust 核心团队成员,集合库(Collection)的主要维护者。\n\n\n\nYoshua Wuyts\n\n博客:https://blog.yoshuawuyts.com/ ↗\n简介:Rust 社区活跃贡献者,WebAssembly 和 Rust 在 Web 领域应用的推动者。\n\n\n\nJames Munns\n\n博客:https://jamesmunns.com/blog/ ↗\n简介:Rust嵌入式生态系统维护者,经常在博客上分享嵌入式Rust相关的内容。\n\n\n\nJames McMurray\n\n博客:https://jamesmcm.github.io/blog/ ↗\n简介:Rust嵌入式编程爱好者,在博客上分享了许多Rust编程相关的话题,包括嵌入式方面。\n\n\n\nLlogiq\n\n博客:https://llogiq.github.io/ ↗\n简介:Rust 社区活跃贡献者,经常就 Rust 编程话题撰写博文。\n\n\n\nLuca Palmieri\n\n博客:https://www.lpalmieri.com/ ↗\n简介:Rust WebAssembly 方面的专家,《Rust 和 WebAssembly》https://rustwasm.github.io/book/ ↗一书的作者。\n\n\n\nSabrina Jewson\n\n博客:https://sabrinajewson.org/blog/ ↗\n简介:Rust 游戏开发生态参与者,她的博客上会分享游戏开发相关的 Rust 话题。\n\n\n\nTyler Mandry\n\n博客:https://tmandry.gitlab.io/blog/ ↗\n简介:Rust 语言教育领域的推动者,他经常就 Rust 教学方法发表见解。\n\n\n\nMara Bos\n\n博客:https://blog.m-ou.se/ ↗\n简介:Rust 语言教育领域的推动者,经常撰写 Rust 语言培训课程。《Rust Atomics and Locks\n》https://marabos.nl/atomics/ ↗ 的作者。\n\n\n\nJack Huey\n\n博客:https://jackh726.github.io/ ↗\n简介:Rust 的教学者、讲师,他的博客上经常有 Rust 初学者可以学习的内容。\n\n\n\nRust We" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/16budqk/rust_blogs_you_follow/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-07 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 博客汇总" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本周 Rust 社区快报发布,内容包括:\nRust 项目治理更新\ncargo-audit 0.18 发布\ncrate.io 事故发生和应对\nRust 游戏开发月报\nSlint 1.2 发布\nDiesel 异步版本发布\n详见: https://this-week-in-rust.org/blog/2023/09/06/this-week-in-rust-511/ ↗请关注我们的更新，以便了解更多有关 Rust 的新闻和动态！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/09/06/this-week-in-rust-511/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-07 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周 Rust 社区快报" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n优雅、直观和富有表现力的 API\n内置测试功能\n支持扩展\n用法：ReadMore:https://github.com/owlduty/grillon" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/owlduty/grillon" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-06 19:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Grillon - API 测试框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "qcd是一个Linux工具，有助于提高命令行的效率。ReadMore:https://github.com/ClaasBontus/qcd_rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ClaasBontus/qcd_rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-06 19:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "qcd - 快速切换目录" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "cargo audit 是一个工具，可以检查你的项目依赖项中已知的安全漏洞。默认情况下，它会检查你的 Cargo.lock 文件，但也可以扫描编译后的二进制文件。新版本带来了以下特点:\n性能: cargo audit 现在在检查被撤回的包时使用稀疏的 crates.io 索引，这大大加快了扫描过程，因为不再需要下载整个 crates.io 索引。\n安全性: cargo audit 之前依赖于所有平台上的 OpenSSL。在这个版本中，我们已经切换到 rustls - 一个高质量的、内存安全的 Rust 中的 TLS 实现。\n兼容性: 由于从 libgit2 切换到 gitoxide 作为我们的 git 实现，解决了许多长期存在的问题。\ngithub仓库地址https://github.com/rustsec/rustsec" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-05 21:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-audit 0.18 版本 - 性能、兼容性和安全性改进" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "tokio-graceful 是一个为使用 Tokio 异步运行时的 Rust 项目提供的优雅关闭工具。该项目使用 guard 这个概念来帮助管理和控制应用程序的关机过程：当一个\"guard\"存在时，它可以阻止应用程序的关机，直到该\"guard\"被放弃或丢弃。这样，它可以确保在应用程序关机之前完成所有重要的任务和操作。在 tokio-graceful 中，有两种类型的\"guard\"：弱守护和强守护。弱守护不会影响关机的引用计数，而强守护则会通过 Rust 中的 Guard 该工具的创建和使用都是无锁的，并且只在以下情况下锁定：\n当你使用(弱或强)守护，等待是否真的取消了关闭信号时；\n当检查应用程序是否可以关闭时，通常会锁定，直到接收到关闭信号并丢弃所有(强)守护。\n并且，该工具是用 100% 安全的 Rust 代码编写的。它提供了一些示例，展示了如何在实际的生产环境中使用这个工具包。github仓库地址https://github.com/plabayo/tokio-graceful" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-05 21:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tokio-graceful: 为使用 Tokio 异步运行时的 Rust 项目提供的优雅关机工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "介绍: Slint 1.2 版本发布，包括许多新功能，同时保持完全的向后兼容性。主要有以下特性：\n改进的平台API: Slint 的平台 API 是一个低级接口，为窗口表面和事件循环提供抽象。在 1.2 版本中，我们显著扩展了 Rust 和 C++ 的公共 API，以支持新的用例，如在外部应用程序中嵌入 Slint UI、为自定义窗口系统实现自己的后端等。\n对 Espressif 的支持: 我们为 Espressif IDF 框架构建了一个Slint ESP-IDF 组件，该组件实现了我们的新 C++ 平台层。\nLinuxKMS 后端: 在 Slint 1.2 中，我们引入了新的轻量级、实验性的 LinuxKMS 后端，为嵌入式设备提供了单一全屏应用程序的用户界面。\n其他功能和错误修复: 包括添加 ReverseModel、增强的 StandardListView、新的 VS code 扩展中的新手指南等。\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-05 21:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Slint 1.2 发布：增强的平台抽象" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "crates.io 安全团队在 8 月 16 日收到了 Phylum 的报告，称有用户上传了 9 个 typosquat  crates，并含有恶意代码。 crates.io 团队立即将这些 crates 下架，并锁定了该用户的账号。在 8 月 18 日，crates.io 团队将这些 crates 从文件存储中完全删除。这些 crates 包含恶意的 build.rs 文件，该文件会尝试将用户计算机的元数据（包括操作系统、IP 地址和基于 IP 地址的地理位置信息）发送到一个 Telegram 频道。其中一个 crates 的早期版本还包含了 PuTTY 安装程序，build.rs 文件会启动 PuTTY 而不是发送元数据到 Telegram。crates.io 团队在收到报告后立即采取了以下措施：下架 crates 并锁定用户账号。分析了 crates 和用户的操作日志，并决定将 crates 从 static.crates.io 文件存储中完全删除，以防止进一步的攻击。crates.io 团队没有发现任何证据表明这些 crates 被实际用户下载过。分析了下载请求的用户代理信息，发现只有自动扫描器和镜像服务下载了这些 crates。该用户在 8 月 18 日前 30 天内没有进行任何其他操作（恶意或非恶意）。Rust 基金会安全倡议计划对所有 crates 上传进行扫描，包括 typosquatting 和 crates 文件的实际内容。crates.io 团队将与基金会合作，在这些扫描程序准备好后进行部署。原文链接https://blog.rust-lang.org/inside-rust/2023/09/01/crates-io-malware-postmortem.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-04 18:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "crates.io 发现用户上传恶意软件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Geese 是一个事件系统库，它允许用户通过构建依赖图来组合 actor。Geese 可以用于构建任何规模的 Rust 项目。本视频提供了使用 Geese 的简介，包括：\n创建上下文\n触发事件\n定义事件系统\n监听事件\n声明和访问系统依赖项\n油管视频https://www.youtube.com/watch?v=zqNTbttpmaY" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-04 18:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 和 Geese 事件框架实现乒乓球游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "just 为您提供一种保存和运行项目特有命令的便捷方式。本教程演示了如何使用 just工具来管理 Rust 的项目.just github 地址https://github.com/casey/just原文链接https://dev.to/nazmulidris/use-just-to-manage-rust-project-commands-56cp--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-04 18:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 just 管理 Rust 项目命令" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "sudo-rs 项目通过以下方式改进了原始 sudo 的安全性：\n使用内存安全语言（Rust），因为估计原始 sudo 中三分之一的安全漏洞都与内存管理问题有关。\n省略不常用的功能，以减少攻击面。\n开发了广泛的测试套件，甚至成功地发现了原始 sudo 中的漏洞。\nBlog: https://www.memorysafety.org/blog/sudo-first-stable-release/GitHub: https://github.com/memorysafety/sudo-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/memorysafety/sudo-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-03 23:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "sudo-rs：sudo 和 su 的内存安全实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "avalanche-rs 是一个 crate 集合，它提供了在 Avalanche 生态系统中开发基于 Rust 的应用程序和 VM 所需的所有抽象。它提供了所有各种 Avalanche API 的规范类型定义，与 avalanchego 中的定义相当，但适用于 Rust 开发人员。Avalanche是一个开源平台，用于在一个互操作性、去中心化和高度可扩展的生态系统中构建分布式应用程序。依靠独特强大的共识机制，Avalanche是第一个旨在适应全球金融规模、近乎瞬间完成交易的生态系统。GitHub: https://github.com/ava-labs/avalanche-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ava-labs/avalanche-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-03 23:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "avalanche-rs：Avalanche API/VM SDK" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "项目目标如下。\n具有自己独立于 Clippy 的自定义代码检查集，以允许不同的默认设置。\n作为 Rustc 内部 API 稳定性的测试平台。\n通过为编译器内部提供自己的 API，充当一种缓冲，以避免频繁重写代码检查工具（这项工作尚未开始）。\n作为 CI 的一部分快速编译，以便项目可以编写特定于项目的代码检查。\nGitHub: https://github.com/estebank/redpen" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/estebank/redpen" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-03 23:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "redpen：又一个linter" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在桌面上显示近乎实时的卫星图像。\n几种不同的卫星可供选择，覆盖地球的大部分地区 - 不仅仅是美洲！\n适用于任意分辨率的显示器。\n地球的大小（相对于输出图像的高度）是可配置的。\nGitHub: https://github.com/Colonial-Dev/satpaper" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Colonial-Dev/satpaper" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-03 23:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Satpaper：桌面上的卫星图像" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个同步没有I/O的WebRTC，RTC实例本身不进行任何网络通信，它没有内部线程或异步任务，所有操作都通过公共 API 的调用同步发生。“sans I/O”意味着在实现某些功能或库时，不涉及任何与输入和输出相关的操作，而仅仅操作数据的字节或文本，以提高代码的重用性和灵活性。这种方法允许使用该库的代码在不受I/O决策的限制下进行重用，并且可以适用于各种I/O方式，包括同步和异步I/O。这个概念通常用于讨论编程中的模块化和通用性设计。相关文档：https://sans-io.readthedocs.io/how-to-sans-io.htmlGitHub: https://github.com/algesten/str0m" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/algesten/str0m" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-03 23:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "str0m：同步无I/O WebRTC" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Stable Diffusion WebUI API请求器，调用HTTP请求到SD WebUI API，从命令行生成图像。Endpoint、要使用的模型、要生成的图像数量、txt2img 配置等都是可配置的。GitHub: https://github.com/sorainnosia/sd-req/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sorainnosia/sd-req/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-03 23:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "sd-req：SD请求器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章衡量了wtx和其他项目的性能，以确定哪个更快。结果如下图所示。Blog: https://c410-f3r.github.io/thoughts/the-fastest-websocket-implementation/GitHub: https://github.com/c410-f3r/regular-crates/tree/main/ws-bench" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/c410-f3r/regular-crates/tree/main/ws-bench" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-03 23:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WebSocket最快实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我发布了 Freya 的第一个版本，这是一个由 Dioxus 和 Skia 提供支持的 Rust 实验性原生 GUI 库。目前它可以在 Windows、macOS 和 Linux 上运行。我希望第一个版本能够收集建议、想法、反馈和贡献。文章链接，https://www.reddit.com/r/rust/comments/167zdd8/announcing_freya_gui_library/Github 链接，https://github.com/marc2332/freya" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/marc2332/freya" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-02 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Freya GUI 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用于 Python 应用程序的 Rust HTTP 服务器。Granian背后的主要原因是：\n拥有单一、正确的 HTTP 实现，支持版本 1、2（最终是 3）\n为多个平台提供单一包\n避免 unix 系统上常见的 Gunicorn + uvicorn + http-tools 依赖组合\n与现有替代方案相比，提供稳定的性能\n文章链接，https://www.reddit.com/r/rust/comments/167yf41/granian_http_server_open_call_for_core/Github 链接，https://github.com/emmett-framework/granian" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/emmett-framework/granian" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-02 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Granian HTTP server" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在是 Pavex 的另一份进度报告的时候了，其中涵盖了 7 月和 8 月所做的工作！我一直在努力实现一个目标：为 Pavex 添加中间件支持。目前还远未完善，但它（终于）可以工作了我将利用这份报告作为深入探讨以下几个主题的机会：\n为什么中间件支持是生产就绪的关键要求\n为 Rust Web 框架设计中间件系统的挑战\nPavex的中间件设计\n我们当前实施的局限性\n但如果您时间有限，这里有一个简单的超时中间件来展示 Pavex 中的中间件：文章链接，https://www.lpalmieri.com/posts/pavex-progress-report-06/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.lpalmieri.com/posts/pavex-progress-report-06/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-02 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pavex DevLog #6: 设计安全且符合人体工程学的中间件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "nucleo 是一个用 Rust 编写的快速模糊匹配库，在 nucleo-matcher 核心之上提供高级 API ，以供应用程序能够方便快捷地集成。其主要特性包括：\n在后台线程池中并行运行匹配器，不阻塞用户界面线程。\n允许完全并行的无锁注入/流式输入到匹配器中。\n相比 fuzzy-matcher 而言， nucleo-matcher 能够提供更好的性能，目前，Helix 编辑器已经集成 nucleo 来取代 fuzzy-matcher，并且解决了许多长期存在的可用性和性能问题。Github - helix-editor/nucleo: https://github.com/helix-editor/nucleo" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/helix-editor/nucleo" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-01 00:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "nucleo - 快速模糊匹配库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RootAsRole 允许你在 Linux 操作系统上更安全地配置特权访问管理，并提供一套基于角色的访问控制模型，有助于更好地管理系统任务。这是作者博士课题研究的一部分，过去使用 C 语言编写，近期使用 Rust 进行了重写。下面列出一些该项目与 sudo 的不同点：\n其核心功能上设定有最小权限原则。\n使用常用或标准化的语法（XML、扩展通配符、PCRE2）。\n使用基于角色的访问控制模型，允许更精确地满足最小权限需求。\n管控规则之间的偏序比较，以防止规则重叠或由于配置错误导致的未经授权访问。\nGithub - LeChatP/RootAsRole: https://github.com/LeChatP/RootAsRole" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/LeChatP/RootAsRole" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-01 00:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RootAsRole - 使用 Rust 重写的 sudo/su 安全替代" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 510: https://this-week-in-rust.org/blog/2023/08/30/this-week-in-rust-510/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/08/30/this-week-in-rust-510/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-09-01 00:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Week In Rust 510" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "打开一个连接，创建一张表，并插入几行数据：选择一些行并逐行以纯文本的形式处理，这通常不是很高效的方法：使用预编译语句运行相同的查询，这比之前的技术要高效得多：使用游标运行相同的查询，这是可迭代的：\nhttps://github.com/stainless-steel/sqlite\nSWC（Speedy Web Compiler）是一个用 Rust 编写的超快速 TypeScript / JavaScript 编译器。它是一个同时支持 Rust 和 JavaScript 的库。如果您使用 Rust 中的 SWC，请参阅rustdoc，对于大多数用户来说，使用该库的入口点将是 parser。https://rustdoc.swc.rs/swc/\nhttps://github.com/swc-project/swc\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-31 18:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "stainless-steel/sqlite -- 与 SQLite 进行交互的接口" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在本文中，我创建了一个几乎不起作用的 Rust 后端，使其能够编译 .NET 运行时（通常用于运行 C# 和 F#）。目前它处于概念验证阶段，但我相信它仍然可能引起一些兴趣。ReadMore: https://fractalfir.github.io/generated_html/rustc_codegen_clr_v0_0_1.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fractalfir.github.io/generated_html/rustc_codegen_clr_v0_0_1.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-29 15:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 编写实验性质的 JVM 和 .NET Runtime" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在这篇文章中，我将讨论 RJVM 如何执行 Java 字节码。我们将讨论各种指令的处理，至于方法调用和异常处理，我们会留到下一部分，因为这篇文章已经够长了。 😅ReadMore: https://andreabergia.com/blog/2023/08/a-jvm-in-rust-part-5-executing-instructions/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://andreabergia.com/blog/2023/08/a-jvm-in-rust-part-5-executing-instructions/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-29 15:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "A JVM in Rust Part 5 - 执行指令" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Ockam 是一套Rust库、命令行工具和托管的云服务，用于编排端到端加密、相互认证、密钥管理、凭证管理和授权策略执行。Ockam的端到端安全通道保证了应用层中所有数据在传输过程中的真实性、完整性和保密性。使用 Ockam，网络管理员无需更新网络访问控制列表、安全组或路由表。Ockam 通过基于属性的访问控制对您的服务应用细粒度控制。您甚至可以与外部身份提供者（如Okta）集成，以限制谁可以访问您的服务。在这篇博客文章中，我们将探索Ockam命令行界面，并看看如何将传统的Web应用程序连接到PostgreSQL数据库。我们将创建一个非常基本的Python Flask应用程序，它只是在PostgreSQL数据库中递增一个计数器。然后，我们将通过Ockam安全通道将应用程序和数据库之间的连接移动。ReadMore: https://www.ockam.io/blog/basic_web_app" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.ockam.io/blog/basic_web_app" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-29 15:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "从Web应用程序安全访问数据库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好！我是 Rust 新手，决定为我的第一个 Rust 项目编写一个模板引擎。并不是出于需要，因为生态系统已经有一些不错的选择，而是为了乐趣和学习。这是我第一次尝试这种类型的库，因此我从其他一些现有项目（即 Tera 和 Upon）中获得了灵感。结果是一个模板引擎支持 Tera 的类似功能集，同时保留 On 做出的一些更好的性能决策。如果其他 Rust 开发人员发现任何需要改进的地方，请指出，以便我改进。我将不胜感激！以下是详细说明迄今为止已实现的内容的文档：https://docs.rs/ban/0.51.0/ban/存储库在这里：https://github.com/jmkng/ban" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-29 13:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "第一个 Rust 项目：模板引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/parksb/collie我使用Tauri制作了一个 RSS/Atom feed 阅读器桌面应用程序！Collie 是一个在桌面上运行的最小 RSS 提要阅读器应用程序。有了柯利犬，您可以：https://tauri.app/\n订阅多个 RSS/Atom 源来组织您自己的新闻源。\n当新项目添加到订阅源时收到实时通知。\n并保存项目以供再次或稍后阅读。\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/parksb/collie" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-29 13:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Collie：专为您打造的简约 RSS 阅读器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "[🛠️项目](https://www.reddit.com/r/rust/search?q=flair_name%3A\"🛠️ project\"&restrict_sr=1)Blob-dl 使从 YouTube 下载视频或音频文件变得非常简单。从本质上讲，它是一种非常用户友好的 yt-dlp 使用方式，但它还提供了错误跟踪等附加功能。您可以在自述文件中阅读有关此工具的更多信息，GitHub 链接为https://github.com/MicheleCioccarelli/blob-dl。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-29 13:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我的第一个 Rust 项目：blob-dl，一个快速下载 YouTube 视频的命令行工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "传统上，微控制器只能运行 C 代码。固件开发人员通常会使用 Eclipse 基于 IDE 以及定制的编译器工具链来编译代码。但是，MicroPython 最近变得流行起来。RaspberryPi Pico、ExpressIf 的 ESP32 是一些对 MicroPython 支持相当不错的微控制器。可以将 WebAssembly (WASM) 二进制文件在浏览器外部运行。如果可以替代 Python，在微控制器上运行 WASM 二进制文件会怎样？这意味着我们可以使用 C++、Rust、Go 等编程语言进行微控制器编程！作为额外的好处，我们还可以获得 WASM 沙箱的安全性和灵活性。Bytecode Alliance 构建的 WASM Micro Runtime（也称为 WAMR）是朝着这个方向迈出的一步。在本文中，我们尝试使用 WAMR 在 ESP32 板上运行 Rust 生成的 WASM 二进制文件原文链接https://anoopelias.github.io/posts/wasm-micro-runtime-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-28 17:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WASM 微运行时与 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust traverse 是一个基于终端的文件资源管理器，它受到 NNN 文件管理器的启发。它使用 tatatui 作为终端用户界面，并使用 crossterm 作为终端后端现在 v2 版本已经发布github 地址https://github.com/dmcg310/Rust-Traverse" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-28 17:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust-Traverse" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tinymarch 是一个用 Rust 编写的 CPU 小型光线 MarcherTinymarch 的特点:\n使用 Rust 编写，可移植性强。\n使用 Rayon 进行多线程处理，可提高性能。\n支持 Signed Distance Fields (SDFs)，可用于渲染复杂的几何图形。\n易于使用，可以快速上手。\nTinymarch 的用途\n可以用于创建逼真的 3D 图像\n可以用于创建动画。\n可以用于创建交互式 3D 应用程序。\n可以用于进行科学计算\ngithub地址https://github.com/TristanAntonsen/tinymarch--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-28 17:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tinymarch" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在reddit上看到这个项目 Stable-Diffusion-XL-Burn ,它 是一个基于 Rust 的项目，将stable diffusion xl 移植到了 Rust 深度学习框架 burn 中。在reddit回帖上，已经有小伙伴在热情的尝试，还有小伙伴问到，“what's the performance difference to Pytorch on GPU/CPU?” 社区有小伙伴对这个项目感兴趣吗？👀Github repo: https://github.com/Gadersd/stable-diffusion-xl-burn阅读原文：https://www.reddit.com/r/rust/comments/1613ajv/stable_diffusion_xl_in_rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Gadersd/stable-diffusion-xl-burn" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-27 00:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Stable-Diffusion-XL-Burn：SDXL in Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust Release Team在 Rust Blog上官宣了1.72.0版本的发布，可以使用如下命令，获取1.72.0：阅读原文了解更多：https://blog.rust-lang.org/2023/08/24/Rust-1.72.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2023/08/24/Rust-1.72.0.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-27 00:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.72.0 stable发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一篇叙述如何使用 ESP32 和 esp-idf-hal 驱动 LED 点阵的文章，准确说是“ESP32 Standard Library Embedded Rust”，有关SPI 与 MAX7219 LED 点阵。阅读原文：ESP32 Standard Library Embedded Rust: SPI with the MAX7219 LED Dot Matrix， https://apollolabsblog.hashnode.dev/esp32-standard-library-embedded-rust-spi-with-the-max7219-led-dot-matrix?ref=twitter-share" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://apollolabsblog.hashnode.dev/esp32-standard-library-embedded-rust-spi-with-the-max7219-led-dot-matrix?ref=twitter-share" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-27 00:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust嵌入式领域应用：Rust on ESP32" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "根据介绍，原文作者是一名后端&区块链开发工程师，全文可以分为三大板块，一块是讲Rust，一块是讲Zig，还有一块是讲二者的对比。当然，作者也在文末表达了自己的看法，没有什么“Winner”，每个语言都有自己的优势与劣势，在使用一门语言钱=前应该去了解、去研究它。小编的看法是，不知道为什么，最近Zig突然“小火🔥了一把”，网上有关Zig和Rust之间对比的文章也多了起来。相比Rust，Zig还是一个太初期的语言，还需要时间发展。相比Rust，如果更加关注与现有C代码进行集成，同时还要在性能与内存安全之间找到平衡，说不定可以考虑下Zig。但是更多的，还是要考虑实际的项目需求，个人喜好和未来发展方向么，然后做出选择。这里不引战嗷！下面有一个表格给我们展示了二者的不同之处，二者的相同之处是：\nMemory safety\nLow-level control\nPerformance optimization\nCommunity and availability\nNo undefined behavior\n具体可以直达原文进行阅读。阅读原文：https://blog.logrocket.com/comparing-rust-vs-zig-performance-safety-more/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.logrocket.com/comparing-rust-vs-zig-performance-safety-more/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-27 00:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust vs Zig：在性能、安全以及更多方面的对比" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "X Posts or Tweets：https://twitter.com/tony_mushah/status/1695074658175889881?s=20" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://twitter.com/tony_mushah/status/1695074658175889881?s=20" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-27 00:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "梗图：I spend my day coding in rust today" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "关于 Rust 编译器性能方面的更新\n增量编译使用哈希算法来检测代码片段何时发生更改并需要重新编译；\n编译器使用的 LLVM 版本升级到 LLVM 16；\n所有基准测试结果的平均挂机时间减少了 1.05%，其中改进主要来自增量构建；\n...\n博客链接，https://nnethercote.github.io/2023/08/25/how-to-speed-up-the-rust-compiler-in-august-2023.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://nnethercote.github.io/2023/08/25/how-to-speed-up-the-rust-compiler-in-august-2023.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-26 20:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何加速 Rust 编译器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "将 Stable Diffusion XL 移植到 Rust 的深度学习框架 burn。就图像质量而言，SDXL 比 SD 有了巨大进步。 方形分辨率已从 512x512 增加到 1024x1024。 SD 存在一个训练错误，导致图像生成被裁剪。SDXL 不存在此问题，因为可以在生成过程中直接指定裁剪参数。https://github.com/Stability-AI/generative-modelsStable Diffusion XL 是 Stability AI 推出的 Stable Diffusion 文本到图像模型套件中最先进的开发成果。GitHub 链接，https://github.com/Gadersd/stable-diffusion-xl-burn" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Gadersd/stable-diffusion-xl-burn" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-26 20:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 实现 Stable Diffusion XL" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Slingshot 是一个在终端中浏览文件的轻量级工具。它允许用户快速过滤任何目录中的文件，使用文本编辑器（默认为 nvim）打开它们，创建/编辑/删除文件，并在简单的界面中运行命令。GitHub 链接，https://github.com/caio-ishikawa/slingshot" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/caio-ishikawa/slingshot" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-26 20:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Slingshot，终端文件浏览工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "视频介绍可用于生产的 Web 应用程序代码库。YouTube 链接，https://www.youtube.com/watch?v=3cA_mk4vdWYhttps://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=3cA_mk4vdWY" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-26 20:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "[视频] Rust Web 开发 - Axum" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Bevy 社区最近就如何进一步完善其 UI 系统展开了热烈讨论。这主要是为了让 Bevy Editor 成为可能。@cart 作为讨论发起人,提出了以下一些改进方向:\n\n统一 Bevy 的场景(Scene)系统和 UI 系统。UI 界面的定义应该通过场景系统来完成,而不是现有的命令式生成方式。\n\n\n引入一种新的 Bevy 场景格式(BSN),同时适用于资源文件和 Rust 代码中场景的定义。比如:\n  Div { width: 10 height: 100 } [\n      Img { handle: \"branding/icon.png\" }\n      Div {\n          width: 100\n          height: 200\n      }\n      @(\"player.bsn\")\n  ]\n\n\n\n增加场景的继承与嵌套支持。一个实体可以从另一个场景继承,也可以从多个场景继承。\n\n\n支持属性的“级联”(cascading)。如果一个场景为一个实体定义了 Style::color,它会覆盖该实体继承的其他场景中的该属性,但保留其他 Style 属性。\n\n\n引入 Schematics 概念,作为现有 Bundle 的扩展。Schematics 定义任意的输入数据,然后在插入到 ECS World 时转换为实际的组件。这填补了现有 Bundle 的功能缺口。\n示例:\n  #[derive(Component, Schematic, Reflect, Clone)]\n  #[reflect(Schematic, Reflect)]\n  struct Div {\n      #[schematic]\n      handle: Handle<Image>,\n  }\n\n  // 上面的宏展开之后大概是下面的样子\n  impl Props for AssetPath<'static> {\n      fn apply_props(&mut self, other: &Self) {\n          *self = other.clone()\n      }\n  }\n\n  impl<T: Asset> Schematic for Handle<T> {\n      type Props = AssetPath<'static>;\n\n      fn from_props(\n          asset_path: Self::Props,\n          context: &mut SchematicContext,\n      ) -> Result<Self, SchematicError> {\n          Ok(context.assets.load(asset_path))\n      }\n  }\n\n\n\n加入对场景的“reactivity”支持,基于 ECS 数据自动重新构建场景。这可大大简化 UI 的更新。示例:\n  #[derive(Component, Clone, Schematic, Reflect, Default, Debug)]\n  #[schematic(example)]\n  #[reflect(Schematic)]\n  pub" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/bevyengine/bevy/discussions/9538" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-24 20:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy UI 系统的演进提议" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "wtx 是一个用 Rust 实现的高性能 WebSocket 库。最近的基准测试显示,在多个指标上 wtx 都优于其他实现,可以称得上是最快的 WebSocket 库。测试分为三个指标:\n连接数量:衡量服务端处理连接请求的能力\n消息数量:反映处理消息编解码和网络往返时间的能力\n传输内存:检查不同 Payload 大小的吞吐量\n结果显示 wtx 的响应时间最短,其次是 tokio-tungstenite 和 uWebSockets。这说明 Rust 的网络库在性能上依然保持领先。详见:https://c410-f3r.github.io/thoughts/the-fastest-websocket-implementation/ ↗" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://c410-f3r.github.io/thoughts/the-fastest-websocket-implementation/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-24 20:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "wtx - 最快的 WebSocket 实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GRDigital 最近发布了一个名为 clown 的项目,它能够捕获 Rust 闭包中的变量,并将其转换为一个等价的闭包形式。clown 通过自定义的 clown 属性宏来实现这一功能。例如:会被转换为:这样就可以在闭包中访问 foo.bar 了。clown 目前还处在早期开发阶段,感兴趣的同学可以前去 GitHub 上 star 一下。项目地址:https://github.com/GRDigital/clown ↗" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/GRDigital/clown" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-24 20:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "clown - 捕获 Rust 闭包中的变量" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这周的 Rust 周刊包括以下内容:\nRust 编译器性能分析:本周编译器优化效果显著\n新 RFC: sandboxed、deterministic、reproducible 的 Wasm 宏编译\nRust 学习资源:命令行程序、ESP32、多人游戏、分布式追踪\nRust 会议预告:RustConf 2023 即将召开\n详见:https://this-week-in-rust.org/blog/2023/08/23/this-week-in-rust-509/ ↗请关注我们的更新，以便了解更多有关 Rust 的新闻和动态！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/08/23/this-week-in-rust-509/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-24 20:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 509" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "随着Rust越来越受欢迎，一系列旨在利用其优势的web框架也越来越受欢迎。本文比较了一些最好的Rust框架，突出了它们各自的优点和缺点，以帮助您为项目做出明智的决策。\n\nAxum\nAxum是一个在Rust生态系统中具有特殊地位的web应用程序框架。它是Tokio项目的一部分，Tokio项目是用Rust编写异步网络应用程序的运行时。Axum不仅使用Tokio作为其异步运行时，而且还与Tokio生态系统中的其他库集成，使用Hyper作为其HTTP服务器，使用Tower作为中间件。这样，开发人员就可以重用来自Tokio生态系统的现有库和工具。\n\n\nActix\nActix是Rust的web框架之一，已经存在一段时间了，因此非常受欢迎。像任何优秀的开源项目一样，它经历了许多迭代\n\n\nRocket\nRocket 一直是 Rust 网络框架生态系统中的明星，它在开发者体验方面毫不含糊\n\nAxumAxum是一个在Rust生态系统中具有特殊地位的web应用程序框架。它是Tokio项目的一部分，Tokio项目是用Rust编写异步网络应用程序的运行时。Axum不仅使用Tokio作为其异步运行时，而且还与Tokio生态系统中的其他库集成，使用Hyper作为其HTTP服务器，使用Tower作为中间件。这样，开发人员就可以重用来自Tokio生态系统的现有库和工具。ActixActix是Rust的web框架之一，已经存在一段时间了，因此非常受欢迎。像任何优秀的开源项目一样，它经历了许多迭代RocketRocket 一直是 Rust 网络框架生态系统中的明星，它在开发者体验方面毫不含糊\n\nWarp\nWarp是一个建立在Tokio之上的网络框架，它是一个非常好的框架。它也与我们目前看到的其他框架非常不同。\n\n\nTide\nTide是一个非常简约的web框架，它建立在async-std运行时之上。简约的方法意味着你得到一个非常小的API界面。\n\n\nPoem\n程序就像一首诗，不写就写不出诗来。——Dijkstra\n\nWar" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.shuttle.rs/blog/2023/08/23/rust-web-framework-comparison" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-24 11:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2023 最好的 Rust Web 框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该页面是关于 Rust 语言内部讨论的一个预RFC（请求评论）提议，主题是“使用沙盒化、确定性、可重现、高效的 WASM 编译过程宏”。当前的过程宏（proc-macro）在 Rust 中是通过动态链接库（DLL）实现的，这种方法存在一些问题，如安全性、跨平台兼容性等。因此，作者 dtolnay 提议使用 WebAssembly（WASM）来编译和执行过程宏，可以带来以下几点优势：https://github.com/dtolnay\n安全性：使用 WASM 可以避免不安全的代码执行。\n跨平台：WASM 是跨平台的，因此可以确保过程宏在不同的平台上都能正常工作。\n高效性：WASM 可以提供更快的编译速度。\n作者详细描述了如何实现这个提议，包括如何编译 WASM、如何与 Rust 的其他部分集成等，该 Pre-RFC 下还有很多社区成员对该提议的反馈和讨论，感兴趣的可以进一步阅读。Pre-RFC 讨论链接https://internals.rust-lang.org/t/pre-rfc-sandboxed-deterministic-reproducible-efficient-wasm-compilation-of-proc-macros/19359" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-22 21:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用沙盒化、确定性、可重现、高效的 WASM 编译过程宏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者 Timur Borisov 分享了他从零开始学习 Rust 的经历。在 Pionir Free School 的一位导师的指导下，他选择创建一个 QR 码编码器作为他的第一个项目。这所学校强调解决社区和社会问题的项目。Timur 选择 Rust 的动机是这门语言广阔的前景和实用的特性，同时，他想探索比 Python 更复杂的东西。文章深入探讨了创建 QR 码生成器的技术方面，包括生成 QR 码的步骤、生成器的架构以及 Reed-Solomon 纠错算法。通过这个项目，Timur 对编程和 Rust 有了更深入的了解。通过 Timur 的分享，你将对下面几点疑问有更好的认识：\n选择 Rust: 对于初学者来说，学习 Rust 相对于更受欢迎的语言如 Python 有什么潜在的优势？\nQR 码的实用性: QR 码的纠错能力，如 Reed-Solomon 算法，如何增强其在各种应用中的可靠性和多功能性？\n原文链接github 仓库链接https://pionir.org/blog/qr-code-generator-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-22 21:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "那年我15岁，用 Rust 编写了人生第一个项目——QR码生成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者 分享了一个名为 Inkjet 的新的语法高亮库。原因是他发现syntect 并不适合他的项目，因此他开始寻找替代品。他找到了 tree-sitter-highlight，这是一个有前景的库，但作者希望支持尽可能多的语言，而不依赖于每种语言的单独crate。因此，Inkjet应运而生。主要特点:\n内置了大约60种语言的语法，总计约1100万行C代码，并链接到可执行文件中，无需在运行时加载任何内容。\n可插拔的格式化程序，包括一个基本的 HTML 格式化程序。\n可以从一个像 rs 这样的标记中查找语言。\n可以高亮到一个 String 或 std::io::Writer。\n仍然是一个正在进行的工作（WIP），作者希望至少添加更多的语言，并看看是否可以加快构建时间，但在他的原始项目中它工作得很好。\ngithub 仓库链接https://github.com/Colonial-Dev/inkjet/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-22 21:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Inkjet - 一个内置了众多功能的语法高亮库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "tower 是一个为构建 健壮的网络客户端和服务器提供模块化和可重用组件的库。它提供了一个简单的核心抽象，即 Service trait，它表示一个异步函数，接受一个请求并返回一个响应或错误.原文链接https://blog.frankel.ch/introduction-tower/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-21 17:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tower 库简介" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在最近的版本中，serde 开始将 serde_derive 作为预编译二进制文件进行分发。这引起了一些开发人员的反对，他们担心这会带来安全风险。一些开发人员还要求将预编译二进制文件作为可选项，而不是默认提供.最终, serde 在 v1.0.184 版本中去掉了预编译的二进制文件.serde v1.0.184 releasehttps://github.com/serde-rs/serde/releases/tag/v1.0.184Rust devs push back as Serde project ships precompiled binarieshttps://www.bleepingcomputer.com/news/security/rust-devs-push-back-as-serde-project-ships-precompiled-binaries/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-21 17:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "serde 去除预编译的二进制" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "zfi 是一个 用于编写 UEFI 应用程序的 Rust crate，具有以下目标：\n提供几乎与 UEFI 规范完全相同的基础 API。\n提供在基础 API 之上构建的附加 API。\n基础 API 是 UEFI API 的零成本抽象。\n安全且易于使用。\n可以在 stable Rust 上工作。\nZFI 仅支持单线程环境，这与 UEFI 规范相同。github地址https://github.com/ultimicro/zfi" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-21 17:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "zfi: 零成本且安全的 UEFI 固件接口" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个油管视频,介绍了如何使用 axum 框架来构建一个内存实现的 Todo 应用, 他包含以下内容:\nRust 模块系统，它将帮助我们构建 Axum Rust 文件夹的结构。\n为什么使用 Rust Mutex。\n为什么使用 Rust RwLock。\nRust 标准 Mutex/RwLock 和 Tokio Mutex/RwLock 的区别\naxum 如何配置路由\n油管视频https://www.youtube.com/watch?v=uSmURlg2A9Y--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-21 17:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Axum 构建内存实现的 Todo 应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我已经在一个名为Rivet 的项目上工作了几年，最近才开源：https://rivet.gg/链接到 GitHubhttps://github.com/rivet-gg/rivet我们在构建 Rivet 时尝试了很多有趣的工具，但其中大部分都没有保留下来。我想我会分享一些你们可能会感兴趣的笔记：\nBolt是我们用于开发和管理超级可定制铆钉簇的工具链。这是超级过度设计的，但我喜欢它。\n您可以将整个存储库用作库。我们的 EE 存储库仅使用 OSS 存储库作为子模块，并将服务作为库导入。\n我们利用 Traefik 作为边缘代理来快速处理 UDP、TCP+TLS 和 WSS 流量。\nApache Traffic Server 因其大文件缓存能力而被低估。它用于边缘 Docker 拉通缓存，以减少冷启动时间并将其用作 CDN 缓存，从而降低我们的 S3 成本。\nClickHouse 处理分析和游戏服务器日志。事情就这么简单；没有进一步的评论。\n使用 Apache TS 提供 Docker 映像比运行 Docker 拉通缓存更容易、更经济。\n事实证明，星云作为我们的覆盖网络是可靠且易于管理的。\n对于复杂的、原子的、内存中的操作，我们使用 Redis Lua 脚本。\n显然，我们是尼克斯的粉丝。\n我们维护一个基本的SBOM。\n我们的许可是在 Apache 2.0（OSI 批准）下进行的，我们鼓励其他人运行和试验 Rivet。我们经常回答与此相关的问题：许可 为什么选择 OSS\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-20 22:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rivet – 使用 Rust 和 Nomad 进行开源游戏服务器管理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ws-tool是一个高性能的websocket库，提供同步和异步IO接口。https://github.com/PrivateRookie/ws-tool这是0.9.0版本的更新\n更多性能提升，每秒读写消息数在EchoServer示例中最高，基准数据见下文\n支持本机 TLS\n一些 API 改进\n一些错误修复\nbenchmark300 bytes payload size, 100000000 messages1M bytes payload size, 100000 messages" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-20 22:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ws-tool 0.9.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "适用于 Rust 的 XRPL SDK 是一个社区驱动的项目，提供用于连接 XRP Ledger 的易于使用的工具。它包括 HTTP 和 WebSocket 客户端、基础包和命令行工具。https://github.com/gmosx/xrpl-sdk-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-20 22:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "适用于 Rust 0.13 的 XRPL Ledger SDK 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Pipelight 的使用方式有很多种，因此我必须保持本自述文件的简洁，以便您快速掌握其概念。您应该查看文档以获得更友好的方法和更深入的理解。Pipelight 是一个 6Mb 的二进制文件，在终端中使用。它的目的是自动化无聊和重复的任务。文章链接，https://www.reddit.com/r/rust/comments/15vc3gy/pipelight_automation_pipelines_but_easier_v0614/Github 链接，https://github.com/pipelight/pipelight" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/pipelight/pipelight" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-19 22:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pipelight v0.6.14 - 一个更简单的自动化pipeline工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我用 Rust 创建了一个非常简单（几乎没有功能）的音乐播放器。坦率地说，这是我的第一个用 Rust \"认真\"编写的项目，这个项目很糟糕，但是我仍然想与社区分享它，以获得一些关于如何改进的指导。文章链接，https://www.reddit.com/r/rust/comments/15vcl4e/i_created_a_dead_simple_still_barely_functional/Github 链接，https://github.com/jernejmarcic/RustyPlayer" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jernejmarcic/RustyPlayer" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-19 22:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustyPlayer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在我最近关于 Rust 编译器 CI（持续集成）和基准测试基础设施的文章中，我承诺写一篇关于运行时基准测试的博客文章，这是 Rust 编译器基准测试套件的新补充。然而，我意识到，在这样做之前，最好首先描述基准测试套件的实际工作原理、它的组件是什么以及 Rust 编译器 (rustc) 开发人员如何使用它，以介绍必要的上下文。因此，运行时基准测试将不得不再等等，这篇文章将尝试介绍 Rust 编译器基准测试基础设施的当前状态。我将尝试描述 rustc 编译器开发人员用来测量和监控 Rust 编译器随时间变化的性能的一般概念和工作流程。主要关注点是 rustc-perf 库，其中包含 Rust 编译器基准测试的所有基础设施，以及所谓的 perf.RLO 网站，该网站托管我们每天用来分析编译器性能的各种仪表板、图表和比较。要真正从头开始，我们应该首先解释创建基准套件的动机。关于 Rust 最常见的抱怨之一是 Rust 程序编译速度很慢。我不会在这里讨论这种情况的原因（简短版本：cargo 从头开始​​编译“整个世界”，Rust 做出了一些有利于运行速度而不是编译速度的设计决策），但即使我对“慢”的定义有一些意见（更多内容见下文），事实仍然是许多 Rust 开发人员认为编译器足够慢，因此它代表了他们的开发工作流程的一个非常现实的瓶颈，这是一个我们无法忽视的大问题。当然，这个问题早已为人所知，因此已经（并且正在！）花费了大量的精力来提高编译器的性能。五年多前，一个名为 wg-compiler-performance 的官方工作组成立。该小组的目标是持续测量、监控和改进 Rust 的编译时间，主要是通过优化编译器，有时也通过例如通过对流行的 Rust crate做出更改，使其编译速度更快。文章链接，https://kobzol.github.io/rust/r" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://kobzol.github.io/rust/rustc/2023/08/18/rustc-benchmark-suite.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-19 22:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "探索 Rust 编译器基准测试套件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在最近关于 Rust 编译器 CI（持续集成）和基准测试基础设施的文章中，作者承诺写一篇关于运行时基准测试的博客文章，这是 Rust 编译器基准测试套件的新补充。然而，在这样做之前，最好首先描述基准测试套件的实际工作原理、它的组件是什么以及 Rust 编译器 (rustc) 开发人员如何使用它，以介绍必要的上下文。因此，运行时基准测试将不得不等待，而这篇文章将尝试介绍 Rust 编译器基准测试基础设施的当前状态。详情请看：https://kobzol.github.io/rust/rustc/2023/08/18/rustc-benchmark-suite.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://kobzol.github.io/rust/rustc/2023/08/18/rustc-benchmark-suite.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-19 17:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "探索 Rust 编译器基准测试套件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RustShip：一个新的播客，作者在其中采访其他 Rust 开发人员，以学习他们的经验。详情请看：https://ieni.dev/2023/08/rustship-a-new-rust-podcast/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ieni.dev/2023/08/rustship-a-new-rust-podcast/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-19 17:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustShip：一个新的 Rust 播客" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Kani 是一个开源验证工具，使用模型检查来分析 Rust 程序。 Kani 对于验证 Rust 中的不安全代码块特别有用，其中编译器不会检查“不安全的超级能力”。详情请看：https://www.reddit.com/r/KaniRustVerifier/comments/15n7lcr/kani_0340_has_been_released/项目地址：https://github.com/model-checking/kanihttps://github.com/Jancd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/model-checking/kani" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-19 17:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Kani 0.34.0已经发布了！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pixi 是由 Prefix.dev 团队开发的一个跨平台、多语言的软件包管理器和工作流工具，在 conda 生态系统的基础上构建。pixi 为所有开发人员提供了与 cargo 或 yarn 等软件包管理器相似的卓越体验，但适用于任何编程语言。\n支持多种编程语言：Python ，C++，R 等\n支持多种操作系统和平台：Windows ，Linux ，MacOS（包括 Apple Silicon）\nlockfile 会永远包含在项目中，并保持最新状态\n简单清晰的命令行界面，受到 Cargo 启发\n支持为每个项目或者系统范围安装工具\n完全由 Rust 编写\nPrefix.dev 致力于开发用于软件包管理的软件，使依赖管理变得简单和无痛。团队是 mamba 软件包管理器的主要开发人员，并与 conda-forge 团队密切合作。Github - prefix-dev/pixi: https://github.com/prefix-dev/pixiLet's stop dependency hell - Launching Pixi ：https://prefix.dev/blog/launching_pixi" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://prefix.dev/blog/launching_pixi" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-18 08:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pixi - 使用 Rust 编写的全新软件包管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在为 GUI 构建做好准备之前，一个典型的挑战是 Rust 中还缺乏用于构建后处理的优雅方法，像签名、部署到仿真器等流程都需要在这个阶段进行处理。尽管文章讨论的是 Rust 是否为 GUI 构建做好准备，但其中的观点也适用于对于跨平台构建和发布有需求的 Rust 程序。Are we GUI (build) yet?: https://epage.github.io/blog/2023/08/are-we-gui-build-yet/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://epage.github.io/blog/2023/08/are-we-gui-build-yet/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-18 08:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "文章：Are we GUI (build) yet?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 508: https://this-week-in-rust.org/blog/2023/08/16/this-week-in-rust-508/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/08/16/this-week-in-rust-508/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-18 08:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Week In Rust 508" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Neon 是 AWS Aurora Postgres 的无服务器开源替代品。它将存储和计算分开，并通过跨节点集群重新分布数据来替代 PostgreSQL 存储层。尝试使用 Neon 免费套餐创建无服务器 Postgres 实例。然后使用您首选的 Postgres 客户端（psql、dbeaver 等）连接到它或使用在线 SQL 编辑器。有关连接说明，请参阅从任何应用程序连接。或者，在本地编译并运行该项目。https://neon.tech/docs/introduction/free-tierNeon 由计算节点和 Neon 存储引擎组成。计算节点是由 Neon 存储引擎支持的无状态 PostgreSQL 节点。Neon 存储引擎由两个主要组件组成：Pageserver - 计算节点的可扩展存储后端。Safekeepers - Safekeepers 形成一个冗余的 WAL 服务，从计算节点接收 WAL，并将其持久存储，直到它被 Pageserver 处理并上传到云存储。https://imgse.com/i/pP1fFde\nhttps://github.com/neondatabase/neon\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-17 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Neon -- AWS Aurora Postgres 的无服务器开源替代品" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rusqlite 是一个使用 Rust 的 SQLite 的符合人体工程学的包装器。从历史上看，该 API 是基于 rust-postgres. 然而，两者在很多方面存在分歧，并且两者之间不存在兼容性。在您的 Cargo.toml 中：基础 rusqlite 包支持 SQLite 版本 3.14.0 或更高版本。如果您需要旧版本的支持，请提出问题。一些货物功能需要更新的 SQLite 版本；请参阅下面的详细信息。\nhttps://github.com/rusqlite/rusqlite\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-17 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rusqlite 使用 Rust 的 SQLite 包装器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "人们对WASI/WASIX的密码学增强功能迫不及待地期待着。目前，WASI正在考虑一个名为WASI Crypto的提案，由Frank Denis和Daiki Ueno提出，目前处于第一阶段-功能提案（CG）阶段。经过数个不眠之夜和大量的尝试，我们成功地将我们的ring分支与WASIX集成。这对我们来说是一个巨大的里程碑，我们非常兴奋地与社区分享。但是，仅仅编译独立的 ring 是不够的。这就像给人们一把打不开的门的钥匙一样。因此，我们开始制作与WASIX和我们的 ring 分支兼容的库。\nrustls\ntokio-rustls\nhyper\nhyper-rustls\nreqwest\nwebpki-roots\nwebpki\nsct\n在WASIX中加入 ring 加密库，为TLS、SSL和所有其他加密操作提供支持，为社区构建几乎任何东西打开了许多用例和可能性。ReadMore: https://wasmer.io/posts/cryptographic-support-for-wasix" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://wasmer.io/posts/cryptographic-support-for-wasix" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-16 10:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WebAssembly 的密码学相关的系统接口/扩展（WASI/WASIX）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "自从大约十年前问世以来，Rust语言一直受到开发者的高度关注和喜爱。而且不仅仅是开发者们喜欢这门语言——大型企业的决策者们也认同Rust是一项出色的技术，近年来该语言在整个行业中得到了广泛应用。AWS在其平台上大量使用Rust，Google在Android中使用它，微软在Windows中使用它。实际上，Rust正在逐渐取代C和C++在许多领域的应用，包括系统编程、操作系统、各种嵌入式系统、低级工具以及游戏和游戏引擎。首先，有tokio，它是一个异步运行时，为网络应用提供了坚实且高效的基础。其上还有成熟且维护良好的Web框架，如axum和actix-web。对于所有相关的数据存储和ORM，也有成熟的驱动程序可供选择。最后，你还可以找到涵盖构建Web应用的其他相关方面的库，例如（反）序列化、国际化、模板化、可观测性等等。总体而言，Rust为构建雄心勃勃的Web后端提供了坚实而稳定的构建模块。当然，有人可能会问：你为什么要在意呢？对于已经使用Ruby、Java、Elixir、TypeScript、Go或其他语言的团队来说，是什么促使他们采用Rust呢？\n高效和卓越的表现\n可靠性和可维护性\nReadMore: https://mainmatter.com/blog/2023/08/14/the-case-for-rust-on-the-web/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://mainmatter.com/blog/2023/08/14/the-case-for-rust-on-the-web/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-16 10:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 做 Web 服务的场景" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "servicer 是一个用户友好的命令行工具，旨在简化 systemd 上的服务管理，摒弃了systemd生态系统的复杂性。通过类似于 pm2 等热门工具的易于使用的API，servicer使用户能够轻松创建、控制和管理服务。servicer 是一个轻量级的、用Rust编写的程序，不会在后台运行。它不会 fork 服务，也不会运行自定义的日志记录解决方案。它只是在 systemd 上创建 .ser.service 文件的薄薄一层。日志记录由journald处理。ReadMore: https://servicer.dev/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://servicer.dev/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-16 10:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "servicer: 更简单的 systemd 上的服务管理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "嗨，大家好！距离我和大家分享这个项目已经一个多月了。你们中一些人对这个项目的热情欢迎让我深受感动。感谢你们中许多人一直支持和帮助我改进它。从那以后发生了什么变化？\n您现在可以在文件修改时触发管道。\n您可以在 28 个可用的 git hook 上触发管道。\n使用更高详细级别的日志 -vvvv 打印日志以查看命令 stdout/stderr。\n该文档的解释和细节不断增加。\n我添加了很多单元测试以避免软件回归。\n我重构了核心，将其作为独立的板条箱公开。\n对于高级用户：\n由于内部 API 重新考虑，二进制大小已从 11 Mb 减少到 6 Mb。\nhttps://pipelight.dev/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-15 10:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pipelight - 自托管自动化管道 -> v0.6.14" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我刚刚发布了egui_dnd的 0.5.0 版本，这是一个用于 egui 的拖放排序库。开发这个版本真的很有趣，我至少两次完全重构了核心逻辑。最终摆脱了我在初始版本中编写的所有解决方法和技巧，这真的很令人满意。https://github.com/lucasmerlin/egui_dnd我现在使用一个大枚举来跟踪拖动的不同阶段，我觉得这确实改善了代码的流程。此版本的更改：\n触摸支持（拖动滚动并按住+拖动进行拖动）\n动画：项目移动时现在有动画\n支持水平和水平环绕布局\n支持拖动手柄中的按钮\n更简单的API\n查看演示和GitHub 页面以获取更多信息。https://lucasmerlin.github.io/egui_dnd/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-15 10:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "egui_dnd 0.5.0，支持动画和触摸" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Kani 是一个开源验证工具，使用模型检查来分析 Rust 程序。Kani 对于验证 Rust 中的不安全代码块特别有用，其中编译器不会检查“不安全的超级能力”。https://model-checking.github.io/kani/tool-comparison.html以下是0.34.0版本中新增内容的摘要：https://github.com/model-checking/kani/releases/tag/kani-0.34.0重大变化\n通过https://github.com/model-checking/kani/pull/2557中的 @celinval 将默认求解器更改为 CaDiCaL默认情况下，Kani 现在将使用 CaDiCaL 运行 CBMC，因为该求解器在我们的大多数基准测试中都优于 Minisat。\n发生了什么变化\n允许在https://github.com/model-checking/kani/pull/1661中的 @fzaiser 在 #[kani_proof] 中为异步函数指定调度策略\n支持由 @feliperodri 在https://github.com/model-checking/kani/pull/2658中删除外部函数\n无需使用 cbmc-viewer 的覆盖率报告，作者为 @adpaco-aws，位于https://github.com/model-checking/kani/pull/2609\n通过 @celinval 在https://github.com/model-checking/kani/pull/2633添加对基于数组的 SIMD 的支持\n在https://github.com/model-checking/kani/pull/2630中添加未检查/SIMD 位移位检查并禁用 @reisnera 的 CBMC 标志\n修复常量字节切片的代码生成，以解决 @zhassan 在https://github.com/model-checking/kani/pull/2663中的虚假验证失败问题\n通过https://github.com/model-checking/kani/pull/2662中的 @remi-delmas-3000 将 CBMC 升级到 v5.89.0\n由 @remi-delmas-3000 在https://github.com/model-checking/kani/pull/2661中将 Rust 工具链更新为每晚 2023-08-04\n完整变更日志：https://github.com/model-checking/kani/compare/kani-0.33.0...kani-0.34.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-15 10:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Kani 0.34.0已经发布了！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者总结了 Rust 是如何解决“十亿美元错误”的。Rust 通过引入以下特性来解决这个问题：\n所有权和借用：Rust 引入了独特的所有权系统来跟踪数据的使用情况\nOption类型和Result类型：Rust 强制我们使用其Option类型和Result类型来显式处理值的缺失。这意味着我们不能意外地使用空值，从而导致崩溃或其他错误。\n没有数据竞争：Rust 的借用检查器不仅可以防止空指针解引用，还可以消除数据竞争的可能性。数据竞争是导致错误的另一个常见原因，Rust 可以通过在编译时检查代码来避免这种情况。\n无畏的并发性：Rust 允许我们编写并发代码而无需担心错误。Rust 的所有权系统和借用规则确保多个线程不会相互干扰，从而避免了传统线程编程的陷阱。\n无损性能：Rust 的所有安全措施都不会影响性能。Rust 代码可以像任何其他语言一样高效地运行。\n原文链接https://medium.com/@ugochukwuchizaramoku/the-billion-dollar-mistake-and-how-rust-eliminates-75604c251e66" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-14 18:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "超越 NULL：Rust 的空指针防御和安全编程的艺术" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这里列出了 截止到 2023-08-12 为止 crates.io 上 前 2000 使用量的 crates.看看你喜欢的 crates 排名如何? 也可以作为crate 选择的参考.原文链接https://gist.github.com/paolobarbolini/9416630ead9478e3913223e0edf0fece" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-14 18:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "crates.io 上的crate 排名" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Struson 是遵循 RFC 8259 的流式 JSON reader和 writer.Struson 的主要目的是允许以内存高效的方式写入 JSON 文档，而无需在内存中存储完整的 JSON 文档结构.不过目前还在试验阶段,一些地方的性能可能还没那么好.读取的例子:github 地址https://github.com/Marcono1234/struson" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-14 18:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Struson: 流式 JSON 读写库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "contract 是 illumos 中一个非常有趣的功能，可以用来管理进程。在本篇文章中，作者介绍了如何使用 Rust 来访问 contract 中的进程成员。原文链接https://lightsandshapes.com/posts/process-contracts-with-rust/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-14 18:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 来处理 contract" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Bevy 是一个用 Rust 构建的令人耳目一新的数据驱动的游戏引擎，如果你想学习如何使用 Bevy 制作 2D/3D 游戏、可视化、用户界面或其他图形应用程序，那可以访问Bevy官网去了解更多。阅读原文：https://bevyengine.org/news/bevys-third-birthday/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://bevyengine.org/news/bevys-third-birthday/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-12 23:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy's Third Birthday" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "阅读原文：https://github.com/containerd/rust-extensions" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/containerd/rust-extensions" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-12 23:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 进入容器领域：rust-extension @containerd" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Keep It Rollin 用 Bevy 引擎制造，在这个 48 小时的即兴游戏中，需要通过策略性地放置墙壁来遏制高能量子粒子。在线试玩：https://nilaysavant.itch.io/keep-it-rollin阅读原文：https://github.com/nilaysavant/keep-it-rolling-game" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://nilaysavant.itch.io/keep-it-rollin" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-12 23:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Keep It Rollin：一个使用Bevy引擎制作的小游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "candle是由抱抱脸社区推出的，由Rust写成的极简机器学习框架。以下摘自一篇博文：而这还不够，Hugging Face同时低调开源了另一个重磅框架，当前还未引起大家的注意，这就是candle（https://github.com/huggingface/candle）。而这个框架又是Hugging Face眼光独到的体现。candle瞄准于当下又一个被广为诟病又不得不接受的痛点，那就是基于Python语言的pytorch框架训练的大模型速度慢，体积大的问题。比如，python的GIL机制导致的假多线程，让很多人都想替换掉它，虽然业内有有诸如python后期版本移除掉GIL的计划以及创造出兼容python的的新编程语言mojo，但始终远水解不了近渴。而Hugging Face给出的解法就是用时下最快的语言rust重写一个ML框架，强调易用性和性能（包括 GPU 支持），并且当前版本已经支持当前最前沿的模型，比如llama2。经过改写的模型，比如llama2能够方便，快速的运行在容器环境，甚至可以运行在浏览器中，而这一举动，为拥有更广阔应用场景的边缘AI带来了巨大想象力，下一站万物大模型开启，而Hugging Face已经埋下了伏笔。https://mp.weixin.qq.com/s/iwrV35oq_j8-SqUIMk-m0AGithub repo：https://github.com/huggingface/candle" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/huggingface/candle" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-12 23:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "candle：一个极简的Rust机器学习框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cargo Binstall 1.2.0 发布，并且支持HTTP/3。Cargo binstall 提供了一种低复杂度的机制来安装 Rust 二进制文件，作为从源代码构建（通过 Cargo install ）或手动下载包的替代方案。Github repo：https://github.com/cargo-bins/cargo-binstall" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/cargo-bins/cargo-binstall" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-12 23:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cargo Binstall 1.2.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lambert" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "探索Rust中的代数类型及其保证和模式、特征和通用相关类型，以编写类型安全编程。阅读更多：https://sanjuvi.github.io/Blog/posts/Rust-Type-System-Part-2/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://sanjuvi.github.io/Blog/posts/Rust-Type-System-Part-2/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-12 23:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一篇探索Rust类型安全的文章：Rust Type System" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "TL;DR：这篇文章描述了 LLVM 优化注释，可以帮助编译器更好地优化你的程序。如果你想分析编译 Rust 程序生成的备注，可以使用 cargo-remark 工具。https://llvm.org/docs/Remarks.html博客文章链接，https://kobzol.github.io/rust/cargo/2023/08/12/rust-llvm-optimization-remarks.htmlcargo-remark，https://github.com/kobzol/cargo-remark" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/kobzol/cargo-remark" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-12 22:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-remark 检查 rustc LLVM 优化注释" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "开源项目是软件开发生态系统的基本组成部分。 虽然创建新项目令人兴奋并会吸引很多关注，但维护我们许多人所依赖的现有软件也同样重要。自去年年底至今，Ferrous Systems 与 ISRG 建立合作伙伴关系，以改进 bindgen 并为其做出贡献。 在这篇博文中，Ferrous Systems 讨论了为什么 bindgen 很重要以及在过去几个月中其所做的工作。https://github.com/rust-lang/rust-bindgen博客文章链接，https://ferrous-systems.com/blog/bindgen/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ferrous-systems.com/blog/bindgen/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-12 22:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust bindgen 新的进展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我发现理解新概念的最好方法之一就是从头开始。从一个尚不存在的地方开始，然后自己重新创建它，在这个过程中不仅要学习它是如何工作的，还要学习它为什么要这样设计。--Ibraheem Ahmed这不是异步的实用指南，但希望它涵盖的一些背景知识将帮助您思考异步问题，或者至少满足您的好奇心，而不会让您因太多细节而感到无聊。这篇博文真的很长。博客文章链接，https://ibraheem.ca/posts/too-many-web-servers/https://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ibraheem.ca/posts/too-many-web-servers/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-08-12 22:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "学习 Rust 异步" }, "type": "text" }], "type": "title" } },]
