export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "又到了一年一度的时候，我们再次向社区宣布：“又到了一年一度的时候”！（这个递归玩笑是给那些使用 LISP 的 1.31% 的用户的。）我们的 2023 开发者调研正式启动了，我们非常期待再次听取开发者社区的反馈，就像过去 12 年一样。多年来，我们从这个调查中学到了很多东西。过去三年在科技行业发生了重大变革，而 Stack Overflow 社区的反应独特地讲述了这个故事。在 2020 年，疫情爆发之前，社区告诉我们，在你们中最高薪的开发者是 SRE/DevOps 贡献者。在 2021 年，我们看到工作状况出现波动，越来越多的开发者转向全日制学校，特别是印度，在那里，相较于 2020 年，增加了 9 个百分点。去年，我们的 46% 的受访者表示他们每天至少花 30 分钟回答问题，用时间量化了我们社区引以为傲的价值：知识分享！今年，我们想要了解这些情况发生了哪些变化，并进一步探索人工智能（AI）和机器学习（ML）在软件开发中的转变。我们想要了解开发者如何使用这些技术，他们面临的挑战，以及他们看到的机遇。像往常一样，我们需要您的帮助来使这项调查具有代表性。广泛分享！在公司聊天渠道中发布。在 LinkedIn 和其他社交网络上发布，在 TikTok 上跳舞宣传。我们非常感激那些抽出时间参与调查并分享他们对塑造软件开发的工具和趋势的反馈的人。您的贡献使我们能够帮助每个人了解行业的变化，并让每个人都感觉在 Stack Overflow 这里是一个社区。Readmore: https://stackoverflow.blog/2023/05/08/the-2023-developer-survey-is-now-live/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://stackoverflow.blog/2023/05/08/the-2023-developer-survey-is-now-live/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-09 15:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Stackoverflow 开发者调研开始了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我实现了一个玩具级别的 std::fs 库，它不依赖于 libc，而是使用 Raw Syscall。社区中有一些声音认为我们应该让标准库脱离 libc 以获得更好的性能，所以我决定尝试一下，看看自己能否实现这样的东西。最终的结果是，我确实实现了它，但最终的实现比 stdlib 慢得多（哈哈哈，我的错）。不管怎样，这是一次很棒的旅程，我很感激。源代码在这里，也许还有其他人对此感兴趣 :)Readmore: https://github.com/japaric/syscall.rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/japaric/syscall.rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-09 15:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个不依赖于 libc 的 std::fs 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "IDEA 用户快来更新吧Readmore: https://intellij-rust.github.io/2023/05/08/changelog-194.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://intellij-rust.github.io/2023/05/08/changelog-194.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-09 15:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "INTELLIJ RUST 更新日志 #194" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章中，作者介绍了如何使用 Tauri 和 Next.js 来构建一个桌面应用程序。\n他们首先介绍了如何设置 Tauri 和 Next.js，并创建了一个简单的 Next.js 应用程序。\n然后，他们将 Tauri 集成到该应用程序中，并展示了如何在本地构建和运行该应用程序。\n最后，他们展示了如何将该应用程序打包为可分发的二进制文件。\n原文链接https://dev.to/valorsoftware/developing-a-desktop-application-via-rust-and-nextjs-the-tauri-way-2iin" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-08 18:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust + Next.js + Tauri开发桌面应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章介绍了 Rust 中的流(Streams)。在 Rust 中，流(Streams)是异步版本的迭代器，由 Stream trait 表示。Streams 可以在异步函数中进行迭代。它们也可以使用适配器进行转换。Tokio 在 StreamExt tait上提供了许多常见的适配器。原文链接https://www.qovery.com/blog/a-guided-tour-of-streams-in-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-08 18:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust streams" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Inlyne 是一个由 GPU 驱动的无浏览器工具，可以帮助您在眨眼之间快速查看 markdown 文件。github地址https://github.com/trimental/inlyne" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-08 18:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Inlyne: markdown查看工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Symphonia是一个纯Rust音频解码和媒体解码库，支持AAC, ADPCM, ALAC, FLAC, MKV, MP1, MP2, MP3, MP4, OGG, Vorbis, WAV和WebM。github 地址https://github.com/pdeljanov/Symphonia--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-08 18:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Symphonia: 纯 Rust 音频解码和媒体解码库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Qdrant OSS 团队现在用一种新方法来挑选加入 Rust 团队的合适候选人——让候选人先做出贡献。如果有一个开放的 Rust 开发者职位，你有兴趣申请，可以从 GitHub Issue 中选择一个任务，解决它，然后提个 PR。如果你的贡献质量好，核心团队接受了 PR，你将受邀参加面试。如果这也顺利进行，你很可能会收到加入 Qdrant 团队的邀请。如果不行... 那好吧，Qdrant 将会为你的贡献付费。当然，即便不用做求职申请，也可以去做某些标有“bounty”标签的任务来获取奖金：https://github.com/qdrant/qdrant/issues?q=label%3A%22%F0%9F%92%8E+Bounty%22这真的是个好方法，也是个好消息，赶紧行动起来吧。Qdrant 是一个面向下一代AI应用的向量数据库。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/qdrant/qdrant/issues?q=label%3A%22%F0%9F%92%8E+Bounty%22" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-07 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "来Qdrant参与贡献" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ReefDB是一个使用Rust编写的极简主义、内存和磁盘数据库管理系统，实现了基本的SQL查询功能和全文搜索。主要功能：\n支持内存或磁盘存储\n基本的SQL语句（CREATE TABLE，INSERT，SELECT，UPDATE，DELETE）\nINNER JOIN 支持\n使用倒排索引的全文搜索\n自定义数据类型（INTEGER，TEXT，FTS_TEXT）\n以磁盘存储为例：GitHub: https://github.com/sachaarbonel/reefdb" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sachaarbonel/reefdb" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-07 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "reefdb" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "类型化的HashMap，允许根据Key类型定义不同的值类型。在需要单个 HashMap 中存储不同的键值对时非常有用。基本用法：GitHub: https://github.com/kodieg/typedmap/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/kodieg/typedmap/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-07 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "typedmap" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Stereokit 的Rust 绑定和wrapper。StereoKit是一个易于使用的开源虚拟现实库，专为创建 VR、AR 和 XR 体验而设计。示例：GitHub: https://github.com/MalekiRe/stereokit-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/MalekiRe/stereokit-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-07 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "stereokit-rs" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Proquint 可用于以更易读的方式编码二进制数据，例如 IP 地址，公钥和 UUID。proquint 是一种可读的五个字母的字符串，用于编码唯一的 16 位整数。使用示例：GitHub：https://github.com/imbrem/proqnt" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/imbrem/proqnt" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-07 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "proqnt" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "关于 Rust 语言中的迭代器(Iterator)和生成器(Generator)的设计问题。现有 Iterator trait 不适合自引用生成器（self-referential generators），如何引入一个新的 Generator trait 来解决这个问题？博客原文链接，https://without.boats/blog/iterator-generator/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://without.boats/blog/iterator-generator/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-07 14:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 迭代器和生成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Hurl 是一个开源的命令行工具，允许使用纯文本运行和测试 HTTP 请求。可以使用它在 CI/CD 管道中获取数据或测试 HTTP API，支持 JSON / GraphQL / SOAP。原文链接，https://hurl.dev/blog/2023/05/05/announcing-hurl-3.0.0.htmlGitHub 链接，https://github.com/Orange-OpenSource/hurl" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Orange-OpenSource/hurl" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-07 14:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Hurl 发布 v3.0.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Brun 是一个全面的深度学习框架，提供卓越的灵活性并用 Rust 编写。目标是通过简化实验、培训和部署模型的过程来满足研究人员和从业人员的需求。v0.7.0 主要包括：改进（反）序列化、优化器和模块修改、初始 ONNX 支持和大量新功能。GitHub 链接，https://github.com/burn-rs/burn" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/burn-rs/burn" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-07 14:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "深度学习框架 Burn 发布 v0.7.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "StereoKit，是一种易于使用的混合现实引擎，专为创建 VR、AR 和 XR 体验而设计。stereokit crate 链接，https://crates.io/crates/stereokithttps://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/stereokit" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-07 14:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "混合现实引擎 StereoKit" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新的版本增强了Windows下的安装方式，对Tauri的代码进行了安全性审计，添加了外部API访问等特性，向成熟又迈进了一步。https://tauri.app/blog/2023/05/03/tauri-1-3/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://tauri.app/blog/2023/05/03/tauri-1-3/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-05 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tauri v1.3发布 - NSIS installer, security audit & External API Access" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "把Js当脚本，在Rust应用程序中运行，嵌了一个Deno运行时。https://austinpoor.com/blog/js-in-rs?ref=reddit" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://austinpoor.com/blog/js-in-rs?ref=reddit" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-05 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Deno在Rust程序中运行JavaScript" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本期有这些精彩的文章：https://rustmagazine.org/issue-3/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rustmagazine.org/issue-3/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-05 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust杂志第三期出炉" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用的Tauri做客户端。https://github.com/kkoomen/pointless" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/kkoomen/pointless" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-05 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pointless - 使用Rust和React构建的画板" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://crates.io/crates/mage-core" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/mage-core" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-05 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个ASCII码游戏引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有开发者发现在使用axum和bb8-tokio-postgres构建项目时，编译时间非常慢，每次增量更改需要44.2秒。尽管很少有时间用于代码生成，但开发者仍在尝试优化。最终发现将编译器从1.66.1升级到1.71.0后，冷启动的编译时间从207秒降至76秒，热编译时间从44.2秒降至0.3秒，效果惊人。其中升级到LLVM 16和调整debuginfo等因素可能对性能产生了影响。另外，如果使用了许多闭包，最新版的夜版编译器也已经修复了增量编译问题。如果需要进行更详细的比较，可以使用cargo build --timings命令生成SVG图表进行分析。详情: https://www.reddit.com/r/rust/comments/136z613/sudden_99_build_time_improvement_going_from_1661/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/136z613/sudden_99_build_time_improvement_going_from_1661/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-04 21:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "从1.66.1到1.71.0：编译时间神奇提速99%+" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "异步工作组的2023年主要目标是稳定 trait中异步函数的“最小可行产品”（MVP）版本计划在 Rust 1.74 版本稳定，该版本将于2023年11月16日发布MVP 功能包括：有点不幸的是，我们不得不从使用 impl HealthCheck 转换为显式 HC 类型参数来使用这个符号。RFC 2289，“关联类型限定”，引入了一种紧凑的符号来解决这个问题。该RFC不是这个MVP的一部分，但如果它被稳定下来，那么我们可以简单地写成：未来解决办法：引入 associated return types (ARTs) ，目前正在起草 RFC，在具有许多方法的特征中，ARTs变得冗长，将来可能会考虑更简洁的语法（https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=2066934a05cb9eafc0b47af7bdf8c57f）。相关  RFC 3425 ，示例：https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=75cfc199cc50a111576c2d8e342ae823一旦完成了这个MVP，接下来呢？我们下一个即时目标是在2024年发布动态调度和异步闭包支持。详细：https://blog.rust-lang.org/inside-rust/2023/05/03/stabilizing-async-fn-in-trait.html消息总结自Rust 视界https://t.me/rust_daily_news" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-04 21:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "trait中的异步函数" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tauri 1.3版本发布了，这个版本增加了一个bundle target，可以使用NSIS在Windows上创建应用程序安装程序，并在macOS和Linux上进行交叉编译。此外，Tauri团队还进行了一次内部审核，手动审核了45个PR，并查阅了大量的外部资源文档，包括RFC6068和RFC3966等，以改进和修复Tauri的安全问题。这次审核反映了Tauri团队对于安全的高度重视，也为使用Tauri构建应用程序的开发者提供了更加可靠的保障。更多内容: https://tauri.app/blog/2023/05/03/tauri-1-3/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://tauri.app/blog/2023/05/03/tauri-1-3/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-04 21:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tauri 发布1.3.0版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 493: https://this-week-in-rust.org/blog/2023/05/03/this-week-in-rust-493/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-04 21:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 493" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Pavex 是一个用 Rust 构建 API 的新框架。它非常不同：我们可以将 Pavex 视为用于构建 Rust API 的专用编译器。它将应用程序应该做什么的高级描述作为输入，一个 Blueprint 描述示例：它生成一个完整的网络服务器的源代码作为输出，根据您的规范运行，准备启动。Pavex 旨在拥有这一切：出色的人体工程学和高性能，让其 Rails、Django 或 ASP.NET Core 一样易于使用并且与剥离所有抽象的手写解决方案一样快！\nhttps://github.com/LukeMathWalker/pavex\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-03 23:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pavex，一个新的 Rust web 框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "  Rust 是创建 GitHub Action 的绝佳语言。在本文中，作者将介绍如何创建 ngerakines/pr-has-issues-action GitHub Action。https://github.com/ngerakines/pr-has-issues-action  对于某些上下文，我想要一种轻量级的方法来验证 PR 的内容，特别是确保标题和正文都不为空并且至少包含 on issue 前缀。例如，如果我要创建一个标题为“Support account creation”的 PR，我想确保标题至少包含一个问题前缀，例如“ISSUE-1 Support account creation”。  有几种不同的方法可以使用输入、输出和环境变量来实现 github action。 我想让它尽可能简单，所以我只查看与触发事件关联的 GitHub action 上下文。 期望此 action 与 pull_request 事件一起使用，因此我正在寻找该有效负载的编号、pull_request.title 和 pull_request.body 值。  该事件数据作为挂载文件传递到上下文，并且 GITHUB_EVENT_PATH 环境变量提供该 JSON 文件的位置。 因为该操作只是与文件系统交互，所以我可以保持较低的依赖项数量和较小的生成的二进制文件。  接下来是存储库根目录中的操作描述符文件。  你会在这里注意到几件事。 首先，runs.image: ... value 并不像 GitHub 文档所说的那样只是 Dockerfile ，而是对容器映像的引用。 当我发布一个版本时，我首先进行构建并推送到 ghcr.io。 如果我不这样做，每次引用操作时，它都会从头开始构建。 这使它减少到 2-3 秒而不是 2-3 分钟。  另一件需要做的事情可能不是很明显，那就是确保你发布的 ghcr 包是公开的。 您需要从存储库导航到包并将可见性从私有（默认）更改为公共。 如果您不这样做，您将在使用该操作时收到容器不存在的错误。\nhttps://blog.ngerakines.me/posts/github-actions-in-rust/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-03 23:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GitHub Actions in Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ToOwned 和 Borrow 是一组 trait，常常用于 &str 和 String 这些简单类型的互相转换，而 borrowme 定义了自己的 ToOwned 和 Borrow traits，可以在带有生命周期的类型和不带生命周期的类型之间实现快速转换，适用范围更加广泛。这个 crate 还提供了一个 #[borrowme] 属性宏，可以帮助快速我们实现这个功能。下面是一个代码实例：github 地址https://github.com/udoprog/borrowme" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-02 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "borrowme: Rust 中缺失的复合借用类型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rumqtt 是 Rust 中 MQQT 协议(为 IoT 设备设计的消息协议)的客户端，力求简单、健壮和高效，其主要包含了两个库：\nrumqttc: 一个高层次的，易于使用的 mqqt 客户端\nrumqttd: 一个更加高性能的，嵌入式 MQTT broker\n近日其发布了 0.21.0 版本，新增了对 MQTT5 协议很多特性的支持，例如：\nMessage Expiry Interval\nUser Properties\nRequest Response\nTopic Aliases\nConnect Properties\n感兴趣的可以参考其 github 项目主页。githuib 地址https://github.com/bytebeamio/rumqtt/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-02 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rumqtt 新增对于 MQTT5 协议的支持" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tensorken 是一个有趣、可hack、GPU 加速的神经网络库，用 Rust 编写。它旨在从程序员的角度理解深度学习，通过从头开始构建深度学习框架来实现这一目标。它包含基本的张量操作，可以在CPU和GPU上运行。同时，这个库的作者还在更新博客，详细描述其实现思路。博客原文github 地址https://getcode.substack.com/p/fun-and-hackable-tensors-in-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-02 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "从头开始实现自己的 Tensor (WIP)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文是 Rust 游戏开发系列中的第一篇. 使用 Bevy 来创建平台, 如下图, 想要实现这种平台的跳跃,比远比看起来要难的多.原文链接https://affanshahid.dev/posts/learning-game-dev-bevy-1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-01 21:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust游戏开发: 1. 使用 Bevy 创建平台" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本来介绍了 Axum 中如何使用模板来实现服务端渲染.原文链接https://blog.frankel.ch/server-side-rendering-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-01 21:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中的服务端渲染" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "安全、稳定、高性能的内网穿透工具，用 Rust 语言编写rathole，类似于 frp 和 ngrok，可以让 NAT 后的设备上的服务通过具有公网 IP 的服务器暴露在公网上。原文链接https://github.com/rapiz1/rathole--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-05-01 21:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rathole: Rust 编写的反向代理工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，我最近开发了rpdf，这是一个帮助我处理 PDF 注释的小型 CLI。对我来说，必须依赖 Web 服务（如 iLovePDF、PDFAnnotators 或其他基本 PDF 实用程序）非常烦人。如果您知道替代品，尤其是开源的，请随时发表评论:-)https://github.com/jeertmans/rpdf当我几乎每天审阅和注释 PDF 时，我决定实施自己的解决方案，以此作为在 Rust 中再做一个项目的借口 :-)什么？：rpdf可以从 PDF 文件中读取注释 ( stats)，merge将同一 PDF 的多个评论中的注释合并为一个，或strip从 PDF 中读取注释。您可以使用 来安装它cargo install rpdf，并直接在终端中使用它。https://preview.redd.it/jpn8mjanm0xa1.png?width=804&format=png&auto=webp&v=enabled&s=33ff5f0bb67687a74e592c151ed998d8422e9008来自示例文件的注释统计信息。我很想听听您对此的看法，尤其是以下几点：作为参考，我使用lopdfcrate。我不喜欢的是 a 需要两次调用get_dictionary，因为我不能有一个对 的可变引用page和另一个对 的可变引用Annots，即使我一次只会修改一个。如果您对此有意见，我很乐意听到！https://docs.rs/lopdf/latest/lopdf/3.关于性能，还是希望有一个比较快的工具。如果您在我的代码中发现任何性能问题，请不要犹豫告诉我:-)" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-30 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rpdf - 用于处理 PDF 注释的命令行工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我很高兴与大家分享我一直在从事的名为Image Maniac的项目。它是一款开源图像查看器，专为游戏开发人员和其他创意专业人士而设计。凭借广泛的功能和跨平台兼容性，它旨在让您的图像查看体验无缝且高效。以下是 Image Maniac 脱颖而出的原因：感兴趣的？前往 GitHub 存储库下载 Image Maniac 并访问源代码：https://github.com/AllenDang/img_maniac/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-30 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "介绍 Image Maniac：适用于游戏开发人员等的快速、多功能和开源图像查看器！🚀" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，我很高兴与大家分享我在 Rust - Vortex中的最新项目。它是一种从 PDF 文件中提取图像并将其转换为不同格式（例如 PNG 或 JPEG）的工具。https://github.com/omkar-mohanty/vortex我使用 Rust 已经一年多了，Vortex 是一个具有挑战性但回报丰厚的项目。我使用“pdf”包提取原始图像数据，使用“image”包以所需格式写入图像数据。Vortex 可以快速准确地从嵌入图像的 PDF 中提取图像。对于需要从 PDF 中提取图像以用于工作或个人项目的任何人来说，这是一个方便的工具。我愿意接受有关改进 Vortex 的反馈和建议，包括在未来添加对更多 PDF 功能的支持。请随时在 GitHub 上查看它，让我知道您的想法。感谢您的支持，祝您编码愉快！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-30 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "介绍 Vortex——一种用于从 PDF 文件中提取图像的 Rust 工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "嘿，大家好，我很高兴能分享我在 Rust的最新项目: Vortex。它是一个从 PDF 文件中提取图像并将其转换为不同格式(如 PNG 或 JPEG)的工具。我已经使用 Rust 一年多了，Vortex 是一个具有挑战性但值得一试的项目。我使用“pdf”crate来提取原始图像数据，并使用“image”crate以所需的格式编写图像数据。文章链接，https://www.reddit.com/r/rust/comments/132jivj/introducing_vortex_a_rust_tool_for_extracting/Github 链接，https://github.com/omkar-mohanty/vortex" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/omkar-mohanty/vortex" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-29 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Vortex: 从 PDF 文件中提取图像的 Rust 工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Git-cliff 可以通过使用常规提交和基于 regex 的自定义解析器从 Git 历史中生成变更日志文件。可以使用配置文件自定义更改日志模板以匹配所需的格式。。文章链接，https://www.reddit.com/r/rust/comments/131s2dz/gitcliff_120_is_released_highly_customizable/Github 链接，https://github.com/orhun/git-cliff" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/orhun/git-cliff" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-29 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Git-cliff 1.2.0发布了! (高度可定制的变更日志生成器)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在过去一个月左右的时间里，我的 Rust 图形引擎项目热线工作进展顺利。我正在慢慢放下我现在的工作，在开始一个新的角色之前有一点时间，所以这给了我更多的时间致力于这个项目。我一直专注于实现不同的图形演示和渲染技术。我开始了构建图形功能单元测试的项目，并将这些测试挂到到本地或自托管的 GitHub Actions 运行器上运行。文章链接，https://www.polymonster.co.uk/blog/building-new-engine-4https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.polymonster.co.uk/blog/building-new-engine-4" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-29 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Rust 中构建新的图形引擎-Part 4" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "将你要用的环境变量一次性导入到类型安全的Rust结构体中，感觉非常好用。https://github.com/softprops/envy" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/softprops/envy" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-28 23:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "envy - 辅助集中处理环境变量" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在默认情况下，不能。但是借助类型系统的辅助，我们只需要多付出一点努力，就可以在编译层面做到。来看看是怎么做的。https://medium.com/@adetaylor/can-the-rust-type-system-prevent-deadlocks-9ae6e4123037" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://medium.com/@adetaylor/can-the-rust-type-system-prevent-deadlocks-9ae6e4123037" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-28 23:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust能防止死锁吗？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "前段时间facebook开源了buck2构建系统，最近 steveklabnik 就在研究如何使用它来编译Rust.https://steveklabnik.com/writing/using-cratesio-with-buck" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://steveklabnik.com/writing/using-cratesio-with-buck" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-28 23:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "steveklabnik Rust book 作者正在研究如何用buck2来编译Rust项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Firebuild 0.8 发布，加入对Rust的支持。号称能加速10倍Rust编译。https://balintreczey.hu/blog/improve-build-time-of-rust-java-and-intel-fortran-projects-with-firebuilds-new-release/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://balintreczey.hu/blog/improve-build-time-of-rust-java-and-intel-fortran-projects-with-firebuilds-new-release/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-28 23:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Firebuild - 编译缓存能让大型Rust项目加速10倍编译" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章讲得比较清晰：https://bertptrs.nl/2023/04/27/how-does-async-rust-work.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://bertptrs.nl/2023/04/27/how-does-async-rust-work.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-28 23:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust的异步是怎样工作的" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 在 GUI 领域正在以前所未有的速度发展，Rust 的跨平台特性和对 WebAssembly 的支持为 GUI 工具提供了更容易的软件发布。在这篇文章中，作者回顾了当前 Rust 中与 GUI 相关的 toolkit ，并分享了一些构建 WebAssembly bundles 的技巧。Article - 50 Shades of Rust: https://monadical.com/posts/shades-of-rust-gui-library-list.html#" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://monadical.com/posts/shades-of-rust-gui-library-list.html#" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-28 11:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "文章：50 Shades of Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 程序经常会使用迭代器，但这些迭代器给验证带来问题。本论文提出了一种用一阶逻辑推理 Rust 迭代器的通用框架，能够验证真实的 Rust 迭代器（包括高阶的 Map）。使用 Creusot 验证平台，作者评估了框架在迭代器客户端上的效果，证明它可以有效地验证复杂的函数式属性。Paper - Specifying and Verifying Higher-order Rust Iterators: https://hal.science/hal-03827702v2/document" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://hal.science/hal-03827702v2/document" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-28 11:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "论文：Specifying and Verifying Higher-order Rust Iterators" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 492: https://this-week-in-rust.org/blog/2023/04/26/this-week-in-rust-492/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/04/26/this-week-in-rust-492/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-28 11:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 492" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ReadMore:https://coderjoshdk.github.io/posts/Rust-Kernel-Programming.html#Everything_you_might_need" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://coderjoshdk.github.io/posts/Rust-Kernel-Programming.html#Everything_you_might_need" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-26 17:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 编写 Linux 内核模块" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n添加 rust-analyzer 作为 rustup 的代理\n将 clap 从 2.x 升级到 3.x\n...\nGithub:https://blog.rust-lang.org/2023/04/25/Rustup-1.26.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2023/04/25/Rustup-1.26.0.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-26 17:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rustup 1.26.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GCC 13 版本即将发布，但是 gccrs 不会包含在这个版本中。ReadMore:https://rust-gcc.github.io/2023/04/24/gccrs-and-gcc13-release.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust-gcc.github.io/2023/04/24/gccrs-and-gcc13-release.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-26 17:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GCC 13和GCCRS的状况" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文介绍了如何在 Rust 中使用 todo! 宏来原型设计您的API。todo! 宏表示未完成的代码。如果您正在进行原型设计并且只是想让您的代码进行类型检查，这可能会很有用原文链接https://foresterre.github.io/posts/todo-macro-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-24 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用todo!宏来设计Rust API" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Linux 内核 6.3 已经发布, 其中的亮点包括:原文链接https://9to5linux.com/linux-kernel-6-3-officially-released-this-is-whats-new" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-24 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Linux内核6.3发布, 包含对 Rust 的支持" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "特别实用的 repo, 有各种方法来减少 rust 编译后的程序体积大小.github地址https://github.com/johnthagen/min-sized-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-24 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "减少rust 编译后的体积大小" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如题, 这是一个可以用来操作 PDF 的Rust 库.github地址https://github.com/J-F-Liu/lopdf--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-24 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "lopdf: 一个Rust 的 PDF库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "嗨，最近几天我写了一个自己的 ECS 库。目前我正在使用它来驱动我正在开发中的软件光线追踪器 treat 的世界，而我仍在学习计算机图形的所有基础知识。尽管如此，我很想得到一些有关我的 ECS 实现的反馈 :)sweets 的结构：实体是一个包含两个 u32 位数的结构体。这两个数字组合在一起组成实体。第一个数字是实体的索引，第二个数字是代数。每次实体被删除时，其索引将保存在实体管理器内的 free_indices vec 中。这使我可以重复使用旧实体。为了使它们与具有相同索引的其他实体仍然独特，我有了代数。每次我删除实体时，我都会增加这个代数。为了检查实体是否存活，我可以比较实体的代数和实体管理器内代数 vec 中实体索引处存储的代数。所有这些都在 EntityManager 结构中管理。组件可以是任何实现 default 的结构体。每个组件都会获得从10到组件数量不等的唯一索引。我的第一个想法是使用静态计数器，每个组件将使用它作为索引，并逐一递增，但它要么不递增，要么每次递增而不是只递增一次。因此，我采用了使用由 Rust 分配给每个组件的 TypeId 索引的哈希映射的方法。索引将被用于索引 ComponentPools 的 Vec，以获取正确的组件池。ComponentPool 保存每个具有此类型组件的实体的组件数据。当删除组件时，它将被释放到池中以便以后重用。使用索引，还可以创建 ComponentId。它只是左移指数的一位（1<<index）。这种方式只会翻转每个 ComponentId 中的一个位。通过按位或将它们组合起来，我得到所需组件的唯一标识符。所有可能具有的组件的此标识符都由 ComponentManager 存储。限制：目前我只能有64个不同的组件。如果我使用 u128，这个数字将加倍，但有些人仍然认为它非常有限。我希望我的解释与源代码相结合，如果不行，请随时提问，我愿意接受任何反馈、想法或问题 :)" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-23 20:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我用 Rust 编写了一个 ECS。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，很高兴与您分享我的一个项目：Netspeed。这是一个简单但有用的应用程序，可以显示您当前的上传和下载速度，以及当天的总数据使用量。Netspeed 是用 Rust 和 Tauri 构建的，这使得它轻巧而快速。它支持 Windows、Linux 和 macOS，您可以从GitHub 发布页面下载它https://github.com/visnkmr/netspeed_pc/releasesNetspeed 是开源的，并根据 MIT 许可证获得许可。您可以在GitHub上找到源代码、文档和贡献指南https://github.com/visnkmr/netspeed_pc我希望您发现 Netspeed 有用。我很想听听您对如何改进它的反馈和建议。你可以在 GitHub 上联系我。感谢您的关注与支持！对于那些有兴趣的人，这里是我制作这个应用程序的旅程的简要总结：我为 API（前端和后端之间的通信层）尝试了不同的后端选项。我尝试在 Tauri 中使用 HTTP、SSE（单客户端和多客户端）和 WebSocket。对于前端，我尝试使用 Python 和 Tauri。我还尝试制作一个单独的应用程序，使用 TCL（Python 提供的原始 Tkinter GUI 背后的语言）前端将 python 前端和 Rust 后端组合到一个模块中。在所有这些尝试之后，我决定制作一个将前端和后端作为一个单元的应用程序，就像您通常看到的那样。我在 Tauri 中做了一个版本，它使用 Tauri 自己的 WebSocket 来进行 Rust 和 JS 之间的通信。但最终决定不使用它，选择使用 Tauri 作为前端和单客户端 SSE 作为后端 rust 模块的版本。您可以在 GitHub 上找到不同版本的所有 repo 链接。它们都是根据 MIT 许可证获得许可的。你可以在Github上找到所有的 repo 链接https://github.com/visnkmr欢迎任何疑问和查询。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-23 20:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "介绍 Netspeed：一个使用 Rust 构建的跨平台桌面应用程序，可以显示网络速度和当天的使用情况。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tridify-rs（最初名为 Ldrawy，基于 Open GL）是一个非常简单但灵活且轻量级的低级别 GPU 渲染框架，基于 Wgpu 来创建自己的框架、引擎、模拟器... 无所不能！通常在我的项目中工作时，我会遇到相同的长时间模板设置窗口和图形上下文，如果使用 Wgpu 或 Vulkan，则会变得更糟，可能需要设置300行才能绘制一个三角形。参考其他语言中类似的框架（如 Three.js），我想为 Rust 创建类似的东西。虽然它仍在不断发展中，可能缺少一些基本功能，但它已经可以在简单的小型项目中使用。在0.2.2中，我的目标是将Egui集成到框架中，因为它极大地改善了可用性和创建工具和调试信息的便利性。从这个点开始，我将开始处理更复杂的系统，因此我希望确保我有一种方法来平滑路径。我鼓励您检查该项目并查看我将要开发的计划功能，请注意，由于该框架仍处于重度开发中，版本之间将会有破坏性变化。此外，由于这是我使用 Rust 的第一个项目，任何批评或建议都是受欢迎的！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-23 20:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tridify-rs 0.2.2 发布：一个快速、简单的底层渲染框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们正在组建一个新团队，专注于 Ubuntu 上的 Rust 编程语言及其生态系统。他们将在 Ubuntu 中提供最佳的 Rust 运行时、开发人员体验和支持工具。我们热衷于确保 Ubuntu 用户可以使用现代编程语言创新的前沿，为未来的发明和开源社区奠定基础。对于热衷于开源软件、Linux 系统、软件架构和 Rust 编程语言的软件工程师来说，这是一个令人兴奋的机会。快来与 Canonical（一家成长中的国际软件公司）技术领域最优秀和最聪明的人一起建立一个有价值的、有意义的职业，并使 Ubuntu 成为在云、数据中心、容器中直接在服务器上开发和运行 Rust 应用程序的最佳操作系统。操作系统，以及 Ubuntu 可以运行的任何地方。Ubuntu Foundations Team 提供核心 Ubuntu 系统，它是整个 Ubuntu 系列产品和服务的基础。Ubuntu 致力于以易于使用和高度可靠的形式提供最新最好的免费软件组件。我们以 Debian 的卓越技术为基础，并为我们为行业提供的解决方案带来更多关注和塑造。作为 Ubuntu Foundations 团队的一员，您将致力于一些最关键的工具链，这些工具链涉及 Ubuntu 的制作，同时也是现代软件生态系统的支柱。您将利用您在 Rust 方面的经验和热情，使 Ubuntu 成为开发、分发和使用使用 Rust 构建的软件的最佳平台。申请人将对 Rust、Ubuntu 的未来充满热情，关注开源生态系统的动态，并同样意识到大型但创新组织的需求。申请人将以安全、可靠、高性能、高效和面向未来的方式推动 Ubuntu 中从桌面到云的最佳集成。您将与其他团队成员讨论设计并指导不太高级的工程师，并参与代码审查和设计审查。您还将与其他团队合作，确保架构决策能够提高 Ubuntu 的整体性能和体验。作为 Ubuntu Foundations 团队的一员，您的角色将对 Ubuntu 的各个方面产生影响，从桌面、服务器、Ubuntu Core 到云映像。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-23 20:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "系统软件工程师 - Rust 编译器、工具和生态系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n主动与分布式团队协作\n使用 Ubuntu 选择、集成和打包最佳工具，以改善开发人员和运维人员的 Rust 体验\n编写高质量代码以创建新功能\n调试问题并生成高质量的代码来修复它们\n审查其他工程师生成的代码\n讨论想法并合作寻找好的解决方案\n在家工作，每年 2 到 4 周进行全球旅行，参加内部和外部活动\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-23 20:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "你会做什么" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n你热爱技术并与优秀的人一起工作\n你热情、好奇、灵活、善于表达、负责任\n你是一个长期的 Linux 用户\n您有经验或有兴趣学习如何为 Debian 和 Ubuntu 打包软件\n你有相关的 Rust 经验，最好是在云原生软件和 Linux 领域\n您拥有计算机科学、STEM 或类似学位的学士学位或同等学历\n您重视软技能并且充满激情、进取心、体贴和自我激励\nCanonical 是一家成长中的国际软件公司，它与开源社区合作，提供世界上最好的免费软件平台 Ubuntu。我们的服务帮助全球企业通过 Ubuntu 降低成本、提高效率并增强安全性。我们为营造一个没有歧视的工作场所而感到自豪。经验、观点和背景的多样性创造了更好的工作环境和更好的产品。无论您的身份如何，我们都会公平考虑您的申请。https://canonical.com/careers/diversity/identity申请编号：933申请链接：https://canonical.com/careers/4383713" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-23 20:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "你是谁" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Strolle 的目标是创建一个交互式路径追踪器，能够在不依赖硬件光线追踪功能的情况下在消费级 GPU 上生成好看的图像。Strolle 支持与 Bevy 集成在一起，但也可以通过 wgpu 单独使用。https://bevyengine.org/目前的状态是正处于开发中，尚未正式发布。适用于 Windows、Mac 和 Linux，将来可能支持 WebGPU。GitHub 链接，https://github.com/Patryk27/strolle" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Patryk27/strolle" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-22 20:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Strolle, 一个实时渲染引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "r3bl_tui，受 Redux、lexbox、CSS等编辑器组件启发的 TUI 库。它现在支持智能列表、基于终端功能的颜色支持（真彩色、ansi 256、灰度）、自定义 Markdown 解析器和语法高亮器。灵感来自 React。crate 链接，https://crates.io/crates/r3bl_tui" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/r3bl_tui" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-22 20:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "r3bl_tui 发布 v0.3.3" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Myval 是个轻量级的 Arrow 数据框架，专注于就地数据（in-place data）转换和 IPC。Myval 并不是 Polars 的竞争对手。GitHub 链接，https://github.com/alttch/myvalhttps://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/alttch/myval" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-22 20:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Myval - Rust 的轻量级 Apache Arrow 数据框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "aws-lc-rs，不过是aws-lc密码库的绑定。API接口与Ring兼容。repo: https://github.com/awslabs/aws-lc-rsblog: https://aws.amazon.com/cn/blogs/opensource/introducing-aws-libcrypto-for-rust-an-open-source-cryptographic-library-for-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-21 23:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "AWS 发布的Rust密码学库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章教你如何写一个简单的解析器。https://www.equalto.com/blog/a-rustic-invitation-to-parsing" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-21 23:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust语言制造你自己的DSL的教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者通过实践总结出如何使用Rust的高级特性实现更加可靠安全的编程。https://ktkaufman03.github.io/blog/2023/04/20/rust-compile-time-checks/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ktkaufman03.github.io/blog/2023/04/20/rust-compile-time-checks/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-21 23:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust将运行时检查带入编译期" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "从学习6502指令集做起，做一个NES模拟器，非常有趣。https://analog-hors.github.io/site/pones-p1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://analog-hors.github.io/site/pones-p1/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-21 23:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "写一个NES 模拟器，第一部分 6502 CPU" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是个奇怪的比较。其实比的就是Web前端框架的速度和体验。从最新的发展态势来看，Rust实现的Web前端框架，速度逐渐赶超了大部分Js前端框架。https://joshmo.hashnode.dev/can-rust-beat-javascript-in-2023" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://joshmo.hashnode.dev/can-rust-beat-javascript-in-2023" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-21 23:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2023年，Rust能打败JavaScript吗？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "线代库，AI的基础。关注一下。https://github.com/sarah-ek/faer-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sarah-ek/faer-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-21 23:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "faer-rs - 又一个线性代数库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust编程语言在今天（2023年4月20日）发布了1.69.0版本，致力于帮助开发者构建高效可靠的软件。\nCargo现在会建议开发者使用cargo fix或cargo clippy --fix命令来自动修复一些警告。\n为了提高编译速度，构建脚本中不再默认包含调试信息。\n一些API在const上下文中得到了稳定。\n该版本包含超过500名开发者提交的3000多个小改进，进一步巩固了Rust在高性能和安全性方面的优势。\nRust官方博客：https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2023/04/20/Rust-1.69.0.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-20 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.69.0发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自reddit的一个网友发帖称赞Rust里的模式匹配很强大，简单概括是：\nRust 中的 | 运算符在模式匹配中非常强大，能够简化代码并提高可读性和可维护性。\n| 运算符在所有的模式匹配上下文中使用，包括嵌套在元组和结构体中的模式。\n在模式匹配语句中，使用 | 运算符可以将多个匹配条件合并为一个，从而简化代码。\n在 if-let 语句中，也可以使用 | 运算符简化模式匹配代码。\n在模式匹配中，多个 | 运算符会尝试所有可能的组合。\n总之，使用 | 运算符可以让我们更加灵活地编写模式匹配语句，提高代码的可读性和可维护性。原帖: https://www.reddit.com/r/rust/comments/12sbjyj/power_of_the_operator_in_pattern_matching/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/12sbjyj/power_of_the_operator_in_pattern_matching/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-20 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust的强大模式匹配" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本周，Rust社区持续推进着各项项目和工具的更新和改进。以下是一些值得关注的内容：\nRust基金会发布了商标政策草案，并开始征求社区反馈。\nNutype发布了v0.2版本，支持更多的文本格式。\ntuxedo-rs正式宣布发布，这是一个用于快速构建Web API的Rust库。\nrust-analyzer更新至177版，增加了一些新的特性和改进。\nRust开发者分享了一些关于优化derive宏编译时间的方法。\nRust开发者使用Rust重写了一个Python项目bmap-tools。\nRust的Traits不仅仅是接口。\nRust添加了Optional If表达式。\nRust开发者分享了如何使用meson构建GStreamer插件。\n有两个好用的Rust库Rutie和Magnus，可以用于构建Ruby扩展。\nRust开发者分享了在其他语言中想念Rust的两个特性。\nRust Analyzer的开发者Lukas Wirth分享了一些关于Rust Analyzer的内容。\nWasmer的开发者Syrus Akbary分享了一些关于Wasmer的内容。\n了解Rust的线程安全性。\n如何在circuit playground classic/atmega32u4上运行Rust代码。\n用#[no_core]和编译器补丁在m68k上编写Rust的Hello World。\nRust开发者分享了一个支持分支控制流和同步共享可变借用的异步join宏。\n用Rust构建Lua解释器的教程。\nRust开发者Zino分享了一个使用100行代码实现带有跟踪功能的错误类型的实现。\nShuttle Batch 2.0发布。\n本周的Crate of the Week是onlyerror，这是一个#[derive(Error)]宏，支持在nightly编译器上使用no_std。此外，本周也有一些Rust社区的贡献机会，包括帮助Quickwit升级clap、实现quickwit数据集CLI命令，帮助Hyperswitch迁移enum_dispatch以减少运行时开销等。本周动态: https://this-week-in-rust.org/blog/2023/04/19/this-week-in-rust-491/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/04/19/this-week-in-rust-491/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-20 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust社区动态：This Week in Rust 491" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一位Rust开发者在Reddit上问到，是否有其他编程语言中的序列化/反序列化库可以与Rust的serde库相媲美。他表示，他曾经使用过C＃，Java，JS，Dart等语言，但是没有看到过像serde.rs这样的生态系统，其中所有库之间都有一种共同的序列化和反序列化数据的一致模式，而这一切都是由Rust的trait系统支持的。对于高赞评论的作者来说，Rust具有几个方面的特点，使得这种组合和通用的库特别可行：\nTrait不会强制执行内存布局或类型层次结构限制，不像接口和纯虚基类。\nSerde可以声明核心和标准类型，如u8和&str，实现Serialize和Deserialize。没有需要奇怪的反射。\n派生宏意味着第三方库可以轻松支持通过派生Serialize和Deserialize来支持crate。因此，他们很可能会付出最小的努力。如果添加对serde的支持很麻烦，第三方crate将不太愿意这样做。\n特性的组合，易于使用的cfg_attr，允许第三方crate选择性地实现Serialize和Deserialize，即#[cfg_attr(feature = \"serde_support\", derive(Serialize, Deserialize))]。这意味着如果crate的用户不需要此功能，第三方crate不需要拉取大量的依赖项。这得益于依赖项可以是可选的，只有在启用功能时才包括。\nCargo的易用性鼓励开发者将crate拆分为几个组件，允许serde单独存在，但与serde-json、toml、quick-xml、postcard等链接。\n不会有破坏性。serde非常早就在Rust的生态中创建了，这意味着它很快成为了事实上的标准，尽管说到这里，我开始看到对tracing crate的第三方支持，例如color-eyre捕获跟踪跨度，因此较新的crate变得标准也是完全可行的。\n综上所述，Rust的serde库确实是一个非常独特和强大的工具，它的设计和实现使得其在序列化和反序列化方面表现出色，并且在Rust生态系统中被广泛使用。原帖: https://www.reddit.com/r/rust/comments/12so3j9/is_rust_serde_unique/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/12so3j9/is_rust_serde_unique/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-20 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 的 serde 库如此独特吗？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "IronBoy 是一个使用 Rust 实现的 GameBoy 模拟器，通过 Wasm 在浏览器中运行。\n仓库地址\n在线游玩地址\n除此之外，Rust 还有很多类似的 Gameboy 模拟器项目：\nrboy\ngbemulator\nboytacean\nrgy\n下面这篇博客中，还详细描述了如何从零开始，实现一个 Gameboy 模拟器，感兴趣的小伙伴可以结合以上几个项目食用。https://yushiomote.org/posts/gameboy-emu" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-18 22:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "IronBoy - 又一个 GameBoy 模拟器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "winit 是一个跨平台的窗口管理器，其内部通过 event-loop 驱动，但是仅提供了同步的编程接口。async-winit 则提供了一个 async/await 的编程接口，让 rust 开发者可以更加优雅地使用 winit。感兴趣的同学可以阅读原文，更加详细地描述了其使用方式。https://notgull.github.io/async-winit/winit github地址async-winit github地址https://github.com/rust-windowing/winit" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-18 22:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-winit: winit 异步化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "拥有 Rust 和 Cargo 商标的 Rust 基金会正在制定新的商标政策，这可能会对广泛的 Rust 社区产生严重影响，因为该基金会限制包括禁止在 Rust 相关工具或用 Rust 编写的软件的名字中使用 Rust，甚至在域名或子域名的部分也禁止使用 Rust。4月7日，Rust 基金会发布了新政策草案，并通过谷歌文档征求意见，截止日期为4月16日，目前反馈通道已经关闭。Rust 商标工作组、Rust 基金会和 Rust 项目主管将一起彻底审查来自社区的反馈。在对反馈进行审查后，Rust 基金会、Rust 项目主管和商标工作组将开始与法律顾问举行初步会议，以解决关键反馈，并对新政策草案进行修订。工作人员重申，在 Rust 基金会和 Rust 项目领导层都满意之前，我们不会实施任何政策。原文https://foundation.rust-lang.org/news/rust-trademark-policy-draft-revision-next-steps/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-18 22:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 商标政策的进展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章是关于在 Linux 系统上如何实现“栈展开”的，作者介绍了一种“硬核”的方法，即使用 DWARF 调试信息来实现。文章中详细介绍了 DWARF 调试信息的结构和使用方法，并给出了一个使用 Rust 和 gimli 库实现的例子。原文链接https://lesenechal.fr/en/linux/unwinding-the-stack-the-hard-way" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-17 19:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "硬核的方式进行栈展开" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Aero 是一个新的现代化、实验性的类 UNIX 操作系统，采用单内核设计。它支持现代 PC 的特性，比如长模式、5级分页和 SMP（多核）等等。github地址https://github.com/Andy-Python-Programmer/aero" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-17 19:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "aero: 又一个 Rust 编写的操作系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "broot 是一个可交互式的命令行工具,可以方便的展示和导航目录.github地址https://github.com/Canop/broot" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-17 19:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "broot: 一种查看目录的新方式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一套 17 小时的 axum 课程视频. 可以让你完整的实现一个 web 服务.油管视频https://www.youtube.com/playlist?list=PLrmY5pVcnuE-_CP7XZ_44HN-mDrLQV4nS--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-17 19:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "axum 课程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/metaworm/luac-parser-rslua字节码解析器，目前支持lua51、lua52、lua53、lua54、luajit这是metaworm的luadec的一部分，是目前最好的lua反编译器http://luadec.metaworm.site/您可以根据此代码编写您的自定义 luac 解析器，它可以编译为 WASM 并由metaworm 的 luadec加载，以反编译非官方的 lua 字节码http://luadec.metaworm.site/由于nom的灵活性，用 Rust 编写自己的解析器非常容易，阅读本文以了解如何编写 luac 解析器https://github.com/rust-bakery/nom" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-16 19:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用 Rust 编写的 lua 字节码解析器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "受Xilem、Leptos和rui的启发，Floem 旨在成为一个高性能的声明式 UI 库，用户只需付出最少的努力。https://github.com/linebender/xilemFloem 最初是为Lapce 代码编辑器创建的新 UI 库，专注于性能和用户体验。https://lapce.dev/可以在回购协议中找到更多详细信息：https://github.com/lapce/floem" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-16 19:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Floem - 另一个新的 Rust 原生 UI 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "WhatsApp 正在为端到端加密消息添加公钥透明技术，并将核心逻辑作为开源发布。工程博客文章https://engineering.fb.com/2023/04/13/security/whatsapp-key-transparency/Auditable Key Directory (akd)是一个新的 Rust crate，用于管理集中式可审计密钥目录，该目录可以扩展到数十亿用户以实现透明解决方案。它发布在crates.io上供akd所有人使用！https://github.com/facebook/akd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-16 19:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WhatsApp 在 Rust 中发布了新的关键crate AKD" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个floem是大名鼎鼎的Rust编辑器lapce的新项目。看来也想在通用原生GUI上发力了。Lapce相当不错。值得期待。https://github.com/lapce/floem" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/lapce/floem" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-15 22:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "floem - 又一个原生Rust GUI库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cloudflare worker对wasm有最好的支持，因而也间接对Rust有最好的支持。https://medium.com/@shyamsundarb/a-serverless-url-shortener-with-rust-and-cloudflare-workers-42e1fb36502e" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://medium.com/@shyamsundarb/a-serverless-url-shortener-with-rust-and-cloudflare-workers-42e1fb36502e" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-15 22:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust和Cloudflare workers开发一个serverless URL短地址服务" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "为了学习，从头写一个是一个有效的办法。https://dietcode.io/p/tracing-macros/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://dietcode.io/p/tracing-macros/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-15 22:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio tracing库的实现原理 - 从头搞一个学习" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://zoe.kittycat.homes/log/rust_atmega32u4_tutorial" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://zoe.kittycat.homes/log/rust_atmega32u4_tutorial" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-15 22:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "嵌入式 - 在atmega32u4运行rust代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "不过是视频的。https://www.youtube.com/watch?v=XZtlD_m59sM" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=XZtlD_m59sM" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-15 22:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Axum完全教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这两天我搞的很开心，所以决定分享出来。它解决了一些我工作中的一个问题，实际上并没有真的解决，因为我们不用Rust，但是如果我们如果用rust，那么它将解决这个问题。那么，这个到底是干什么的呢？它就像一个非常有限制的Vector版本，它可以变得非常大。首先，可以往里面push items，在一定的阈值后，开始会交换到一个临时文件。文章链接，https://www.reddit.com/r/rust/comments/12m26ec/swapvec_a_vector_that_swaps_to_disk_if_growing/Github 链接，https://github.com/julianbuettner/swapvec" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/julianbuettner/swapvec" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-15 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SwapVec - 一个Vector实现，当特别大的时候会交换到硬盘" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Svgbob是一个通过ascii文本生成avg的工具，可以为您的文本图形创建一个很好的图形。Svgbob 提供了一个 cli，它将文本作为输入，并创建一个 svg 图像作为输出。文章链接，https://www.reddit.com/r/rust/comments/12mrysm/ascii_to_svg_tool_svgbob_v070_is_just_released/Github 链接，https://github.com/ivanceras/svgbob/blob/master/Changelog.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ivanceras/svgbob/blob/master/Changelog.md" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-15 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "svgbob v0.7.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我想管理我的财务，收入和支出。我讨厌记账，但我想要记一下。我不想要一些花哨的图形用户界面工具，我只想要一个简单的 cli 工具，它可以记录我的收入和支出，简单的命令类似于 git。文章链接，https://www.reddit.com/r/rust/comments/12mmxtx/fig_a_personal_finance_management_cli_tool/Github 链接，https://github.com/IsotoxalDev/fighttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/IsotoxalDev/fig" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-15 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fig：一个个人理财的cli工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "WhatsApp 发布新的密钥透明度 crate - AKD，由 Rust 编写。WhatsApp 正在为端到端加密信息添加公钥透明技术，并将核心逻辑开源发布。Auditable Key Directory (akd) 是一个全新的 Rust crate，用于管理集中式的可审计密钥目录，可以扩展到数十亿用户的透明解决方案。现已发布在 crates.io 上供所有人使用！Blog - Deploying key transparency at WhatsApp: https://engineering.fb.com/2023/04/13/security/whatsapp-key-transparency/crates.io - akd: https://crates.io/crates/akd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/akd" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-14 02:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "AKD - WhatsApp 开源的可审计密钥目录管理 crate" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "png 这个 crate 是 Rust 中用于读取和写入 PNG 图像的事实标准。在 v0.17.8 中，解码图片时间比之前的 v0.17.7 少了 15% 到 75%。\n一个新的、专门为 PNG 设计的 Zlib 实现。它比以前使用的通用 Zlib 实现提供了更高的性能。\n重写了 PNG filter，以利用自动向量化，利用 SIMD，没有 unsafe 或平台特定的代码。\n另外，压缩性能也获得大幅提高。Reddit - png crate gets an ultrafast compression mode, up to 4x faster decompression: https://www.reddit.com/r/rust/comments/12ks0ka/png_crate_gets_an_ultrafast_compression_mode_up/fdeflate - A fast deflate implementation: https://crates.io/crates/fdeflatehttps://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/fdeflate" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-14 02:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "性能优化，png 解压速度提高 4 倍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nGATs 支持\n禁用指定项目的完成和自动导入功能\n半开区间模式支持\n在宏主体中注入语言或引用\n...\nReadMore:https://blog.jetbrains.com/rust/2023/04/11/new-in-intellij-rust-for-2023-1-part-1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.jetbrains.com/rust/2023/04/11/new-in-intellij-rust-for-2023-1-part-1/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-13 10:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2023.1 版 IntelliJ Rust 中的新功能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "This Week in Rust 490Github:https://this-week-in-rust.org/blog/2023/04/12/this-week-in-rust-490/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/04/12/this-week-in-rust-490/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-13 10:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周的 Rust - 490" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n通过或加密的配置文件\n将配置文件加载到你的终端会话中\n在未来会话中可用的持久性环境变量\n用你的配置文件运行程序\n从文件中导入配置文件\n下载配置文件，然后将其导入\n将配置文件导出到一个文件\nReadMore:https://humblepenguinn.github.io/envio/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://humblepenguinn.github.io/envio/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-13 10:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "envio - 安全的管理环境变量" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "主要功能\n支持ZipCrypto和AES加密。\n利用多个线程来加快过程。\n使用字典攻击测试来自字典文本文件的密码（每行一个单词）。\n使用暴力破解来生成给定字符集和密码长度范围内的所有密码。\n可用于密码生成的字符集包括：\n基本字符集：小写字母。\n简单字符集：基本字符集+大写字母。\n中等字符集：简单字符集+数字。\n复杂字符集：中等字符集+标点符号和额外字符。\nReadmore: https://github.com/agourlay/zip-password-finder" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/agourlay/zip-password-finder" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-11 18:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个 Rust 编写的 Zip 密码破解工具 zip-password-finder" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "zune-png 解码 PNG 图像的速度比 png crate和 libpng 快得多。目前，zune-png 在不同的图像上比 png crate 快 1.7 倍到 3.5 倍。这得益于快速的 zune-inflate 作为基础的 gzip 实现，以及 PNG 的自动向量化位操作和 SIMD 实现。zune-png 是用Rust编写的，除了 SIMD 指令以外没有使用不安全的代码。这是因为 std::simd 仍然不稳定。使用 unsafe 是可选的，可以在编译时和运行时进行切换。与 png 这个 crate 相比，zune-png 的缺点是缺乏流式传输（需要在内存中使用输入和输出缓冲区，从而实现更多的优化），以及不支持 APNG（动画）扩展。它已经在60万个实际图像上进行了广泛测试，同时以各种方式进行了模糊测试，现在已经可以在生产中使用了！Readmore: https://crates.io/crates/zune-png" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/zune-png" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-11 18:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 库推荐：zune-png" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ReadMor: https://www.bilibili.com/video/BV1tL41127tw/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.bilibili.com/video/BV1tL41127tw/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-11 18:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "北京 Rust meetup 视频回放" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "minus 是一个用 Rust 编写的异步终端分页库。这个版本有点特别，因为它经过几个月的开发，终于减去现在有它自己的 API 来添加/删除终端上的键/鼠标绑定。以前复制默认模板，更改您需要的部分并将其设置为的方法InputClassifier仍然可行，但不推荐使用。还修复了一个错误，即使用鼠标滚动会导致显示损坏的输出。在此处查看完整的变更日志https://github.com/arijit79/minus/blob/main/CHANGELOG.md#v530-2023-04-10如果你喜欢减号，请给它一个星。它不花任何钱，但确实激励我继续努力。GitHub | Discord | Matrixhttps://github.com/arijit79/minus" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-10 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "minus v5.3.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n该项目基于stdwebcrate，用于cargo-web构建 WebAssembly 文件，这两个文件自 2019 年以来都没有收到更新，实际上已被放弃。wasm-bindgen我用和替换了前者，web-sys用 替换了后者trunk，所有这些都得到了积极的开发和维护。\n回购使用的是一种非常古老的 GitHub Pages 形式，你必须将构建工件放在主分支中，并且没有设置为自动构建，所以我添加了一个 GitHub Actions 工作流来自动构建、测试和部署代码一个单独的gh-pages分支机构，该分支机构由该站点提供服务。\n正在使用的版本regex已经过时（1.3.9），因此项目已更新到最新版本（1.7.3）\nfancy-regex被添加为一个选项，以便它的正则表达式也可以被测试。\n我在做的时候也做了一些代码清理/重构。\n项目托管在 GitHub 上： http: //github.com/lpil/rustexphttp://github.com/lpil/rustexp" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-10 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 正则表达式编辑器和测试器已更新！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "AskBend 是一个 Rust 项目，它利用 Databend 和 OpenAI 的强大功能从 Markdown 文件创建基于 SQL 的知识库。您可以轻松地将博客或文档用作数据源并托管您自己的实例。\nGitHub repo： https: //github.com/datafuselabs/askbend\nLive Demo demo about asking for Databend documentation: https://ask.databend.rs/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-10 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "askbend - 使用 Databend 进行基于 SQL 的知识库搜索和完成" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章讨论了编译器优化的问题，以及为什么我们可以信任编译器来优化我们的代码。他解释了编译器如何工作，以及如何在编写代码时考虑编译器的优化。总的来说，编译器是可以信任的，因为它们会尽力优化代码，而不会改变代码的语义。但是，有时候编译器可能会出现错误，因此我们需要进行测试和调试。原文链接https://matklad.github.io/2023/04/09/can-you-trust-a-compiler-to-optimize-your-code.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-10 18:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "你能相信编译器优化的代码吗 ?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Dozer 可以连接任何数据源，实时组合它们并立即获得低延迟的数据API，所有这些只需要简单的配置！github 地址https://github.com/getdozer/dozer" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-10 18:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Dozer: 一个实时数据 api 后端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "PL/Rust是一种可加载的过程语言，它使得可以使用Rust编程语言编写PostgreSQL函数。这些函数被编译为本机机器代码。与其他过程语言不同，PL/Rust函数不是解释的例子:原文链接github 地址https://tcdi.github.io/plrust/plrust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-10 18:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "PL/Rust: 一个可信任的过程语言处理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个油管视频, 讲述如何使用 axum 进行 web 开发的全教程视频.油管视频https://www.youtube.com/watch?v=XZtlD_m59sM--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-10 18:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Axum 全教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "OctaSine 是一款免费开源的调频合成插件，支持 VST2 和 CLAP 格式，发布了 v0.8.5，最显著的新功能是新增了新的操作器波形，即方波、三角波和锯齿波形，使声音创造更加灵活。还修复了在 Windows 上清除库/补丁时崩溃的问题。另外，它获得了本月 KVR Audio One Synth Challenge 的特色合成器。https://www.kvraudio.com/forum/viewtopic.php?t=595348GitHub 链接，https://github.com/greatest-ape/OctaSine" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-09 07:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "OctaSine 发布 v0.8.5" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章希望大家开始关注错误，并对其设计进行思考，并学习如何优雅地实现好回溯、可扩展性、检查性（错误匹配）、稳定性和模块化五个目标之间的平衡。文章提出的错误处理的准则：\n利用.source()方法\n构建错误类型\nFrom\n邻近性\n详细性\n错误处理很难，但学会它是值得的。博客原文链接，https://sabrinajewson.org/blog/errors" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-09 07:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中模块化错误" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "faer 是一个在纯 Rust 中实现低级线性代数例程的 crates 集合。其目标是最终提供一个功能齐全的线性代数库，侧重于可移植性、正确性和性能。faer v0.7\n添加 to_owned 函数，用于将 MatRef/MatMut 转换为 Mat\n允许比较共轭矩阵\n改进了 f32、c32 和 c64 的性能\n改进了小/中型矩阵分解的性能\n重构了 ComplexField 特质以允许非 Copy 类型\nGitHub 链接，https://github.com/sarah-ek/faer-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-09 07:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Faer 发布 v0.7" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "cargo-eval 是随 Rust 一起提供的新程序，可用于单文件cargo包，这些包是带有嵌入式清单的.rs文件。可以将其放置在#!行中以直接运行这些文件。清单将是一个模块级别的文档注释，其中包含以cargo为类型的代码围栏。Pre-RFC 链接，https://internals.rust-lang.org/t/pre-rfc-cargo-script-for-everyone/18639https://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-09 07:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-script的预提案" }, "type": "text" }], "type": "title" } },]
