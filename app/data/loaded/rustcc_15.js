export const propertiesForNewPages = [{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一次构建，到处运行。Rust 真的可以做到 Actually Portable Executables 吗？本文作者使用 Cosmopolitan Libc 进行了一次探索，并成功构建了一个可以跨 Linux, Windows, MacOS, FreeBSD, NetBSD, OpenBSD 六个平台运行的 Rust 可执行程序。Actually Portable Executables with Rust and Cosmopolitan Libc: https://ahgamut.github.io/2022/07/27/ape-rust-example/Crate - ahgamut/rust-ape-example: https://github.com/ahgamut/rust-ape-exampleGitHub - jart/cosmopolitan: https://github.com/jart/cosmopolitan"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/jart/cosmopolitan"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-28 20:36"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"文章 - 使用 Rust 和 Cosmopolitan Libc 构建可移植可执行文件"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在这篇文章中，介绍了新的关键字泛型计划，解释为什么会存在这样一个企划，并展示了一个简短的例子。该倡议在 Rust Zulip 的 t-lang/keyword-generics 上非常活跃 —— 如果您对此感兴趣，请访问！Announcing the Keyword Generics Initiative: https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.htmlZulip - t-lang/keyword-generics: https://rust-lang.zulipchat.com/#narrow/stream/328082-t-lang.2Fkeyword-generics"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://rust-lang.zulipchat.com/#narrow/stream/328082-t-lang.2Fkeyword-generics"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-28 20:36"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"文章 - 关键字泛型计划"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 453: https://this-week-in-rust.org/blog/2022/07/27/this-week-in-rust-453/https://github.com/PsiACE"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2022/07/27/this-week-in-rust-453/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-28 20:36"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week in Rust 453"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"简单、便携、高性能、ACID、嵌入式键值存储。redb 是用纯 Rust 编写的，并受到 lmdb 的启发。\n零拷贝、线程安全、基于 APIBTreeMap\n完全符合 ACID 的事务\nMVCC 支持并发读写器，无阻塞\n默认情况下是安全的\n在许多基准测试中，redb几乎与lmdb一样快，并且比sled更快例子：ReadMore:https://github.com/cberner/redb"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/cberner/redb"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-27 22:23"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"redb - 嵌入式数据库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"0.4.20 是自 2020 年 9 月以来的第一个 chrono 版本。由于之前的维护者不再能够在 crate 上花费太多时间，因此中断了很长时间；感谢@quodlibetor 多年来对 chrono crate 的管理！新的维护者是@djc 和@esheppa。ReadMore:https://github.com/chronotope/chrono/releases/tag/v0.4.20-rc.1"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/chronotope/chrono/releases/tag/v0.4.20-rc.1"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-27 22:23"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"chrono 有了新的维护者"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Jakob Waibel 是 IBM 的工程师，他最近发布了 lurk，这是一个非常简洁而美观的 strace 替代品，它实现了 strace 的绝大部分功能，并且在可读性上做出了很大程度的优化，旨在给用户带来更好的体验。github仓库地址https://github.com/JakWai01/lurk"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-26 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"lurk - strace written in rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本文是关于 hprof-slurp 项目的性能回顾的第二部分。https://agourlay.github.io/rust-performance-retrospective-part2/hprof-slurp是一个 JVM 堆转储分析器，它通过流式处理转储文件，而不在主机上存储中间结果，这种方法可以提供非常快速的转储文件概览（并不能取代 Eclipse Mat 和 VisualVM 这样提供更高级功能的工具）。本文中，作者通过分析 hprof-slurp 的 flamegraph，定位了 memcpy 存在的性能瓶颈，并针对 Rust 代码做了优化，取得了很好的成效，不妨来学习一下作者分析和解决问题的思路。（建议阅读 part1，以便对于该项目有基础的了解）part 1https://agourlay.github.io/rust-performance-retrospective-part1/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-26 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Rust 进行性能观测 part2"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"不同的操作系统的服务管理器各异：service-manager 对于不同操作系统的接口进行了封装，提供了统一的编程范式：该 library 还支持 system-level 和 user-level 的切换，以及自定义配置，更多详细信息可以参考其 github 主页github仓库链接https://github.com/chipsenkbeil/service-manager-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-26 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Service Manager - 跨平台的服务管理器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 消除了在其他语言中流行的各种愚蠢的bug和陷阱，使开发和维护我们的项目变得更加容易。不幸的是，当涉及异步编程中常见问题时，Rust在本质上没有那么强的能力。事实上，异步编程在Rust中要比在 Javascript 中难得多.上个月，作者的服务因为一个严重的死锁bug而瘫痪了好几天，这不是他们看到的第一个死锁了, 至少是第四个了。就在上周，作者所在公司又看到了一次死锁导致的服务中断。幸运的是，5个死锁中有4个具有相同的根本原因: futures::stream::Buffered 天生就容易发生死锁。在这篇文章中，作者将解释这个问题，并探索防止这种情况再次发生的方法。原文链接https://blog.polybdenum.com/2022/07/24/fixing-the-next-thousand-deadlocks-why-buffered-streams-are-broken-and-how-to-make-them-safer.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-25 19:41"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何修复和预防 buffered streams 死锁"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是一个手把手教你使用 Rust + Actix + mongoDB 来创建一个支持 GraphQL 的 web 服务, 里面有详尽的步骤和代码.原文链接https://dev.to/hackmamba/create-a-graphql-powered-project-management-endpoint-in-rust-and-mongodb-actix-web-version-3j1"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-25 19:41"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 actix 和 mongo 创建支持 GraphQL Rust 项目"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该项目的目标是模拟3D打印机，但任何类型的 stm32 控制器固件都可以工作。github地址https://github.com/nviennot/stm32-emulator"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-25 19:41"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"STM32 Emulator"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"LanguageTool 是一个开放源码的语法风格检查器。它可以纠正20多种语言，并免费使用，更多信息请访问languagetool.org. 他有一个公共API，你也可以在本地托管自己的服务器。LanguageTool-Rust 可以帮助你通过 Rust 代码轻松地与这些服务器进行通信!github 地址https://github.com/jeertmans/languagetool-rust--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-25 19:41"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"LanguageTool-Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"RaidProtect 是一个审核机器人，专注于安全/自动审核（但我想扩展它的功能）。该机器人自 2018 年以来一直存在，目前被近 230,000 台 Discord 服务器使用。但是，该机器人很长时间没有任何更新，当前版本已经无法维护。所以我决定完全用 Rust 重写机器人，并将这个版本作为开源发布。目标是重写现有功能，因为目前生产中的机器人使用旧版本的 Discord API，该版本将在 8 月底不再受支持。支持的主要功能是反垃圾邮件系统、阻止自我机器人的验证码和审核工具。该机器人的当前版本仅提供法语版本，但这个新版本将翻译成英语。使用的技术该机器人使用 Twilight 库与 Discord API 进行交互，并在结构上支持大量服务器。我选择使用 Redis 作为机器人缓存，使用 MongoDB 来存储持久数据（配置、审核日志等）。最终，目标是在集群中运行机器人以获得更好的弹性并允许零停机更新。有关项目架构的更多信息：https ://raidprotect.github.io/docs/architecture.htmlhttps://raidprotect.github.io/docs/architecture.html资金计划该机器人从一开始就完全免费（没有付费功能，不像许多 Discord 机器人），目前没有收入。拥有庞大的用户群，我计划打开一个 OpenCollective 页面以允许财务贡献并确保项目的未来。如果该项目筹集的资金超过了为基础设施提供资金所需的资金，那么最活跃的贡献者将获得奖励。有兴趣参与的可以加入开发专用的Discord服务器：https ://discord.gg/Z3ZWhs38dahttps://discord.gg/Z3ZWhs38da一些有用的链接：\nGitHub 仓库：https ://github.com/raidprotect/raidprotect\n文档：https ://raidprotect.github.io/docs/ （进行中）\n网站：https ://raidprotect.org/\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-24 11:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"征集贡献：RaidProtect，一个流行的用 Rust 编写的 Discord 审核机器人"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在这里，我们尝试用 Rust 编写一些网络安全工具，因为我们在网络安全领域没有足够的 Rust 社区所以这个项目可以用作新编码人员的示例，我们将重新编写小工具，例如tomnomnom hacks，完成后你会发现一篇关于如何编写它的简单博客文章GitHub 仓库：https://github.com/knassar702/hacks"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-24 11:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 用于网络安全"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"vSMTP v1.1.3 现在可用。vSMTP 是一个邮件传输代理 (MTA) - 完全用 Rust 编写 - 免费、快速且安全。除了 vSL（一种允许完全流量控制的消息传递脚本语言）之外，1.1.3 版现在还包括 SPF 和开放中继过滤器。但是 vSMTP 需要您的帮助。安全产品的设计需要一整套测试，包括最终用户。vSMTP 社区正在成长，我们很高兴将您列为早期采用者。不要犹豫，关注https://github.com/viridIT/vSMTP上的项目。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-24 11:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Announcing vSMTP 1.1.3"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Veloren 发布了0.13版本! 这个版本已经制作了5个月，我们有很多东西可以炫耀！如果你在7月23日格林尼治标准时间18:00之前读到这篇文章，一定要参加发布会。将有一个定制的海盗主题地图与大量的秘密等待发现(感谢@Hannibal)，所以不要错过它，一定要带上你的朋友一起！探索手工制作的丛林小岛，寻找沉没公爵夫人的珍宝！文章链接，https://veloren.net/release-0-13/Github 链接，https://github.com/veloren/veloren"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/veloren/veloren"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-23 20:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Veloren 0.13，一款开源多人角色扮演游戏，今天正式发布！"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个简单的 tui 来查看和控制 Docker 容器用rust构建，大量使用了 tui-rs & Bollard文章链接，https://www.reddit.com/r/rust/comments/w5v2qi/oxker_v010_docker_tui_app/Github 链接，https://github.com/mrjackwills/oxker/tree/v0.1.0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/mrjackwills/oxker/tree/v0.1.0"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-23 20:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Oxker v0.1.0 – Docker TUI app"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个高级库，提供一个强类型 DSL，它与官方的 Elasticsearch 查询 DSL 进行一对一的映射。文章链接，https://www.reddit.com/r/rust/comments/w5zopz/strongly_typed_elasticsearch_dsl_written_in_rust/Github 链接，https://github.com/vinted/elasticsearch-dsl-rshttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/vinted/elasticsearch-dsl-rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-23 20:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用 Rust 编写的强类型 Elasticsearch DSL v0.4"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"huangjj27"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"张老师对 Carbo 的动机很好奇：\n创造 Carbon 的动机是什么？\nCarbon 到底想要解决什么问题呢？这些问题是 Rust 无法解决的吗？\nCarbon 如何解决这些问题？\nCarbon 的未来将走向何处？\n并且将他自己对这些问题的思考写在了 觉学社公众号上https://mp.weixin.qq.com/s/lrot3Szp79123ifzHVN87w"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-23 00:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Carbon vs Rust ｜ 你想要了解的"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"huangjj27"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"《Rust实战》通过探索多种系统编程概念和技术引入Rust编程语言，通过深入研究计算机的工作原理来学习Rust。本书帮助读者如何用Rust扩展其他应用程序，结合十多个现实生活中的用例给出一些Rust编程技巧，让读者了解Rust语法，了解Rust在实际用例中的运用，最终具备用Rust解决实际问题的能力。更多资讯： https://mp.weixin.qq.com/s/jXs12Haiir-5HMjHBeuqyQ"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-23 00:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"《Rust实战》首发"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我最近一直在用Rust解析大量的json，这里有一些细节我想和大家分享。\n与有标签的unions相比，无标签的unions解析起来非常慢。如果你关心性能，最好是有一个可以区分unions变量的属性。\n你可以通过解析到一个使用&str字段的数据结构来避免对字符串的分配。\n有一种类型serde_json::Number可以避免转换为数字格式，直到你真正想要花费处理时间。\n如果你使用标签union来区分json属性值，你不需要使用枚举变量的名称，你可以使用:\n该帖子下还有其他网友分享的一些细节。Reddit: https://libreddit.spike.codes/r/rust/comments/w3q1oq/things_i_wish_i_had_known_about_serde_json/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://libreddit.spike.codes/r/rust/comments/w3q1oq/things_i_wish_i_had_known_about_serde_json/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-22 00:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"关于serde_json我希望大家都能知道这些事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"LibAFL为你提供了许多现成的模糊器的优点，同时可以完全定制。目前的一些亮点功能包括:\n快速：我们在编译时做了所有能做的事情，使运行时的开销最小。用户在手机上的frida-mode中达到12万次/秒的执行率（使用所有内核）。\n可扩展性：低水平消息传递，简称LLMP，允许LibAFL在核心上几乎线性地扩展，并通过TCP传输到多台机器。\n可适应性强：你可以替换LibAFL的每个部分。例如，BytesInput只是一个潜在的表单输入：可以随意添加一个基于AST的输入，用于结构化的模糊测试，以及更多。\n多平台：LibAFL被证实可以在Windows、MacOS、Linux和Android的x86_64和arch64上工作。LibAFL可以在no_std模式下构建，将LibAFL注入到不知名的目标中，如嵌入式设备和管理程序。\n你自己的target：我们支持纯二进制模式，如Frida-Mode，以及基于资源的仪器化的多个编译通道。当然，添加自定义的仪器化后端也很容易。\nGithub: https://github.com/AFLplusplus/LibAFL/releases/tag/0.8.0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/AFLplusplus/LibAFL/releases/tag/0.8.0"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-22 00:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"LibAFL 一个模糊器发布0.8.0版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Poem 是一个用 Rust 编写的 Web 框架。它提供了简洁的 API，并且功能丰富，超出了您通常在微框架中找到的功能。它可以将自身与 Web 框架的许多主要功能解耦，从而为开发人员提供尽可能多的灵活性。简而言之，Poem 主打的就是简洁，几行即可启动一个 websocket 聊天室：在网络浏览器中打开 http://127.0.0.1:3000/ 会显示一个表单，要求您设置用户名并加入聊天组。这样做之后，您将能够通过 WebSockets 将消息发送到单个聊天频道。目前根据一个综合基准测试，比较了几个 Web 框架，Poem 在 64 线程上的表现优于 Warp、Axum 和 Salvo，但它的得分领先于 Gotham、Actix 和 Rocket。也就是说，当考虑到所有语言的框架时，它仍然在基准测试结果的前 20% 中。https://web-frameworks-benchmark.netlify.app/result?asc=0&l=rust&order_by=level512\nhttps://tech.marksblogg.com/poem-rust-web-framework.html\nrepo : https://github.com/poem-web/poem\n引用 Rust Book 中的话：“错误是软件生活中的一个事实”。这篇文章讲更细致地讨论如何处理它们。很值得一读\nhttps://www.shuttle.rs/blog/2022/06/30/error-handling\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-20 22:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"今年 4 月的时候，作者根据当时的编译器的情况写了一篇有关 rust 编译速度的文章 https://nnethercote.github.io/2022/04/12/how-to-speed-up-the-rust-compiler-in-april-2022.html 三个月过去后，rustc 又有一些新的变化。平均来看编译时间平均缩短了 5% 左右，特别的，得益于 windows 下 PGO 机制的实现，windows用户有约 12.5% 的编译时间缩短。ReadMore: https://nnethercote.github.io/2022/07/20/how-to-speed-up-the-rust-compiler-in-july-2022.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://nnethercote.github.io/2022/07/20/how-to-speed-up-the-rust-compiler-in-july-2022.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-20 10:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rustc 为加速编译所做的努力"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 为我们提供了一个非常复杂的模块系统，允许我们将 crate 巧妙地拆分为任意小的类型和函数的子模块，但有时也很难在保持手头项目的整体结构比较科学，借助这个工具可以查看整个项目的依赖关系：ReadMore: https://github.com/regexident/cargo-modules"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/regexident/cargo-modules"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-20 10:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo-module 一个展示 cargo 依赖树的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"ReadMore: https://rust-analyzer.github.io/thisweek/2022/07/18/changelog-138.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://rust-analyzer.github.io/thisweek/2022/07/18/changelog-138.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-20 10:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rust-analyzer 更新日志 #138"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"官网通告: 1.62. pre-release 已经可以测试了, 大家可以提前安装尝鲜测试了.1.62.1 Release note原文链接https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1621-2022-07-19"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-18 19:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 1.62.1 pre-release 测试"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者记录了他如何参与  Rust Analyzer 的代码贡献的整个过程, 有同样的想法的小伙伴可以参考一下.原文链接https://dorianlistens.com/2022/07/improving-extract-function-in-rust-analyzer/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-18 19:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"改进  Rust Analyzer 的 Extract Function功能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"nvim-oxi 提供了对 Neovim 文本编辑器所公开的 rich API的一级 Rust 绑定。该项目主要面向插件作者.原文链接https://github.com/noib3/nvim-oxi"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-18 19:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"nvim-oxi: Neoviom API Rust binding"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Shuttle 是Rust的一个 serverless 平台，它使得部署你的web应用非常容易。Shuttle 是为生产,可靠性和性能而打造:\n使用 注解 达到零配置支持\n通过 Infrastructure-From-Code 自动提供资源(数据库、缓存、子域等)\n主流 Rust 框架一级支持(Rocket, Axum, Tide和Tower)\n可伸缩的托管(可选的自托管)\ngithub地址https://github.com/shuttle-hq/shuttle--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-18 19:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"shuttle: 一键部署 Rust 程序"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 作为第二语言被引入 Linux 内核，虽然目前是实验性质，但对每一个 Rustaceans 来说都是一件值得关注的大事。本文通过编写一个简单的字符设备驱动，带领我们了解如何通过 Rust 为 Linux 编写内核模块。文章地址：https://mp.weixin.qq.com/s/m2eZ0lEzQHjrNVC6YCC_IA"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-17 20:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用Rust写Linux内核"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"可能是迄今为止最大的更新。此版本增加了 12 个新练习，对现有练习进行了大量小改进，重新安排了大部分练习并删除了一些不适合此项目的练习。未来可能为智能指针提供更好的练习。详细更新日志：https://github.com/rust-lang/rustlings/blob/main/CHANGELOG.md#500-2022-07-16"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-17 20:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rustlings 5.0.0 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"终端文件浏览器，是 cd+ls 的快速替代方案。它只做一件事：使用 TUI 高效地导航到文件夹，然后在退出时打印该文件夹路径。GitHub：https://github.com/mgunyho/tere"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-17 20:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"tere：终端文件浏览"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"跨平台键盘定制。这是一个适用于 Linux 和 Windows 的软件键盘重映射器。功能概述：\n跨平台宜人的配置文件。\n多层按键功能。\n高级按键定制。\n设计文档：https://github.com/jtroo/kanata/blob/main/docs/design.mdGitHub：https://github.com/jtroo/kanata"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-17 20:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"kanata：键盘定制"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 写的解释型、动态类型、多线程编程语言。特点包括：\n多种数据类型：字符、整数、浮点数、字符串、数组、哈希表、字节和缓冲区。\n算术和逻辑运算。\n变量和常量。\n控制和循环结构。\n函数和 Lambda 表达式。\n线程和多线程。\nShell 运算符用于在语言语句中运行 shell 命令。\n一些基本的内置功能。\n迭代器（伪迭代器）。\n字节码生成、序列化和加载。\nGitHub：https://github.com/Narasimha1997/boson-lang"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-17 20:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"boson-lang：用Rust写个语言"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"查找可能未使用的已启用 feature 标记并移除它们。使用步骤：\n分析启用的未使用 feature：unused-features analyze\n生成 HTML 报告（可选）：unused-features build-report --input \"C:/some_path/report.json\"\n应用删除建议：unused-features prune --input \"C:/some_path/report.json\"\nGitHub：https://github.com/TimonPost/cargo-unused-features"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-17 20:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo-unused-features：移除启用未用的feature"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"WhitePool 是 Rust+Tokio 的轻量级通用池库，专注于简单、性能和稳固的灾难恢复。使用示例：GitHub：https://github.com/Rustixir/whitepool"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-17 20:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"whitepool：通用池库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"经常有人在Rust Discord的#gui-and-ui频道上问：“对于我的应用程序来说，最好的 UI 工具包是什么？”不幸的是，这个问题仍然没有明确的答案。一般来说，最重要的竞争者是 egui、Iced 和 Druid。这篇文章是 Rust 2020: GUI and community的续篇。作者Raph Levien希望对当前的事态进行一个清晰的调查，并就如何改进它提出建议。它还包括迄今为止 Druid 的一些教训。https://raphlinus.github.io/rust/druid/2019/10/31/rust-2020.html博客链接，https://raphlinus.github.io/rust/gui/2022/07/15/next-dozen-guis.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://raphlinus.github.io/rust/gui/2022/07/15/next-dozen-guis.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-16 23:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Raph Levien 对 Rust GUI 的建议"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 1.64 支持 Nintendo Switch，编译目标名为：aarch64-nintendo-switch-freestanding。Github PR#88991https://github.com/rust-lang/rust/pull/88991#issuecomment-1184905543"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-16 23:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 1.64 支持 Nintendo Switch"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"目前，通过 Sourcegraph 可以搜索87k+的 Rust crates 及其所有版本。https://sourcegraph.com/searchhttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-16 23:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Sourcegraph 搜索 Rust crates"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者将 dfdx 比作用 100% Rust 实现的 pytorch/tensorflow 。下面是一些设计上的目标：\n易于使用的接口。\n易于理解/维护内部结构。\n尽量在编译时进行检查。\n最大限度地提高性能。\n保持内部实现灵活度。\n尽可能减少 unsafe 使用。\n尽可能减少内部代码中的 RC 和 RefCell 。\nGitHub - dfdx: https://github.com/coreylowman/dfdxCrate - dfdx: https://crates.io/crates/dfdx"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://crates.io/crates/dfdx"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-14 23:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Crate - dfdx 使用常量泛型构造的深度学习库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在之前的文章中，Amos 曾经讨论过为什么 Rust 构建如此缓慢，介绍了 Cargo 的工作机制以及优化编译速度的一些技巧。这篇文章则试图解决：当你尽可能优化构建之后，构建速度比理想情况还要慢很多，该如何分析/处理这种奇怪的情况？When rustc explodes: https://fasterthanli.me/articles/when-rustc-explodes"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://fasterthanli.me/articles/when-rustc-explodes"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-14 23:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"文章 - 如何分析编译器以解释指数级的构建时间"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 451: https://this-week-in-rust.org/blog/2022/07/13/this-week-in-rust-451/https://github.com/PsiACE"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2022/07/13/this-week-in-rust-451/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-14 23:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week in Rust 451"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Aidan Hobson Sayers 和 Ashley Williams 将离开核心团队。他们于 2018 年加入核心团队，非常感谢他们两位的贡献！ReadMore:https://blog.rust-lang.org/2022/07/12/changes-in-the-core-team.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.rust-lang.org/2022/07/12/changes-in-the-core-team.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-14 00:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Core Team的变化"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"如果安装了以前版本的 rustup，那么升级 rustup 1.25.1 就会很简单Rustup 还会在正常工具链更新结束时更新自己：新增功能详情见链接ReadMore:https://blog.rust-lang.org/2022/07/12/Rustup-1.25.1.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.rust-lang.org/2022/07/12/Rustup-1.25.1.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-14 00:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rustup 1.25.1"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\n没有 null\n没有合适的 OOP\n内存安全对于有能力的人不是问题\n使用技术谋取政治利益是对技术的歪曲(https://twitter.com/rustlang/status/1267519582505512960 )\n关于发布者的这个问题，评论区给予了很有效的反击，详情看redditReadMore:https://www.reddit.com/r/rust/comments/vy5t5d/why_ill_never_use_rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/vy5t5d/why_ill_never_use_rust/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-14 00:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"为什么我永远不会使用 Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"GCC Front-End For Rust（也称为 GCC Rust）是 Rust 语言在 GCC 之上的一个完整替代性实现，目标是成为 GNU 工具链的完全上游。由于这是一个前端项目，该编译器将获得对所有 GCC 内部中端优化通道的完全访问权，这与 LLVM 不同。这个编译器的用户可以使用熟悉的 -O2 标志来调整 GCC 的优化器。从 2020 年 11 月开始，开发者 Philip Herron 就已全职从事 GCC Rust 的开发工作，在他和整个社区的共同努力下，GCC 指导委员会日前正式宣布，接受 GCC Rust 对 GCC 的贡献，GCC Rust 将被纳入 GCC 主线代码库，由 GCC 提供 Rust 编程语言支持。GCC mailing listhttps://gcc.gnu.org/pipermail/gcc/2022-July/239057.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-12 16:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"GCC Rust 将被纳入 GCC 主线代码库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"1.25.0 中最大的变化之一是在 Windows 安装上提供了自动安装 Visual Studio 2022 编译器的新功能，可以简化在 Windows 上进行开发的入门过程。1.25.0 的第二个重要变化是合并了一些关注 Rustup 启动性能的 PR。尽管对许多人来说似乎并不那么重要，但 Rustup 的启动时间对于构建涉及大量 crate 的构建所需时间有很大的影响。详细信息可以查看更新日志https://github.com/rust-lang/rustup/blob/stable/CHANGELOG.md"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-12 16:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rustup 1.25.0 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"大多数 JVM 开发人员都熟悉 VisualVM 和 EclipseMat，它们提供了大量功能来深入了解堆转储的内容，以帮助您非常准确地定位问题。然而，在分析大文件时，它们往往非常消耗内存并且速度很慢，因此 Arnaud Gourlay 创建了一个项目，该项目是一个用 Rust 编写的 CLI，它以流方式处理转储文件，通过只执行一次而不在主机上存储中间结果来权衡速度，从而降低了分析的深度。https://github.com/agourlay/hprof-slurp如果您对性能分析或 JVM 感兴趣，不烦关注一下该作者的系列文章。原文链接https://agourlay.github.io/blog/rust-performance-retrospective-part1/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-12 16:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何在 Rust 中更快地创建一个简单的 JVM 堆转储分析器 - part1"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust-Edu，一个致力于 Rust 教育的组织，于 7 月 11 日成立。该组织由一群希望取得进展，并为 Rust 教育提供关注和支持的学者和社区成员组成。该组织致力于与 Rust 社区合作，为学生和教师提供工具和教育支持，带来更好的学习方式。他们的三大目标是：如果您对此有兴趣，不妨前往官网了解更加详细的内容，甚至贡献自己的一份力量。https://rust-edu.org/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-12 16:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust-Edu 成立"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是一个嵌入式入门教学视频, 不需要任何硬件或复杂的设置.在这个视频中，作者展示了如何通过 ARM Cortex M0+ 系列处理器 来学习嵌入式 Rust.油管视频https://www.youtube.com/watch?v=_sYnzFe9A6E"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-11 19:14"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"嵌入式 Rust 学习"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"“This Month in Rust OSDev” 会定期概述Rust操作系统开发生态系统的显著变化, 六月份涉及的项目如下:\nlinked-list-allocator\nmultiboot2\nuefi-rs\nbootloader\nx86_64\ncargo-xbuild\ngoogle/gpt-disk-rs\nvinc/moros\nphil-opp/blog_os\n原文链接https://rust-osdev.com/this-month/2022-06/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-11 19:14"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Month in Rust OSDev: 六月份"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"lyon 提供了许多与矢量图形相关的功能，并使用 polygon tessellation 来渲染它们, 目前正式发布 1.0 版本.同时, 1.0 也增加了一些新的功能,下面为一个新特性的示例:渲染的图形如下:原文链接https://nical.github.io/posts/lyon-1-0.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-11 19:14"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"lyon: 1.0 版本发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"fe2o3-amqp 是一个基于 serde 和 tokio 的AMQP 1.0协议的一个完整实现。github 地址https://github.com/minghuaw/fe2o3-amqp"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-11 19:14"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"fe2o3-amqp: AMQP 1.0的 Rust 版本实现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是一个油管视频,介绍如何使用axum 进行 web 开发.油管视频https://www.youtube.com/watch?v=QtKO9f_iPhI&list=PL8lUUBadSMNB5h1KWPcyOM6WFimE4hNdv--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-11 19:14"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"axum web 框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我试图设计一个既能循环精确又能多线程的控制台仿真器架构。Rust 的 Async await 特性及其生态系统是一个很大的启发。https://www.n0mandevelopblog.com/posts/cycle-accurate-multithreaded-console-emulator/page/我的想法是将共享内存区域与设备组件分离成一个中央共享内存总线参与者，该参与者将接受读写请求并在正确的时钟周期内提交它们。这样，组件可以异步运行，然后等待它们需要来自其他组件的某些数据可用。我最初在 /EmuDev 上发布了这篇文章https://www.reddit.com/r/EmuDev/comments/vtuwj8/cycle_accurate_multithreaded_console_emulator/?utm_source=share&utm_medium=web2x&context=3"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-10 17:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"理论上的多线程仿真器架构"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本周早些时候，我分享了我的项目 Trane ( https://github.com/trane-project/trane )，以及用于学习新技能的自动化系统。https://github.com/trane-project/trane-music有一些课程，但我认为有一个自包含的课程来展示 Trane 会很好。鉴于 Trane 是我的第一个 Rust 项目，我认为用 Trane 来增加 rustlings ( https://github.com/rust-lang/rustlings/ ) 会很好。结果是 trane-rustlings ( https://github.com/trane-project/trane-rustlings )。本课程是如何使用特灵轻松扩充现有教育材料的一个示例。本课程中的练习只是按名称引用了沙沙的练习。通过按照特灵介绍的顺序解决沙沙声练习，您可以逐步掌握所有这些练习，同时在进行过程中加强它们。如果您发现您被多次展示相同的练习（特别是在开始时），那么您可以完成您的学习课程并稍后继续有时间吸收材料或将练习添加到黑名单中，这样它就不会再显示了."},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-10 17:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"trane-rustlings：与 Trane（和 rustlings）一起学习 Rust。"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我想利用一些非默认的 clippy lint，但我厌倦了为每个 bin/example/lib 启用它们的麻烦，为工作区中的每个 crate 重复。有一段时间我一直在添加运行我喜欢的所有 lint 的 shell 脚本（例如--warn clippy::cast_possible_truncation），但我也希望能够从 vscode 中运行我的 lint 选择。所以我写了一个小货运扩展来帮助我：cargo-craky。它搜索Cranky.toml包含要允许/警告/拒绝的 lints 的配置文件，然后在启用这些 lints 的情况下运行 clippy。它可以在命令行和 vscode 中按预期工作。https://github.com/ericseppanen/cargo-cranky到目前为止它非常基本，但它对我来说已经非常有用了。希望你也觉得它有帮助！"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-10 17:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo-craky：轻松配置 Clippy lints"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Tauri是什么Tauri 是一个应用程序构建工具包，可让您使用 Web 技术为所有主流桌面操作系统构建软件。核心库是用 Rust 编写的，用户界面几乎可以使用任何前端框架编写。它包括一个可选且tree-shakeable的 JavaScript API，用于方便访问地层系统，一个带有代码签名和工件验证的桌面二进制打包工具，一个安全更新程序，可让您的用户保持最新版本，一个广泛的插件系统，以及对操作系统级集成的支持，例如通知和应用程序托盘。Tauri 既易于使用，又易于扩展。对于那些刚接触 Rust 编程语言的人，Tauri 提供了一个舒适的学习环境，将与您一起成长。一旦你安装了 Rust，创建你的第一个应用程序只是运行 create-tauri-app。但是，如果您希望保持 100% Rust 的安全和舒适，您根本不必使用 Node.js。文章链接，https://tauri.app/blog/tauri_1_0/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://tauri.app/blog/tauri_1_0/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-09 23:12"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Tauri 1.0 Release"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作为一名活跃的软件工程师，我年龄越大，就越不接受我的软件质量差。我认为我们所有的白胡子都知道软件崩溃通常是开发人员对下述选项的一些选择导致的：\n技术平台——一些技术本质上比其他技术风险更大\n开发实践——诸如测试驱动开发和结对编程之类的东西（不要争论结对编程；我们以后可以讨论这个问题；我敢打赌，我在积极结对上花费的时间比你多）明显提高了代码质量\n工程哲学——Erlang 是一个绝妙的证明，通过拥抱失败，你可以开发出更可靠的软件\n但是，当您未能解决上述任何问题时，您最终将面临今天的软件质量危机——崩溃、膨胀等等。而且，老实说，我已经厌倦了。文章链接，https://fuzzyblog.io/blog/rust/2022/07/08/rust-alternatives-to-textmate-2-the-agony-of-despair.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://fuzzyblog.io/blog/rust/2022/07/08/rust-alternatives-to-textmate-2-the-agony-of-despair.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-09 23:12"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"找一个 Rust 编辑器替换 TextMate 2"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"快速介绍：Robyn 是一个快速且可扩展的异步 Python Web 服务器，具有 rust 运行时。它最近发布了 v0.17.0，其中引入了一个名为“const requests”的功能。常量请求消除了获取和释放 GIL 的需要，并使响应速度比以往任何时候都快。Github 链接，https://github.com/sansyrox/robyn文章链接，https://www.reddit.com/r/rust/comments/vumnr2/robyn_v0170_released_introducing_const_requests/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/vumnr2/robyn_v0170_released_introducing_const_requests/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-09 23:12"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Robyn v0.17.0 Released"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"huangjj27"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这两年 Rust 正在快速占领前端基础设施领域，Webpack、Babel、Prettier 这些热门工具都已有了 Rust 替代方案，且性能有着 10～100 倍的提升。亚马逊和 FaceBook 都认可它是其系统中 C/C ++ 的最佳替代品，微软更是认为 Rust 作为工业级的开发语言，在云的基础设施领域应该是首选。Figma、Dropbox 也已经在客户端中使用 Rust。甚至有说法：任何能够用 Rust 实现的应用系统，最终都必将用 Rust 实现。原文： https://mp.weixin.qq.com/s/JOnz0IVWRm_bYWReACyWAg"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-08 23:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"前端研发的新基础设施"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"huangjj27"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"（转自 Rust 视界）lunatic 是类似于 erlang vm的 WASM 运行时，基于 Rust 实现原文：https://dev.to/serokell/functional-futures-lunatic-with-bernard-kolobara-4nifgithub: https://github.com/lunatic-solutions/lunatic"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-08 23:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"lunatic 创始人访谈"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一篇帖子，发帖人在 WSL2 上编译 helix-term 明显比在 Windows 上更快，具体的数据是 WSL2 Ubuntu 22.04 耗时数据是 41秒 ，而 Windows 则耗时 64秒。一些有趣的评论：绝对的。我现在使用WSL2作为我的主要开发环境，因为它的编译时间要快得多 EDIT: (我在Win11上)说实话，这很值得期待。Linux通过积极地缓存东西，使做大量的小文件操作变得便宜得多。这并不奇怪，Linux对小文件的操作是非常快的。例如，在Mac上，在Linux虚拟机中进行nodejs捆绑要比在原生系统上快得多（老式英特尔Mac，尽管我怀疑这一点在M1/M2中有所改变，因为这是关于操作系统，而不是硬件）。另外，windows比linux有更多的依赖性，这导致了更长的编译时间。Reddit: https://libreddit.spike.codes/r/rust/comments/vtc0fy/wsl2_faster_than_windows/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://libreddit.spike.codes/r/rust/comments/vtc0fy/wsl2_faster_than_windows/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-07 22:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"WSL2 比 Windows 更快？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这篇文章是探索基于Rust的网络框架系列的一部分。Poem是一个用Rust编写的网络框架。它提供了一个简洁的API，而且功能丰富，超出了你通常在微型框架中找到的功能。它做了很多工作，将自己与网络框架的许多主要功能解耦，以便给开发者提供尽可能多的灵活性。https://github.com/poem-web/poem我还没有找到它的主要开发者的全名，但这个人在网上的名字是Sunli，GitHub说这个人在中国。Poem的工作于去年8月开始。代码库包含48个示例项目，其中14个是针对OpenAPI的。该代码库包括32K行Rust代码，并且组织良好。一篇关于 Poem 框架的博客，另外补充一下博文提到的作者，作者在各大Rust中文交流群里应该都能找到，同时也是 async-graphql 的作者。https://github.com/async-graphql/async-graphql博文: https://tech.marksblogg.com/poem-rust-web-framework.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://tech.marksblogg.com/poem-rust-web-framework.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-07 22:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Poem 框架的极简指南"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 450: https://this-week-in-rust.org/blog/2022/07/06/this-week-in-rust-450/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2022/07/06/this-week-in-rust-450/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-07 22:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week in Rust 450"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"来自 Google Security Blog 的文章。安卓平台上代码的正确性是每个安卓版本的安全性、稳定性和质量的首要任务。C 和 C++ 中的内存安全错误仍然是最难解决的不正确性来源。我们投入了大量的精力和资源来检测、修复和缓解这类错误，这些努力有效地防止了大量的错误进入 Android 版本。然而，尽管有这些努力，内存安全漏洞仍然是稳定性问题的首要因素，并且一直占 Android 高严重度安全漏洞的 70% 左右。除了正在进行的和即将进行的改善内存漏洞检测的努力外，我们还在加紧努力从一开始就预防内存漏洞。内存安全语言是防止内存漏洞的最经济的手段。除了像 Kotlin 和 Java 这样的内存安全语言外，我们很高兴地宣布，安卓开源项目（AOSP）现在支持 Rust 编程语言来开发操作系统本身。更多请看原文：https://security.googleblog.com/2021/04/rust-in-android-platform.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://security.googleblog.com/2021/04/rust-in-android-platform.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-06 20:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Android 平台中的 Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"文章将如何使用 WASM 移植 Hugging Face Rust Tokenizers 服务器库，以创建用于 Web 浏览器的客户端 JS SDK。出于性能和/或安全原因，可以将服务器逻辑移植到客户端。 Rust 是用于此目的的优秀语言，因为它可以轻松编译为 WASM，这使我们能够“轻松”允许从 Web 浏览器到 Android 和 iOS 的客户端执行服务器端逻辑。更多请看原文：https://blog.mithrilsecurity.io/porting-tokenizers-to-wasm/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.mithrilsecurity.io/porting-tokenizers-to-wasm/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-06 20:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"将 Hugging Face Rust Tokenizers 移植到 WASM 的一些体会"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Microsoft  Threat Intelligence Center(MSTIC) 在分析检测到的用于删除 .key 文件的 Hive 勒索软件技术时发现了新变种。我们知道 Hive 丢弃了它的加密密钥文件，其中包含用于解密加密文件的加密密钥，并使用一致的命名模式。更多请看原文：https://www.microsoft.com/security/blog/2022/07/05/hive-ransomware-gets-upgrades-in-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.microsoft.com/security/blog/2022/07/05/hive-ransomware-gets-upgrades-in-rust/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-06 20:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Hive 勒索软件在 Rust 中获得升级"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"bstr 这个 crate 为 &[u8] 和 Vec<u8> 提供了扩展特性，可以将它们用作字节字符串，其中字节字符串通常是 UTF-8。这与标准库的 String 和 str 类型不同，它们不需要是有效的 UTF-8，但可以是完全或部分有效的 UTF-8。bstr 现在即将迎来 1.0 版本，现征求大家的意见、建议，项目地址：https://github.com/BurntSushi/bstr详情请看：https://github.com/BurntSushi/bstr/issues/40https://github.com/Jancd"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/BurntSushi/bstr/issues/40"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-06 20:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"bstr 1.0 征求意见"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"ReadMore: https://towardsdatascience.com/nine-rules-for-elegant-rust-library-apis-9b986a465247"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://towardsdatascience.com/nine-rules-for-elegant-rust-library-apis-9b986a465247"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-05 15:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"让 Rust 库更优美的九个建议"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust的发展速度很快，它的生态系统也是如此，因此有必要将项目的维护工作自动化。为此，社区已经建立了一些工具，它们将为你节省大量时间，让你的项目保持最新状态。ReadMore: https://kerkour.com/rust-projects-maintenance-and-supply-chain-security"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://kerkour.com/rust-projects-maintenance-and-supply-chain-security"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-05 15:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust项目的自动化维护和依赖安全"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"mold是现有Unix链接器的一个更快的直接替代者。LLVM lld是第二快的开源链接器，mold 比其链接速度快数倍。下面是GNU gold、LLVM lld和mold在模拟的8核16线程机器上连接主要大型程序的最终调试信息可执行文件的性能比较。在 rust 中使用可以添加下面的 RUSTFLAG 来启用，修改 ~/.cargo/configReadMore: https://github.com/rui314/mold"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rui314/mold"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-05 15:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"mold 一个比 llvm linker 快数倍的链接器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本教程使用 Diesel 和 PostgreSQL 建立一个Rust应用程序, 内容包括:\n设置 GraphQL模式\n设置 GraphQL服务器\n设置 Diesel\n处理查询\n处理值的修改\n原文链接https://www.section.io/engineering-education/rust-api-with-diesel-orm-and-postgresql/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-04 20:01"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Diesel 和 PostgreSQL 创建 Rust API"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Toshi 是一个类似 Elasticsearch 的全文搜索引擎. Toshi致力于成为Elasticsearch，就像Tantivy之于Lucene一样.github地址https://github.com/toshi-search/Toshi"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-04 20:01"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Toshi: Rust编写的全文搜索引擎"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个 axum 的简单指引\n简要的介绍了 axum 的一些特性, github 数据指标 等\n如何快速的启动 axum 服务\n性能测试对比\n原文链接https://tech.marksblogg.com/axum-rust-web-framework.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-04 20:01"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Axum 的一个简单入门指引"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Vosk 是一个语言识工具包, 支持 20 多种语言, 可以在 raspberry Pi, Android, iOS 上等脱机使用.vosk-rs 是他的一个 Rust binding.Vosk介绍地址https://alphacephei.com/vosk/index.zhgithub地址https://github.com/Bear-03/vosk-rs--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-04 20:01"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"vosk-rs: Vosk 的 Rust binding"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"是 memmap-rs 的 folk，前者已经 4 年没再更新。特性包括：\nfile-backend 内存映射\n匿名内存映射\n同步和异步 flush\ncopy-on-write 内存映射\n只读内存映射\n支持栈（Unix 上的 MAP_STACK）\n可执行内存映射\nGitHub：https://github.com/RazrFalcon/memmap2-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-03 23:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"memmap2-rs：用于内存映射IO的跨平台Rust API"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"对于为什么需要一个新的错误处理库，作者在文章中做了解释，主要是他们项目比较复杂，有一些额外的需求。\n如果 scope 发生了变化，鼓励用户提供新的错误类型，通常跨越模块边界（比如解析配置文件的 ConfigParseError 和文件读取的 IoError。\n能够在返回类型中使用这些错误类型，而无需处理困难的 From 逻辑。\n无需大量配置即可将任何数据附加到一个错误上，而不仅仅是类似字符串的类型，然后可以在处理错误时请求这些数据。\n文章：https://hash.dev/blog/announcing-error-stack视频：https://www.youtube.com/watch?v=g6WUHcyjsfc示例代码：https://github.com/letsgetrusty/error-stack-demoGitHub：https://github.com/hashintel/hash/tree/main/packages/libs/error-stack"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-03 23:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"error-stack：上下文感知的错误处理库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Dragonfly 镜像服务，提供对容器镜像的快速、安全和轻松的访问。nydus 项目在 RAFS 格式之上实现了一个内容可寻址文件系统，在容器启动速度、镜像空间和网络带宽效率以及数据完整性方面改进了当前的 OCI 镜像规范。Dragonfly 是一个基于 P2P 的智能镜像和文件分发系统。官网：https://nydus.dev/GitHub：https://github.com/dragonflyoss/image-service"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-03 23:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Image-service：Dragonfly镜像服务"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Dragan Rakita 前几周做了一个关于 Rust 的分享，想法是在十个主题中涵盖整个语言，并尝试提出什么是 rust，为什么要使用它，以及复杂性来自哪里。并且只占用人们一个小时的时间。这十个主题包括：https://twitter.com/rakitadragan\nRust 看起来很受人喜欢。自从 2016 年以来，Rust 每年都在 Stack Overflow 开发者调查中被评为「最受欢迎的编程语言」。考虑到 Rust v1.0 是 2015 年发布的，如果你是一个 Rust 新人，一定会觉得这很神奇。\n工具和生态很赞。Cargo——一个你期望从新一代语言中获得的工具。cargo run/build/fmt/clippy/doc 和 crates.io 统一了生态中的 Rust 项目。\n项目/代码组织做的很好。Rust 允许将一个包（项目）拆分为多个 crate（lib/binaries），并将一个 crate 拆分为模块（部分代码或文件/文件夹），以便可以在一个模块中引用另一个模块的内容。\n对抽象和数据类型很轻。它具有预期的原始类型和控制流。有 Struct/Enum/Tuple 等复杂类型，抽象在 Traits 上完成。Traits 很 nice，使用「孤儿规则」你不能用他们的代码破坏你的代码。\n枚举和模式匹配用途广泛且令人赞叹。枚举是标记的联合。模式匹配允许部分匹配复杂数据类型的值以进行条件分支或分解数据。\n具有内存安全。Rust 带来的新玩意儿。所有权让我们有垃圾回收的感觉，但是在编译时。\n引用和生命周期：生命周期是规则的副产品，引用始终需要有效并且所有权在编译时完成。它有一个陡峭的学习曲线，并且可能会变得繁杂。\n无惧并发和 async/await：所有权和生命周期消除了数据竞争。async/await 是 Rust 的绿色线程，它的运行时只是外部库，而且速度很快。\n具有函数式编程特性：闭包和迭代器是对语言很好的补充。\n泛型和卫生宏。\n一些小却能拯救你生活的特性：编译错误是上帝赐予的，也是 Rust 流行的主要原因之一。使用 ? 让错误传播更简单。\n如果你也正在准备一个关于 Rust 的分享，不妨作为参考。链接：https://twitter.com/rakitadragan/status/1543290604465045506"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-03 23:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"十个主题涵盖Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 语言服务器 (RLS) 已被弃用，取而代之的是 rust-analyzer。RLS 用户应该改用 rust-analyzer。RLS 将继续发布直到 Rust 1.64 版本 (2022-09-22)，之后将不再发布新版本。 此时间表可能会发生变化。如果你使用 VSCode，应该卸载 rust-lang.rust 扩展，并安装官方的 rust-lang.rust-analyzer 扩展。Rust 博客原文链接，https://blog.rust-lang.org/2022/07/01/RLS-deprecation.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.rust-lang.org/2022/07/01/RLS-deprecation.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-03 07:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RLS 被弃用，请用 rust-analyzer"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"gfx-rs 社区的目标是让 Rust 中的图形编程变得简单、快速和可靠。 我们的主要项目有：wgpu（https://github.com/gfx-rs/wgpu） 是一个可移植的图形 api。 它提供对 GPU 的安全、可访问和便携式访问。naga （https://github.com/gfx-rs/naga）在语言之间翻译着色器程序，包括 WGSL。 它还提供着色器验证和转换，确保在 GPU 上运行的用户代码安全高效。发布链接，https://gfx-rs.github.io/2022/06/30/release-0.13.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-03 07:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"wgpu v0.13 发布及测试征集"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这个视频试图弄清楚为什么 cargo crate 需要很长时间才能构建。 最终并没有做出有意义的改进，但探索了许多现有的有助于分析和补救的工具，以及每个工具的价值和缺点。Youtube链接，https://www.youtube.com/watch?v=pMiqRM5ooNwhttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.youtube.com/watch?v=pMiqRM5ooNw"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-03 07:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"【视频】让 Rust crate 编译得更快"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Fetch-Data 库可以快速检查本地数据目录，然后下载所需文件。它总是通过哈希验证本地文件和下载的文件。它可以轻松下载大小样本文件。例如，这里我们从 GitHub 下载一个基因组学文件（如果尚未下载）。然后我们打印现在本地文件的大小。它有如下特征\n线程安全——允许它与 Rust 的多线程测试框架一起使用。\n受到 Python 流行的Pooch和我们的 PySnpTools文件缓存模块的启发。\n使用异步运行时例如 Tokio（使用 ureq 通过阻塞 I/O 下载文件）。\n推荐使用方法：\n创建一个registry.txt包含以空格分隔的文件列表及其哈希值的文件。\n创建一个 FetchData 读取 registry.txt 文件的全局静态实例。赋予它：\n1、文件 URL 根目录；\n2、一个环境变量，告诉存储文件的本地数据目录\n3、qualifier, organization, and application 用于在未设置环境变量时创建本地数据目录。有关详细信息，请参阅 crate ProjectsDir。\n如下所示，定义一个公共 sample_file 函数，该函数接受一个文件名并返回一个 Result 包含下载文件的路径的函数\n您现在可以sample_file根据需要使用您的函数下载文件。\nhttps://docs.rs/fetch-data/latest/fetch_data/\n大家盼望已久的好消息终于来到了！Rust中文社区大会策划小组已经决定，将大会由线下转移至线上进行。时间为2022年7月30日（周六）或 31日（周日），具体提前通知。线上的具体形式还在策划和准备中，有最新消息，会即时通报给大家。2021年在活动行上售卖的门票已经做了退款处理。如果有谁还没收到退款的，请留言与我们联系。这次大会改为纯线上了，失去了线下大会的面基优势，但我们会努力通过扩展线上的形式，尽量达到大家互动的效果。敬请期待。\nhttps://rustcc.cn/article?id=48c7f26a-8014-402f-9638-ec0794a61ad4\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-07-02 00:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"rcore-os 开源社区组织的第 3 届 2022 年开源操作系统学习训练营即将开始了，本次训练营在学习体验上进行了新的尝试，使用了 github classroom, codespaces, issues 等功能，可以仅基于 net browser 进行全程在线 OS 学习与训练。第一阶段实验内容来自 2022 年春季本科 OS 课实验，第二阶段实验内容来自 OS 扩展实验和相关 OS 探索实验。欢迎感兴趣的朋友访问如下网址报名参加！2022 年开源操作系统训练营: https://github.com/LearningOS/rust-based-os-comp2022/blob/main/scheduling.md"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/LearningOS/rust-based-os-comp2022/blob/main/scheduling.md"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-30 23:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"第 3 届开源操作系统学习训练营（2022 年）"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"2022 年 7 月 Rust 新书预告：《Rust 实战》，是《Rust in Action》的中文翻译本。原作者  twitter@timClicks"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-30 23:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"7 月新书《Rust 实战》"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"lettre 是 一个用于 Rust 编程语言的电子邮件客户端。它允许从 Rust 应用程序发送电子邮件，侧重于易用性、安全默认设置和现代特性（如支持完全国际化）。现在许多项目都使用 lettre ，甚至包括 crates.io ！Announcing lettre 0.10: https://lettre.rs/post/lettre-0-10/crates.io - lettre: https://crates.io/crates/lettre"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://crates.io/crates/lettre"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-30 23:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"lettre 0.10 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 449: https://this-week-in-rust.org/blog/2022/06/29/this-week-in-rust-449/https://github.com/PsiACE"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2022/06/29/this-week-in-rust-449/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-30 23:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week in Rust 449"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"相比其他的 playgroud 最大的优点就是开箱即用，默认支持了超多的 crate，如果想临时体验一下某个库真的非常好用。所有特性：\n包含了最常用的1万个crate\n设置了 [profile.dev] 用于性能测试\n支持连接外网\n支持结果保存并再后面的运行中使用（类似 gitlab 的 artifacts）\nReadMore: https://www.rustexplorer.com/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-28 16:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RustExplorer  自带10000个crate的Rust在线运行环境"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"zig 是一门语言，cargo-zigbuild 使用了 ziglang 的链接器来简化跨平台编译的复杂度。安装后用法非常简单，如果没有 c 依赖，直接就可以生成对应平台的代码。ReadMore: https://github.com/messense/cargo-zigbuild"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-28 16:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo-zigbuild 使用 zigbuild 来简化跨平台编译"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"主要用于防止静态字符串在编译后的二进制直接暴漏，如果你有代码保护的需求，可以参考下。ReadMore: https://github.com/CasualX/obfstr"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-28 16:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"obfstr 一个编译时进行字符串混淆的库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"ReadMore: https://rust-analyzer.github.io/thisweek/2022/06/27/changelog-135.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-28 16:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rust-analyzer 更新日志 #135"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"ReadMore: https://intellij-rust.github.io/2022/06/27/changelog-173.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-28 16:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"intellij-rust 更新日志 #173"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"开放策略代理(Open Policy Agent, OPA)是一种开源的通用策略引擎，它支持跨整个环境中执行统一的上下文感知策略. OPA 是 云原生计算基金会(CNCF)的一个毕业项目。本文介绍了如何在 Rust 中使用 wasm 来执行 OPA 的策略.原文链接https://inspektor.cloud/blog/evaluating-open-policy-agent-in-rust-using-wasm/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-27 19:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 中使用 wasm 来执行 OPA 策略"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是在 Rust 中实现 swift 风格keypath的早期实验. 可以实现对任意嵌套字段的强类型引用. 目前它只是一个概念验证. 示例代码如下.原文链接http://www.cmyr.net/blog/keypaths.htmlkeypath github 地址https://github.com/cmyr/keypath"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-27 19:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"keypath: Rust中的 keypath 实现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者买了 Palmieri 的 <<Rust 从零到生产>> 这本书, 本文是学习笔记分享, 也算是对于该书的点评.原文链接https://bitemyapp.com/blog/notes-on-zero2prod-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-27 19:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"<<Rust 从零到生产>> 笔记"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"基于 generational arena 实现的 LRU 实现.原文链接https://github.com/arindas/generational-lru"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-27 19:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"generational-lru: 一个新的 LRU 实现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个介绍 Rc 和 RefCell 的视频,需要科学上网.油管视频https://www.youtube.com/watch?v=KYJ95TxEC18--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-06-27 19:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 中的 Rc和 RefCell"},"type":"text"}],"type":"title"}},]
