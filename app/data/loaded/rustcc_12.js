export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "CnosDB 2.0 是一款基于 Rust 研发的时间序列数据库（TSDB），具有高性能、高压缩比、高可用的特点，可广泛应用于 IoT 监控、实时分析等场景。CnosDB 2.0 致力于解决时间线膨胀问题，具备超大规模时间序列支持以及更好的生态特性，且实现了分布式云原生。2022 年 3 月，CnosDB 2.0 在 GitHub 上开源了源码，并持续构建系统；2022 年 10 月 24 日，CnosDB 2.0 版正式发布；2022 年 11 月 9 日 19:00，CnosDB 2.0 将通过产品发布会，正式发布第一个 Release 版本。CnosDB 社区发起人 Harbour 还将知无不言分享 CnosDB 的整体设计思路，内容涵盖:\n存算分离，时间序列膨胀支持与横 / 纵向扩展；\n兼顾性能与成本，高性能 IO，Run-to-Completion 调度模型，支持使用对象存储进行分级存储；\n可选压缩算法，在用户可选择的情况下实现降精度的有损压缩。\n\n使用 Apache Arrow 及 DataFusion 实现查询引擎；\n支持查询引擎矢量化的执行，执行复杂的查询语句；\n支持标准 SQL，支持丰富的聚合查询及算子。\n\n面向用户需求实现分布式系统可调节一致性，实现反熵机制；\n在云原生环境下实现数据库高可用、低成本、高性能与生态兼容。\nReadMore:https://mp.weixin.qq.com/s/5pl3zctvNh-4XDAuemj10w" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://mp.weixin.qq.com/s/5pl3zctvNh-4XDAuemj10w" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-11-02 22:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "CnosDB 2.0 发布预告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n驱动程序支持\n支持 EXISTS, ALL, ANY, SOME\n支持 ON CONFLICT WHERE\n更改 cond_where 语义\n...\nReadMore:https://www.sea-ql.org/blog/2022-10-31-whats-new-in-seaquery-0.27.0/#drivers-support" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.sea-ql.org/blog/2022-10-31-whats-new-in-seaquery-0.27.0/#drivers-support" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-11-02 22:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SeaQuery 0.27.0 的新功能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n修复 fmaddsub\n修复/simd 位掩码\n修复/simd 选择位掩码\n为内联汇编添加缺少的寄存器类转换\nBump Github actions\n删除不适用的 rustc 补丁\n改善安装文档\n修复 gcc 构建说明\nReadMore:https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-17" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-17" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-11-02 22:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustc_codegen_gcc 进度报告 #17" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "tokio 官方团队近日发布了 async-backtrace 的初个版本，旨在让开发者能够高效地追踪应用中异步任务的状态。使用步骤如下：需要注意的是，async-backtrace 才刚刚起步，如果遇到任何问题，欢迎大家在 github issue 上进行反馈https://github.com/tokio-rs/tokio-metrics/issues\n仓库地址\n原文链接\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-11-01 19:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-backtrace 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者 stencillogic 近日发布了使用纯 rust 实现的一个任意精度的浮点数库 astro-float，采用了很多广泛使用的算法，例如 Toom-3，Schönhage–Strassen 等大数乘法。https://github.com/stencillogic/astro-float此类完全使用 Rust 实现的浮点数运算库还有 ibig、num-bigint，相比于 rug 这类对于 GMP 的绑定库，它们最大的好处是完全用 Rust 实现，不依赖 std，但是在性能上仍有差距。https://github.com/tczajka/ibig-rs更详细的 benchmark 结果可以参考以下文章：\nbigint benchmark\nastro-float benchmark\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-11-01 19:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "astro-float：一个任意精度的浮点数库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Ironfish 是一款功能丰富的合成器，该example crate 展示了 Makepad 框架的一些功能。makepad 应该是目前最漂亮最快的Rust UI kit\n原文链接\nironfish demo 的演示链接\nironfish 的 github 地址\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-31 19:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Makepad Framework 发布第一个完整示例应用程序 Ironfish" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "arbitrary 库主要提供了 Arbitrary 以及相关功能, 他可以从任意的非结构化的输入生成结构化的数据.通常情况下, 他可以配合类似 cargo-fuzz 等库进行 fuzz 测试, 但是本文展示了另外一个非常实用的用法:领域模型和数据库实体之间的转换方法测试, 可以省去大量的手写代码测试.例子如下:\n原文链接\narbitrary github 地址\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-31 19:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中使用 arbitrary 来做特性测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对于 Linux 的发行版本, 由于大部分的程序是由 C 编写的,所以是天然的比较容易打包 C 程序和相关库的.但是对于其他语言来说, 由于每个语言都有自己的依赖管理等, 所以导致打包其他语言的程序一直是一个问题.本文讨论了 Fedora 在打包 Rust 应用时候遇到的一些问题.原文链接https://lwn.net/SubscriberLink/912202/79e7892b07f9350a/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-31 19:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fedora 打包 rust 应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "OpenSSL将在 11 月 1 日披露一个新的严重漏洞并发布补丁版本。为了保护您的 Rust 程序，您需要做的就是更新系统范围内的 OpenSSL 安装。这是因为opensslcrate可以通过以下两种方式之一获取 OpenSSL：使用 OpenSSL 的系统范围安装。在这种情况下，更新系统范围的 OpenSSL 可以解决问题。捆绑自己的 OpenSSL 并静态链接。如果vendored启用该功能，就会发生这种情况。在这种情况下，openssl板条箱使用不受此漏洞影响的 OpenSSL 1.1.x。应该注意的是，静态链接 C 代码并不是一个好的安全实践。如果捆绑版本受到影响（除非您使用的是cargo auditable." }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-30 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何修补 Rust 中即将出现的 OpenSSL 漏洞" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好！这是我长期以来一直在考虑构建的东西，我终于学会了 Rust 并决定尝试一下。这是一个具有一些独特功能的键值数据库（更多详细信息可以在自述文件中找到）。它仍处于非常早期的阶段。我想得到社区的反馈。请随时与我联系。Github - https://github.com/segment-dev/segment" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-30 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Segment - 用 Rust 编写的新键值数据库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们刚刚发布了一个重要且令人兴奋的 Zellij 版本——Rust的终端工作区和多路复用器。我个人在这个版本上工作了很多，并且可以愉快地证明 Rust 的 KDL 生态系统的质量。如果您正在考虑使用新的配置语言，请尝试一下。所以事不宜迟 - 0.32.0 中有什么新功能？\n\n我们所有的配置/布局/主题都从 YAML 转移到了 KDL。这些将自动为您转换。\n\n\n介绍命令窗格，查看它们：zellij run --floating -- ls -l\n\n\n新布局系统\n\n\n通过 CLI 向 Zellij 发送命令\n\n我们所有的配置/布局/主题都从 YAML 转移到了 KDL。这些将自动为您转换。介绍命令窗格，查看它们：zellij run --floating -- ls -l新布局系统通过 CLI 向 Zellij 发送命令有关更多详细信息和示例，请查看博客文章：https://zellij.dev/news/config-command-layouts/或直接查看发布：https ://github.com/zellij-org/zellij/releases /tag/v0.32.0我们还更新了所有新功能的文档：https ://zellij.dev/documentation/introduction.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-30 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Zellij 0.32.0 发布：YAML => KDL、命令窗格、通过 CLI 执行的操作和新的布局系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "今天刚刚发布了这个。这是一个建立在Rust中的文件搜索库，用于递归地搜索给定的函数输入。这实际上是非常快的，它只花了大约1秒钟就得到了我整个系统中大约40万个javascript文件的列表。文章链接，https://www.reddit.com/r/rust/comments/ygdfay/blazingly_fast_file_search_library_built_in_rust/Github 链接，https://github.com/ParthJadhav/rust_search" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ParthJadhav/rust_search" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-29 19:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust构建的快速的文件搜索库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好在过去的几周里，我一直在研究这个小原型，它已经达到了我可以开始向你展示它的状态！这仍然不稳定，也没有完成。希望大家试用并提出意见和建设性的批评 :)文章链接，https://www.reddit.com/r/rust/comments/ygcb4d/introducing_comet_an_isomorphic_reactive_web/Github 链接，https://github.com/Champii/Comet" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Champii/Comet" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-29 19:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Comet：Rust+Wasm中的反应型网络框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用Rust编写的TypeScript类型检查器。文章链接，https://www.reddit.com/r/rust/comments/ygc5vv/i_decided_to_use_rust_instead_of_go_for_my_new/Github 链接，https://github.com/dudykr/stchttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/dudykr/stc" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-29 19:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "开源的新TypeScript类型检查器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "hyper将发布v1.0.0-rc1版本，算是喜大普奔了。Blog: https://seanmonstar.com/post/699184177097179136/hyper-v100-rc1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://seanmonstar.com/post/699184177097179136/hyper-v100-rc1" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-27 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "hyper v1.0.0 Release Candidate 1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个新闻需要结合前几天reddit上的一个帖子一起看，好几天前的了，懒得翻，简单说一下，大概是某个Rust用户发现最近的编译项目速度比之前明显快了很多，查了一下最近合并的PR，发现有一个和LTO（ link-time optimization）相关的一个PR合并之后编译速度明显提升。本文算是对这个事件的一个延伸，当然不止这一个合并，还提到了最近几个月来在编译速度上做出的一些工作。感兴趣的可以看一看原文。Blog: https://nnethercote.github.io/2022/10/27/how-to-speed-up-the-rust-compiler-in-october-2022.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://nnethercote.github.io/2022/10/27/how-to-speed-up-the-rust-compiler-in-october-2022.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-27 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2022年10月是如何加快Rust编译器的速度" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "可以理解成rayon的异步版本。https://crates.io/crates/rayonGithub: https://github.com/mkawalec/deluge" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mkawalec/deluge" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-27 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "新的异步流处理器--Deluge" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust周报645期This Week in Rust 466: https://this-week-in-rust.org/blog/2022/10/26/this-week-in-rust-466/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/10/26/this-week-in-rust-466/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-27 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 466" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "EtherCAT 名称的由来是：Ethernet for Control Automation Technology，也就是用于控制自动化技术的以太网协议技术，其实也就是工业以太网的一种。EtherCAT 是倍福公司旗下的 ETG（ EtherCAT 技术协会）负责研发并推广的一种实时以太网技术，它是一种开放的网络协议，可以进行主从设备之间的通信。通过主从系统架构进行控制。主站发送“目标数据”，从站接收目标数据并写入“实际数据”。 目标数据可以是用于有源设备（执行器）的控制指令，以便执行特定的动作，例如设置电动机的转速。 另一方面，实际数据表示来自被测设备（传感器）的有关各种状态（例如当前位置，转速或温度）的信息。EtherCAT 主站组装 EtherCAT 数据报，然后通过所有连接的从站发送它们。 EtherCAT 的特殊之处在于，在通过过程中，每个从站都将从循环数据报中取出其特定目标数据，同时将自己的实际数据放入数据报中。 所有不打算用于从站的剩余数据都将原封不动地转发。 数据报经过所有从站后，它会返回并由主站接收。 即使对于大量互连的 EtherCAT 从站，此过程也非常快捷，因为单个从站的通过延迟仅为几纳秒。而 EtherCrab 就是用 rust 编写的 EtherCAT 主站。目前 EtherCrab 正在招募赞助商\nhttps://github.com/ethercrab-rs/ethercrab\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-26 19:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "EtherCrab -- 一个用 Rust 编写的 EtherCAT 主站" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RuSTy 是用 Rust 编写的结构化文本 (ST) 编译器，基于 LLVM 编译器后端。使用 logos crate 库在自定义解析器运行之前执行词法分析。RuSTy 通过翻转命令行标志来输出静态或共享对象以及 LLVM IR 或位码。作者的目标是打造至少支持第 2 版 IEC 61131 标准中的功能的开源工业级 ST 编译器。\nhttps://github.com/PLC-lang/rusty\nhttps://plc-lang.github.io/rusty/\nhttps://plc-lang.github.io/rusty/build_and_install.html\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-26 19:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RuSTy -- 一个用 Rust 编写的结构化文本编译器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n课程主题：内存布局\n内容概览：Struct内存布局，成员顺序优化，enum内存布局等\n😈 大家依旧相约直播间：\nhttps://live.bilibili.com/23768194\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-26 19:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cnosdb 的 Rust 教学" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rio 是作为一个实验性的，所谓 hello async world async 运行时诞生的，但它希望在未来能作为 rust 一个可选的异步运行时。Rio 在GitHub上的网址是：https://github.com/vincenzopalazzo/rio，架构分为：\nrio_rt: Rio最小的异步运行时间\nrio_io: 来自异步IO可移植性建议的Rio异步IO（正在进行中）\nrio_lib：Rio实验性标准库（正在进行中）\nReadMore: https://blog.hedwing.dev/async-rust/rio" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.hedwing.dev/async-rust/rio" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-25 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rio 一个实验性的微型异步运行时" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者开发了一个平台无关的 MAX7219 LED 驱动器，这篇文章主要描述如何将这个驱动包发布到 crates.io 来让大家都能使用。\n第1步：注释代码! #️⃣\n第2步：生成文档 📚\n第3步：更新包的元数据 🏷\n第4步：发布到Crates.io! 📦\nReadMore: https://apollolabsblog.hashnode.dev/platform-agnostic-drivers-in-rust-publishing-to-cratesio" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://apollolabsblog.hashnode.dev/platform-agnostic-drivers-in-rust-publishing-to-cratesio" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-25 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "发布包到 crates.io" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ReadMore: https://www.bilibili.com/video/BV1JD4y1b73J/?vd_source=9b7727a7810f27c2668f2732e0ae698e" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.bilibili.com/video/BV1JD4y1b73J/?vd_source=9b7727a7810f27c2668f2732e0ae698e" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-25 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "异步社区10.18晚直播回放" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个库是 Asynchronix 的一个分支，它持续努力地构建用于系统仿真的高性能异步计算框架。这是一个简洁的异步通道，以快速著称，但也不会再正确性和质量方面取巧。它的性能主要来自于对 MPSC 用例的关注和一些精心的优化，包括：\n为全队列和空队列事件积极优化通知原语。\n发送者一旦创建就不会再分配，即使对于被阻止的发送者 / 接收者通知。\n没有任何自旋锁，并且热点路径（程序中那些会频繁执行到的代码）中没有互斥锁。\n针对单个接收器优化的底层队列。\n示例：GitHub：https://github.com/asynchronics/tachyonix" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-24 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tachyonix：异步多生产单消费有界通道" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用指南：示例：GitHub：https://github.com/TheAwiteb/rsre" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-24 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rsre：重命名工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有许多我们不希望发生的错误，但即便错了我们也不希望 panic，当然我们也不想花太多时间处理意外错误。这就是本项目的用途，你可以保留意外错误，直到以后再担心它们。示例：GitHub：https://github.com/botahamec/exun" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-24 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "exun：错误处理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用 Rust 和 Bevy 制作的开源横向展开的太空射击游戏。Demo：https://larsdu.github.io/StarRust/GitHub：https://github.com/LarsDu/StarRust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-24 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "StarRust：太空射击游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "COSMIC Text 提供了高级文本变形、布局和渲染。这些都被包含在一个简单抽象中。\n文本变形由 rustybuzz 提供，并支持各种高级变形操作。\n渲染由 swash 提供，它支持连字和彩色表情符号。\n布局是在安全的 Rust 中自定义实现的，支持双向文本。\nGitHub：https://github.com/pop-os/cosmic-text" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-24 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cosmic-text：多行文本变形和渲染" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n12 分钟 SQLx（比 Diesel 更简单的替代品）：https://www.youtube.com/watch?v=vLcoW408QvE\nRust 中的快速原型设计（像 Python 一样「快」，像 C 一样「快」）：https://www.youtube.com/watch?v=X7Dsu0oRk0U\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-24 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "学习资源" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "解决经典的 Cart Pole 问题有很多种, 作者这里借用 dfdx 这个深度学习的库, 使用 Deep Q-Learning 的方法来解决.并且使用 Bevy 来构建展示的效果.原文链接相关代码github地址https://monadmonkey.com/bevy-dfdx-and-the-classic-cart-pole" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-24 19:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Bevy 和 dfdx 解决经典的 Cart Pole问题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "MacroKata 是一系列 宏 的练习题, 这些练习题的风格和 Rustlings 一样. 想学习 macro 的同学可以试试.github地址https://github.com/tfpk/macrokata" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-24 19:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MacroKata: Rustlings 风格的 宏 练习题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个Rust 编写的命令行的小游戏, 提供了超过 500 种的独特模式.github 地址https://github.com/omagdy7/gof-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-24 19:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "命令行上的小游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 Bevy 引擎的入门教程视频:\n介绍\n其他的游戏引擎\nBevy 的两个场景\nInstanceId\nSceneInstance\nSceneSpawner\n如何创建一个 SceneSpawner\n如何使用 SceneBundles\n如果创建一个场景\n如何创建一个动态的场景\n如何保存和加载一个动态的场景\n使用 GLTF\n油管视频https://www.youtube.com/watch?v=bbBh3oKibkE--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-24 19:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy: 基础场景" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rustdesk" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "应对广大粉丝的强烈要求，RustDesk 正式发布 Nightly Build，每日格林威治时间零点构建发布。相比上个稳定版本，此版本包含很多变化，尤其是使用 Flutter 重构前端，以及 Wayland 支持。https://github.com/rustdesk/rustdesk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-24 13:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "此版本目标是改进对工作区的支持，包括：\n支持工作区继承\n调用 cargo release --unpublished 更好地版本控制\n发布新 crate 时设置 crate 所有者\nGithub链接，https://github.com/crate-ci/cargo-release/releases/tag/v0.22.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-22 22:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-release 发布 v0.22" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Philip Herron 和 Arthur Cohen 在 2022 Kangrejos 会议上介绍了 Rust 语言 GCC 前端的更新。原文链接，https://lwn.net/Articles/909887/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-22 22:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "深入了解 GCC Rust 前端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Gtk-rs 发布新版本：\n更新最低版本\n更多异步功能\nGTK 4\n添加支持枚举 #[derive(glib::Variant)]\n博客原文链接，https://gtk-rs.org/blog/2022/10/18/new-release.htmlGithub，https://github.com/gtk-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-22 22:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Gtk-rs 发布新版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对于大多数用例来说，多线程使用相同的编译正则表达式是完全可以的。但是，如果代码从多个线程进行大量的正则表达式匹配，并在一个正则表达式上完成大部分或全部匹配，那么几乎肯定会希望将已编译正则表达式的不同实例提供给不同的线程。请务必在对代码进行更改前测试性能。更多参见原文链接，https://morestina.net/blog/1827/multi-threaded-regexhttps://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-22 22:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "多线程正则表达式匹配" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Mesa 的 Rusticl 驱动程序作为开源 Gallium3D 驱动程序的现代基于 Rust 的 OpenCL 实现，已经表明它能够在至少一些 GPU 和工作负载上胜过 AMD 的开源 ROCm 计算堆栈。更多请看原文：https://www.phoronix.com/news/Rusticl-Outperformed-ROCm" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.phoronix.com/news/Rusticl-Outperformed-ROCm" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-21 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rusticl OpenCL 实现可以胜过 Radeon 的 ROCm 计算堆栈" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Fig 是一个比较好用的命令行工具，目前使用 Rust 进行了完全重写，相关讨论：https://www.reddit.com/r/rust/comments/y9np09/fig_posted_on_twitter_saying_the_did_a_full/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/y9np09/fig_posted_on_twitter_saying_the_did_a_full/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-21 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fig 使用 Rust 完全重写" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "油管视频教程，主要内容是通过使用Rust和WebAssembly来构建你可以在任何地方部署的应用程序，而无需安装。地址：https://www.youtube.com/watch?v=y10jJX35shEhttps://github.com/Jancd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=y10jJX35shE" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-21 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust & Wasm（安全快速的 Web 开发）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "网络时间协议（network time protocol）使连接到网络的设备之间的时间达成同步。该项目源自 Prosimo 的倡议，并得到 Cisco 和 AWS 的支持。其首要的短期目标是在 Let's Encrypt 部署该实现。而长期目标是开发一个可广泛使用的、功能齐全的网络时间协议替代实现。A Memory Safe Implementation of the Network Time Protocol: https://www.memorysafety.org/blog/memory-safe-ntp/GitHub - memorysafety/ntpd-rs: https://github.com/memorysafety/ntpd-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/memorysafety/ntpd-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-20 23:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "网络时间协议的内存安全实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "mirrord 是一款致力于改善开发工作流的开发工具，为后端开发者设计，使用 Rust 编写。在过去，开发者需要在本地机器上编写微服务代码，测试然后再部署到模拟环境中，从而完成与云的第一次接触; 而有了 mirrord ，你将会得到一个与模拟环境相符合的开发环境，代码一经编写完成即可与云相遇。mirrord 3.0 是第一个把本地进程完全封装在 Kubernetes 集群上下文中的版本 —— 将网络流量、文件访问、环境变量通通连接在一起，开发者可以在熟悉的舒适的本地环境中继续运行程序进程，但是输入、配置和状态都来自于云。mirrord 3.0 is out!: https://metalbear.co/blog/mirrord-3.0-is-out/GitHub - metalbear-co/mirrord: https://github.com/metalbear-co/mirrord" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/metalbear-co/mirrord" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-20 23:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mirrord 3.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 465: https://this-week-in-rust.org/blog/2022/10/19/this-week-in-rust-465/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/10/19/this-week-in-rust-465/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-20 23:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 465" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有 20 年编程经验的 egui 作者讲了自己为什么选择了 Rust。\n安全性和速度\n借用检查器\n枚举类型\n错误处理\n...\nReadMore:https://www.rerun.io/blog/why-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.rerun.io/blog/why-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-19 20:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么要用 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "nom 可以使任何人都可以写出简单、类型安全的解析器。ReadMore:https://naiveai.hashnode.dev/practical-parsing-nom" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://naiveai.hashnode.dev/practical-parsing-nom" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-19 20:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Rust 中使用 nom" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文作者比较了几种语言--Go、Java、C++和Rust。C++更难扩展和保持高质量Java不能灵活性不足和不能进行系统编程Go也是一种垃圾回收语言我们选择了Rust。Rust有着性能强、内存管理简单和易用性等优点。ReadMore:https://www.pinecone.io/learn/rust-rewrite/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.pinecone.io/learn/rust-rewrite/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-19 20:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust重写高性能矢量数据库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rustc_codegen_gcc 是 Rustc 的 GCC 编译器前端，这意味着它可以被现有的 Rustc 前端加载，但支持更多的架构和并能受益于 GCC 多年积累的优化。当前正在做的工作是：\n支持 signed char 标志\n其他正在进行或已完成的参考原文。ReadMore: https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-16" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-16" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-18 11:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust GCC 后端进度报告#16" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我还在努力学习Rust。除了语法，学习一门语言还需要熟悉它的习语和生态系统。我正处在一个想探索Rust测试的阶段。文中介绍了不同测试的编写方法，新手可以看一下。ReadMore: https://blog.frankel.ch/different-test-scopes-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.frankel.ch/different-test-scopes-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-18 11:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust中的不同测试范围（Scope)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "谷歌本周宣布发布 KataOS，它是用于进行机器学习的嵌入式设备的操作系统。KataOS 从设计上就具备安全考虑，不但几乎完全是由 Rust 实现的，而且是建立在 seL4 微内核的基础之上，seL4 在数学上被证明是安全的，具有保证保密性、完整性和可用性。消息来源： https://opensource.googleblog.com/2022/10/announcing-kataos-and-sparrow.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-17 18:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "谷歌宣布推出 Rust 开发的 KataOS 操作系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好！2022秋冬季开源操作系统训练营开始招生https://github.com/LearningOS/rust-based-os-comp2022报名时间段 2022.10.16 ~ 2022.10.30，训练时间段 2022.11.1~2023.2.1如希望参加本次训练营，请在报名登记处 填写相关信息，并加入相关微信群. 后续获得邀请后，将开始参与本次训练营活动。https://github.com/LearningOS/rust-based-os-comp2022/issues/101" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-17 18:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2022秋冬季开源操作系统训练营开始报名了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Kanal 是一个目前 Rust 最快的 channel 实现,比标准库快 80 多倍. 目前版本是 0.1.0-pre1, 作者正在完善和构建中.github地址https://github.com/fereidani/kanal" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-17 18:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Kanal: 比标准库快 80 倍的 channel 实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者在写 warp 时,为了让处理 anyhow::Result 能够简单和美观, 自己编写了一个过程宏, 在此分享该过程宏的编写过程, 通过此宏, 可以让代码精简到如下类似代码.--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-17 18:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "过程宏代码分享" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Leptos 是一个全栈、同构的 Rust Web 框架，利用细粒度的响应式来构建声明性用户界面。\n全栈：可用于构建在浏览器、服务器或通过在服务器上渲染 HTML 然后在浏览器中添加交互性运行的应用程序。\n同构：相同的应用程序代码和业务逻辑被编译运行在客户端和服务器上，无缝集成。\nWeb：Leptos 建立在 Web 平台和 Web 标准之上。\n框架：Leptos 提供了构建现代 Web 应用程序所需的大部分内容：响应式系统、模板库和可在服务器端和客户端工作的路由器。\n细粒度响应式：整个框架是从响应式原语构建的，这允许以最小的开销执行极高性能的代码。\n注意：此项目正在开发中，API 不一定稳定。GitHub：https://github.com/gbj/leptos" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-16 19:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "leptos：全栈同构Web框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Plane 是一个服务器编排器，实现了一种「会话后端」的架构，可以启动许多临时容器实例，并通过 HTTPS 直接连接到这些容器。与在多个用户之间共享的传统 Web 服务器相比，这些容器可以更像一个碰巧远程运行的后台进程。 我们可以将 Plane 后端视为恰好在服务器上运行的客户端应用程序的扩展。主页：https://plane.dev/GitHub：https://github.com/drifting-in-space/plane" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-16 19:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "plane：基于浏览器的APP容器编排器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对 rm API 进行了扩展和性能改进（特别是对大文件和深度嵌套目录）。特点如下：\n原生 GNU rm API。\n回收站集成（-t）。\n贼快。\n不可恢复的移除（--shred）。\n更多过滤选项。\n性能对比如下：GitHub：https://github.com/demfabris/rmx" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-16 19:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rmx：增强的rm" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "官网：https://relay.dev/GitHub：https://github.com/facebook/relay" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-16 19:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "relay：构建数据驱动的React应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Prusti 是 Rust 的原型验证器，建立在 Viper 验证基础设施之上。默认情况下，Prusti 通过证明诸如 unreachable!() 和 panic!() 之类的语句不可达来验证是否存在整数溢出和 panic。最简单的尝试方法是使用 VS Code 插件：https://marketplace.visualstudio.com/items?itemName=viper-admin.prusti-assistantGitHub：https://github.com/viperproject/prusti-dev" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-16 19:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "prusti-dev：Rust静态验证器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个非常简单（当下）的实时音频可视化工具，使用 WGPU。当前实现仅适用于使用 minimp3-rs 的 mp3 文件。GitHub：https://github.com/joshpauline/oscli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-16 19:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "oscli：实时音频可视化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Frui是一个开发者友好的UI框架，它使构建用户界面变得简单而富有成效。它的灵感来自于Flutter架构，是用Rust编写的。示例：Github 链接，https://github.com/fruiframework/frui" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/fruiframework/frui" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-15 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Frui: 一个rust写的开发者友好的框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "它在我以前的工作中非常有用，当我们使用AWS的API的时候。事实上，我已经习惯了使用它，以至于我无法想象没有它该如何处理分页。现在它已经开源了，包括一些额外的功能（并发查询）文章链接，https://docs.rs/page-turner/latest/page_turner/Github 链接，https://github.com/a1akris/page-turner" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/a1akris/page-turner" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-15 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "page-turner: 一个将分页api变为异步流的trait" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust音频播放库：\n播放是由cpal处理的\nMP3解码是由minimp3处理的\n...\n文章链接，https://crates.io/crates/rodioGithub 链接，https://github.com/RustAudio/rodiohttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/RustAudio/rodio" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-15 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rodio：一个音频播放库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇博文是为在async Rust方面有一些经验的读者准备的。它假定你知道什么是Future!什么是Async UI？Async UI是一个概念验证的Rust UI库，它的后端是Web（HTML/JS）和GTK 4。很有意思的一个概念，可惜作者是在校学生，现在忙于学习，没有时间继续更新，但是这个概念真的很有意思，之前的macroquad （一个Rust实现的游戏引擎），获取下一帧也是用到了异步，说到底，Rust的异步本身的核心思想就是状态机，而UI也是一个个状态机组合在一起的，两者的碰撞就很有意思。macroquad的简单事例：async_ui的简单事例：具体请看原文：原文: https://wishawa.github.io/posts/async-ui-intro/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://wishawa.github.io/posts/async-ui-intro/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-13 21:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Async UI：一个Rust UI库，一切皆有可能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我是一家小公司的首席技术官，我负责大部分的编程工作，根据工作量的大小，我们会有2到4个开发人员在我手下工作。我们90%的工作代码和物流有关，大部分时间是在建立应用程序，通过API接收信息、处理数据，提供API接口来预订货物，等等。我们需要开始升级我们的代码库；目前在GO和Rust之间争论。我喜欢这两种语言，但更倾向于Rust。因为我做了大部分的工作，我觉得我应该选择我更喜欢用的那个。但我担心初级开发人员永远不会明白这一点。我想知道你们的看法。我应该使用Rust，因为我想用它，还是应该使用GO，因为更多的人知道它，而且它可能更容易找到开发人员？以下是一些高赞回答：我也是CTO。我们雇用了大学毕业的应届生，让他们学习Rust。他们没有遇到任何问题就学会了，并且正在编写干净的、性能良好的代码，单元测试覆盖率达到100%。然而，Rust的库生态系统并不像Node或Go那样完善。但是，它也正在努力发展。另一位CTO：我一直在教同事（一个拥有多年Go后端经验，另外两个有前端/TypeScript经验）写Rust代码时，即使写的时间相对有限，也有相当高的效率。学习曲线可能会很陡峭，但如果有人可以教授和指导，我认为这不会是一个大问题。我们写TypeScript的程序员非常喜欢Rust，并希望能用它做更多的事情。我管理一个项目，其中有大量的restapi调用，它是从Python移植到Rust的。光是Serde就为我们节省了数百甚至数千小时的工作。我对Go不是很熟悉，但Rust的工具（库和基础设施）很不错。如果你想和一群初级开发人员一起快速入门，就使用Go。如果你想更容易地产生可维护和可靠的东西，并且愿意帮助后辈和新人度过Rust陡峭的学习阶段，那么就使用Rust。Go（在我看来）是一种有缺陷的语言，它有很多令人不舒服的地方和奇怪的错误处理。另一方面，一些伟大的软件是用它写的，它相对较小，也相对简单。它的编译速度很快，可以让一个新的开发人员能在几周内完成工作并至少有一定的生产力。Rust有更多的安全机制，更好的内存处理，更好的错误处理，更少的语法噪音，更友好的社区，更低的资源使用，所有这些都是好东西。然而，如果你是个新手，而且你还不是一个可靠的开发者，你将需要所有你能得到的（优秀的）文档和帮助，这仍然需要花费一些时间。选择你的取舍。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-13 21:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个小公司的CTO在reddit上发帖询问是否应该在公司内推广Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust周报645期This Week in Rust 464: https://this-week-in-rust.org/blog/2022/10/12/this-week-in-rust-464/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/10/12/this-week-in-rust-464/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-13 21:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 464" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nhttps://github.com/bouffalolab/bl808-pac\n本文解释了如何使用 Rust 暴力破解受保护的 ZIP 文档密码。它主要针对初学者 Rust 开发人员，但它肯定会对更广泛的受众对其感兴趣。zip-password-finder 提供了具有更好错误处理和正确命令行参数 (CLI) 的完整代码。不久前，作者发现自己拥有一个 ZIP 档案，其中包含他无法访问的家庭数据。档案受密码保护，没人知道内容。经过短暂的调查，作者发现有几个工具被宣传为能够恢复各种类型压缩档案的密码。然而，他们中的大多数看起来很可疑或需要许可证，这让作者相当怀疑。正是因为这一点，他决定自己构建这样一个工具，这也将是一个很好的学习机会。https://github.com/agourlay/zip-password-finder\nhttps://agourlay.github.io/brute-forcing-protected-zip-rust/\nCnosDB 是一款高性能、高压缩率、高易用性的开源分布式时序数据库；CnosDB 依托于 Rust, Apache Arrow 与 DataFusion 进行构建。本周 cnosdb ：committed 了其 sql command line 的实现。详情https://github.com/cnosdb/cnosdb/commit/781024b0c8f290e4ca8850f6d1f29953219d8b27\n每晚 19点 Cnosdb 出品 Rust 教学视频\nhttps://github.com/cnosdb/cnosdb\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-12 20:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Fyrox 是一个功能丰富、可用于生产的通用 2D/3D 游戏引擎，其采用 Rust 编写，并带有场景编辑器，能帮助你进行高效的开发。近日，其发布了 0.28 版本，包括了一系列改进和修复，让你的游戏开发更加便捷。主要改动点为：感兴趣的不妨阅读以下资料：更新日志github主页https://fyrox.rs/blog/post/feature-highlights-0-28/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-11 19:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fyrox 0.28 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "hyper 是一个非常完善且“正确的” HTTP 协议实现，广泛应用于各个项目中，有位网友在 reddit 上发帖问：像 hyper 这样的 HTTP 协议实现，声称是“正确的”，这到底意味着什么？以下节选自高赞回答：协议类似于一组规则。其规定了可接受的数据格式、在不同站点中允许哪些指令、应当采取的行为......。超文本传输​​协议（HTTP）也对应一个这样的规则列表，例如：a. 请求的第一行必须以动词（GET、POST 等）、url 和 HTTP 版本开头，然后是换行符；b. 标头必须采用特定格式。例如，标题的名称不能包含 “:” 字符；c. 如果请求包含正文，则必须声明长度。如果说 HTTP 协议的实现是“正确的”，背后的想法是，用户必须不可能生成无效的 HTTP 请求。例如，一旦您开始发送正文，就不可能设置 HTTP 头部，因为这样做是无效的。从另一个角度来看，特别是对于像 HTTP 这样的协议，它比 RFC 规定的内容更难实现。最“正确的”实现，在应用于现实世界时，总会遇到一长串奇怪但合法的行为，这将使一些客户端或服务器在某些时候崩溃。有时候在现实世界中，你需要忍受一些不正确的实现。例如 Cloudflare 就没有将 Hyper 应用于他们的 Rusty Proxy 服务中，因为它太严格了，不满足 Cloudflare 对于现实应用的需求。reddit 讨论连接https://www.reddit.com/r/rust/comments/xzxin3/what_is_meant_by_correct_http_implementation/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-11 19:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "“正确的” HTTP 协议实现意味着什么" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文主要探索了在 rust 中进行单元测试和集成测试的一些方式, 虽然是讲 测试为主,但是作者从 DI(依赖注入)的视角讲述了使用 cfg 来实现不同的环境进行不同的初始化的一些思路.原文链接https://blog.frankel.ch/different-test-scopes-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-10 19:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 不同的测试方式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个模板项目, 主要使用 actix做后端, yew做前端.特性包含:github 地址https://github.com/security-union/yew-actix-template" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-10 19:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "yew + actix 的项目模板" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rkl (Rust Keras Like) 是一个纯 Rust 实现的,类似 keras 的一个机器学习库,示例代码如下:github 地址https://github.com/AhmedBoin/Rust-Keras-Like--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-10 19:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Keras Like: 纯 Rust 实现的机器学习库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rustc_codegen_gcc 是 rustc 的 GCC 预编译代码生成器，这意味着它可以被现有的 rustc 前端加载，可以从 GCC 中受益，其支持更多的架构并可以访问 GCC 的优化。不要与 gccrs 混淆，gccrs 是 Rust 的 GCC 前端。本月进度：支持有符号字符标志。更多详细信息请查看原文链接，https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-16" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.antoyo.xyz/rustc_codegen_gcc-progress-report-16" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-09 21:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustc_codegen_gcc 进度报告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pulp 是一个安全的便携式 SIMD 库。它是对 SIMD 指令的安全抽象，编写一次函数，根据运行时检测到的特征分派到等效的矢量化版本。Github链接，https://github.com/sarah-ek/pulp/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sarah-ek/pulp/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-09 21:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pulp，SIMD库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "speki 是一个基于终端的 Flashcard 应用。Github链接，https://github.com/tbs1996/spekitchatche.rs 是一个使用 Axum 和 yew.rs 构建的超快聊天应用。GitHub链接，https://github.com/nag763/tchatchershttps://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/nag763/tchatchers" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-09 21:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust应用之speki和tchatche.rs" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/pepabo/dd-trace-layerdd-trace-layer 是一个用于发送 Datadog 跟踪的中间件。它基于Tower和OpenTelemetry Rust。https://github.com/tower-rs/tower当我使用 hyper 构建 Rust Web 应用程序时，我想向 Datadog 发送跟踪信息，但找不到适合它的 crate。这是一个小箱子，但可能对那些想做类似事情的人有用。谢谢！https://github.com/liabri/rimca)" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-09 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "dd-trace-layer - 用于发送 Datadog 跟踪的 Web 应用程序中间件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我想尝试 rust 并使用ws-rs开发了一个游戏 websocket 后端。当然，当我做出选择时，我没有意识到它几乎没有维护。范例非常好和简单，对于初学者来说使用（tokio-）tungstenite 似乎真的很难......https://github.com/housleyjk/ws-rs不幸的是，当我尝试使用 TLS（有时工作但非常随机），就在发布我的 POC（当然）之前，这个板条箱显示自己非常不稳定。所以现在我必须迁移有没有人有好的稳定板条箱建议来最小化我对新库的学习开销？😅（我不需要 HTTP 服务器，只需要 ws(s)）。最初发布在这里https://www.reddit.com/r/rust/comments/xujc65/comment/irjwxjt/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-09 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ws-rs 替代方案" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "基本上如果你想说服别人，你能展示什么理由。我可以看到 rust 的优势\n系统编程：速度和内存安全\n前端：如果你需要 WASM\nrust 的后端生态系统在竞争中具有什么优势？\n节点：如果您希望前端和后端在单个堆栈中并拥有全堆栈开发人员。\ndotnet 和 Java：针对需要标准化和自有结构的大公司。如果您从一家公司转到另一家公司，dotnet 项目结构和其他基础知识仍然完全相同。从而使新人快速高效地入职。\n对于rust：\n成本（也许？）：我在某处读到，在无服务器设计中，Rust 后端成本最低。（不要引用我的话哈哈）\n这里还有什么？？？\n编辑1：drogus建议的正确性。\n这些可能不会有太大区别：\n类型安全：Typescript、dotnet、java 等都涵盖了这一点。\n速度：在大多数情况下并不重要。在大多数后端系统中，等待网络调用将成为瓶颈。除非你有一个非常高的 CPU 密集型后端。\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-09 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "出于什么原因，您应该选择 rust 进行后端开发而不是其他选项？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "添加了一些管理功能，并且迁移现在也在 Rust 中。https://saru-tora.github.io/anansi/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-09 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Anansi 0.2，一个简单的 MVC Web 框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自 Google 的项目：Crubit - 用于 C++ 和 Rust 的极具实验性的互操作工具。目前是一个实验项目，项目将在没有警告的情况下进行重大更改。项目地址：https://github.com/google/crubit" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/google/crubit" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-07 22:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Crubit - C++/Rust 双向互操作工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自官博，作为正在进行的治理工作的一部分，Rust 领导层联合建立了一个名为“领导聊天”的小组，由核心团队、治理页面上所有团队的负责人、Moderation 团队和 Rust 基金会董事会的项目负责人组成。该小组一直担任临时管理机构，同时正在努力建立 Rust 项目范围治理的下一次演变。更多请看原文：https://blog.rust-lang.org/inside-rust/2022/10/06/governance-update.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-07 22:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 社区治理更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原文阅读：https://nickb.dev/blog/avoiding-allocations-in-rust-to-shrink-wasm-modules/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-07 22:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "避免在 Rust 中分配内存进而影响 Wasm 模块大小" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自博文，这篇文章是一个仅使用最少的、人为约束的 API（例如，没有动态内存分配）编写 Rust 应用程序的案例研究。它假定你对该语言相当熟悉。原文请看：https://matklad.github.io/2022/10/06/hard-mode-rust.htmlhttps://github.com/Jancd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-07 22:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "困难模式下的 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "zerocal 是一个使用 Rust 编写的 Serverless 日历应用，运行在 shuttle.rs 上 。zerocal 允许通过链接共享邀请，并且根据请求动态生成日程。（服务器端部分使用 axum）。可以通过使用 curl 访问日程来将其添加到你的日历中。作者计划使用 zerocal 邀请朋友们参加一些小型的、非正式的聚会。GitHub - mre/zerocal：https://github.com/mre/zerocalzerocal - A Serverless Calendar App in Rust Running on shuttle.rs：https://endler.dev/2022/zerocal/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://endler.dev/2022/zerocal/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-06 23:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "zerocal - Serverless 日程应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rusty 是一款由 GPT-3 支持的 CLI 工具，可帮助用户记住 bash 命令。GitHub -  zahidkhawaja/rusty: https://github.com/zahidkhawaja/rusty" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/zahidkhawaja/rusty" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-06 23:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rusty - GPT-3 驱动的命令行工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 463: https://this-week-in-rust.org/blog/2022/10/05/this-week-in-rust-463/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/10/05/this-week-in-rust-463/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-06 23:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 463" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust-for-Linux的初始支持大致有4个方面：\n\n内核底层（Rust 符号的 kallsyms 扩展，%pA 格式)\n\n\nKbuild 基础设施（Rust构建规则和支持脚本）\n\n\n用于初始最小可行构建的 Rust crates 和 bindings\n\n\nRust 内核文档和样本\n\n内核底层（Rust 符号的 kallsyms 扩展，%pA 格式)Kbuild 基础设施（Rust构建规则和支持脚本）用于初始最小可行构建的 Rust crates 和 bindingsRust 内核文档和样本ReadMore: Merge tag rust-v6.1-rc1 of https://github.com/Rust-for-Linux/linuxhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8aebac82933ff1a7c8eede18cab11e1115e2062b" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-04 22:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "初版的 Rust 支持已合并到 Linux 内核" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我发现 Async Rust 经常被误解了，围绕着 \"为什么是异步 \" 的讨论往往集中在性能这个高度依赖于任务负载的问题上，结果常常是谈论一些与 Rust 异步本身不太相关的点。虽然性能是选择 Async Rust的一个很好的理由，但我们往往不应该在遇到性能问题后才去用 Async Rust。所以我想谈谈异步 Rust 提供了哪些非异步 Rust 所不具备的功能。虽然我们在这篇文章的最后也会讨论一下性能问题。ReadMore: WHY ASYNC RUSThttps://blog.yoshuawuyts.com/why-async-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-04 22:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么要用 Async 的 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 inus Torvalds 关于 rust: add kernel crate 的一些回复.邮件中指出了内核中一些特殊之处,例如 panic 处理等. 同时告诉大家, 虽然Rust 是安全的,但是现实是没有完全安全的.原文链接https://lkml.org/lkml/2022/9/19/1105#1105.php" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-03 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Linus Torvalds: 回复 rust: add kernel crate" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一篇 Iterator 的教程. 从原理, 实现 Iterator trait 到如何测试.原文链接https://aloso.github.io/2021/03/09/creating-an-iterator" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-03 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中创建 Iterator" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该网站追踪各种语言的开源项目的每周趋势, 此为 Rust 相关项目,本周趋势前五为:原文链接https://trendy.dev/week/Rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-03 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 开源 每周趋势" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "上周作者介绍了 使用 Rust 编写了Apache APISIX 的插件, 今天, 作者再次使用 Rust 来编写esponse-rewrite 插件.原文链接https://blog.frankel.ch/rust-apisix/2/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-03 21:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 重写 Apache APISIX 插件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "地址：https://lore.kernel.org/lkml/202210010816.1317F2C@keescook/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-03 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust正在进入Linux6.1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GraphScope 是阿里巴巴达摩院智能计算实验室研发并开源的一站式图计算平台。依托于阿里海量数据和丰富场景，与达摩院的高水平研究，GraphScope 致力于针对实际生产场景中图计算的挑战，提供一站式高效的解决方案。主页：https://graphscope.io/GitHub：https://github.com/alibaba/GraphScope" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-03 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GraphScope：大规模图计算系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "MicroBin 是一个超小型、功能丰富、可配置、自包含和自托管的粘贴 Web 应用程序。  它非常易于设置和使用，并且只需要几兆字节的内存和磁盘存储空间。GitHub：https://github.com/szabodanika/microbin" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-03 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "microbin：粘贴工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Linkal 是一个公共日历聚合服务器。 给定一组公共日历链接，它可以让 CalDav 客户端相信所有这些日历都是同一个日历集合的一部分。GitHub：https://github.com/JulienMalka/Linkal" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-03 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Linkal：公共日历聚合服务器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Findlargedir 是一个快速查找包含大量文件目录的工具。注意事项：\n每个正在测试的目录需要 r/w 权限（过程中会创建临时目录）。\n精确模式（-a 参数）可能导致过多的 IO 和内存使用。\nGitHub：https://github.com/dkorunic/findlargedir" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-03 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "findlargedir：多文件目录查找工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "dsync 是一个用于从 Schema 文件生成数据库结构和查询代码的工具。给定 Schema：执行 cargo dsync -i schema.rs -o models，生成如下代码：GitHub：https://github.com/Wulf/dsync" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-10-03 00:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "dsync：从schema到代码" }, "type": "text" }], "type": "title" } },]
