export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者认为C语言是新时代的汇编，C++更抽象，Rust实际是对C++的一次回炉重造。https://www.thecodedmessage.com/posts/rust-new-cpp/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.thecodedmessage.com/posts/rust-new-cpp/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-07 23:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "blog：思考，Rust,是实现C++主要目标的一次尝试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tauri现在火得不行，很多大工具都用或正在用Tauri重新包装。https://spacedimp.com/blog/using-rust-tauri-and-sveltekit-to-build-a-note-taking-app/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://spacedimp.com/blog/using-rust-tauri-and-sveltekit-to-build-a-note-taking-app/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-07 23:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust, Tauri 和 SvelteKit 构造一个笔记应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "5月10号，Amsterdam.https://2023.rustnl.org/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://2023.rustnl.org/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-07 23:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "活动：RustNL 5月10号 Rust Meetup" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者举例对比了Rust和Go与Js对模型的抽象能力，同时能保持高性能。大赞Rust真棒。https://monomorph.is/posts/zero-cost-abstractions/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://monomorph.is/posts/zero-cost-abstractions/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-07 23:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "好文推荐：Rust的零成本抽象 - 解锁高性能和强表达力" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Buck1是Java实现的，现在Meta发布了v2,用Rust重新实现了。可用于Rust,C++，Py,Erlang, Ocaml等。https://buck2.build/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://buck2.build/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-07 23:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Buck2 - Meta开源的大型构建工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "最近，Lyon 库的作者 Nicolas Silva 在他的博客中深入探讨了在 Rust 中使用自定义分配器的优点和权衡。他分享了多种实现自定义分配器的方法，包括使用泛型参数、Allocator trait 和手动分配与 trait 对象等，提醒开发者在实际场景中验证假设并测量性能。在博客中，Nicolas Silva 强调了添加泛型参数对代码性能的意外影响，以及验证假设和在实际场景中测量性能的重要性。如果您正在考虑在 Rust 项目中使用自定义分配器，那么 Nicolas Silva 的博客提供了有用的见解，可帮助您做出明智的决策。详情: https://nical.github.io/posts/rust-custom-allocators.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://nical.github.io/posts/rust-custom-allocators.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-06 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 开发者探讨自定义分配器的优点和实现方法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust编程语言的编译器rustc近期进行了一项重要的性能优化，通过使用SipHash-1-3算法来加速其稳定哈希器，从而大幅提升了编译速度。稳定哈希器是rustc用于哈希增量编译数据的组件，因此这个改进将使得增量编译的速度更快，尤其是在处理大型代码库时效果更加明显。这个改进已经被合并到了rustc的主分支，并将在未来的版本中发布。虽然这个改进可能存在一些潜在的风险，但作者认为这些风险对于稳定哈希器的使用并不重要。详情: https://github.com/rust-lang/rust/pull/107925" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-lang/rust/pull/107925" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-06 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustc使用SipHash-1-3算法加速稳定哈希器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "PL/Rust是一个全新的过程语言处理器（New Procedural Language Processor）,可以让开发人员使用Rust语言编写PostgreSQL函数。与其他过程语言不同，PL/Rust函数不是解释执行的，而是编译为本机机器代码，从而获得更好的性能。PL/Rust还提供了对Postgres的Server Programming Interface（SPI）的访问以及安全的Rust类型，包括TEXT、INT、BIGINT、NUMERIC、FLOAT、DOUBLE PRECISION、DATE和TIME等。此外，PL/Rust还提供了更加用户友好的文档格式。未来，PL/Rust也可能会提供适用于不同平台的plrust和plrustu版本。如果您想快速开始使用PL/Rust进行评估，请先安装cargo-pgx，然后执行以下操作...然后，您就可以真正运行它并开始编写函数了！详情: https://github.com/tcdi/plrust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/tcdi/plrust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-06 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "让Rust语言成为PostgreSQL的新过程语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 489: https://this-week-in-rust.org/blog/2023/04/05/this-week-in-rust-489/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/04/05/this-week-in-rust-489/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-06 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 489" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "trust-dns 的目标是构建具有现代功能的安全可靠的 DNS 服务器和客户端。仅使用安全的 Rust 构建，并通过适当的错误处理避免所有恐慌，其功能设计在一定程度上防止 DDOS 攻击，全局负载平衡功能的支持选项让它操作更简单。\nhttps://github.com/bluejekyll/trust-dns\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-05 23:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "基于 Rust 的 DNS 客户端、服务器和解析器 trust-dns" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rocket 是 Rust 的 Web 框架，专注于可用性、安全性、可扩展性和速度。Rocket 使编写快速、安全的 Web 应用程序变得简单，而不会牺牲可用性。Rocket0.5.0-rc.3 是 Rocket v0.5 的候选版本，目前可用。此版本建立在之前的候选版本之上，并为 Rocket 带来了更多功能、改进和修复。和以前一样，这是一个在正式发布之前发现 Rocket v0.5 及其文档问题的机会。我们鼓励所有用户将他们的应用程序迁移到第三个候选发布版，并向GitHub 问题跟踪器报告任何问题。有关如何从 Rocket v0.4 升级的完整详细信息，请参阅新的迁移指南。对于自 Rocket v0.5.0-rc.2 以来的更改，请参阅 CHANGELOG。https://github.com/SergioBenitez/Rocket/issues\nhttps://rocket.rs/v0.5-rc/news/2023-03-23-version-0.5-rc.3/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-05 23:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rocket v0.5 的第三个候选发布版" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Slint 1.0 正式发布了，这是一个重要的里程碑，标志着 Slint 可以逐步在生产环境中应用了。Slint 的开发始于 2020 年 5 月，最早被称为 \"SixtyFPS\"，旨在解决现代化 UI 开发的需求。其使用 Rust 的声明式编程来构建桌面和嵌入式设备的本机用户界面，提供了易于阅读、编写和学习的语法，它的编译器优化并将 UI 描述翻译成本机代码，从而高效执行，该工具包还使用工具支持来进行代码完成、导航、重构和语法高亮显示，除了在编辑器中开发，还可以在 web editor中快速上手。https://marketplace.visualstudio.com/items?itemName=Slint.slintSlint 支持各种操作系统和处理器架构，包括 Linux、macOS、Windows、RISC-V、ARM Cortex-M 等。使用 Slint 构建的图形应用程序可以在内存小于 300kB 的系统上运行，这使其非常适合用于开发嵌入式设备的应用程序界面。该工具包具有未来可扩展性，可与多种编程语言（如 C ++、JavaScript 和 Rust）集成。原文链接github 地址https://slint-ui.com/blog/announcing-slint-1.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-04 23:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Slint : 下一代 GUI 编程工具包" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "SeaStreamer 是一个流处理工具包，目前提供了对于 kafka 和 redis 数据流的支持。SeaStreamer 基于 async-std and tokio 两个异步框架，实现了高效的消息系统，同时向开发者提供了完善的 API。下面是一个基本的 kafka 消费者示例：详细内容可以参考 官方文档https://www.sea-ql.org/blog/2023-04-03-intro-sea-streamer/#fn-1-e1956fgithub 地址https://github.com/SeaQL/sea-streamer" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-04 23:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SeaStreamer: 流处理工具包" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者用两篇文章详细说明了，如何实现一个 Zip 密码破解工具 zip-password-finder ，以及如何一步步对齐进行性能优化。https://github.com/agourlay/zip-password-finderzip-password-finder 目前支持 ZipCrypto 和 AES 两种加密方式，通过多线程进行加速，支持字典破解和暴力破解两种方式，详细内容可以参考其博客和 github：\nblog1\nblog2\ngithub 地址\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-04 23:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 rust 实现 Zip 密码破解工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "性能和并发性是开发人员在为其项目选择编程语言时考虑的两个关键因素。目前在这方面越来越受欢迎的语言包括Rust、Go和Swift。这些语言旨在提供高性能和高效的并发性，使它们成为构建需要速度和可扩展性的现代应用程序的理想选择。在本文中，我们将探讨Rust、Go和Swift在性能和并发性方面的差异，并帮助您决定下一个项目使用哪种语言。原文链接https://programmingeeksclub.com/what-are-the-differences-between-rust-go-and-swift-in-terms-of-performance-and-concurrency/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-03 18:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust、Go 和 Swift 在性能和并发性方面的区别" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Spaceman 是一个跨平台的 gRPC 客户端, 旨在使用愉悦, 外观漂亮. 它既可以作为桌面GUI, 也可以作为CLI使用. 它的主要用途是手动测试和调试gRPC服务器: 只需加载Protobuf描述符, 选择请求, 填写输入消息正文并发送即可.github 地址https://github.com/eliaperantoni/spaceman" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-03 18:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "spaceman: 跨平台的gRPC客户端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "受 bytes 的启发, 该 crate 提供了零拷贝字符串切片, 做的事情和 bytes 一样, 只不过是作用于string.github地址https://github.com/xfbs/imstr" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-03 18:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "imstr: Immutable strings" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文描述了如何 Rust移植到 WinChipHead CH32V003 微控制器的过程.原文链接https://noxim.xyz/blog/rust-ch32v003/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-03 18:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "移植 Rust 到 CH32V003" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，我们很高兴地宣布 2023 年 UARust 大会。与 14 位领先的 Rust 专家会面🦀 分享他们的见解和预测。我们的演讲者包括《Zero To Production In Rust》一书的作者 Luca 和 Veloren 的核心开发人员之一 Christof Petig。加入在线会议https://uarust.com/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-02 21:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "乌克兰 Rust 会议 2023 - 4 月 8 日" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我学习 Rust 有一段时间了，终于写出了我的第一个小程序。它的诞生源于我对一些程序的烦恼，我在 Windows 上到处使用不断乱扔点文件，但不会自动隐藏。它可以搜索和监视多个目录，使用基于 glob 和正则表达式的匹配，并且具有无限期监视目录变化的模式。它肯定有一些我不太满意的地方，比如一些错误处理丢失的边缘情况，想要避免 Arc 但发现它有必要，以及一些我无法绕过的克隆。https://github.com/Echaleon/cloak" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-02 21:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我的第一个实际 Rust 程序：Cloak，一个用于搜索和监视目录以自动隐藏文件和目录的简单应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "嘿，所以当我最初发布 FileSorterX 时，我得到了很多反馈，甚至还有一些人与我在项目上合作；我不能说我是多么感谢我得到的所有支持和建议。我认为如果我分享最新版本 (1.2.0) 和自 1.0.0 以来的所有主要更改会很好如果您试用新版本，请务必让我知道您的想法，并再次感谢您对该项目的所有支持。Github , Crates.iohttps://github.com/Xanthus58/FileSorterX-Changelog->添加：基准命令/功能> 新增：更高效的代码/加速应用程序> 新增：多个新的文件扩展名> 新增：排序命令的自定义目录标志> 新增：更详细的目录结构> 新增：更好的帮助文档> 添加了 customsort 命令/行为，现在用户/程序员可以指定他们想要清理的内容。> 添加了一个选项来自我更新应用程序（仅限 Windows）> 添加了使用创建标志选择生成多少文件的功能> 新增全新的cli界面> 添加：创建命令现在将使用我们数据库中的所有文件类型" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-02 21:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "FileSorterX 进展如何" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Navi 是一个用 Rust 实现的高性能、多功能的机器学习服务器，专门用于生产使用。它的设计是为了有效地服务于 Twitter 的技术堆栈，提供一流的性能，同时专注于核心功能。主要功能：\n\n最简设计优化的生产用例: Navi 提供超高性能，稳定性和可用性，设计处理现实世界的应用程序需求，简化的代码库。\n\n\nTensorFlow 兼容的GRPC API: 通过其 gRPC API 与现有 TensorFlow 服务客户端无缝集成，使得在生产环境中易于集成、平稳部署和扩展成为可能。\n。。。\n\n最简设计优化的生产用例: Navi 提供超高性能，稳定性和可用性，设计处理现实世界的应用程序需求，简化的代码库。TensorFlow 兼容的GRPC API: 通过其 gRPC API 与现有 TensorFlow 服务客户端无缝集成，使得在生产环境中易于集成、平稳部署和扩展成为可能。。。。文章链接，https://www.reddit.com/r/rust/comments/127xwu1/twitter_open_sources_navi_highperformance_machine/Github 链接，https://github.com/twitter/the-algorithm/blob/main/navi/navi/README.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/twitter/the-algorithm/blob/main/navi/navi/README.md" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-01 21:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Navi: Rust开发的高性能机器学习服务器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我最近注意到 Rust 的一个名为 Bevy 的游戏编程框架，它使用一个名为 ECS (实体组件系统)的编程模型。据称，Bevy ECS 以一种复杂的方式使用 Rust 的类型系统来自动并行执行游戏逻辑，同时避免竞态条件。ECS 的想法显然已经存在了一段时间 ，但它对我来说是新的。好奇Bevy是否会像他说的那么酷，刚好最近读了《Newton’s Gift》，我决定使用Bevy实现一个n体模拟器。文章链接，https://bagnalla.github.io/posts/newton_bevy.htmlGithub 链接，https://github.com/bagnalla/newton_bevy" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/bagnalla/newton_bevy" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-01 21:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Bevy ECS的经历" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 Bezier-rs 库的交互式文档。查看详细的函数描述和 API 使用的文档。单击并拖动演示曲线的端点，以可视化方式操作各种 Bezier 函数。文章链接，https://graphite.rs/libraries/bezier-rs/Github 链接，https://github.com/GraphiteEditor/Graphite/tree/master/libraries/bezier-rshttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/GraphiteEditor/Graphite/tree/master/libraries/bezier-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-01 21:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bezier-rs: 用于贝塞尔曲线的计算几何算法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "garde 是对 validator crate 的重写。全面重写的原因在于 validator 在底层实现上存在一些问题。它使用普通函数来实现其验证规则，这意味着很难将这些规则用于自定义新类型和第三方 crate 类型之上。这项工作是为了响应 validator 作者对维护的帮助呼吁而开始的，TA 也多次表达了对全面重写的渴望。crates.io - garde: https://crates.io/crates/gardegithub - jprochazk/garde: https://github.com/jprochazk/garde" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jprochazk/garde" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-01 08:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "项目：garde" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目前，对于 Cargo 项目来说，定义 Dockerfile 并跳过在任何源代码更改后重新构建依赖项并不容易。这意味着每个 Cargo 项目的 Docker 构建可能会非常缓慢，并且无法充分利用 Docker 层缓存。这篇文章对 cargo build --dependencies-only 的动机，现有解决方法，先前的技术和可能的解决方案进行总结。原问题关注“提供一个Cargo命令来构建项目依赖项”，但并没有充分描述主要问题。而文中将其关注点变更为“修改 Cargo 以更好地支持 Docker 层缓存” 进行了深入的讨论。https://github.com/rust-lang/cargo/issues/2644Article - Better support of Docker layer caching in Cargo: https://hackmd.io/jgkoQ24YRW6i0xWd73S64AExploring the problem of faster Cargo Docker builds: https://www.reddit.com/r/rust/comments/126xeyx/exploring_the_problem_of_faster_cargo_docker/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/126xeyx/exploring_the_problem_of_faster_cargo_docker/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-01 08:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "文章：Better support of Docker layer caching in Cargo" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 488: https://this-week-in-rust.org/blog/2023/03/29/this-week-in-rust-488/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/03/29/this-week-in-rust-488/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-04-01 08:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 488" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "4 月 8 日下午的北京线下 Rust Meetup 活动开始报名了，地点在 环球财讯中心北京市西城区宣武门外大街甲 1 号，二号线宣武门站，报名链接： https://www.meetup.com/rust-chinese-group/events/292379002ReadMore:https://www.meetup.com/rust-chinese-group/events/292379002" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.meetup.com/rust-chinese-group/events/292379002" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-30 11:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "北京线下 Rust Meetup 活动" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者的一个核心Python库出现了性能问题，它使用NumPy和其他科学计算的Python包来进行数学和几何操作。作者使用 Rust 写了接口使得性能得到了巨大的提升。Github:https://ohadravid.github.io/posts/2023-03-rusty-python/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ohadravid.github.io/posts/2023-03-rusty-python/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-30 11:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用不到 100 行的 Rust 使 Python 快 100 倍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ngrok-rs让开发者可以在互联网上提供服务，而不需要做一些繁琐的设置，如IP、NAT、证书、负载均衡器，甚至端口！ReadMore:https://ngrok.com/blog-post/ngrok-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ngrok.com/blog-post/ngrok-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-30 11:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ngrok-rs - Rust 版本的 ngrok" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "让我们假设我们想为 x86_64 的 Linux 制作一个二进制文件，它应该是非常便携的。它期望能在 Debian 和Arch Linux 上工作。它应该能在没有 glibc 的系统上工作，比如 Alpine Linux。它甚至应该在 FROM scratch Docker 容器中工作。在一个更严肃的环境中，你会把 musl-libc 和你的 Rust 程序静态连接起来，但今天我们要尝试在没有libc 的情况下工作。我们还将使用Rust，更确切地说，是 Rust 的稳定版，所以这篇博文不会使用 任何夜间版的功能。如果你使用的是 Rust 1.0 版本或更高版本（根据我的电脑，>=1.68.0），你应该可以很好地尝试这个方法。最终代码：编译方式：ReadMore: https://vulns.xyz/2023/03/linux-executable-from-scratch-with-x86_64-unknown-none-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://vulns.xyz/2023/03/linux-executable-from-scratch-with-x86_64-unknown-none-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-29 17:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 从零写一个可执行程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者从多个方面阐述了对 Zig 和 Rust 这两门语言的看法，最终总结来看\nRust是关于组合安全的，它是一种比 Scala 更可扩展（scalable）的语言。\nZig是关于完美的。它是一个非常 Sharp、危险，但更灵活的工具。\nReadMore: https://matklad.github.io/2023/03/26/zig-and-rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://matklad.github.io/2023/03/26/zig-and-rust.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-29 17:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Zig and Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ReadMore: https://rust.extension.sh/changelog/#v1-10-0-2023-03-25" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust.extension.sh/changelog/#v1-10-0-2023-03-25" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-29 17:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Search Extension v1.10.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个油管视频,介绍如何使用 itertools 库来让 迭代器更快.油管视频github 地址https://www.youtube.com/watch?v=qY9j4dRaMjU" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-27 18:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 itertools 让迭代器快 10 倍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个关于 Ferrous Systems 如何使用QNX Neutrino构建嵌入式世界演示的博客文章.QNX Neutrino 是一种在汽车行业中比较受欢迎的POSIX兼容实时操作系统。这篇文章详细介绍了他们如何使用Rust编写代码，并将其编译成QNX可执行文件，以及如何在嵌入式设备上运行它。原文链接https://ferrous-systems.com/blog/how-we-built-our-embedded-world-demo-on-rust-for-qnx/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-27 18:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何在 QNX 上使用 Rust 构建嵌入式世界" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文介绍了 AsRef 和 Borrow trait 这两者的区别, 以及何时我们应该使用他们.原文链接https://rusty-ferris.pages.dev/blog/asref-vs-borrow-trait/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-27 18:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "AsRef vs Borrow trait" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者相信发布 generators 语法会使编写命令式迭代代码变得容易，特别是使迭代代码与异步性能够更良好地交互，从而解决许多用户问题。不过令作者沮丧的一件事是，generators 已经准备好发布多年了，但几乎没有什么可见的进展.文章中作者写了自己对 generators 的看法,并且希望收集大家的意见和反馈.原文链接https://without.boats/blog/generators/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-27 18:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Generators" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Crossbus 是一个Rust库，用于无平台、无运行时的基于Actor的计算，是Actor计算模型的一种实现，crossbus的概念是crossbus既不为下游应用程序执行提供运行时，也不访问系统接口。去除运行时并不意味着没有运行时，而更确切地说，没有内置运行时，但允许使用任何运行时。目前刚刚发布.github地址https://github.com/hominee/crossbus--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-27 18:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "crossbus: 无平台、无运行时的Actor实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "说实话，小编我属实没想到 Rust 居然有这么多编辑器了：链接：https://www.reddit.com/r/rust/comments/121l4ek/editors_written_in_rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-26 23:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust实现的编辑器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该库实现了PostgreSQL Wire协议，并提供了编写PostgreSQL可组合服务器和客户端的基本API。Postgres Wire Protocol 是一种相对通用的第 7 层协议。协议有 3 个部分：\n启动：客户端-服务器握手和身份验证。\n简单查询：postgresql 的遗留查询协议。查询以字符串形式提供，并且允许服务器在响应中流式传输数据。\n扩展查询：用于查询的新子协议，能够在服务器端缓存查询并使用新参数重用它。响应部分与简单查询相同。\n另请注意，Postgres Wire Protocol 没有关于 SQL 的语义，因此从字面上看，可以使用任何查询语言、数据格式甚至自然语言与后端进行交互。响应始终编码为数据行格式。并且有一个字段描述作为数据的标题，用于描述其名称，类型和格式。GitHub：https://github.com/sunng87/pgwire" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-26 23:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pgwire" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "体现KISS理念的工具，可让以超快速度截取网页/ URL的屏幕截图。会在当前目录生成一个包含网页截图的文件夹。主要特点是可以同时截取多个网页。GitHub：https://github.com/bytehunt/haylxon" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-26 23:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "haylxon" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果希望 Rust 成为桌面应用程序的开发语言，就需要让 Rust GUI 的使用更加安全。目前为止，Rust 在这方面已经做得相当好了。有 winit 用于设置窗口，虽然它缺少一些一流 GUI 系统必要的功能，但可以容易地实现这些功能。有 wgpu 用于 GPU 加速的绘制和 softbuffer 用于解决软件渲染的问题。所有这些包都提供安全的 API。但当一起使用它们时，仍然存在不安全。这篇文章希望改变这种情况，提出了一个用 Rust 开发安全窗口句柄的提案。博客原文链接，https://notgull.github.io/safe-windows/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://notgull.github.io/safe-windows/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-25 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 开发安全窗口句柄的提案" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "stabby 是创建应用二进制接口 ABI 的一站式工具，使用 stabby 的主要方式是用 #[stabby::stabby] 这个宏。stabby 链接，https://crates.io/crates/stabby" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-25 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "stabby：一个稳定的 Rust 应用二进制接口" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GitHub链接，https://github.com/bytehunt/haylxonhttps://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-25 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Haylxon：一个极快的抓取网页屏幕截图的工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Bristol大学的研究人员（看论文名字都是华人），利用Rust的所有权概念，研发了一个静态所有权分析工具：Crown, 将C指针安全地转换为Rust代码。目前尝试在真实世界中使用，转换50w行代码只需要10秒。论文地址：https://arxiv.org/pdf/2303.10515.pdf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://arxiv.org/pdf/2303.10515.pdf" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-25 12:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "利用所有权分析将C代码安全地转换到Rust代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用Rust和Wasm基于WebRTC实现了会议工具。在两个浏览器tab页输入同一个地址就可以视频了。目前还是原型阶段。https://github.com/williamlsh/meeting.rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/williamlsh/meeting.rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-25 12:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "meeting.rs 在线会议" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "通用库的意思就是可以几乎给所有语言使用的库，当然，使用的是WASM中间介质。及配合wasmer定义的插件规范。https://www.youtube.com/watch?v=uKlHwko36c4" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=uKlHwko36c4" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-25 12:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "wasmer 的宣传：使用Rust构建通用库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "爱丁堡的科研人员在HPC上做了Rust,Fortran, C的对比（实现流体模拟）。然后今天开源了， 代码写得相当糟糕，被吐曹了。https://github.com/lmoran94/eurocc_cfd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/lmoran94/eurocc_cfd" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-25 12:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust in HPC" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 1.68.1发布，修复了一些回归问题。主要修复了以下问题：\nRust CI对于Windows MSVC编译器的构建方式，不再对Rust代码启用LTO。这导致了一个误编译，现在Rust团队正在进行调试，同时回滚到启用LTO。\n编译器构建中 --enable-local-rust 的修复。\n编译器中的其他崩溃修复。\n如果之前已经通过rustup安装了Rust，可以使用以下命令更新到1.68.1版本：更多细节可以在GitHub上查看详细的发布说明：https://blog.rust-lang.org/2023/03/13/Rust-1.68.1.html。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2023/03/13/Rust-1.68.1.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-24 12:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.68.1发布，修复了回归问题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在“如何加速 Rust 编译器”系列的第15篇文章中，作者讨论了其他人最近对 Rust 编译器进行优化的改进。具体如下：\nPR #107449: @saethlin 启用了一个名为 CopyProp 的现有 MIR 优化通道，这导致所有基准测试结果的平均墙时减少了0.54％，并且所有优化的主要基准测试结果减少了0.83％。这是一项相对简单的改进，但需要进行大量挖掘才能发现。在链接的 Mastodon 帖子中，还有关于 @saethlin 进行的其他 MIR 改进的信息。\nPR #108815: @the8472 改进了约束处理，导致 keccak 上的墙时减少了10-12％，cranelift-codegen 上的墙时减少了1-3％。令人印象深刻的是，这是在已经有高度优化的快速路径的基础上添加了一个非常快的路径。\n这些改变显着提高了 Rust 编译器的性能。详情请见：How to speed up the Rust compiler in March 2023https://nnethercote.github.io/2023/03/24/how-to-speed-up-the-rust-compiler-in-march-2023.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-24 12:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何在2023年3月加速 Rust 编译器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust周报487期This Week in Rust 485: https://this-week-in-rust.org/blog/2023/03/22/this-week-in-rust-487/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/03/22/this-week-in-rust-487/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-24 12:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust本周报487期" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "“sqlx 真的很好，但是你肯定会受到编译时间的影响”。在我以前的工作中大量使用 sqlx 之后，这确实引起了我的共鸣。 即使使用 Ryzen 3700，\"cargo check\" 时间也从 5 秒增加到 10 秒再到 20 秒，虽然 cargo sqlx prepare 远程数据库是休息一下的好借口。 但是我们必须做点什么…… -- CosmicHorror文章说的问题出现在 sqlx v0.5-v0.6 上, sqlx 的主要卖点之一是它可以针对实际数据库执行编译时查询检查。这意味着如果你有这样的代码：并使用 DATABASE_URL env var 设置为您的数据库 URL 进行编译，然后它将在编译时连接到数据库以验证查询是否有效以及 Rust 类型是否与数据库的返回类型匹配。 如果您的查询无效，或者您的数据库类型与其对应的 Rust 不匹配，那么您将遇到编译时错误。当然，每次构建时都需要数据库连接可能会很麻烦（例如在 CI 中），因此 sqlx 还提供了进行离线构建的选项。 您只需将“offline”功能添加到 sqlx，现在您可以使用 sqlx-cli 中的 cargo-sqlx 准备一个 sqlx-data.json 文件来描述您的所有查询。现在，您的项目可以使用 sqlx-data.json 中的信息进行构建，而无需实时连接到数据库。在编译时连接到数据库是人们在谈论 sqlx 时通常提到的那种 proc-macro (ab) 用法。它是把双刃剑。在编译时启用离线模式时，67.5% 的时间被 expand_crate 占用了，似乎让 sqlx 成为了一个非常大的焦点，但是它在做什么占用了这么多时间？ 然后作者的目光落在了那个约 500 KiB 的 sqlx-data.json 文件上，500 KiB 并没有那么大它可能真的处理得很差？JSON 打印得很漂亮。也许如果我们压缩它-22% 的变化是巨大的，但现在留下了为什么 JSON 解析如此缓慢的问题。即使 sqlx 正在做一些非常糟糕的事情，比如为每个宏重新读取整个文件，那么仍然只有几百个查询。497 KiB * 203 查询结果为98.5 MiB，这对于优化的 JSON 解析器来说应该不算什么。cargo 使得改变我们构建依赖关系的方式变得足够容易。为什么不将其设置为对所有与 proc-macro 相关的位进行优化构建？那应该会加快很多事情。查阅文档 ，我们看到我们可以通过添加对所有 proc-macros 及其依赖项进行优化构建https://doc.rust-lang.org/cargo/reference/profiles.html#build-dependencies我们再次执行这样就又快了 12 秒，至此我们为这个问题打上一个创可贴。作者还在文章中对 sqlx 的代码层面对 json 解析进行了优化，并添加了缓存，使得在此基础上又快了 1s 。目前代码已经合并到了 sqlx 的更高版本中。PR地址https://github.com/launchbadge/sqlx/pull/1684\nhttps://cosmichorror.dev/posts/speeding-up-sqlx-compile-times/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-23 14:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "sqlx 真的很好，但是你肯定会受到编译时间的影响" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用于使用 GPT-3 编写提交消息的 git prepare-commit-msg 挂钩。使用此工具，您可以轻松生成清晰、全面和描述性的提交消息，让您专注于编写代码。\nhttps://github.com/zurawiki/gptcommit\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-23 14:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gptcommit -- 可以想 gpt3 提交代码的 git hook" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Adam Chalmers 是 cloudflare 的一名 Rust 工程师，几年来一直使用 Rust 进行后端服务开发。他在一篇博客中，分享了自己日常工作中使用 Rust 使用的一些经验，以及为什么选择 Rust 而非其他的高级语言的原因，例如：Adam Chalmers 同时介绍说，在 cloudflare，几乎大多数性能敏感服务都会使用 Rust，只有对性能不那么敏感的服务，才会选择 Golang 等语言，实际选择时，还是应该做好权衡。详细内容请参考博客原文https://blog.adamchalmers.com/why-rust-on-backend/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-21 22:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么在后端服务中使用 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "过去的两年的编程经历中，作者看到了数篇文章，都旨在说明 Range 这种数据类型的缺陷。https://ridiculousfish.com/blog/posts/least-favorite-rust-type.html因此作者参照 itertools 的设计，构建了 rangetools 这个库，为 Range 实现了很多扩展方法，带来了很多的便捷性。crates.io 链接https://crates.io/crates/rangetoolsgithub 链接https://github.com/rsnively/rangetools" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-21 22:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rangetool 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在这篇文章中，作者分享了他用WebAssembly和Rust为浏览器创建一个贪吃蛇游戏的经验。原文链接https://medium.com/comsystoreply/creating-a-small-game-with-webassembly-and-rust-20c6945efa1d在线 demohttps://wasm-rust-snake.github.io/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-20 20:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用WebAssembly和Rust创建一个小游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "再过去的几个月里,作者一直在开发一个静态分析工具，叫做klint，它能够在编译时检测内核代码中可能导致死锁或数据竞争的原子上下文违规.原文链接https://www.memorysafety.org/blog/gary-guo-klint-rust-tools/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-20 20:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Klint：内核开发中的原子上下文违规的编译时检测" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "BonsaiDb 是一个新的数据库，旨在成为最适合开发者的Rust数据库. 今天是BonsaiDb初始提交的两周年纪念日, 作者详细介绍了什么是 BonsaiDb 以及他的功能.原文链接https://bonsaidb.io/blog/two-year-anniversary/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-20 20:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "BonsaiDb两周年" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "endtree 是一个现代的,多线程的文件树可视化和磁盘使用分析工具，它默认遵循隐藏文件和.gitignore规则.目前1.6 版本发布.github地址https://github.com/solidiquis/erdtree--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-20 20:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "endtree: 1.6.0 版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "不同工具和软件的 Rust 替代，目前已收集 30 多个小工具。主页：https://oxidizeyour.life/GitHub：https://github.com/kfirfitousi/oxidize-your-life除此之外，还有几个：GitHub：https://github.com/TaKO8Ki/awesome-alternatives-in-rustGitHub：https://github.com/ibraheemdev/modern-unix" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-19 20:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "oxidize：Rust工具集" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Mindot 是一个简单小巧的 dot 文件管理器，它复制当前目录中的 dot 文件以共享它们。使用场景：\nmindot add file1 file2 添加备份。\n使用 mindot backup <path> 将文件复制到其他地方并推送到 GitHub。\n在新机器上使用 mindot restore 将它们复制回来。\nGitHub：https://github.com/0xfederama/mindot" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-19 20:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mindot：dot文件管理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "演示：https://www.reddit.com/r/rust/comments/11ulldz/media_announcing_tarsila_010_pixel_art_and/GitHub：https://github.com/yds12/tarsila" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-19 20:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tarsila：像素编辑" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "将此项目与数据库文件的脱机副本一起使用。示例：GitHub：https://github.com/fernandobatels/rfirebird" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-19 20:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rfirebird：数据库文件工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Jetro 提供了一个自定义 DSL，用于转换、查询和比较 JSON 格式的数据。它易于使用和扩展。示例如下：GitHub：https://github.com/mitghi/jetro" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-19 20:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "jetro：JSON工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Syn 是一个Parser库，用于将 Rust token流解析为 Rust 源代码的语法树。这个版本包含了一批语法树的改进，包含了自 syn 1以来的过去3.5年中一直进行的 Rust 语言发展。文章链接，https://github.com/dtolnay/syn/releases/tag/2.0.0Github 链接，https://github.com/dtolnay/syn" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/dtolnay/syn" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-19 11:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "syn v2.0.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个可以让你舒适的监听网络流量的应用。多线程、跨平台new feature:\n增加了 GUI 的新翻译（德语，简体中文，乌克兰语），使支持的语言总数达到8种\n增加了键盘快捷键，使整个体验更加愉快和高效:\nGithub 链接，https://github.com/GyulyVGC/sniffnet/releases/tag/v1.1.2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/GyulyVGC/sniffnet/releases/tag/v1.1.2" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-19 11:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Sniffnet v1.1.2" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好！这是我的第一个主要的 Rust 项目，我已经工作了相当长的一段时间。我决定这样做，因为我找不到一个密码管理器，可以适合我的喜好。最初是用 C 语言实现的，为了学习这门语言，我在 Rust 中对它进行了改进。文章链接，https://www.reddit.com/r/rust/comments/11v4tbd/passrs_an_encrypted_data_manager/Github 链接，https://github.com/Swarthe/pass-rshttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Swarthe/pass-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-19 11:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pass-rs: 加密的数据管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者详细实现了一些并行map算法，用Rust和zig分别实现，并做了一些对比。https://zigurust.gitlab.io/blog/naive-map/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://zigurust.gitlab.io/blog/naive-map/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-18 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "并行map在Rust和zig中的对比实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "快人一步，API产品就具有巨大优势。Climatiq使用了Fastly的边缘计算服务，跑Rust生成的wasm代码。https://www.gustavwengel.dk/how-we-keep-the-climatiq-api-fast" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.gustavwengel.dk/how-we-keep-the-climatiq-api-fast" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-18 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust和Webassembly帮助Climatiq降低了请求延迟" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "其实就是加各种颜色，作者探讨了几个库的选择。https://epage.github.io/blog/2023/03/anstream-simplifying-terminal-styling/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://epage.github.io/blog/2023/03/anstream-simplifying-terminal-styling/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-18 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何让你的终端程序亮起来" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "很简单的一个分享。但是实用。初学的话可以照着做。https://spacedimp.com/blog/using-rust-axum-postgresql-and-tokio-to-build-a-blog/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://spacedimp.com/blog/using-rust-axum-postgresql-and-tokio-to-build-a-blog/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-18 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust,Axum, Postgresql, Tokio创建一个博客" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "with_dir 是一个轻量、快速的实用库，支持临时变更当前工作目录。crates.io - with_dir: https://crates.io/crates/with_dirgithub - huwper/with_dir: https://github.com/huwper/with_dir" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/huwper/with_dir" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-17 01:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "项目：with_dir" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 Rust 语言团队设计会议上，回顾了 Niko Matsakis 写的关于 Temporary lifetimes 的文档，并且考虑如何在 Rust 2024 Edition 中如何解决一些毛刺。这篇文章是 Lang 团队审阅的文档副本。Article - Temporary lifetimes: https://smallcultfollowing.com/babysteps/blog/2023/03/15/temporary-lifetimes/Reddit - Temporary lifetimes by Niko Matsakis: https://www.reddit.com/r/rust/comments/11sfjd5/temporary_lifetimes_by_niko_matsakis/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/11sfjd5/temporary_lifetimes_by_niko_matsakis/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-17 01:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "文章：Temporary lifetimes" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 486: https://this-week-in-rust.org/blog/2023/03/15/this-week-in-rust-486/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/03/15/this-week-in-rust-486/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-17 01:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week In Rust 486" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "object 提供了一个统一的接口来跨平台处理目标文件。 支持读取目标文件和可执行文件，支持写入COFF/ELF/Mach-O目标文件和ELF/PE可执行文件。对于读取文件，它提供了多个级别的支持：\n\n适用于零拷贝访问的原始结构定义\n\n\n用于访问原始结构的低级 API\n\n\n一个更高级别的统一 API，用于访问目标文件的共同特征，例如部分和符号\n支持的文件格式：ELF、Mach-O、Windows PE/COFF、Wasm 和 Unix 存档。\n\n\nhttps://github.com/gimli-rs/object/blob/master/crates/examples/src/objdump.rs\n\n适用于零拷贝访问的原始结构定义用于访问原始结构的低级 APIhttps://github.com/gimli-rs/object/tree/master/crates/examples/src/readobj一个更高级别的统一 API，用于访问目标文件的共同特征，例如部分和符号支持的文件格式：ELF、Mach-O、Windows PE/COFF、Wasm 和 Unix 存档。https://github.com/gimli-rs/object/blob/master/crates/examples/src/objdump.rshttps://github.com/gimli-rs/object/blob/master/crates/examples/src/objdump.rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-15 20:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "object -- 用于读写目标文件格式的统一接口" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "🥳CnosDB Rust课程精彩继续🥳本期主题：设计模式进入下一轮学习啦，大家准备好了吗？👾本节课我们将学习如何使用Rust实现设计模式Make Some Noise!🤡有趣的知识，等你来发掘~Rust课程，🤠 本周三，03.15晚7点😈 大家依旧相约直播间https://live.bilibili.com/23768194" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-15 20:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "CnosDB" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我试图让 LLaMA 语言模型在纯 CPU实现上工作，灵感来自于这里的一个很棒的CPU实现：https://github.com/ggerganov/ggml，它可以运行GPT-J 6B模型。在我的蹩脚的 OpenCL 的代码下，我的GTX 3090上可以实现每个 Token 耗时 270毫秒。在Ryzen 3950X上使用纯 CPU 和 OpenCL，我可以使每个 Token 700ms左右。而在没有任何 OpenCL 的情况下，只用纯Rust代码，加上我手写的一些 AVX2 实现，每个令牌大约1秒。所有这些都运行在LLaMA-7B模型上。ReadMore: https://github.com/Noeda/rllama" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Noeda/rllama" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-14 17:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust实现的纯 CPU 运算的 LLaMA 模型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "sqlx真的很好，但你肯定会对编译时间印象深刻。即使使用Ryzen 3700，cargo check 也需要比较长的时间才能运行结束，而这成了一个喝咖啡休息的好借口。我想要看下到底在这背后发生了什么。ReadMore: https://cosmichorror.dev/posts/speeding-up-sqlx-compile-times/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://cosmichorror.dev/posts/speeding-up-sqlx-compile-times/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-14 17:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Sqlx 编译速度分析" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章是高阶一点的针对 Rust 编码风格的讨论（因为它没有涉及到具体的细节），部分灵感来自于面向数据的设计，部分灵感来自于基于ML的函数式编程语言，我认为这很自然地适用于Rust，并使得 API 更人性化且灵活易于扩展。这不是什么高级的东西，但我希望这对刚接触Rust的人起到一些作用。ReadMore: https://tzemanovic.gitlab.io/posts/rust-coding-style/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://tzemanovic.gitlab.io/posts/rust-coding-style/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-14 17:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust编码风格" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "YiiSh" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "直接上链接https://github.com/mokeyish/smartdns-rshttps://github.com/mokeyish/smartdns-rs/blob/main/README_zh-CN.md软件是移植 c 版(因为其仅支持 Linux)的，目前已完成大部分功能，并且在自己的苹果电脑上正常使用几个月了。个人感觉比较有用的几个功能是：\n支持 DoH(DNS over HTTPS)，DoT(DNS over TLS)这样，电脑就没有明文的DNS 流量发出了，不会被路由器测监控到具体访问的网站域名\n支持域名分流和 ping，https 测速，国内的用阿里云的，国外网站用 cloudflare 的，提升上网的速度。\n域名预读取功能，常用网站自动后台查询更新，这样每次浏览器查询到缓存的就是 0 毫秒，响应速度极快，避免了采用加密的 DoH 带来的性能损失。\n最后一个就是去广告了，下载广告域名列表，对这些域名屏蔽解析。\n有时候运营商的 DNS 会篡改解析结果，比如广东电信的，会屏蔽 Github 的域名，下面命令查出的是 0.0.0.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-14 00:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是作者所在的团队在多年之后, 使用 Rust重写CLI的故事. 是否值得用 Rust 重写呢? 估计很多人有同样的疑问. 作者最后给出了答案, 并且描述了他们在重写过程中碰到的问题.原文链接https://blog.railway.app/p/rust-cli-rewrite" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-13 18:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust重写CLI,是否值得?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个对是否需要把 trait 标记为 async 的思考和讨论.原文链接http://smallcultfollowing.com/babysteps/blog/2023/03/12/to-async-trait-or-just-to-trait/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-13 18:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async trait还是只使用trait" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个由 ChatGPT驱动的过程宏,该过程宏可以在编译时生成代码。例子github 地址https://github.com/retrage/gpt-macro" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-13 18:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gpt-macro: ChatGPT 宏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个 Bevy的教程视频, 本节主要讲解 Enemy Movement, Collisions, Sound Effects, Despawning 这些概念以及用法.油管视频https://www.youtube.com/watch?v=4TjEo-gDgAg--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-13 18:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy教程: Enemy Movement, Collisions, Sound Effects, Despawning" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "链接：https://rustmagazine.org/issue-2/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-12 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust杂志第二期" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "crux 可帮助用户跨移动设备（iOS 和 Android）和 Web 共享应用的业务逻辑和行为。分享：https://www.youtube.com/watch?v=cWCZms92-1gGitHub：https://github.com/redbadger/crux/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-12 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "crux：跨平台APP开发" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个命令行时间跟踪工具，可手动或自动跟踪活动。GitHub：https://github.com/mariodujic/track-time" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-12 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "track-time：时间跟踪" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "解压缩工具，支持并行，自动编码检测。GitHub：https://github.com/quininer/unzrip" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-12 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "unzrip：unzip替代品" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "halp 旨在通过检查常用选项/标志的预定义列表来帮助找到命令行工具的正确参数。此外，它还提供了快速访问给定命令的手册页或备忘单的提示。假设有这样一些历史记录（你不知道帮助文件或版本的 flag）：然后使用 halp：还可以借助 plz 子命令查看相应帮助文档（直接能查cheat sheet）：GitHub：https://github.com/orhun/halp" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-12 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "halp：帮助之帮助" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个命令行的天气预报，常用参数如下：GitHub：https://github.com/tobealive/wthrr-the-weathercrab" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-12 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "weathercrab：天气预报" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "duplicate，提供了用于通过变量替换来复制代码的宏。duplicate 链接，https://crates.io/crates/duplicate" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/duplicate" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-11 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "duplicate 发布 v1.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tiger 是一种使用 Tauri 构建的用于创作游戏 spritesheet 及其元数据的可视化工具。GitHub 链接，https://github.com/agersant/tiger" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/agersant/tiger" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-11 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tiger 发布 v1.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "当提到 CPU 使用率或时间时，它是以单个内核的百分比来衡量。使用 Rust 和 wgpu 构建一个屏幕保护程序，在 10,000 倍的播放速度下，CPU 使用率徘徊在 18-25% 左右，平均每秒渲染 500 万像素更新。它是如何工作的？请查看博客原文链接，https://maxisom.me/posts/rendering-5-million-pixel-updates-per-second" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://maxisom.me/posts/rendering-5-million-pixel-updates-per-second" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-11 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 和 wgpu 每秒渲染 500 万像素更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在这个视频中，从一个没有 CI 和仅有很少量测试的 Rust crate 开始，将它扩展为同时拥有这两者。YouTube 视频链接，https://www.youtube.com/watch?v=xUH-4y92jPghttps://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=xUH-4y92jPg" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-11 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【视频】为 Rust crate 搭建 CI 和属性测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "前几天发的Zed编辑器的新闻，现在可以试用了，目前只支持MacOS. 性能叼暴了，界面也很好看。快去寻找邀请码吧。目测是下一代要大火的编辑器。什么VSC之类的，弱爆了，太慢了。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-11 13:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Zed 编辑器，叼暴了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Greptime团队在开发greptime db的过程中，总结出来的一套在同步环境下调用异步代码的经验和实践模式，基于tokio. 供学习。https://greptime.com/blogs/2023-03-09-bridging-async-and-sync-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://greptime.com/blogs/2023-03-09-bridging-async-and-sync-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-11 13:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "架起异步和同步的桥梁" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用Rust技术栈和ScyllaDB, 快速地从AWS s3中拉取大数据文件，并灌入ScyllaDB中进行处理，并利用 tokio 和 Actix 提供快速的 REST 接口服务。整体实现了3到5倍的性能提升。https://www.scylladb.com/2023/03/08/rust-in-the-real-world-super-fast-data-ingestion-using-scylladb/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.scylladb.com/2023/03/08/rust-in-the-real-world-super-fast-data-ingestion-using-scylladb/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-11 13:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用ScyllaDB和完整的Rust技术栈开发真实世界的应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者记录了整个优化的过程。供参考。https://maxisom.me/posts/rendering-5-million-pixel-updates-per-second--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://maxisom.me/posts/rendering-5-million-pixel-updates-per-second" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-11 13:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust和wgpu实现每秒500w像素的渲染" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新版本发布了，有新的pin!宏在标准库稳定了，其他更新请看详情。https://doc.rust-lang.org/stable/std/pin/macro.pin.html详情: https://blog.rust-lang.org/2023/03/09/Rust-1.68.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2023/03/09/Rust-1.68.0.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-10 00:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.68发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是zed编辑器的技术推广文，zed开发团队是之前atom编辑器的团队，也是Electron框架的创始团队。不过因为某些原因atom已经宣布不再更新，现在他们专注于zed编辑器，一个用Rust开发的代码编辑器。值得关注的是，他们自己实现了一个UI框架，使用Rust，并且这个UI框架同时也是warp所使用的。目前还未开源，后续有开源计划。本文重点介绍他们实现的一些细节。详情: https://zed.dev/blog/videogame" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://zed.dev/blog/videogame" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-10 00:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "利用Rust和GPU以120FPS的速度渲染用户界面" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者自己的初创企业使用Rust作为主要的开发语言，本文介绍了他们选择Rust的一些想法。详情: https://cloak.software/blog/i-built-startup-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://cloak.software/blog/i-built-startup-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-10 00:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个使用Rust的初创公司" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "无船大大的新博文，概述了他对2023年Rust设计的一些想法，特别是async相关的。详情:https://without.boats/blog/the-registers-of-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://without.boats/blog/the-registers-of-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-10 00:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "The Registers of Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust周报485期This Week in Rust 485: https://this-week-in-rust.org/blog/2023/03/08/this-week-in-rust-485/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2023/03/08/this-week-in-rust-485/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2023-03-10 00:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust本周报485期" }, "type": "text" }], "type": "title" } },]
