export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个小而快速的 rust 工具，它可以模糊图像，具有很酷的功能，例如：\n比例因子\n缩小过滤器\n调整大小过滤器\n灰度缩放\n仅模糊特定区域\n当我锁定我的电脑或笔记本电脑时，我喜欢它对当前状态进行截图，模糊图像并将模糊图像设置为锁定屏幕。过去，我使用 convert 来模糊我的图像，但 convert 是一个如此糟糕的工具，它需要很长时间才能模糊图像（尤其是大图像）。所以，这个想法是在 Rust 中创建一个小工具。就是这样，只是一个模糊图像的小工具。:)最显着的区别之一是，转换需要 2 秒，并且会提升我所有的 16 个内核。CLIblur 只需要 460ms 并且在一个线程上运行。我还添加了一些很酷的功能和模糊效果，因此可以单独设置缩小和放大滤镜。:)如您所见，看到图像中的细节但无法解密字符串看起来很棒！<3您可以通过键入来安装它cargo install cliblur:)请告诉我，你觉得这个工具怎么样？:)二进制和源代码可以在这里找到：https ://gitlab.com/kerkmann/cliliblurhttps://gitlab.com/kerkmann/fastblurhttps://preview.redd.it/oejzr6enyh791.png?width=3840&format=png&auto=webp&s=a77bc272b10ec6aa0eb632320bbcdbdc424418cc" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-26 09:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fastblur - 一个带有一些很酷的功能和过滤器的小型模糊工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，好久不见。我很高兴终于能够说 0.9 的 lnx 在几个月不活动后终于出来了，我在为朋友构建网站后端时有点脱轨，并在 6 月做了一个相当愉快的关于 lnx 的技术谈话。就上下文而言，lnx 是 Elasticsearch 和 Aloglia 的快速替代品，用 Rust 编写并建立在令人惊叹的 Tantivy 库之上。在不牺牲性能的情况下提供实用性和易用性的良好组合。事实上，快速模糊系统使模糊文本搜索几乎与常规文本搜索一样便宜，在 10 核机器上每秒可能查看数万次查询.该代码位于https://github.com/lnx-search/lnx，该组织下包含各种其他工具和库，文档可在https://docs.lnx.rshttps://docs.lnx.rs/完整的变更日志可在 @ https://github.com/lnx-search/lnx/releases/tag/0.9.0获得关于它的小博客文章也可在 @ https://chillfish8.ghost.io/whats-new -in-lnx-0-9/https://chillfish8.ghost.io/whats-new-in-lnx-0-9/本月早些时候，我还在 Rust 伦敦聚会上做了一个技术演讲（也大大超过了时间限制），这可能会让任何无聊的人感兴趣：https ://www.youtube.com/watch?v =kzCYbZjJcTkhttps://www.youtube.com/watch?v=kzCYbZjJcTk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-26 09:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "lnx 0.9，像 Elasticsearch 和 Algolia 这样的快速搜索引擎已经出来了！+ 技术讲座" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "second-stack是一个切片的分配器，它不需要超过堆栈，但可能不适合堆栈本身。在内部，它是一个不断增长的堆栈。second-stack最初是为在 WebGL 中编写动态缓冲区而开发的（例如：程序生成一些三角形/颜色，将它们写入缓冲区，然后每帧多次将它们交给显卡，而不会产生许多堆分配的成本）。但是，随着时间的推移，我发现需要一个短暂的切片是很常见的，并且在second-stack所有地方使用可以实现最佳的内存重用和性能。潜在的进一步补充：\n放置非切片的大值\n释放 threadlocal 的 API（现在它在线程下降时被释放）\n全局启用/禁用功能标志，因此库可以毫无顾忌地使用它，但让应用程序决定它是否对其线程模型有意义。（禁用时，将为每个调用分配一个 Vec，但使用相同的外部 API）\n链接：\nDocs.rs\n板条箱.io\nGithub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-26 09:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "介绍第二栈" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们刚刚发布了 cross v0.2.2，这是一个用于交叉编译和测试交叉编译包的工具。我们上一次发布是在两年前，从那以后我们修补了许多 bug，添加了许多特性，并增加了新的目标。这是许多人的工作，而我只是其中的一小部分。我们破坏了你的工作流程吗? 如果破坏了，请给我们提issue。...文章链接，https://www.reddit.com/r/rust/comments/vk2xfc/cross_v022_released/Github 链接，https://github.com/cross-rs/cross" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/cross-rs/cross" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-26 00:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cross v0.2.2 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我在 Rust 中创建了第一个 CLI 应用程序。这是一个在终端上显示 Github 贡献图的命令。这是我第一次创建，所以我正在等待一个pr! ！文章链接，https://www.reddit.com/r/rust/comments/vke8dt/developed_a_cli_app_to_display_github/Github 链接，https://github.com/Ryu0118/Kusa" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Ryu0118/Kusa" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-26 00:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "开发了一个 CLI 应用程序来显示 Github 贡献图" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust for Linux 项目旨在将一种新的系统编程语言引入 Linux 内核。作为内核的第二语言，Rust 有一个非常有趣的特性: 它保证不会发生任何未定义行为(只要unsafe的代码是健全的) ，特别是在内存管理方面。这包括没有释放后使用的问题，不会重复释放内存，没有数据竞赛，等等。Prosimo 是互联网安全研究小组(ISRG)的一个项目。它的目标是通过使用内存安全语言解决 C 和 C + + 代码中的内存安全问题，从而改善因特网的安全敏感软件基础设施。这种基础设施的一个关键例子是 Linux 内核，它用于世界上大多数服务器以及数十亿个设备中。文章链接，https://www.memorysafety.org/blog/memory-safety-in-linux-kernel/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.memorysafety.org/blog/memory-safety-in-linux-kernel/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-26 00:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "世界上最大的软件项目的内存安全" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "（本日日报转自 TG频道 Rust 视界）" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-24 21:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本卷总分为 100 分，时间 30 分钟。开卷考试，资料仅限 Rust 标准库文档，禁止访问外部网站。本卷不附带标准答案，完成后请自行订正。https://zhuanlan.zhihu.com/p/532496013" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-24 21:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "来做unsafe rust 小测验 （一）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "7月7号会有四场 Rust 相关议题，可通过下面链接页面找到注册地址，线下观看https://mp.weixin.qq.com/s/nU6VS3T-T0TE1IJHaxSh5Q" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-24 21:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "会议预告 | 华为 2012 实验室全球软件技术峰会-欧洲分会场" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一系列推特，有小技巧，也有一些关键字现存的缺陷。as: x as T可以做有损的转换，所以如果你想让它失败时有提示（例如，如果一个u64不能转换到u32），最好选择T::try_from(x).expect(\"...\")。选译了其中一条，一共39条，感兴趣的可以去看原文：推特: https://twitter.com/jonhoo/status/1539661689880137728" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://twitter.com/jonhoo/status/1539661689880137728" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-23 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Jon Gjengset 的关键字小技巧系列" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大概就是你可以给那些经常使用的但是又臭又长的命令取一个别名保存到 again 里，然后用 again run 去调用别名即可。Github: https://github.com/MatteoNardi/again" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/MatteoNardi/again" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-23 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Again 一个用Rust构建的命令行别名管理工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust-PHF是一个使用完美哈希函数在编译时生成高效查找表的库。它目前使用CHD算法，可以在大约0.4秒内生成一个10万个条目的map。默认情况下不产生统计数据，但如果你设置了环境变量PHF_STATS，它就会发出一个关于所花时间的编译器注释。附带了一篇详细的博客：博客: https://simplabs.com/blog/2022/06/23/the-perfect-hash-function/Github: https://github.com/rust-phf/rust-phf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-phf/rust-phf" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-23 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust-PHF  用于Rust的编译时静态映射" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 448: https://this-week-in-rust.org/blog/2022/06/22/this-week-in-rust-448/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/06/22/this-week-in-rust-448/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-23 23:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 448" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "2022 WebAssembly 使用情况调查结果出炉，Rust作为对wasm最友好的语言，名副其实。采用率在不断攀升，并远远甩掉其它语言的占比。希望Rust继续完善wasm目标生态，成为未来20年的霸主。https://blog.scottlogic.com/2022/06/20/state-of-wasm-2022.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.scottlogic.com/2022/06/20/state-of-wasm-2022.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-21 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WebAssembly 2022 最新情况" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "不过现在项目还在很早的早期。可以关注，也仅仅是关注而已，做不了什么。https://www.fornjot.app/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.fornjot.app/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-21 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fornjot - 使用Rust开发的CAD程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文讲述了 mirrord 的蟹化过程（此处发明一个新名词：蟹化，指的是开始的时候不是用rust语言写的，然后通过一步一步演进，最终使用Rust重写的过程）。mirrord 是一个在云环境下运行本地进程的工具。https://metalbear.co/blog/carcinisation-of-mirrord-or-why-we-use-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://metalbear.co/blog/carcinisation-of-mirrord-or-why-we-use-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-21 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mirrord 的蟹化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Postcard 是在 no_std 下实现 serde 能力的一个库。专为资源受限环境而优化设计。现在发布了 1.0 版本。https://jamesmunns.com/blog/postcard-1-0/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://jamesmunns.com/blog/postcard-1-0/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-21 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Postcard 1.0.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "nvtx是 NVIDIA®Tools Extension SDK (NVTX)的 Rust binding, 使用该库,可以方便我们集成到 NVIDIA提供工具中(例如 NVIDIA®Tools),方便我们进行性能剖析.原文链接nvtx 的 Rust bindinghttps://simbleau.github.io/blog/gpu-profiling-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-20 20:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 使用NVTX 来做 GPU/CPU 性能分析" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "serde_json 我们经常会用到, 最常用的基本是两个:\nserde_json::from_str 返回 Result\nserde_json::to_string() 也返回 Result\nfrom_str 返回 Result 的场景很多, 但是  to_string 是不常见的, 作者用了几年之后才遇到.详细见原文.原文链接https://www.greyblake.com/blog/when-serde-json-to-string-fails/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-20 20:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "serde_json::to_string() 什么时候会失败" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rspleeter 是 rspleeter的 Rust 实现, 利用机器学习, 可以把一首歌切分为 人声和伴奏 两部分.github 地址https://github.com/ldm0/rspleeter" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-20 20:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rspleeter: spleeter 的 Rust 版本实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "FIM是一个文件监控工具，可以跟踪在您的文件上执行的任何事件github地址https://github.com/Achiefs/fim" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-20 20:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "fim: 文件监控工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果你的编辑器使用 rust-analyzer, 那么,可以通过相关的配置, 使 unsafe 代码具有更高亮的显示.只需要修改 settings.json 中的下面配置即可.原文链接https://veykril.github.io/posts/semantic-unsafe/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-20 20:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 rust-analyzer 对 unsafe 代码进行高亮显示" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 标准库 1.63 增加了一个期待已久的功能：scoped thread（作用域线程）。与 thread::spawn() 不同，这个新特性允许线程借用局部变量，而不仅仅是静态变量。借用官方例子：更多可查看官方文档：https://doc.rust-lang.org/nightly/std/thread/fn.scope.html另外，Mutex::new，RwLock::new 和 Condvar::new 都是 const function。这意味着现在可以将这些类型用作静态变量，而不再需要 lazy_static 或 once_cell 或其他解决方法。Rust 1.63 将会在 8 月 11 日发布。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-19 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.63新特性" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ReadySet 是一个轻量级的 SQL 缓存引擎，可预先计算经常访问的查询结果，并在数据库中的基础数据更改时自动使这些结果随时间推移保持最新。ReadySet 与 MySQL 和 Postgres 有线兼容，无需更改代码即可采用。ReadySet 同时充当 SQL 缓存和代理 – 当首次将 ReadySet 连接到应用程序时，它默认将所有查询代理到后面的数据库，因此它不会更改应用程序的行为。主页：https://readyset.io/文档：https://docs.readyset.io/GitHub：https://github.com/readysettech/readyset" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-19 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "readyset：一个轻量SQL缓存引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Ante 是一种低级别的函数式语言，用于探索细化类型、生命周期推理和其他有趣的功能。语言概览：https://antelang.org/docs/language/主页：http://antelang.org/GitHub：https://github.com/jfecher/ante" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-19 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ante：一个安全简单的系统语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "简单示例：GitHub：https://github.com/mitghi/quartz.rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-19 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "quartz.rs：一个小巧的调度库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "CreuSAT，用 Rust 实现的 SAT 求解器（SAT solver，https://en.wikipedia.org/wiki/SAT_solver），已通过 Creusot（Creusot，https://github.com/xldenis/creusot） 验证。这意味着 CreuSAT 解决了布尔可满足性问题（Boolean Satisfiability Problem，称为 SAT）。Github链接，https://github.com/sarsko/CreuSAT" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sarsko/CreuSAT" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-18 22:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "CreuSAT, SAT 求解器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文探讨了 Rust 嵌入式生态系统。 它适用于不熟悉 Rust 嵌入式，不了解可用的工具和库的新手。 对于有 Rust 经验但不了解嵌入式的人可能特别有用。 希望在阅读这篇文章之后，能够了解何时可能需要某个工具，并且能够在出现用例时识别它，并应该能够确定哪些工具适合和不适合给定的用途。博文链接，https://www.anyleaf.org/blog/rust-embedded-ecosystem-and-tools" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.anyleaf.org/blog/rust-embedded-ecosystem-and-tools" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-18 22:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 嵌入式生态系统和工具概述" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果你曾经构建过一个全栈 Web 应用程序，那么你可能遇到过模板引擎，例如 Django 或 Flask 提供的模板引擎。 这些简洁的实用程序包解析你的 HTML 文件并使用动态内容“填充空白”（可以这么说）。本教程面向初学者 Rustaceans，但应该熟悉编程和在终端上工作。博文链接，https://blog.spike.codes/build-a-template-enginehttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.spike.codes/build-a-template-engine" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-18 22:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用不到 100 行 Rust 代码构建一个简单的模板引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "前端技术栈：Yew, trunk, tailwindcss后端技术栈：Actix-web, diesel.rs, Sqlite在线体验 Crabtyper: https://www.crabtyper.comGitHub - brancobruyneel/crabtyper: https://github.com/brancobruyneel/crabtyper" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/brancobruyneel/crabtyper" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-17 00:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Crabtyper：用 Rust 构建的打字速度练习网站" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文又名，如何终止 Rust 程序中的内存泄漏。这是一篇关于修复 fly-proxy（用 Rust 写的代理程序）中的内存泄漏的文章。该程序可以将用户的请求发送到最近的虚拟机，从而完成这些请求。How to Make Rust Leak Memory (Also: How to Make It Stop) : https://fly.io/blog/rust-memory-leak/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fly.io/blog/rust-memory-leak/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-17 00:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "文章 | 如何使 Rust 内存泄漏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 447: https://this-week-in-rust.org/blog/2022/06/15/this-week-in-rust-447/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/06/15/this-week-in-rust-447/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-17 00:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 447" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust-minidump实现了非常可靠的minidump解析+分析，适用于大部分平台 (x86, x64, ARM, ARM64; Windows, MacOS, Linux, Android)。ReadMore:https://hacks.mozilla.org/2022/06/everything-is-broken-shipping-rust-minidump-at-mozilla/ReadMore:https://github.com/luser/rust-minidump/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/luser/rust-minidump/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-15 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Mozilla：rust-minidump 转储内存的解析和分析" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "c2rust（从C到不安全Rust的转译器）再次被积极开发，现在增加了一些新功能和修复了错误，并且放弃了c2rust-refactor。\n\n安装很容易\ncargo install c2rust\n\n\n\n支持M1 Mac\n\n安装很容易支持M1 Mac...ReadMore:https://immunant.com/blog/2022/06/back/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://immunant.com/blog/2022/06/back/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-15 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "C2Rust 回来了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "互斥：“妈妈说轮到我打开了同步原语。“vs.写锁：“嘿！在我写完之前，你们都不许看！“读锁：“嘿！在我们读完之前，你不能编辑你写的东西！“ReadMore:https://www.reddit.com/r/rust/comments/vcaabk/rwlock_vs_mutex_please_tell_me_like_im_5/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/vcaabk/rwlock_vs_mutex_please_tell_me_like_im_5/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-15 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于Rwlock 和 Mutex的讨论" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "CeresDB 是一款高性能、分布式、Schema-less 的云原生时序数据库，能够同时处理时序型（time-series）以及分析型（analytics）负载。该项目近日正式开源了，目前在快速迭代中，欢迎大家积极参与到该项目中。github地址https://github.com/CeresDB/ceresdb" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-14 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ceresdb: Rust 实现的高性能时序数据库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "clap 是 Rust 中常用的命令行参数解析器，近日发布了 v3.2 版本，该版本也将是 v4.0 之前的最后一个版本。v3.2 在 v3.1 的基础上，废弃了 Arg::validator Arg::allow_invalid_utf8 等 API，引入了更加开放和灵活的 API，例如：以 ArgAction 为例，因为 clap 会在解析时推断出如何处理参数，在某些情况下，它并不能完全满足用户的需求，需要提供更明确的控制。现在通过指定一个 ArgAction，即可确定它与解析器的交互方式（目前，这是一个封闭的 API，但我们希望将来允许用户提供自己的操作）。示例：clap v3.2 版本将会稳定一个月左右，之后会开始 v4.0 版本的迭代，本次更新的详细信息可查看其更新日志https://epage.github.io/blog/2022/06/clap-32-last-call-before-40/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-14 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Clap 发布 v3.2 版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GBemulator 是使用 Rust 从头开始​​编写的 Gameboy 模拟器，兼容 macOS、Linux 和 Windows 系统。该项目使用 wgpu 进行渲染，使用 cpal 进行音频输出，使用 egui 设计图形界面，目前完成度已经相当高，感兴趣的小伙伴不妨尝试一下该项目。github地址https://github.com/p4ddy1/gbemulator" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-14 19:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GBemulator：Rust 实现的 GameBoy 模拟器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "<<Crust of Rust>> 系列的最新视频: Send, Sync 和他们的实现者.视频中深入探索了 Send/Sync 是什么, 为什么 以及如何实现等等.油管视频https://www.youtube.com/watch?v=yOezcP-XaIw" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-13 19:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Crust of Rust: Send, Sync 和他们的实现者" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用过 Firefox 的人都知道, 重新打开浏览器时可以恢复之前的浏览页面.本文作者闲来无事,用 Rust 一步一步的将其分析和解析出来.原文链接https://blog.dend.ro/decoding-firefox-session-store-data/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-13 19:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 解析 firefox 的 session store data" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这一个 Rust 的 docker image, 有了他,你可以:使用也很简单:运行如下命令, 然后再浏览器中打开 localhost:8020 即可.原文链接https://docs.alnoda.org/rust-workspace/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-13 19:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-workspace" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "adsbdb 是一个基于 Rust axum, PostgreSQL, Redis 构建的 api 服务, 提供了 公共的飞机和航线数据 API.github 地址https://github.com/mrjackwills/adsbdb--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-13 19:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "adsbdb: 公共飞机和航线API" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这开始是一个与 PoC 一起进行的实验，但现在已经发展成为一个完整的库。它允许你从 JS 中导入 React 组件，用 Rust 编写组件，然后再次导出它们以供 JS 使用。GitHub：https://github.com/yishn/wasm-react/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-12 16:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "wasm-react：用于 React 的 WASM 绑定" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是RustSec 咨询数据库的可视化。我希望它会有所帮助。如果您需要更多图表，请随时发表评论。https://github.com/rustsec/advisory-dbhttps://preview.redd.it/iacwi5y7rr491.png?width=1595&format=png&auto=webp&s=28a02c1186a6a9c8ae03ca9413be2d056c5b197c链接：https ://metabase.nekonode.com/public/dashboard/f5d98df6-7986-46b0-b00b-54b5c2b09a64https://metabase.nekonode.com/public/dashboard/f5d98df6-7986-46b0-b00b-54b5c2b09a64GitHub：https://github.com/brxken128/dexios" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-12 16:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustSec 咨询数据库可视化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GitHub：https://github.com/benharmonics/gsftp它基本上只是一个带有 *TUI 的 SFTP 程序。您可以使用密码或作为参数提供的公钥文件通过 SSH 登录。如果您两者都不提供，它会尝试使用您的 SSH 身份验证代理中提供的第一个公钥文件让您登录 - 这是使用该程序的首选方式。完成身份验证后，您可以上传/下载文件。您无法删除文件-添加恕我直言似乎是一个危险的功能？此外，ssh2箱子似乎有一种通过交互式键盘输入进行身份验证的方法，但我还没有解决这个问题；目前还不清楚如何使用它。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-12 16:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "具有图形界面的文件传输程序 (GSFTP)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "好吧，至少，NLL 借用检查器终于在默认情况下完全启用了----但这并不是一个吸引人的标题，不是吗？让我们从头开始说。我写这篇文章是为了什么？实际上，有几个原因。首先，许多生命周期相关的错误在 nightly 上有了一些变化，所以我想介绍一下，因为我觉得他们真的很酷。其次，我想介绍一下我们是如何走到今天的，因为我认为回顾过去总是很重要的。第三，在此过程中，我想大声宣传所有贡献者为实现此功能所做的所有工作。我个人在这里所做的工作很少；我主要是讲别人写的故事，他们应该得到所有的赞扬。...文章链接，https://jackh726.github.io/rust/2022/06/10/nll-stabilization.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://jackh726.github.io/rust/2022/06/10/nll-stabilization.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-11 19:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust借用检查器变得更加智能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Ferium 是一个快速且功能丰富的 CLI 程序，用于从 Modrinth、CurseForge 和 GitHub Releases 和 Modrinth、CurseForge 下载和更新 Minecraft 模组。只需通过 CLI 指定您使用的模组或模组包，只需一个命令即可下载您配置的所有模组或模组包。Github 链接，https://github.com/gorilla-devs/ferium文章链接，https://www.reddit.com/r/rust/comments/v9rdmw/ferium_the_fast_and_multisource_cli_program_for/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/v9rdmw/ferium_the_fast_and_multisource_cli_program_for/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-11 19:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Ferium：一个快速的Minecraft模组管理cli程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我刚刚发布了Pasts (v0.11.0) 的新版本，这是一个单线程无标准兼容异步运行时，没有宏、依赖项（除了针对 Web 的 wasm-bindgen-futures）或unsafe代码。 Pasts 的目标不是像 tokio 或 async-std 那样内置网络或文件 I/O，它的主要目标是用于嵌入式系统、GUI 应用程序和视频游戏，而不是专注于 Web 服务器。新版本带来了一些不错的改进...Github 链接，https://github.com/ardaku/pasts/文章链接，https://www.reddit.com/r/rust/comments/v9qgo8/pasts_a_nostd_compatible_async_runtime/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/v9qgo8/pasts_a_nostd_compatible_async_runtime/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-11 19:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pasts：一个非标准兼容的异步运行时" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "b站搬运: https://www.bilibili.com/video/BV1wr4y1V758?p=1&share_medium=iphone&share_plat=ios&share_session_id=09674680-F266-445E-B4C3-90F224D24588&share_source=WEIXIN&share_tag=s_i&timestamp=1654833200&unique_k=t1CC5KY&share_times=1附上视频中出现的 RIIR：\ngrep -> ripgrep\ncat -> bat\nfind -> fd\nsed -> sd\ntop -> ytop\ncoreutils -> uutils\nxterm -> alacrity\nls -> exa\ngold -> mold\nPython -> RustPython\njekyll -> zola\ngo -> goscript\nelectron -> tauri\nV8 -> spidermonkey\nQt -> iced\nBitCoin -> solana\nnodejs -> deno\nLinux -> Rust for Linux\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-10 23:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【油管趣搞】Rust 语言是不可避免的趋势" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章持有与上周五 Rust Is Hard, Or: The Misery of Mainstream Programming 一文不一样的观点：如果你懂得权衡性能与可用里，例如不过分纠结 Arc 优化、使用适当的 动态分发，Rust 也可以不复杂。https://hirrolot.github.io/posts/rust-is-hard-or-the-misery-of-mainstream-programming.html原文： https://itsallaboutthebit.com/async-simple/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-10 23:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "(async) Rust doesn't have to be hard" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "shuttle 是一款stateful serverless框架，可以直接使用 rocket，这公司对比了 hyper 与 rocket 的功能、编译时间与性能。至于是需要更底层开发 hpyer 框架直接使用，还是基于 rocket 框架来获得更多开箱即用的功能，就要看各位的权衡了。https://www.shuttle.rs/blog/2022/06/01/hyper-vs-rocket--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-10 23:11" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "hyper vs rocket" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一篇介绍 IntoFuture trait的博文。好消息是：自2021年12月以来，实现这些模式的功能已经在Rust的nightly版上可用，并最终走向稳定。Blog: https://refaktory.net/blog/posts/into-the-future-with-intofuture-improving-rust-async-ergonomics" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://refaktory.net/blog/posts/into-the-future-with-intofuture-improving-rust-async-ergonomics" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-09 20:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用IntoFuture into 到 Future--改善Rust异步的人体工程学" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "This Month in Rust OSDev: https://rust-osdev.com/this-month/2022-05/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust-osdev.com/this-month/2022-05/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-09 20:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本月Rust操作系统开发生态进展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 游戏开发本月进展已经发布：This Month in Rust GameDev: https://gamedev.rs/news/034/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gamedev.rs/news/034/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-09 20:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本月Rust游戏开发生态进展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 446: https://this-week-in-rust.org/blog/2022/06/08/this-week-in-rust-446/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/06/08/this-week-in-rust-446/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-09 20:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 446" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文中细数了，函数式编程的好处，以及Rust中对函数式编程的特性的支持。算作一篇简单的总结笔记。https://kerkour.com/rust-functional-programming" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://kerkour.com/rust-functional-programming" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-07 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一篇小文：Rust中的函数式编程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust Search Extension 是在浏览器中快速搜索Rust相关参考的插件，目前已支持 Chrome, Firefox, Edgehttps://rust.extension.sh/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust.extension.sh/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-07 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Search Extension 更新至 v1.7.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "主体由Rust和Wasm实现。这里是使用 Fluvio 的 SmartModules 处理 XML 数据的例子。https://www.infinyon.com/blog/2022/06/smartmodule-xml/Repo: https://www.fluvio.io/https://github.com/infinyon/fluvio" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.infinyon.com/blog/2022/06/smartmodule-xml/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-07 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fluvio - 开源的实时数据流计算平台" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "它将 GMP 和 FLINT 的 C 算法代码翻译成了安全的 Rust 代码，并且添加了充分的测试用例覆盖 4297 个单元测试和 1652 个文档测试。https://gmplib.org/这里是初步的性能评测结果：https://www.malachite.rs/performance/Website: https://www.malachite.rs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.malachite.rs/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-07 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "malachite - 任意精度计算库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust在过去2年（24个月）中，开发者数量涨到3倍，达到 220 万开发者。这是一篇 Stack 采访 Dr Rebecca Rumbul, CEO of the non-profit Rust Foundation 和 Mara Bos, team lead of the Rust Library team 的新闻稿。整理了Rust这几年的重要进展，以及Rust基金会对社区激励的一些措施。Rust的未来势不可挡。https://thestack.technology/rust-language-explosive-growth-challenges-rust-governance/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://thestack.technology/rust-language-explosive-growth-challenges-rust-governance/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-07 23:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 在挑战中迎来爆发" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文对比了常见的语言的闭包用法, 包括 Javascript, Quiz, C#, Java, Python,Rust 等语言, 同时还包括了 Rust 的几个版本中的闭包用法.原文链接https://blog.oberien.de/2022/06/06/finally-getting-closure.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-06 21:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "不同语言中的闭包对比" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个受 kakoune / neovim 启发的编辑器, 使用 Rust 编写二次.github地址https://github.com/helix-editor/helix" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-06 21:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "helix: 后现代模式文本编辑器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "arrow2 是一个能够使用 Apache Arrow 的 Rust crate,也是 C++实现版本之外,功能实现最全的一个实现.目前 v0.12.0 已发布.原文链接https://github.com/jorgecarleitao/arrow2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-06 21:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "arrow2: v0.12.0 版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rulex-rs 是一个新型,可移植的正则表达式语言, 目前已有了在线的Playgroud, 使用 wasm 编写完成.rulex-rs githubrulex-rs Playgroudhttps://github.com/rulex-rs/rulex" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-06 21:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rulex-rs: 一个新型,可移植的正则表达式语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该 repo 为一个 TUI 的程序,可以帮助大家快速学习 TUI 相关用法.github地址https://github.com/FeistyKit/quickstudy--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-06 21:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "quickstudy: 一个简单的 TUI 学习程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "动态模板引擎是阿里巴巴优酷技术团队研发的一套轻量级的纯Native动态化卡片跨端解决方案。动态模板引擎是阿里巴巴优酷技术团队研发的一套轻量级的纯Native动态化卡片跨端解决方案。除了客户端渲染SDK，还提供了配套的模板可视化搭建工具和详情的功能Demo（模板示例，以及扫码预览），支持从模板搭建/编辑、真机调试/预览等研发链路技术支撑，优酷动态模板引擎的目标是在保证Native体验性能的同时，帮助客户端开发领域实现低代码。核心概念：文档：https://www.yuque.com/biezhihua/gaiax/kibtopGitHub：https://github.com/alibaba/GaiaX" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-05 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GaiaX：动态化卡片跨端解决方案" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "cannoli 是针对 QUMU 的高性能跟踪引擎，可以记录PC的执行轨迹和内存操作。Cannoli 旨在以最小的 QEMU 执行干扰记录这些信息。在实践中，这意味着 QEMU 需要产生一个事件流，并将它们（非常快速地）交给另一个进程来处理对它们的更复杂的分析。在 QEMU JIT 本身执行期间进行分析会大大减慢执行速度。Cannoli 每秒可以处理数十亿条目标指令，可以处理多线程 QEMU 用户应用程序，并允许多个线程使用来自单个 QEMU 线程的数据以并行处理跟踪。GitHub：https://github.com/MarginResearch/cannoli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-05 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cannoli：QEMU内存和指令跟踪器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Mac APP/CLI，为repo的文件夹添加图标。GitHub：https://github.com/samdenty/git-icons" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-05 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "git-icons" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "特性：\n适用于MacOS，Windows和Linux\n易于安装和更新\n支持安装多个R版本\n为终端和RStudio选择默认的R版本\n使用符号名称选择要安装的版本，如devel、next、release、oldrel等\n使用快速链接同时运行多个版本\n在M1的Mac上，可以选择安装x86_64或arm64版本，或者同时安装\n创建和配置用户级 library\n限制对系统库的权限\nzsh和bash自动补全功能\n更新R安装允许在 Mac 上使用 lldb 进行调试，并允许核心 dump\n在 Windows 上安装适当的 Rtools 版本并进行设置\n从 Windows 注册表中清除与 R 相关的旧条目\n根据需要切换到 root/administrator 用户\n常用命令：GitHub：https://github.com/r-lib/rig" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-05 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rig：R管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "mirrored将流量从生产环境镜像到开发环境。\n加速反馈循环：从本地计算机测试云服务，无需CI或部署。\n轻量：几秒钟内启动并运行。\n安全：在同一个云环境上同时测试\n传统软件开发是一个循环，开发人员在本地编写和测试他们的代码，然后将其部署到云上模拟/预发环境，在那里执行额外的测试。这些测试通常会失败，因为代码是第一次满足近乎生产的环境，并且遇到了新的条件。然后必须修复/重写代码，再次在本地测试，再次部署，依此类推，直到测试通过。本项目试图通过将 “部署” 完全排除在流程之外，从而消除开发部署相关成本。通过将本地进程直接插入模拟环境，用户可以在云条件下测试代码，而无需经历漫长的 CI 流程；同时，也没有破坏其他开发人员环境的风险。网址：https://mirrord.dev/GitHub：https://github.com/metalbear-co/mirrord" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-05 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mirrord：dev→prod环境" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust编译很慢，主要因为它在编译期间检查了很多东西，以提供内存和并发安全。像在许多其他情况下一样，管道可以通过缓存来加速，但是正确设置缓存非常重要。本文提供了一份可复用的编译流程，使用GitHub Actions借助actions/cache缓存，最终从原来的15分钟提升到月1分钟。https://docs.github.com/en/actions网址：https://ectobit.com/blog/speed-up-github-actions-rust-pipelines/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-05 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "加速Rust在GitHub上的构建" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "与Rust相关的问题包括：\nRust中所有权是什么意思？\nRust中borrow做了什么？\nString和&str的区别是什么？\n描述下Rust中的async。\n描述下Rust中的std。\nunsafe里面能干什么？\ntrait和dyn trait的区别是什么？\nRust为什么静态链接依赖？\n网址：https://flakm.github.io/posts/rust_interview_questions/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-05 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust面试问题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "课程地址：https://agileperception.com/ultimate_rust_crash_courseGitHub：https://github.com/CleanCut/ultimate_rust_crash_course" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-05 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Crash Course" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "昨天有篇文章《Rust Is Hard, Or: The Misery of Mainstream Programming》，但作者 Piotr Sarnacki 写了这篇文章，Rust 并不一定很难。 它是一种难语言，尤其是与 Javascript 或 Go 等语言相比。但随着时间的推移，它只会变得更容易。 在 2022 年编写 Rust 与编写 Rust 1.0 版本时的体验截然不同，Rust 团队正在努力使其更易于使用。https://hirrolot.github.io/posts/rust-is-hard-or-the-misery-of-mainstream-programming.html博客原文链接，https://itsallaboutthebit.com/async-simple/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://itsallaboutthebit.com/async-simple/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-04 23:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 不一定很难（async）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者 Conrad Ludgate 写了很多宏，专业写宏。 关于宏，作者认为其很难有效编写。 然而，可以了解下在其博客中如何谈论宏。https://conradludgate.com/博客链接，https://conradludgate.com/posts/macros_matchhttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://conradludgate.com/posts/macros_match" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-04 23:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 宏模式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇博文是展示分析 rust 应用程序的堆使用情况的方法。 应用程序将可能较大的 csv 读取到内存中，然后存储标题和字段以供以后通过索引访问。我们一起来看一下作者 Maciek 的分析方法。\nhttps://flakm.github.io/posts/heap_allocation/\n网上经常吐槽：为什么 Rust 这么难呢？Rust 是一种静态语言同时是一种系统语言。它包含了不对程序员隐藏底层计算机内存管理的特性，同时它也有“无所畏惧的并发”——一个形式上正确但仍然具有误导性的陈述。是的，你不再害怕数据竞赛，但你有 PAIN ，非常痛苦的 PAIN。正因如此，Rust 也并非解决了所有问题，你需要不影响其他特性的前提下，使用它专一方向的特性以解决问题，事情就变得有趣了，我们来看一下 Hirrolot 的博客对这些问题的思考。\n投稿人：PotatoTooLarge\nhttps://hirrolot.github.io/posts/rust-is-hard-or-the-misery-of-mainstream-programming.html\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-03 22:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "上周 RustDesk 在 GitHub 发布了一个关于桌面技术选型的讨论「Tauri or Flutter for RustDesk desktop?」，Tauri 作者与 flutter_rust_bridge 作者都有深度参入。尽管最后 Tauri 投票得分更高，且团队初衷也希望采用 Tauri，但是由于 IPC 问题，RustDesk 还是暂时选择 Flutter。这篇文章是对讨论的一个总结，方便大家日后选型。Flutter 与 Tauri 选型讨论总结: https://zhuanlan.zhihu.com/p/520770477Discussions | Tauri or Flutter for RustDesk desktop?: https://github.com/rustdesk/rustdesk/discussions/533" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rustdesk/rustdesk/discussions/533" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-02 22:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Flutter 与 Tauri 选型讨论总结" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "标题有些耸人听闻，但有诅咒，自然也有解咒的法子，看看 fasterthanlime 是如何与编译器错误搏斗并揭示里面的秘密。The curse of strong typing: https://fasterthanli.me/articles/the-curse-of-strong-typing" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fasterthanli.me/articles/the-curse-of-strong-typing" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-02 22:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "文章 | 强类型的诅咒" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 445: https://this-week-in-rust.org/blog/2022/06/01/this-week-in-rust-445/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/06/01/this-week-in-rust-445/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-02 22:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 445" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在本文中，可以学习如何使用 Rust 实现 Web 抓取。主要使用reqwest和scraper ，从 IMDb 中抓取前一百部电影列表。ReadMore:https://www.scrapingbee.com/blog/web-scraping-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.scrapingbee.com/blog/web-scraping-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-01 23:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何 Rust 写爬虫" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cow是一种类型，它的名字来自一个概念，即写入时复制的概念。Rust's Cow有点复杂，因为它涉及寿命和所有权，所以Cow的“通常”用例有点罕见（它们被Rc / Arc接管）。...ReadMore:https://www.reddit.com/r/rust/comments/v1z6bx/what_is_a_cow/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/v1z6bx/what_is_a_cow/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-06-01 23:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Reddit 话题 - 什么是 cow" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Some notes on internal working of pprof-rshttps://www.reddit.com/r/rust/comments/v10kht/some_notes_on_internal_working_of_pprofrs/我们中的许多人都使用profiler来测量代码段所消耗的CPU或内存。为了了解profiling，作者摸索了一个流行的评测库pprof-rs，这个库用于测量rust程序的CPU使用率。https://github.com/tikv/pprof-rsprofiling的基础知识让我们简要介绍一下rust程序示例，看看pprof是如何使用的。在上面的示例中，我们使用ProfilerGuardBuilder在程序开始时开始分析在程序结束时，我们生成报告并将其写入profile.pb文件。该报告是通过运行该程序生成的，并使用谷歌的pprof进行可视化https://github.com/google/pprof执行上述命令后，pprof将允许您在 http://localhost:8080 可视化profile文件：#从可视化的概要文件中，您可以清楚地看到is_prime_number2比is_prime_number1消耗了更多的cpu。这是因为使用is_prime_number1时，只有给定的数字可以被3整除。现在，我们学习了如何使用pprof-rs分析rust程序，下面让我们了解pprof-rs如何在内部工作。https://github.com/tikv/pprof-rscpu profilers 要点在我们进入pprof-rs代码之前，让我们从理论上学习cpu评测。https://github.com/tikv/pprof-rs\nprofiler 在一定的时间间隔内暂停程序；\n对当前堆栈跟踪进行采样后恢复；\n采样时，它获取每个堆栈帧并增加其计数；\n使用采样数据创建火焰图或类似的东西。\n\npprof-rs实现及其系统调用\n开始分析\n注册信号处理程序\n指定时间间隔\n处理SIGPROF信号\n取样\n绘图\n原文：Some notes on internal working of profilerhttps://inspektor.cloud/blog/how-profiler-works/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-31 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于pprof-rs内部工作原理的一些笔记" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Lisp Interpreter in a browser using WASMhttps://www.reddit.com/r/rust/comments/v1n5r6/lisp_interpreter_in_a_browser_using_wasm/此网页在浏览器中托管一个Lisp解释器。解释器是用Rust编写的，并编译为WASM。解释器的实现可以在这里找到。可以在此处找到WASM绑定和此webapp的源代码。您可以通过在网页下面的文本框中键入代码来运行Lisp程序。https://vishpat.github.io/lisp-rs-wasm/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-31 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "基于WASM的浏览器中的Lisp解释器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Announcing mail-send, a Rust e-mail delivery library with DKIM supporthttps://www.reddit.com/r/rust/comments/v127d0/announcing_mailsend_a_rust_email_delivery_library/mail-send 于今天发布，它是 lettre 的替代品，但依赖性较少，并具有一些附加功能：https://github.com/stalwartlabs/mail-send\n\n生成符合互联网邮件格式标准（RFC 5322）的电子邮件；\n\n\n完全支持MIME（RFC 2045-2049），自动为每个消息正文部分选择最佳编码；\n\n\n域密钥识别邮件（DKIM）签名（RFC 6376）；\n\n\nSMTP支持；\n\n通过TLS安全交付；\n通过自动机制选择进行身份验证（支持XOAUTH2、CRAM-MD5、DIGEST-MD5、LOGIN和PLAIN）；\n\n\n\n第三方电子邮件转发：\n\nMailchimp\nMailgun\n其他\n\n\n\n完全异步（需要Tokio，可根据要求添加其他执行器）。\n\n生成符合互联网邮件格式标准（RFC 5322）的电子邮件；完全支持MIME（RFC 2045-2049），自动为每个消息正文部分选择最佳编码；域密钥识别邮件（DKIM）签名（RFC 6376）；SMTP支持；\n通过TLS安全交付；\n通过自动机制选择进行身份验证（支持XOAUTH2、CRAM-MD5、DIGEST-MD5、LOGIN和PLAIN）；\n第三方电子邮件转发：\nMailchimp\nMailgun\n其他\n完全异步（需要Tokio，可根据要求添加其他执行器）。除了这个库之外，您可能还想查看邮件解析器mail-parser（几个月前发布），它支持以41种不同编码解析MIME消息。https://github.com/stalwartlabs/mail-parser" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-31 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mail-send：一个支持DKIM的Rust电子邮件转发库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Lemmy (a federated reddit alternative) Release v0.16.4 - Peertube federation, Rust API and other improvementshttps://www.reddit.com/r/rust/comments/v100c2/lemmy_a_federated_reddit_alternative_release/Lemmy是一个自我托管的社交链接聚合和讨论平台。它是完全免费和开放的，不受任何公司的控制。这意味着没有广告、追踪或秘密算法。内容被组织到社区中，因此很容易订阅您感兴趣的主题，而忽略其他主题。投票是用来把最有趣的项目排在首位的。Rust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-31 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Lemmy v0.16.4 发布：Peertube 联邦、Rust API和其他改进" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文介绍了 builder 模式的一个表亲: 精简 builder 模式.示例代码如下.原文链接https://matklad.github.io/2022/05/29/builder-lite.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-30 20:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Builder Lite: 精简 builder 模式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "其他编程语言中的 async/await 特性似乎比Rust中的更直观一些, 例如 JavaScript.本文介绍了 Rust 中的 async/await 的一些场景.原文链接https://www.geekabyte.io/2022/05/a-neophytes-introduction-to-asyncawait.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-30 20:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async/await 在 Rust 中场景介绍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "duf 是一个简单的 file server. 支持以下特性:\n静态文件服务器\n以 zip 方式下载文件\n文件搜索\n文件上传\n文件删除\n基础权限\n方便使用 curl 使用\n...\ngithub 地址https://github.com/sigoden/duf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-30 20:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "duf: 简单的文件服务器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 Rust 编写的一个小游戏,完成度比较高, 并且开源了源代码, 感兴趣的小伙伴可以自取.游戏源码油管视频https://github.com/kennoath/wizrad--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-30 20:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust编写的小游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https-dns是一个最小且高效的 DNS-over-HTTPS (DoH) 客户端。DNS-over-HTTPS ( RFC 8484 ) 是一种通过 HTTPS 协议执行 DNS 解析的协议，可防止操纵 DNS 响应。https-dns将来自客户端的 DNS 查询转发到上游 DoH 服务器，缓存响应，并将响应发送回客户端。https://datatracker.ietf.org/doc/html/rfc8484GitHub：https ://github.com/xiaoyang-sde/https-dnshttps://github.com/xiaoyang-sde/https-dnsCrate.io：https://crates.io/crates/https-dns _https://github.com/Cveinnt/LetsMarkdown.com)" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/https-dns" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-29 14:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "https-dns：基于 Rust 的高效 DNS-over-HTTPS (DoH) 客户端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "命令行加密工具Dexios v8.1.0 已经发布！Dexios 快速、安全，并使用经过身份验证的加密算法来确保数据的完整性。支持 XChaCha20-Poly1305、AES-256-GCM 和（自 v8.1.0 起）Deoxys-II-256。这是 v7.xx 版本的一大进步，因为加密的文件头终于被标准化了！. 这意味着您的文件将始终向后兼容并始终受支持。https://github.com/brxken128/dexios/wiki/Headers这是我用 Rust 制作的第一个生产就绪的东西，为了让事情达到应有的样子已经花了一个月的时间。我计划为 Dexios 的性能和代码库提供支持、更新、补丁（必要时）和优化。Wiki的技术详细信息页面详细介绍了如何完成工作，而 Wiki 仅包含有关项目的一般信息。https://github.com/brxken128/dexios/wiki/Technical-DetailsGitHub：https ://github.com/brxken128/dexioshttps://github.com/brxken128/dexios" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-29 14:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Dexios v8.1.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "以下是自上次更新以来添加的功能的要点概要：\n将重点工作区移动到监视器\n在轴上调整窗口容器的大小\n设置自定义调整大小增量\n具有调整尺寸的快速保存和快速加载布局\n保存和加载布局与调整尺寸到/从特定文件\n具有垂直堆栈布局的主半高窗口 ( horizontal-stack)\n具有水平堆栈布局的主半角窗口 ( vertical-stack)\n2x 主窗口（一半和四分之一宽度），水平堆栈布局 ( ultrawide-vertical-stack)\n从 JSON 和 YAML 表示加载自定义布局\n根据打开窗口的数量动态选择布局\n配置工作区偏移以保留自定义任务栏的空间\n切换鼠标跟随焦点\n订阅事件和消息通知\n如果你想看看这在代码方面是什么样的，你可以在 GitHub 上查看这个差异https://github.com/LGUG2Z/komorebi/compare/v0.1.4...v0.1.9如果您想查看 komorebi 的实际效果，请参阅项目自述文件中来自 komorebi 用户的两个很棒的小演示。https://github.com/LGUG2Z/komorebi就我个人而言，这一时期最酷的新功能是：\n能够在 YAML 和 JSON 中定义自定义布局，这真的很棒，对我来说已经彻底改变了游戏规则，而且在许多情况下，空间可以比传统 BSP 布局更有效地使用在比平均水平更宽的监视器上。还有一个可视化自定义布局生成器，您可以使用它为您的自定义布局生成 JSON！\n能够设置规则以根据屏幕上打开的窗口数量在不同的内置和自定义布局之间自动切换。这是回想起来似乎很简单的事情之一，但我还没有看到它在其他平铺窗口管理器中实现。也许您认为 BSP 可以在屏幕上最多显示 3 或 4 个窗口，但是一旦您考虑了这一点，您希望工作区切换到您认为对于更多数量的空间更有效和更高效的不同自定义布局视窗。没问题！只需告诉 komorebi 达到打开窗口的某个阈值后切换到哪个布局！\n一个基于推送的事件订阅 API，允许其他应用程序订阅最新的 komorebi 事件。如果您想编写自己的状态栏，这特别有用。yasb是用 Python 编写的状态栏的一个很好的示例，它订阅来自 komorebi 的最新事件，以始终向用户显示有关工作区和应用程序窗口的最新信息。\n您可以轻松地导出 JSON 模式文件，以帮助您生成任何语言的类型，这得益于出色的schemars crate，从而使处理订阅事件的更新变得轻而易举。\n在 YAML 中引入了一个解耦的应用程序特定修复库，可用于为默认不合作的应用程序生成大多数配置选项。目标是最终只能够运行一个命令来生成 99% 的配置，让您专注于其他 1%，这基本上应该是您首选的快捷方式和工作区布局选项。\n如果您有兴趣第一次尝试 komorebi，现在比以往任何时候都更容易，因为您现在可以extras使用 Scoop 直接从桶中安装它！最后，非常感谢在这个 sub 和社区 Rust Discord 服务器上帮助过我的每个人，以及在 GitHub 和 komorebi Discord 服务器上提供反馈和建议的每个人。如果您对使用 Rust 为 Windows 进行开发、编写自己的平铺窗口管理器，甚至您在项目代码中发现的任何您想讨论的问题有任何疑问，我会尽力在评论中回答。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-29 14:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Komorebi（Windows 的平铺窗口管理器）v0.1.9 已发布！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Neon 是 AWS Aurora Postgres 的无服务器开源替代方案。它通过跨节点集群重新分配数据来分离存储和计算并替代 PostgreSQL 存储层。该项目曾经被称为“Zenith”。许多命令和代码注释仍然提到“zenith”，但我们正在进行重命名相关的工作。Github 链接，https://github.com/neondatabase/neon文章链接，https://www.reddit.com/r/rust/comments/uziz66/github_neondatabaseneon_the_serverless_open/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/uziz66/github_neondatabaseneon_the_serverless_open/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-28 21:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Neon：AWS Aurora Postgres 的无服务器开源替代方案。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在可以使用新版本的 artem。 artem 是一个 cli 程序，用于将图像从多种格式（jpg、png、webp 等）转换为 ASCII 样式，用 rust 编写。此版本具有一些令人兴奋的新功能，例如\n只需使用 url，即可自动从网络下载和转换图像。这是一个可选功能（默认启用），可以在编译时禁用。\n在终端中居中 ascii 图像\n一次转换多个文件的能力，以及改进的输出文件的警告和错误处理\n...\nGithub 链接，https://github.com/FineFindus/artem文章链接，https://www.reddit.com/r/rust/comments/uzkfqh/artem_110_release/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/uzkfqh/artem_110_release/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-28 21:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "artem 1.1.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，我宣布了 compact_str 的 0.4 版本，这是一个针对 Rust 的小字符串优化。这个库导出了一个struct CompactString，它可以内联长达 24 个字符的字符串（在 32 位机器上为 12 个），以及一个trait ToCompactString，它公开了一种将类型转换为 CompactString 的方法。此版本带来了多项改进：\n将 CompactStr 重命名为 CompactString 以更好地反映我们拥有底层字符串缓冲区\n介绍 ToCompactString 特征，其中包含一些基本类型的特化\n...\nGithub 链接，https://github.com/ParkMyCar/compact_str文章链接，https://www.reddit.com/r/rust/comments/uzb9i7/announcing_compact_str_version_04_a_small_string/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/uzb9i7/announcing_compact_str_version_04_a_small_string/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-28 21:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "宣布 compact_str 0.4！ Rust 的小字符串优化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "venial是syn的轻量替代品。关于这次发布，作者又一些话：这个版本的主要变化是与属性解析有关。另外，一些错误也得到了修复。说实话，我有点厌倦了在这个crate上的工作。我在前三周取得了我想取得的95%的进展，而在那之后的几个月里，我觉得这是个拖累。在我的积压作品中一直有venial，感觉它一直在耗费我的注意力。这个版本将是在可预见的未来的最后一个版本。几个月后，我将把版本号更新为1.0，以示稳定，此后我预计将很少碰它。不过，我仍然会接受PR。从我上一篇文章开始，潜在的改进是相同的。增加模糊测试。将更多的库移植到venial。很好的候选者是derivative、clap和darling。另外，clap的维护者epage也表示有兴趣帮助任何这样的帖子，所以如果你有兴趣，可以去找他。在这个过程中，我可能会发现一些缺失的功能。编写更好的基准测试。特别是，比较venial和syn在Github Actions机器上的构建时间有多长，会很有意思。剖析和优化crate。即使这些都没有进展，我仍然对venial的现状感到满意。我认为它是一个很好的概念验证，可以实现更简单的宏解析，而且它目前的API对于它的目的来说也很成熟。就我而言，我希望能尽快回到Panoramix和其他与GUI有关的工作。Github: https://github.com/PoignardAzur/venial" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/PoignardAzur/venial" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-26 22:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "venial发布0.4版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RustLab是一个关于Rust编程语言的国际会议，今年将于10月在意大利佛罗伦萨附近举行。它将采用混合模式，但在现实生活中会更加有趣 :)我们已经开放了CPF，我们正在寻找演讲者或研讨会:)但我们已经有了一堆提案...... 门票将在几天内提供。详情: https://rustlab.it/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rustlab.it/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-26 22:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustLab" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大多数Rust工作是在加密货币领域吗？是的，有50%多一点确实是区块链提供的工作机会。详情: https://scrapingfish.com/blog/are-most-rust-jobs-in-crypto" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://scrapingfish.com/blog/are-most-rust-jobs-in-crypto" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-26 22:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "国外一项关于Rust工作与加密相关的调研" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 444: https://this-week-in-rust.org/blog/2022/05/25/this-week-in-rust-444/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/05/25/this-week-in-rust-444/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-26 22:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 444" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "近日 Flutter 发布了 3.0 版本，如何同时享受 Flutter 和 Rust 的双重优势呢？答案是 flutter_rust_bridge。该项目将 Flutter 和 Rust 之间进行了高级绑定，带来了以下好处：github 地址https://github.com/fzyzcjy/flutter_rust_bridge" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-24 20:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "通过 flutter_rust_bridge 使用 Flutter" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作为 Apache Spark 的加速器，blaze 利用矢量化执行来加速查询处理。它从 Spark 获取一个完全优化的物理计划，将其映射到 DataFusion 的执行计划中，并在 Spark 执行器中执行本机计划计算，同时结合了DataFusion 库的强大功能和 Spark 分布式计算框架的可扩展性。github 地址https://github.com/blaze-init/blaze" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-24 20:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "blaze：Apache Spark 的矢量化查询加速器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 OneSignal 公司，大家都喜欢 Rust，并且将很多核心业务功能转换成了 Rust 技术栈开发，Journeys 就是其中一个项目。其由几个 gRPC 服务和一个用 Rust 编写的 Kafka 消费者组成，允许客户使用无代码 UI 轻松构建复杂的消息传递工作流。随着 Journeys 的采用率开始增加，以及其开始处理更多事件，他们开始注意到，其内存使用情况令人不安，并不断导致 JourneyX 进程被 OOM Killer 杀死、重启。事实上，与很多人的第一印象相反，根据 Rust 的规则，内存泄漏是完全安全的，例如我们可以使用 std::mem::forget 故意泄漏尽可能多的内存，尽管最终会导致程序被内核杀死。OneSignal 最终排查到，导致内存泄露的是对于 tracing 库和析构特性的不当使用，如果你尚未遇到这个问题，不妨来借鉴一下他们的经验教训，也许以后就能避免这类错误。原文链接https://onesignal.com/blog/solving-memory-leaks-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-24 20:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "OneSignal 是如何解决 Rust 内存泄露问题的" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Parca 最近合并了一个 pull request, 内容为使用 Rust 重写 eBPF 的 profiler, 使用了 aya-rs 实现.github pull requesthttps://github.com/parca-dev/parca-agent/pull/377slides地址https://static.sched.com/hosted_files/cloudnativeebpfdayeu22/7f/eBPF%20Day%202022_KubeCon%20EU_%20eBPF%3F%20Safety%20First%21.pdf油管视频https://www.youtube.com/watch?v=oWHQrlE2-G8" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-23 21:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Parca: 使用 Rust 重写 eBPF profiler" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "BonsaiDb 是一个新的数据库，旨在成为最适合开发人员的 Rust 数据库.本文深入讲解了 file synchronization 机制以及他如何影响性能.原文链接https://bonsaidb.io/blog/durable-writes/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-23 21:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "BonsaiDb: 深入文件同步" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "claui 可以为 clap 自动生成 GUI, 内部使用 egui实现.github地址https://github.com/grantshandy/claui" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-23 21:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "claui: 命令行GUI生成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Trunk 是一个 Rust的 WASM web 应用打包器. 他使用一个简单的可选项配置模式，通过源HTML文件来构建和绑定WASM, js 和其他 assets (image，css, scss)。github地址https://github.com/thedodd/trunk--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-05-23 21:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "trunk: 构建,打包和发布你的 wasm 应用" }, "type": "text" }], "type": "title" } },]
