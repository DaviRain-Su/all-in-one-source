export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "baoyachi" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rkyv是Rust实现的零拷贝反序列化框架。我们都知道在Rust库中，序列化、反序列化多少都离不开serde_json。rkyv宣称堪比serde_json序列化更快的crates。详情链接：https://davidkoloski.me/blog/rkyv-is-faster-than/有位作者在Reddit发表了一篇帖子：I really love TOML files.“我没在使用Rust之前，并不了解Toml文件。现在我想用它来做任何事。” 这不就是传说中的：相见恨晚嘛。为什么Toml文件会被人喜爱？下面有人评论：“对于许多简单的配置，它们真的很酷！ 它们没有YAML陌生性，也没有JSON的字符串性，并且它们大多是扁平的，几乎没有级别缩进。...”详细链接：https://www.reddit.com/r/rust/comments/m37zya/i_really_love_toml_files/cargo-quickinstall 有点类似于Homebrew的Bottles（二进制包）概念，但用于cargo install。作者认为：在此之前，通常将二进制文件托管在Bintray（homebrew serves）上，但是该服务正在逐步淘汰，因此我需要更换它。😁看来作者的野心非常大，使用Rust编写的（酒桶）有没有可能性？详细链接：https://www.reddit.com/r/rust/comments/m2vp2o/release_cargoquickinstall_020_prebuilt_binary/vedio:https://www.reddit.com/r/rust/comments/m3b7r9/czkawka_300_my_data_cleaner_app_written_in_rust/详细链接：https://www.reddit.com/r/rust/comments/m3b7r9/czkawka_300_my_data_cleaner_app_written_in_rust/用Rust写游戏:神枪在手，说抖不抖。本教程是系列教程的后续部分，我们将使用rg3d游戏引擎制作3D射击游戏。详细链接：https://rg3d.rs/tutorials/2021/03/11/tutorial3.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rg3d.rs/tutorials/2021/03/11/tutorial3.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-12 23:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "wgpu 创建渲染管道的方式已经进行了改进。大多数属于自己的字段都被分组为结构，例如 MultisampleState 。这意味着简单的管道更容易创建，因为我们可以对我们不关心的字段使用Default::Default()或None。https://docs.rs/wgpu/0.7.0/wgpu/struct.MultisampleState.htmlRead More ：https://sotrh.github.io/learn-wgpu/Github ：https://github.com/sotrh/learn-wgpu" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sotrh/learn-wgpu" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-11 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "learn wgpu系列教程终于完全升级到了0.7版本！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "WebGPU 是 Web 上图形和计算的新标准。他们的团队积极参与设计和规范过程，同时在 Gecko 中开发实现。自从 Mozilla Hacks 博客上一次公开更新以来，他们已经取得了很大的进步，他们在本篇blog中分享他们的进展！本文具体到WGSL和WGPU的相关进展，对这方面有兴趣的可以看看。Read More ：https://mozillagfx.wordpress.com/2021/03/10/webgpu-progress/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://mozillagfx.wordpress.com/2021/03/10/webgpu-progress/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-11 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WebGPU在Gecko中的进展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ter是一个文本表达式运行器，使在命令行上的文本处理可读。note：此处有gif！😀Github ：https://github.com/schulke-214/ter" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/schulke-214/ter" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-11 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ter v0.1.1 released" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在已经有方法可以将miri编译到wasm了。issue ：https://github.com/rust-lang/miri/issues/722#issuecomment-795763551" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-lang/miri/issues/722#issuecomment-795763551" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-11 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Miri运行在wasm上！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "教你如何用Rg3d制作一个射击游戏系列教程更新第二章了！Rg3d是一个使用Rust编写的游戏引擎，渲染后端用的是OpenGl的Rust绑定：glutin ，说到这个教程出现的原因，很心酸的想贴上这段话：I have a simple question for the community: what stops you from using the engine? The lack of tutorials, immaturity, different approaches (no-ecs for example, or maybe you have your reason you want to share? I need to know what should be done first to make engine more newcomer-friendly. I have ~10 years of experience in gamedev and some things may be not obvious to me, so I need your help.消息是Rg3d的作者在Discord上发布的，时间是2月16日的时候，发布之后有不少人表达了自己的想法，同时现在你看到的教程，也正是通过这次调查得到大家反馈之后才出的。作者本人在Discord上对大家的提问回复都很及时，Rust社区本身不是很大，同时Rust游戏社区就更小了，但是仍然有很多人对此不断耕耘，所以如果你对游戏开发很有兴趣，同时也是Rust厨的话，一直还没有去尝试过使用Rust开发游戏的你，一定要去感受一下使用Rust开发游戏！Read More： https://rg3d.rs/tutorials/2021/03/09/tutorial2.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rg3d.rs/tutorials/2021/03/09/tutorial2.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-11 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "教你如何用Rg3d制作一个射击游戏！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "许多人对在现有的项目中添加Rust来增加项目的安全性很感兴趣，例如，可以方便地使用Rust来处理个别高风险的事情，比如字符串解析，同时还可以保留其他部分代码不变。而实现这样一个共享库的过程中，如果你仍然通过Cargo来管理你的项目，你会碰到以下两个问题：Read More: https://nibblestew.blogspot.com/2021/03/mixing-rust-into-existing-c-shared.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://nibblestew.blogspot.com/2021/03/mixing-rust-into-existing-c-shared.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-11 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Meson将Rust混合到现有的C共享库中" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本篇blog名字是Rust's async isn't f#@king colored!仅看blog名字也能想到作者是个爆操的老哥，开个玩笑_。本篇blog衍生自15年的一篇著名blog：What Color is Your Function?，在这篇blog种将编程语言的函数调用区分为不同的颜色，特别指出多种语言种的异步调用和同步函数是两种不同的颜色，在编写程序的时候会给程序员造成一些痛苦。而文中所说go、java之类的则不属于这类语言，详细的可以去看看原文。https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/而本篇blog也就沿着上面提到的这篇blog讨论了Rust异步编程种是否存在同样的问题。结论已经被标题出卖了，Rust异步不是有色函数！Read More：https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/[Rust's async isn't f#@king colored!]：https://www.hobofan.com/blog/2021-03-10-rust-async-colored/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-11 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 异步不是有色函数！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "381。Read More：https://this-week-in-rust.org/blog/2021/03/10/this-week-in-rust-381/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/03/10/this-week-in-rust-381/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-11 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 381" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://aloso.github.io/2021/03/10/rusts-universes.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://aloso.github.io/2021/03/10/rusts-universes.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-10 18:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【博客】Rust 命名空间" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者在 AWS serverless 云计算服务上部署了一些 Rust 代码，但是却发现延迟很高。经过一番研究，作者解决了这个问题。https://www.peakscale.com/100ms-gotcha/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.peakscale.com/100ms-gotcha/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-10 18:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【博客】 AWS Lambda 上 Rust 代码的 100ms 延迟" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者对这一问题进行了分析，并提到一个观点，如果用 Rust 来写 curl 的话，这些漏洞会减少一半。https://daniel.haxx.se/blog/2021/03/09/half-of-curls-vulnerabilities-are-c-mistakes/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://daniel.haxx.se/blog/2021/03/09/half-of-curls-vulnerabilities-are-c-mistakes/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-10 18:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "curl 一半的漏洞都是关于 C 语言的错误" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Giganotes 是作者开发的一个笔记软件，作者尝试使用 Rust 来提高软件的性能，并取得了很好的成效。https://github.com/giganoteshttps://www.reddit.com/r/rust/comments/m14agf/how_i_significantly_improved_giganotes_app/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/m14agf/how_i_significantly_improved_giganotes_app/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-10 18:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我是如何使用 Rust 大幅提高笔记软件的性能的？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在可以用Rust版的Coreutils (cp, chmod, ls, rm, tail, install..) 来运行Debian啦。GitHub项目地址：https://github.com/uutils/coreutils/阅读更多：https://sylvestre.ledru.info/blog/2021/03/09/debian-running-on-rust-coreutils" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://sylvestre.ledru.info/blog/2021/03/09/debian-running-on-rust-coreutils" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-09 22:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust版coreutils现在可以用来跑Debian啦" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "详情请见：https://rust-gamedev.github.io/posts/newsletter-019/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust-gamedev.github.io/posts/newsletter-019/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-09 22:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust在游戏开发中的进展，2021年2月" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "详情请见：https://rust-osdev.com/this-month/2021-02/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust-osdev.com/this-month/2021-02/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-09 22:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust在系统开发中的进展，2021年2月" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个月的Rust游戏开发meetup将举行于 16:00 GMT。https://everytimezone.com/s/9c3c5622详情请见：https://www.reddit.com/r/rust_gamedev/comments/m0nxan/the_march_rust_gamedev_meetup_is_this_saturday/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust_gamedev/comments/m0nxan/the_march_rust_gamedev_meetup_is_this_saturday/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-09 22:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Meetup - Rust游戏开发" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "和Nikolai Vazquez一起参加线上Meetup。一起通过学习 impls 和 static_assertions 的实现来加深对宏的理解。来学学怎么用Rust类型系统完成一些看似不可能的任务吧。日期：Wednesday, March 10, 2021 7:00 PM to 9:00 PM EST详情请见：https://www.meetup.com/Rust-NYC/events/276666844" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.meetup.com/Rust-NYC/events/276666844" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-09 22:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Meetup - Rust类型系统中的黑魔法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇教程中你将会学到如何为一个树结构实现迭代器。阅读更多: https://aloso.github.io/2021/03/09/creating-an-iterator" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://aloso.github.io/2021/03/09/creating-an-iterator" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-09 22:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "教程：如何在Rust中实现一个迭代器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Linfa是Rust写的统计学习综合工具箱，现在它有自己的网站啦。快来看看吧：https://rust-ml.github.io/linfa/GitHub项目地址: https://github.com/rust-ml/linfa" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-ml/linfa" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-09 22:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Linfa 现在有网站啦" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者分享了自己用Rust写的跨平台命名管道库 ipipe 。项目地址：https://crates.io/crates/ipipe阅读更多：https://www.reddit.com/r/rust/comments/m0rh4p/im_making_a_crossplatform_namedpipe_api_in_rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/m0rh4p/im_making_a_crossplatform_namedpipe_api_in_rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-09 22:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ipipe 跨平台的命名管道API" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ReBackup是一个轻量级的备份程序，它不会直接为你创建存档，而是帮助你列出需要备份的文件列表，然后你可以将这些列表再传给其它压缩程序（如tar, zip）。可以通过Cargo安装：GitHub项目地址: https://github.com/ClementNerma/ReBackup阅读更多：https://www.reddit.com/r/rust/comments/m0mhrc/rebackup_a_lightweight_backup_program_that_builds/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/m0mhrc/rebackup_a_lightweight_backup_program_that_builds/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-09 22:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ReBackup: 轻量级备份程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "由华为、openEuler 、Netwarps、开源中国和Rust中文社区联合主办，包括六大议题 ：报名：https://www.oschina.net/m/event/2321485" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-08 21:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "3 月 27 深圳 Meetup 等你来" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "超详细 Rust Web 开发人员的路线图, 不说了, 看图.github 地址https://github.com/anshulrgoyal/rust-web-developer-roadmap" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-08 21:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Web开发人员路线图" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文总结了常见的返回引用的几种方式,强烈推荐.原文链接https://bryce.fisher-fleig.org/strategies-for-returning-references-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-08 21:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中返回引用的各种策略" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "gloo 是 rustwasm 下的一个官方项目 (801星) , 由于作者不能再维护, 所以在寻找一个maintainer. 感兴趣的小伙伴可以尝试联系一下.原始issue地址https://github.com/rustwasm/gloo/issues/119" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-08 21:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gloo: 一个官方的 rustwasm 项目寻找 maintainer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 <<使用 Rust 构建 OpenStreetMap App>>的第五部分, 本文会展示如何获取 OpenStreetMap 的数据并且展示在 map 中.原文链接https://blogg.bekk.no/building-an-openstreetmap-app-in-rust-part-v-f14831e13e61" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-08 21:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 构建 OpenStreetMap app: Part V" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "增加了大量的特性:\nadd line to block and back comment conversion assist\n(first contribution) add region folding support\nsuggest name in \"extract variable\" assist\nshow docs on hover for keywords and primitives\n(first contribution) \"add type ascription\" assist\ngenerate_function assist: convert arg names to lower snake case\nadd \"generate default()\" assist\nadd while let completion.\nmake imports grouping configurable via rust-analyzer.assist.importGroup\nrename rust-analyzer.cargo.loadOutDirsFromCheck to rust-analyzer.cargo.runBuildScripts\n原文链接https://rust-analyzer.github.io/thisweek/2021/03/08/changelog-67.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-08 21:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-analyzer changelog #67" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一系列学习 Rust 视频的第三部分, Structs and Traits, 内容相对比较简单, 有喜欢看视频学习 Rust 的小伙伴可以翻墙看一下.油管视频https://youtu.be/tYfA5rjrhqk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-08 21:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Learning Rust: Structs and Traits" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "maple 是一个基于 WebAssmebly 的, 不使用 Virtual DOM技术的 web 框架. 该框架使用更细致的控制,直接修改 DOM.github 地址https://github.com/lukechu10/maple--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-08 21:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "maple: 一个无VDOM 的 web 框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "gloo 是 使用Rust和Wasm构建快速，可靠的Web应用程序和库的工具包。GitHubhttps://github.com/rustwasm/gloo" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-07 22:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gloo：rustwasm project" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust-guidelines 收集了用于编写Rust代码的新出现的原理，约定，抽象和最佳实践。Docshttps://doc.rust-lang.org/1.0.0/style/README.htmlGitHubhttps://github.com/rust-lang/rust-guidelines" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-07 22:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Style Guidelines" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust lambda 是适用于AWS Lambda的Rust运行时。GitHubhttps://github.com/awslabs/aws-lambda-rust-runtime" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-07 22:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust lambda" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在本文中，我们将研究单线程C ++中的几种内存访问错误，以及Rust如何防止我们犯这些错误。我写了一篇简短的文章，展示了C ++中的内存访问错误以及Rust如何阻止我们访问这些错误。目录：\nReturning references to temporaries\nShort lifetimes\nReferenes to container contents\nTricky lifetime extensions\n阅读原文https://radekvit.medium.com/avoiding-single-threaded-memory-access-bugs-with-rust-for-c-developers-2b7fc9c877echttps://rustcc.cn/blog_with_author?author_id=2b94dbc4-c79f-43c0-b3c2-f143596ea535" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-07 22:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "避免使用Rust进行单线程内存访问错误" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们上一讲结束了为我们的操作系统编写图形驱动程序和事件驱动程序。我们还添加了几个系统调用来处理绘图原语以及处理键盘和鼠标输入。现在我们将使用这些动画来制作简单的pong游戏。就像《hello world》是对所有编程语言的测试，《pong》也是对我们所有图形和事件系统的测试。文章链接，https://blog.stephenmarz.com/2021/02/22/writing-pong-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.stephenmarz.com/2021/02/22/writing-pong-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-06 20:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust给我的操作系统写乒乓（Pong）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本教程开始了一系列关于rg3d游戏引擎的教程。在这个系列中，我们将制作一个3D射击游戏-类似于rusty-shooter的射击游戏。此外，该系列应该帮你学习引擎底层的基本原理。文章链接，https://rg3d.rs/tutorials/2021/03/05/tutorial1.htmlGithub 链接，https://github.com/mrDIMAS/rg3d-tutorials" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mrDIMAS/rg3d-tutorials" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-06 20:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用rg3d编写3D射击游戏 #1-角色控制器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "感谢从以前的帖子中得到的灵感，今天我尝试将pipe .sh转换成rust代码。在rust_cmd_lib的帮助下，它变得非常简单，您可以在project examples目录中查看这两种语言的版本。我之前也对tetris.sh做过同样的转换。你可以尝试“cargo run—example tetris”或“cargo run—example pipes”。文章链接，https://www.reddit.com/r/rust/comments/lyuqyn/convert_tetrissh_and_pipessh_linebyline_to_rust/Github 链接，https://github.com/rust-shell-script/rust_cmd_libhttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-shell-script/rust_cmd_lib" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-06 20:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "将tetris.sh和pipe .sh逐行转换为rust代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 采用每六周一个小版本和每三年一个 Edition 版本的方式来迭代更新。相比于 2018 Edition，2021 Edition 会是一个相对小的版本，官方计划于 2021年10月21号（1.56）正式发布。目前并没有完全确定下来哪些功能将纳入 2021 Edition，但有部分特性是已经确定好的了，这些特性包括：\n\nPrelude 加入新的 trait：TryFrom / TryInto, FromIterator\n\n\n更 ergonomic 的闭包变量捕获规则。\n\nPrelude 加入新的 trait：TryFrom / TryInto, FromIterator更 ergonomic 的闭包变量捕获规则。现在的闭包变量捕获非常严格，就算你只引用了单个 struct 的字段，它也会把整个 struct 捕获进来。新的规则会做到尽量小范围的捕获变量，比如下面两个例子在 2018 Edition 编译不通过，但是 2021 Edition 是可以的：\n改善 or 模式匹配\n\n统一 macro_rules 定义的宏的默认可见性，移除#[macro_export] 和 #[macro_use] 宏：\nRust 所有类型可见性默认都是私有，只有加 pub 或 pub($PATH) 才能修改为公开可见，而 macro_rules 定义的宏却不是这样的，你需要使用 #[macro_export] 才能让这个宏公开。从 2021 Edition 开始，macro_rules 定义的宏默认为私有，同样需要加 pub 或 pub($PATH) 才能修改可见性。#[macro_export] 和 #[macro_use] 这两个宏就没什么用了，直接移除。链接：https://blog.rust-lang.org/inside-rust/2021/03/04/planning-rust-2021.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/inside-rust/2021/03/04/planning-rust-2021.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-05 22:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 2021 Edition 计划10月21号发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "链接：https://github.com/rust-lang/rust/pull/81451" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-lang/rust/pull/81451" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-05 22:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 编译器后端升级为 LLVM 12" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "小编去年的日报 (日报链接）有到过 Embark 公司尝试为了让 Rust 成为 GPU 编程的一等公民，发布了 rust-gpu 这个 crate 来替代 OpenGL 和 DirectX 的着色器语言。现在这个 crate 又迈出了很关键的一步，他们的游戏引擎使用 Rust 完全替代了 GLSL/HLSL ！https://rustcc.cn/article?id=6094b07e-3a9b-4826-89bc-63dc0313f448链接：https://github.com/EmbarkStudios/rust-gpu/releases/tag/v0.3.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/EmbarkStudios/rust-gpu/releases/tag/v0.3.0" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-05 22:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-gpu v0.3 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "官方宣称 synth 是一个 faker 和 HashiCorp 的 Terraform 的混合产品，比 faker 强大，比 Terraform 简单。小编看了一下，非常不错！https://pypi.org/project/Faker/链接：https://github.com/openquery-io/synthhttps://github.com/folyd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/openquery-io/synth" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-05 22:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "synth - 一个 Rust 编写的声明式数据生成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自 AWS Open Source Blog 的文章：AWS 至少从 2017 年开始就在多个服务中使用 Rust，自今年年初以来，AWS Rust 团队一直在起草我们的章程和原则。章程和原则是 AWS 团队用来定义我们的范围和优先事项的框架。章程告诉你团队在做什么，而原则告诉你团队将如何去做。由于我们团队的信条之一是公开和透明的运作，我们想与你们分享我们的章程和信条，我们想让你知道我们在做什么。起草我们的章程很容易。只有一句话：AWS Rust 团队致力于为所有用户提高 Rust 的性能、可靠性和生产力。不过，写这些信条花了不少功夫。更多请看原文：https://aws.amazon.com/cn/blogs/opensource/how-our-aws-rust-team-will-contribute-to-rusts-future-successes/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://aws.amazon.com/cn/blogs/opensource/how-our-aws-rust-team-will-contribute-to-rusts-future-successes/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-04 21:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "AWS Rust 团队将如何为Rust未来的成功做贡献" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们在本文中将致力于制作一个 AWS Lambda，该 Lambda 调用 API（异步操作）并为我们获取报价，AWS Lambda是执行此操作的一种好方法。我们将使用 Rust 来发布一个单独的可执行二进制文件，我们的 lambda 可以在被调用时运行它。这并不像它应该的那样简单，主要是由于编写时 lambda rust 运行时的原因。更多请看原文：https://beanseverywhere.xyz/blog/rust-lambda" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-04 21:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "将 Rust 用于 AWS Lambdas" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Fluvio Cloud 是一个用 Rust 编写的实时应用程序的开源高性能分布式数据流平台，平台现在已经进入alpha阶段，查看原文：https://www.fluvio.io/blog/2021/03/announcing-fluvio-cloud-platform/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-04 21:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fluvio Cloud 平台" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果您希望用 Rust 编写速度更快的代码，那么有好消息!Rust 让编写快速代码可以变得非常容易。对零成本抽象的关注、缺乏隐式装箱和静态内存管理意味着，即使是 naïve 代码也往往比其他语言中的同类代码要快，当然也比任何同等安全的语言的代码要快。但是，也许像大多数程序员一样，您在整个编程生涯中都不必担心机器的任何细节，而现在您想要更深入地了解并找出重写的 Python 脚本的真正原因。 Rust 的运行速度快了 100 倍，并使用了十分之一的内存。毕竟，它们都做相同的事情并在相同的 CPU 上 运行，对吧？因此，这里有一个优化指南，针对那些知道如何编程，但可能不知道代码如何 CPU 上映射到真实的 1 和 0 的人。我将尝试编写关于优化 Rust 代码的实用技巧，并解释为什么它比替代方法更快，最后我们将以 Rust 标准库中的一个案例研究作为结束。原文地址（好像之前日报发过）：https://gist.github.com/little-dude/674de61df7f48547bdcc5bbe2860563d" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-04 21:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 优化技巧" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个项目是使用 Rust 编程语言和 Bevy 游戏引擎对 Game Physics in a Weekend这本书的实践。这对我来说是一个学习练习，以便更好地理解如何使用 Bevy 和数学库 glam 来实现物理引擎。项目地址：https://github.com/bitshifter/bevy-physics-weekendhttps://gamephysicsweekend.github.io/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-04 21:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "bevy-physics-weekend 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Qovery Engine是一个开源抽象层库，仅需几分钟，它就可以轻松地在AWS，GCP，Azure和其他云提供商上部署应用程序。Qovery引擎是用Rust编写的，并利用Terraform，Helm，Kubectl和Docker来管理资源。https://www.rust-lang.org/\n零基础架构管理： Qovery Engine为您初始化，配置和管理您的Cloud帐户。\n支持多个云：Qovery Engine可以在AWS，GCP，Azure和任何云提供商上使用。\n在Kubernetes之上： Qovery Engine在更高的抽象级别上利用了Kubernetes的功能。\nTerraform和Helm： Qovery Engine使用Terraform和Helm文件来管理基础结构和应用程序部署。\n强大的CLI：使用提供的Qovery Engine CLI在您的Cloud帐户上无缝部署您的应用程序。\nWeb界面： Qovery通过qovery.com提供Web界面。\nhttps://asciinema.org/a/370072ReadMore:https://github.com/Qovery/engine" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Qovery/engine" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-03 21:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Qovery Engine - Rust库,可在云服务上自动化部署应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "从PyCharm Professional 2021.1 EAP开始,也可以使用 pycharm 调试 rust 了,不过需要装Native Debugging Support](https://plugins.jetbrains.com/plugin/12775-native-debugging-support) 这个插件,并且仅支持 LLDB 调试。其余的更新就去下面的链接看吧ReadMore:https://intellij-rust.github.io/2021/03/01/changelog-142.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://intellij-rust.github.io/2021/03/01/changelog-142.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-03 21:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "INTELLIJ RUST CHANGELOG #142" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个CLI工具，用于根据Rust中编写的OCI规范生成和运行容器。ReadMore:https://github.com/huanghongxun/runc-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/huanghongxun/runc-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-03 21:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust: runc-rs" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "serde是在Rust生态系统最流行的crate，一个用于高效地序列化和deseri一个LIZING数据结构。它支持多种数据格式，包括JSON，YAML，MessagePack等。与许多其他（反）序列化器不同，它不使用运行时反射，而是使用Rust的引人注目的特征系统。这使Serde异常有效，因为数据结构本质上知道如何序列化或反序列化自身，并且它们通过实现SerializeorDeserialize特性来实现。幸运的是，这要归功于大多数类型，这要归功于derive宏。您可能会像我一样遇到陷阱，在这篇博客文章中，作者想特别谈一谈：转义序列。https://github.com/serde-rs/serdeReadMore:https://d3lm.medium.com/rust-beware-of-escape-sequences-85ec90e9e243#ee0e-58229fc84d02" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://d3lm.medium.com/rust-beware-of-escape-sequences-85ec90e9e243#ee0e-58229fc84d02" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-03 21:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust: 提防转义序列 \\n" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "主讲人：Mike内容：OpenRA 是开源重制版红警，不过目前已经实现的部分只是红警1，红警2尚未完成。目前OpenRA是用C#写的。我们来憧憬一下，如果OpenRA用Rust重新实现会怎样？如果做，那就基于Rust最热的bevy游戏引擎来做。对Rust游戏开发感兴趣的都来出出主意吧。我们会先启动一个学习型的项目，openra-rs内部分享甚至会成为一个专门的视频系列。敬请期待。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-02 22:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《Rust唠嗑室》第19期 - 启动 OpenRA-rs 项目+乱聊" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者 @EbTech 是应用数学出生，因此本书提供的算法主要包括应用数学（傅里叶变换等）的算法以及图的算法使用 Rust 的实现。仓库： https://github.com/EbTech/rust-algorithms" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-02 22:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-algorithms 用 Rust 写算法的教科书" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "过去的一周时间小编翻看了一些基于 Rust 的身份证识别库（如 https://crates.io/crates/rust-idcard ),基本上只提供了身份证证件号码和其他文本信息的读取，而缺少其他根据《中华人民共和国身份证法》需要提供的指纹和照片信息的读取。于是小编决定将这些信息结构化，并且统一为信息完全的特质库，并且提供了一些相应符合生活常识的类型对读取的身份信息进行处理仓库：https://github.com/huangjj27/idcard-cn" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-02 22:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "idcard-cn v0.0.1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "TiFS 是一个基于 TiKV 的分布式 POSIX 文件系统，具有分区容限和严格的一致性。目前发布了 0.1.0 版本, 感兴趣的小伙伴可以看一下.github地址https://github.com/Hexilee/tifs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-01 20:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "TiFS: 基于 TiKV 的分布式 POSIX 文件系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者是 Rust 的核心团队成员, 之前就职于 Mozilla, 现就职于 Facebook. 写过最初的基于 LLVM 的 Rust 代码生成器, 以及很多 Rust 相关的工作.该 keynote 讲述的是 Rust 中 LLVM 相关工作:\n新的特性. 将LLVM 的提升带到 Rust 中.\nLLVM 相关的提升和修复.\n未来的挑战.\n对于 Rust 编译器层面感兴趣的小伙伴可以深入了解.keynote地址https://www.icloud.com/keynote/09ZXbPfbCKm8vCtAnWdfi2xIg#rust-llvm-cgo-2021" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-01 20:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust and LLVM in 2021" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者打算使用 Rust 重新实现 C++教程 <<Ray tracing in One Weekend>>, 本文目标人群是对于 Rust 感兴趣的, 或者对图像渲染感兴趣的人.通过本教程,最终会得到下面的预览图.整个过程, 作者既给出了C++代码, 也给出了Rust代码, 对于熟悉 C++的同学,可以更加清晰的了解两种语言的不同.原文链接https://jduchniewicz.com/posts/2021/02/c-to-rust-or-how-to-render-your-mindset/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-01 20:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "C++ to Rust - or how to render your mindset" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Speedy2D 是一个拥有硬件加速, 简单易上手的 API的图像库, 可以方便的绘制 各种形状, 图像 和 文本.目标:\n最简单的 Rust API 来创建 window, 渲染图像和文本, 处理输入.\n兼容任意带有 OpenGL 2.0+ 和 OpenGL ES 2.0+ 的设备\n非常快\ngithub地址https://github.com/QuantumBadger/Speedy2D--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-03-01 20:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Speedy2D: 兼容 OpenGL (ES) 2.0+ 的图像库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust时光易逝，转眼二月即将过去，春暖花开的三月即将到来。过年的余味犹在，但我们不得不继续踏上征途。经过各位小编的工作《 RustMagazine 中文精选 》2021 年第二期发布了，伴随着二月刊发布， mdbook 模版功能也有两个改进：\n增加评论功能，评论会自动同步到 RustMagazine GitHub 仓库 与文章同名的 issues 下（文章下有评论就自动创建）。\n增加画图功能，使用 mermaid 来画图。参考：mermaid 在线使用指南。\n欢迎大家直接使用本刊 mdbook 模版进行创作投稿发PR！阅读：https://rustcc.cn/article?id=4da4069e-42f2-43cc-a466-50c22d2c29ce" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 21:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《 RustMagazine 中文月刊 》2021 年第二期发布！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rustOuter Wonders是一款游戏，这篇博客介绍了一目了然的可视化脚本工具，可以使用该脚本工具在Outer Wonders中实现交互性和过场动画！这篇技术博客文章还介绍了如何使用自定义的 rustlang 支持的引擎来运行脚本！Read Morehttps://utopixel.games/en/blog/designing-outer-wonders-scripting-engine/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 21:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【阅读】为 Outer Wonders 设计脚本引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rustRust Lab 是一个 Rust 语言的大会，目前正在筹划第一次会议，预计将在三月举办，现在的主题有：\nEmbedded\nPatterns / Idiomatic code / Best practices\nWebAssembly\nBorrow Checker\nConcurrency / Parallelism\nHow to create a good crate\nPros/Cons Async / No Async\nPros/Cons std / no std\nMemory tracing\n现在正在广泛征求建议，主办方会根据建议修改/新增演讲主题，如果有想分享的内容可以通过建议提出来。https://rustlab.it/en/call-for-proposal/Read Morehttps://rustlab.it/en/call-for-proposal/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 21:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustLab conference 正在征求建议" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "时光易逝，转眼二月即将过去，春暖花开的三月即将到来。过年的余味犹在，但我们不得不继续踏上征途。《 RustMagazine 中文月刊 》2021 年第二期发布了，后续也期待大家投稿。阅读：https://rustmagazine.github.io/rust_magazine_2021/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rustmagazine.github.io/rust_magazine_2021/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本期目录" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n发刊通告\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "发刊通告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "精选自《Rust日报》\nRust官方动态\n社区热点\n推荐项目\n学习资源\nRust 唠嗑室本月汇总\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本月社区动态简报" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n知乎 Rust 圆桌年话专题问答精选\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 问答精选" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n华为 | 可信编程 -- 华为引领Rust语言开发的实践和愿景\n蚂蚁集团 CeresDB 团队 | 关于 Rust 错误处理的思考\n华为工程师 | Rust中的错误传递和日志记录\nPingCAP | traceing\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust in Production" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n新年新人新气象 | Rust 学习笔记\n「译」使用 Rust 实现命令行生命游戏\n「译」使用 Tokio 实现 Actor 系统\n解读 Rust 1.51 稳定版\n解读 Rust 2021 Edition RFC \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "学习园地" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n前端入门 ｜ Rust 和 WebAssembly \n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WASM 专题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n实践案例 | 使用 Bevy 游戏引擎制作炸弹人\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "游戏专题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nio_uring | Linux 全新异步接口 io_uring 的 Rust 生态盘点 \nio_uring | 用 Rust 实现基于 io_uring 的异步随机读文件\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "操作系统与网络编程专题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n如何为 Rust 语言做贡献 | Part 1\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 编译器专题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "mdbook 模版功能新增：\n增加评论功能。评论会自动同步到 RustMagazine GitHub 仓库 与文章同名的 issues 下（文章下有评论就自动创建）。\n增加画图功能。利用 mermaid 来画图。参考：mermaid 在线使用指南。\n画图示例：欢迎大家直接使用本刊 mdbook 模版进行创作投稿发PR！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本刊 mdbook 模版功能改进" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "ZhangHanDong" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "浏览量：\n网页浏览量 ：3,678\n唯一身份浏览量 ：2,889\n读者访问最多时段：\n每天上午 8点 到 下午 6点。\n周四 和 周五 阅读量相对更多。\n读者分布地区排名：\n中国\n北美（美国/加拿大）\n澳洲\n一月份比较受欢迎的文章 Top 5（按访问量依次排名）：\n《图解 Rust 所有权》，作者：肖猛\n《用 Rust 写操作系统 | rCore 教程介绍》，作者：清华大学\n《RustChinaConf2020 精选 | Rust 异步开发》，作者：赖智超\n《关于 io_uring 与 Rust 的思考》，作者：王徐旸\n《图解 Rust 编译器 | Part 1》，作者：张汉东\n阅读量最低为：\n《Rust 生态安全漏洞总结系列 | Part 1》，作者：张汉东\n《Rustc Dev Guide 中文翻译启动》，作者：张汉东\n简报关注分类依次为：\nRust 官方动态\n学习资源\n推荐项目\n社区热点\nRust 唠嗑室\n读者阅读渠道依次为：\n直接访问\nGitHub\n百度\n⾕歌\nrustcc\n其他\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-28 15:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "上期（一月刊）访问数据统计小结" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "常量泛型（const generics）是Rust最受期待的功能之一，其从最初RFC被接受至今已有三年了，现在其第一个版本已经在Rust beta版本中提供，并将在 v1.51版本中提供，该版本预计2021年3月25日发布。使用常量泛型的示例：如此重要的新功能，如果遇到任何问题，欢迎提交 issue。更多详情，请阅读 Rust 博客文章，链接，https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-27 23:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 将发布常量泛型 MVP beta版" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 2021 版有几个额外的 traits，具体可以参见该 rfc 链接，https://github.com/djc/rfcs/blob/prelude-2021/text/0000-prelude-2021.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/djc/rfcs/blob/prelude-2021/text/0000-prelude-2021.md" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-27 23:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 2021 edition 计划" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在过去的三个月中，rg3d和rusty-editor取得了很多重要的功能和改进。并开始使用引擎制作了新游戏，Station lapetus，一款Sci-Fi 3D射击游戏，游戏的 Github 链接 https://github.com/mrDIMAS/StationIapetus。近3个月的进展报告，链接，https://rg3d.rs/general/2021/02/26/progress.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rg3d.rs/general/2021/02/26/progress.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-27 23:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rg3d 游戏引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "LAM，针对 WebAssembly和 Native 的 actor VM。访谈链接，https://notamonadtutorial.com/lam-an-actor-model-vm-for-webassembly-and-native-d7939362e1b8项目链接，https://abstractmachines.dev/LAM Github 链接，https://github.com/AbstractMachinesLab/lamhttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/AbstractMachinesLab/lam" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-27 23:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "LAM，actor模式的VM" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baoyachi" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "昨天，《Rust语言中文》社区推送的一篇公众号关于：Rust for web development: 2 years later的文章。可以理解为作者使用了两年Rust后的一些感悟，在此翻译中文。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-26 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baoyachi" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大约2年前，我开始使用Rust开发Web服务（JSON API），我认为是时候可以摆脱先入为主的观念并分享我学到的知识了。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-26 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《Rust用于web开发的2年后感悟》" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baoyachi" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nRust代码很丑陋：Rust是显式的。不可否认。但是，当我编写代码时，我的IDE可以帮到我很多，而不必按下那么多键。当我阅读代码时，这种明确性真是太棒了！没有隐藏的惊喜，没有奇怪的事情。\n内存管理令人分心：实际上呢，没有。我没有使用那么多的词法生命周期，而是使用了智能指针。是的，因此我理解了Box，Rc和Arc之间的差异，与之同时和Node.JS、Golang语言相比，我的生产率没有因此受到影响。\n编译器很麻烦：一开始是的。但是几个月后，我能够立即理解错误，并能立刻解决这些错误。今天，我真的没有花太多时间在编译器上。相反，它成为了我最好的朋友，尤其是在重构大部分代码或升级依赖项时。\n缓慢的编译时间:我给这个说明。在Node.JS或Golang中，一个中等大小的服务的Docker image大约需要3到10分钟来构建和部署，在Rust中大约需要30分钟。\n生态系统还不存在：不可否认，的确是这样。缺少一些组件，例如官方的Stripe和AWS开发工具包，但是社区确实很活跃，并构建了所有这些缺少的组件。\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-26 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "偏见" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baoyachi" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n静态链接非常简单：创建小的Docker images 一件令人愉快的事情。。\nRust会让你成为一个更好的程序员：Rust很复杂，如果你不了解它的详细工作原理，它不会放过你。掌握它需要时间和耐心，但是一旦你这样做了，你就会学到很多你永远不会像以前那样接近编程的东西。在学习Tokio的工作原理时，我了解了Golang的运行时是如何工作的。(心智模型学习)\n一旦它编译，通常它就可以正常工作:这是关于Rust我最喜欢的地方。当我的程序编译时，它按我的计划工作。注意：只要记住不要阻塞事件循环，编译器就会处理剩下的事情。您不再需要花时间为语言的怪癖编写测试。\nRust具有很高的生产力：由于Rust是多种范式，因此在编写复杂的业务逻辑时，由于其功能方面，它的确非常出色。\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-26 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我特别值得点赞的几件事" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baoyachi" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nactix-web 用于HTTP层.\nsqlx 用于数据库PostgreSQL.\nrusoto AWS接口服务（S3、SQS、SES）\ntera 用于电子邮件模板\nthiserror 用于错误类型处理\nsentry 用于错误监控\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-26 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "当前我正在使用的一些crates" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baoyachi" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust非常适合用于web开发，在此我强烈建议尝试一下。取得成功是一次漫长的旅程，但完全值得，即使您不是每天都在使用它，也一定会通过学习它而成为一名更好的程序员，如果失去了，那就重新去发现编程的乐趣🤗一句话总结：Rust生而平静。凌晨3点不再有不好的惊喜，因为依赖项更新了它的API使得不再有bug。没有更多恼人的配置自动缩放或什么。而且响应时间非常短，您的用户因此会爱上您的产品。原文地址：https://kerkour.com/blog/rust-for-web-development-2-years-later/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://kerkour.com/blog/rust-for-web-development-2-years-later/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-26 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "结论" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本篇blog作者是今年七月要出的rust新书Black Hat Rust的作者，在两年前作者就已经开始尝试用Rust去进行web开发，这篇blog谈的是他开发的一些感受，一些经验，同时提到了他开发中用到了哪些crate。https://academy.kerkour.com/black-hat-rust?coupon=BLOGRead More: https://kerkour.com/blog/rust-for-web-development-2-years-later/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://kerkour.com/blog/rust-for-web-development-2-years-later/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-25 20:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust for web development" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "维护这个框架的作者是seed的主要维护者，所以，理所当然的在前端部分选择了seed。ReadMore: https://moonzoon.rs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://moonzoon.rs/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-25 20:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MoonZoon 一个 Rust 全栈框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "为了真正了解Rust，我们需要了解其关键的区别于其它语言的特性: 所有权。本篇blog用了笨方法的方式来讲解Rust的所有权。ReadMore: https://chrismorgan.info/blog/rust-ownership-the-hard-way/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://chrismorgan.info/blog/rust-ownership-the-hard-way/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-25 20:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "笨方法学习Rust所有权机制" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个纯Rust实现的WebRTC栈。用Rust重写Pion的WebRTC栈。http://pion.ly/WebRTC是一个实时P2P通信的规范。详情可以看这里：https://webrtc.org/。现WebRTC被用于浏览器中的视频会议和语音通信。谷歌Meet或Discord voice，他们正在使用WebRTC进行数据传输。它还被用于多人游戏，文件传输，基本上任何需要 P2P 通信的事情。官网: https://webrtc.rs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://webrtc.rs/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-25 20:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WebRTC.rs" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "379。Read More：https://this-week-in-rust.org/blog/2021/02/24/this-week-in-rust-379/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/02/24/this-week-in-rust-379/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-25 20:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 379" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "前天日报的六道问题答案公布在了当日论坛评论之中，考虑到有小伙伴看的是公众号，所以在此整理题目和对应解析给大家：The type parameter T represents the data that this lock protects. It is required that T satisfies Send to be shared across threads and Sync to allow concurrent access through readers.是否可以通过编译？为什么？不可以，参考object safe 三条规则。Copy是marker trait，告诉编译器需要move的时候copy。Clone表示拷贝语义，有函数体。不正确的实现Clone可能会导致Copy出BUG。Deref 是一个trait，由于rust在调用的时候会自动加入正确数量的 * 表示解引用。则，即使你不加入*也能调用到Deref。调用处宏调用、声明时用宏声明包裹、proc_macro包裹函数、邪道一点用compiler plugin、llvm插桩等形式进行。（Go:我用snippet也行）一个可以被Send到其他线程里的没有参数和返回值的callable对象，即 Closure，同时是 ownershiped，带有static的生命周期，也就说明没有对上下文的引用。再次感谢@wayslog老师的题目和解析，同时感谢@huangjj27的整理。同时我看到不少小伙伴评论想要加入TG群，我只知道Rust众[https://t.me/joinchat/BScxlkthNrn4Vo0L1dG__w]，不知道是不是大家想要加的群。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://t.me/joinchat/BScxlkthNrn4Vo0L1dG__w" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-25 20:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "经典 Rust 面试题六道及其解析" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "今天在电报群由 @wayslog 提出的六道面试题目，wayslog 老师称之为“经典六道”：是否可以通过编译？为什么？3. Clone与 Copy 的区别是什么？4. deref 的被调用过程？5. Rust里如何实现在函数入口和出口自动打印一行日志？6. Box<dyn (Fn() + Send +'static)> 是什么意思?读者们又会几道呢~" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-23 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "经典 Rust 面试题六道" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "十分适合在写命令的时候播放自己喜欢的音乐，有节奏才能更快地编写代码~仓库地址： https://github.com/Bluemi/musicus_rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-23 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个在终端音乐播放器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "双工 Duplex 意味着通道可以同时进行输入及输出。Read 和 Write 特质的串流通常需要 &mut self 而不能同时使用读端和写端。除了 Duplex 特质，该库还为实现了 Duplex + Read + Write 特质的类型提供 HalfDuplex 特质的实现，为实现了 Duplex + AsyncRead + AsyncWrite 特质的类型提供 FullDuplex特质的实现。仓库地址：https://github.com/sunfishcode/duplex仓库地址：https://github.com/sunfishcode/duplex" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-23 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "duplex -- 提供双工与半双工特质" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "相信有大批的人喜欢 terminals这种审美, 作者也是其中之一.作者使用 webassembly + Rust 构建了一个 telnet 聊天服务器. 你可以使用下面的命令来尝试一下.原文链接https://lunatic.solutions/blog/lunatic-chat/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-22 20:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何使用 webassembly 构建一个 telnet 聊天服务器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "EasyRust 是一个非常好的 Rust 入门教程,现在,他不仅有文档,还有视频了.下面是第一期视频,未来至少还有 70 期. 想学习的小伙伴可以跟着视频了解一下.EasyRust地址https://dhghomon.github.io/easy_rust/Chapter_0.html油管视频https://www.youtube.com/watch?v=-lYeJeQ11OI&list=PLfllocyHVgsRwLkTAhG0E-2QxCf-ozBkk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-22 20:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "EasyRust 现在有视频了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Crust of Rust 是一系列非常不错的Rust 视频, 本期作者带来的是 Subtyping and Variance 深度解读.油管视频https://www.youtube.com/watch?v=iVYWDIW71jk&feature=youtu.be" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-22 20:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Crust of Rust: Subtyping and Variance" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "gtk-rs 仓库中有不少代码示例, 作者将很多示例的效果截图并分享出来,可以让大家有个更直观的认识.原文链接https://nivethan.dev/devlog/rust-gtk-examples-images.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-22 20:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gtk-rs example 的截图示例" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "once_cell 1.60 版本发布了. 下面是主要变动.\nAdd Lazy::into_value\nStabilize once_cell::race module for \"first one wins\" no_std-compatible initialization flavor.\nMigrate from deprecated compare_and_swap to compare_exchange\n原文链接https://github.com/matklad/once_cell/blob/97027d52da0c9ab63936ddfe83f46585d7e49408/CHANGELOG.md#160--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-22 20:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "once_cell 1.60 版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Ballista-0.4.0 已于昨天发布。Ballista是主要在Rust中实现的分布式计算平台，由Apache Arrow支持。https://ballistacompute.org/release/2021/02/20/ballista-0.4.0/[Architecture]GitHubhttps://github.com/ballista-compute/ballistaBallista 一个现代的分布式计算平台https://ballistacompute.org/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-21 22:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Ballista：在Rust中实现的分布式计算平台" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "[#]AWS re:Invent 2020当今的网络基础架构软件具有严格的要求。它不仅必须快速而且必须安全-即能够处理不受信任的数据而不会崩溃或不易受到安全漏洞的攻击。传统上，这两个要求是不一致的。网络程序员必须选择提供速度或安全性的语言。使用Rust编程语言和Tokio网络库，您可以同时拥有两者。本次会议展示了如何利用Tokio的零成本抽象来提供可提供表现力，速度和安全性并在两者之间进行权衡的网络平台。YouTubehttps://youtu.be/MZyleK8elPk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-21 22:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust和Tokio构建下一代网络基础架构" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Reddit上的Rust社区有条帖子提到想使用Rust进行实时运动控制，小编就来介绍一个Repo。https://www.reddit.com/r/rust/comments/lo9w23/rust_for_realtime_motion_control/RTIC 是一个 用于构建实时系统的并发框架。RTIC 电子书地址https://rtic.rs/0.5/book/en/preface.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-21 22:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust进行实时运动控制" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用 PyO3 可以与Python交互。\n从Python使用Rust\n从Rust使用Python\nGitHubhttps://github.com/PyO3/pyo3" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-21 22:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "PyO3 0.13.2 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "小编推荐一篇文章~两年多来，Kraken的Core Backend团队一直使用Rust来使最初用PHP编写的服务现代化，同时构建新产品，扩展功能集并支持加密货币交易活动的不断增长。阅读原文https://blog.kraken.com/post/7964/oxidizing-kraken/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-21 22:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Kraken：一个使用Rust 重写核心服务的企业" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在这个项目中会使用到 nRF52840，具体操作点击阅读原文。阅读原文https://embedded-trainings.ferrous-systems.com/preparations.htmlGitHubhttps://github.com/ferrous-systems/embedded-trainings-2020https://rustcc.cn/blog_with_author?author_id=2b94dbc4-c79f-43c0-b3c2-f143596ea535" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-21 22:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Embedded Rust：一个Rust嵌入式项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，我花了很多时间在编写类似JS的小语言上，但实际上没有用，所以我决定开发与ECMAScript兼容的JS引擎。:)现在没有多少ECMAScript标准支持，但是Starlight已经通过了2k+test262测试！它比Boa（另一个Rust写的JS引擎）更快，目标是和V8一样快，也许在达到V8性能后，它可以和JSC一样快。文章链接，https://www.reddit.com/r/rust/comments/lo0hii/starlight_js_engine_focused_on_performance_in_rust/Github 链接，https://github.com/Starlight-JS/Starlight" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Starlight-JS/Starlight" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-21 09:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Starlight：专注于性能的js引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个我用于探索rust做的贪吃蛇游戏。使用了ncurses库。Github 链接，https://github.com/adder46/snake" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/adder46/snake" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-21 09:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "snake：终端贪吃蛇小游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，大约又工作了一个月，RKYV0.4终于推出了新特性和重大变化。如果你还没听说过的话，rkyv是一个针对Rust的零拷贝反序列化框架，类似于Cap'n Proto和FlatBuffers。它主要是为游戏开发而构建的，但也适用于广泛的其他应用程序。文章链接，https://www.reddit.com/r/rust/comments/lniraj/rkyv_04_shared_pointers_and_custom_serializers/Github 链接，https://github.com/djkoloski/rkyvhttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/djkoloski/rkyv" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-21 09:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rkyv 0.4：共享指针和自定义序列化程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者计划使用Rust重新复制一个SQLite数据库，目前正在进行中。SQLite有很完善的文档，代码质量非常高，而且有非常丰富的单元测试用例，终于有人尝试使用Rust重写一个SQLite了，感兴趣的朋友可以一起参与！Github: https://github.com/joaoh82/rust_sqlite链接：https://medium.com/the-polyglot-programmer/what-would-sqlite-look-like-if-written-in-rust-part-1-4a84196c217d" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://medium.com/the-polyglot-programmer/what-would-sqlite-look-like-if-written-in-rust-part-1-4a84196c217d" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-19 21:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust从零重写一个SQLite" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "链接：https://github.com/mattsse/voyager" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mattsse/voyager" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-19 21:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "voyager - Rust写的一个爬虫" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一位台湾同胞写的阳历和农历转换的crate，支持繁体和简体中文，很不错！链接：https://github.com/magiclen/chinese-lunisolar-calendar" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/magiclen/chinese-lunisolar-calendar" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-19 21:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "chinese-lunisolar-calendar" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "主要介绍怎样在Windows平台使用windows-rs这个crate构建Rust程序。链接：https://kennykerr.ca/2021/02/18/rust-for-windows-getting-started/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://kennykerr.ca/2021/02/18/rust-for-windows-getting-started/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-19 21:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "微软的员工发布的Windows用户Rust视频" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rpm-ostree 是一个CoreOS上的包管理器，最近使用Rust重写部分功能。该团队说更多氧化项目（比如/etc/{passwd,group}）正在进行中。链接：https://github.com/coreos/rpm-ostree/releases/tag/v2021.2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/coreos/rpm-ostree/releases/tag/v2021.2" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-19 21:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "CoreOS 的rpm-ostree用Rust重写部分功能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "链接：https://this-week-in-rust.org/blog/2021/02/17/this-week-in-rust-378/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/02/17/this-week-in-rust-378/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-19 21:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust #378" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "谷歌安全博客最近在“缓解开源软件中的内存安全问题”一文中提到了 “The new Rust-based HTTP and TLS backends for curl”，Google 感谢 ISRG 以及社区维护者，可见 Rust 定会在内存安全领域大放异彩，原文地址：https://security.googleblog.com/2021/02/mitigating-memory-safety-issues-in-open.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://security.googleblog.com/2021/02/mitigating-memory-safety-issues-in-open.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-18 22:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "谷歌安全博客：缓解开源软件中的内存安全问题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cranelift 是用 Rust 编程语言编写的代码生成器，旨在成为快速的代码生成器，其输出以合理速度运行的机器代码。如今，它被用于包括 Wasmtime 和 Wasmer 在内的几种不同的 WebAssembly 运行时中，并且还可以作为 Rust 调试编译的替代后端。更多见博客原文：https://blog.benj.me/2021/02/17/cranelift-codegen-primer/Cranelift 仓库地址：https://github.com/bytecodealliance/wasmtime/tree/main/cranelift#cranelift-code-generator" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/bytecodealliance/wasmtime/tree/main/cranelift#cranelift-code-generator" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-18 22:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cranelift 代码生成入门" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "message-io 是事件驱动的消息库，可轻松快速地构建网络应用程序。它管理和处理套接字数据流，以便向用户提供简单的事件消息 API。作为通用网络管理器，它允许你遵循一些规则来实现自己的协议，而繁琐的异步和线程管理则由 message-io 帮你管理。 仓库地址：https://github.com/lemunozm/message-io" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/lemunozm/message-io" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-18 22:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "message-io 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 语言作为一门新兴语言，从2015年发布以来，收获了不少关注度。Rust 目前也逐渐进入了成熟的阶段。并且在2021年02月08号，Rust 基金会也宣布正式成立。关注度比较多的几个话题:\nGitHub 上有哪些值得关注的 Rust 项目\n学习 Rust ,可以绕开 C 语言吗?\n您对 2021 年的 Rust 语言有哪些期待？\n只学过 C 语言适合学 Rust 吗？\n在中国有多少开发者使用Rust编程语言？\n我应该放弃 C++，学习 Rust 吗？\n如何看待 Rust 的应用前景？\n写 wasm 项目选 C++ 还是 Rust？\n关于 Rust 语言基金会成立，你有什么想说的呢？\n学Rust之前，是不是应该先学C++？\n可以看得出来许多话题都围绕着C,C++可以看得出大家对 Rust 的期待,希望 Rust 2021会带来新的惊喜吧。ReadMore:https://www.zhihu.com/roundtable/rustyuyanyuanzhuoni" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.zhihu.com/roundtable/rustyuyanyuanzhuoni" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-18 01:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 圆桌年话" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "AWS开发工具包团队是大多数AWS服务的门户。构建的库将AWS连接到全球开发人员社区。\n2年以上的非实习专业软件开发经验\n至少使用Java，C ++或C＃等现代语言进行编程的经验，包括面向对象的设计\n1年以上的架构和设计（架构，设计）经验模式，可靠性和扩展性）。\n\n在提供的工作或相关职业中至少有2年经验，必须涉及：使用Rust和面向对象设计来设计和开发大规模的分布式软件应用程序，工具，系统和服务。\n与用户，其他技术团队和高级管理层沟通以收集需求，描述软件产品功能，技术设计和产品策略的经验。\n具备有关完整软件开发生命周期的专业软件工程实践和最佳实践的知识，包括编码标准，代码审查，源代码管理，连续部署，测试和操作。\n具有使用Rust语言进行开发的经验。\n具有设计SDK的经验。\nReadMore:https://www.amazon.jobs/en/jobs/1424393/software-development-engineer-aws-rust-sdk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.amazon.jobs/en/jobs/1424393/software-development-engineer-aws-rust-sdk" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-18 01:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "AWS 招聘软件开发工程师 - AWS Rust SDK" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "优点:\n安全可靠\n有生命周期事件：StartedBy，InterruptedBy，等。\nOneshot动作\n结果互动\n高优先级的即时操作\n流可以作为动作附加到参与者\n支持结果精简的任务\n子角色和任务的终止顺序\n计划的行动\n信号（可以收听CtrlC）\ntokio 兼容的\nWASM 兼容（进行中）\nReadMore:https://github.com/rillrate/meio" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rillrate/meio" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-18 01:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Async actor framework for Rust." }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者扎克·伯恩斯发布了这款侵入式代码分析器。“火旋风”分析器能帮助代码作者测试Rust代码的性能；它能分析项目中的时间敏感部分，输出到时间轴图、合并的火焰图或其它的表现形式。这是一款侵入式分析器，也就意味着在代码编写的过程中，用户就需要使用分析器提供的宏，帮助分析器的记录过程。项目文档指出，这款分析器能通过编译特性来启用或禁用；未被启用时，所有的记录操作都被编译为空操作，这将不会影响生产程序的运行性能。我们常用的性能分析器，常常基于系统提供的“perf”指令，它就像是一个调试器，在合适的时候暂停进程，读取此时所有的线程和有关信息，从间隔的采样过程记录，从而得到运行性能输出。这种采样不需要重新添加和编译代码，但较可能漏掉时间短的函数。合理使用侵入式代码分析器，可以精细记录运行性能的细节，也能更少地影响待测程序的运行性能。“火旋风”分析器已经在GitHub上开源，并配有丰富的使用文档。项目主页https://github.com/That3Percent/firestorm" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-16 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "“火旋风”代码分析器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章作者弗拉迪斯拉夫·奥列斯克是白俄罗斯国立大学数学系的大一新生，为了实验他学到的新知识，用Rust编写了这个光线追踪器例子。除了极其凡尔赛的文章标题，从光线、平面的计算到投影三维几何体，项目里的干货也十分足料。作者在文章的结尾，呈现了几个典型的几何体渲染例子，也大胆分享了编写过程中遇到的问题。贴文地址https://www.reddit.com/r/rust/comments/lkg5w8/missed_rust_when_studying_maths_so_i_made_a_super/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-16 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《数学读着读着想念Rust了，于是我做了个巨简单的光线追踪器》" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "广泛使用的代码动态分析器rust-analyzer发布了此次公告。现在，编辑器能在语句块内部给定特定的提示。这将为更多的提示提供可能性：比如在match语句块中，根据枚举变量的可能性，提示还需要的解构语句臂。另外，编辑器将帮助生成获取-设置语法的函数，以便外界封装访问结构体部分变量的引用和可变引用。以自我类型“Self”指定的枚举变量，现在也将获得match解构有关的语法提示。此外，搜索功能现在支持搜索类型的所有构造函数。此次更新处理的问题包括for关键字的补全、dyn T类型的函数名补全等等，还包括若干项问题修复和内部性能提升。公告地址https://rust-analyzer.github.io/thisweek/2021/02/15/changelog-64.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-16 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-analyzer发布第六十四期更新公告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "知名的代码编辑器在官方博客发布了此次更新公告。现在，插件已经支持最新2021.1预览版的编辑器软件。一些功能更新包括快速移除多余的函数参数，检测更多的编译错误，使用LLDB调试器帮助调试，新建函数的功能现在也支持异步函数。性能提升包括优化大模块的名称解析等等。本次更新也包括大量的小问题修复和内部性能提升。官方博客https://intellij-rust.github.io/2021/02/15/changelog-141.html来自 日报小组 洛佳" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-16 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "IntelliJ Rust发布第一百四十一期更新公告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "微软官方Twitter发布了几张情人节卡片，都是微软经典产品，直男程序员情人节必备。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-15 23:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "来自微软的情人节卡片" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "下面是对 Rust Loop 进行的一些优化。比如通过使用可变借用的 slice，在汇编代层面每次循环不需要进行 bound 检查，还可以使用 SIMD 加速计算。使用位运算求N以内整数之和百倍提升性能。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-15 23:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 循环优化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文使用Tokio直接构建 Actors, 而不是使用任何现有的 actor 库.感兴趣的同学可以阅读一下.原文链接https://ryhl.io/blog/actors-with-tokio/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-15 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Tokio 直接构建 Actors" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 <<Rust 从零到生产>> 系列的第七章 part 1.该章节主要侧重于测试. 整个书基本上都是使用 test-driven的方式来编写新的功能. 当代码变的庞大之后, 一个良好的测试框架可以更好的支撑更复杂的特性和日渐增多的测试用例.原文链接https://www.lpalmieri.com/posts/skeleton-and-principles-for-a-maintainable-test-suite/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-15 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 从零到生产: 可维护的测试套件的骨架和原则" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "宏是一种超越 more power的存在, 他赋予了我们超越 源代码 的抽象能力, 但是,同时,你也会放弃表层语法. 例如, 在一个拥有强大的宏的语言中, 重命名 基本上是不太可能 100% 工作的.本文尽力探索Rust 中宏的使用方式, 目的是为了找到一种不放弃源代码推断的解决方案.原文链接https://matklad.github.io/2021/02/14/for-the-love-of-macros.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-15 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "For the Love of Macros" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "relm 是一个 Rust 的异步的,基于 GTK 的 GUI 库, 目前最新的 0.21 版本发布, 该版本是迄今为止发布的最大版本.原文链接https://relm.antoyo.xyz/big-release/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-15 20:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "A big release for relm" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust牛年春晚，明天牛年初三，下午4点-12点。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-13 21:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust牛年春晚节目单" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "calc，一个Rust 实现的命令行计算器。Github 链接，https://github.com/coriolinus/calc表达式模式Shell 模式" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/coriolinus/calc" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-13 21:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "calc，一个命令行计算器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "nlprule 使用 LanguageTool 中的资源为NLP实现了基于规则和查找的方法。https://github.com/languagetool-org/languagetoolGithub链接，https://github.com/bminixhofer/nlprule" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/bminixhofer/nlprule" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-13 21:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "nlprule，Rust 实现的 NLP 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Fly.io 基于Rust 的 Tokio 和 Hyper 实现负载均衡，Tokio 升级到 v1.x，Fly.io 将其使用的 Tokio 从 v0.2 升级到 v1.x，并认为虽然是一个主要版本的升级，但升级过程并不难。https://github.com/tokio-rs/tokio这篇博客文章记录了一些笔记，文章链接，https://fly.io/blog/the-tokio-1-x-upgrade/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fly.io/blog/the-tokio-1-x-upgrade/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-13 21:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fly.io 升级Tokio到1.x" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在 Debian Buster，Alpine 3.12 和其他使用较旧 Rust 编译器版本 v1.41 的平台，PyO3 不能与Rust v1.41一起编译，目前已提供支持 Rust v1.41。https://github.com/PyO3/pyo3Github issue 链接，https://github.com/PyO3/pyo3/issues/1420https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/PyO3/pyo3/issues/1420" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-13 21:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "PyO3 为 Rust 1.41 提供支持" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baoyachi" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust每周一期的杂志，详细介绍了Rust变更的内容，RFC,以及社区相关的。对于每周预览Rust的变更和动态相当有用。github:https://github.com/rust-lang/this-week-in-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-lang/this-week-in-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-12 23:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "this-week-in-rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baoyachi" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "注意：Rust 1.50.0 里 compare_and_swap方法被废弃了，推荐用compare_exchange和 compare_exchange_weak方法代替详细链接:https://github.com/rust-lang/rust/blob/master/RELEASES.mdhttps://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1500-2021-02-11" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-12 23:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.50.0变更注意" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baoyachi" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "预告，就在2月13日，大年初三，《Rust中文社区》将带来线上春晚。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-12 23:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust牛年春晚预告：大年初三，连续8小时热闹" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust中文论坛日报小组祝愿大家：新的一年，万事随想，所爱如山。张汉东老师70行 Rust 代码祝大家新春健康快乐，祝 Rust 牛气冲天！源码在这：https://github.com/ZhangHanDong/2021soaring" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-11 23:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 牛气冲天！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust stable 1.50 版本在今天发布了，你可以通过以下命令升级你的Rust版本：关于1.50这个版本，改进了数组索引，扩展了对联合字段的安全访问，并添加到标准库中。请参阅详细的发布说明（https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1500-2021-02-11） ，了解更多信息。Read More: https://blog.rust-lang.org/2021/02/11/Rust-1.50.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2021/02/11/Rust-1.50.0.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-11 23:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust stable 1.50 发布！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者写了一些代码，试图比较 Linux 线程上下文切换所需时间和Rust async任务调度切换所需时间及其各自在使用时的内存使用总量，并且还做出了总结。Github: https://github.com/jimblandy/context-switch" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jimblandy/context-switch" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-11 23:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "比较 Rust async 与 Linux 线程上下文切换时间" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者最近因为从之前的mac环境由于一些原因需要切换到windows环境下工作，但是没有找到之前使用mac时的桌面分割工具（窗口排放管理工具），于是自己花了几天，研究了不少其它类似的工具，捣鼓出了这个。Github: https://github.com/LGUG2Z/yatta" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/LGUG2Z/yatta" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-11 23:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Yatta: 用于 Windows10 的 BSP 平铺窗口管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你可以用这个crate构建很漂亮的图标，将你的数据可视化。示例：渐变：自定义颜色的渐变：更多示例请直接查看该项目 github 主页：Github: https://github.com/mazznoer/colorgrad-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mazznoer/colorgrad-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-11 23:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "colorgrad-rs 一个用rust编写的颜色标尺库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "377。Read More：https://this-week-in-rust.org/blog/2021/02/10/this-week-in-rust-377/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/02/10/this-week-in-rust-377/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-02-11 23:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 377" }, "type": "text" }], "type": "title" } },]
