export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在已支持动图编辑！目标包括：\n支持尽可能多的图像格式。\n60Hz，避免阻塞超过 16ms。\n无闪烁重绘。\n平滑缩放。\n尽可能始终使用 GPU 加速。\n桌面操作系统支持。\n基本图像处理。\n不包括：\n强大的处理（不是下一个 Photoshop）。\nWeb/移动平台支持。\n主页：https://simp.axelkappel.se/GitHub：https://github.com/Kl4rry/simp" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-28 20:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "simp：GPU加速图像处理程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个类似元胞自动机的 Demo，可以产生波形模式。Demo：https://tom.cv/vortex/GitHub：https://github.com/0xTiger/vortex" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-28 20:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "vortex：Rust和WASM海洋模拟" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "WRLD 是一组派生宏，基于 Learn wgpu 教程，用于让 wgpu 代码简单、愉悦、更安全。示例：将生成：GitHub：https://crates.io/crates/wrld" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-28 20:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "wrld：WGPU Rust描述符" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个是 u8g2 的纯 Rust 实现。示例：https://github.com/olikraus/u8g2GitHub：https://github.com/Finomnis/u8g2-fonts" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-28 20:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "u8g2-fonts：基于u8g2的嵌入式图形文本呈现器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个系列文章的目的是了解什么是容器，它是如何工作的，并创建一个 container 来创建和管理容器。内容如下：\n1 Introduction to containers\n2 Starting the project\n3 Creating the skeletton\n4 Birth of a child process\n5 Defining the container environment\n6 User namespaces and Linux Capabilties\n7 Syscalls and resources restriction\n8 Executing the binary\n教程地址：https://litchipi.github.io/series/container_in_rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-28 20:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust写一个Container" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Udemy 推出的（目前免费的）Rust 课程，内容包括：\nRust 语言基础、工具和生态。\n基本原理，如变量、作用域、函数、模块、标量和复合类型、控制流、字符串、Struct、Trait、Enums 等。\n使用 Rust 和系统编程有趣的 Tips 和技巧。\n理解 Rust 所必需的概念，如所有权、引用和借用、内存模型，以及为什么 Rust 关注安全性、并发和速度。\n共 8 个部分，35 课时，课程大纲：\n导论\n基础：Cargo、变量、作用域、内存安全、函数、模块系统。\n基本类型和控制流：标量、复合类型、控制流、字符串。\nRust 核心概念：所有权、引用和借用。\nRust 主要内容：Struct、Trait、Collections、Enums。\n终极内容：闭包、线程。\n项目\n课程地址：https://www.udemy.com/course/ultimate-rust-crash-course/?couponCode=BACKTOSCHOOL" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-28 20:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Udemy的Rust课程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个有趣的系列视频，作品成果讲述了一个小卫星在地球停止回电后试图了解发生了什么的旅程。本视频向你展示了如何从数据模型开始，构建简单的 Rust 程序。视频地址：https://www.youtube.com/watch?v=7GzQArrek7A" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=7GzQArrek7A" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-28 14:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用 Rust 构建空间站" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自 cxx-qt 项目的功能更新，cxx-qt 项目是一个 QT 相关的项目，提供 Rust 和 Qt 之间的安全互操作。现在 cxx-qt 现在可以使用 cargo 构建 QML 应用程序，无需 CMake。详情请看：https://github.com/KDAB/cxx-qt/pull/221" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/KDAB/cxx-qt/pull/221" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-28 14:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "完全使用 cargo 构建 QML 应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rumqtt 是一组用 rust-lang 编写的开源库，用于实现 MQTT 标准，同时力求简单、健壮和高性能。更新详情请看：https://github.com/bytebeamio/rumqtt/releases/tag/R15https://github.com/Jancd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-28 14:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rumqttc 项目 v0.15.0 版本更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rusty_jsc，这个库为 JavaScriptCore 引擎提供了一个 Rust API，主要目标：\n用于 Swift 的 JavaScriptCore API 等高层级 API；\n包装底层 C++ API 而不是 jsc 以避免对 GTK 的依赖。\nGitHub 链接，https://github.com/penberg/rusty_jsc" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-27 23:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "JavaScriptCore 引擎的 Rust 绑定" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "KissCam，一个网络摄像头照片应用程序，用来试用 egui，它允许调整硬件支持并由 V4L 公开的所有图像设置。GitHub 链接，https://github.com/donkeyteethUX/kcam" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-27 23:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用 egui 构建的 KissCam" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Wrapped_mono，是一个围绕 mono 库的安全轻量级包装器。它允许在 Rust 代码中嵌入 mono 运行时（一个开源 .NET 运行时），并运行 .NET 框架中编写的代码。 Wrapped_mono 允许在托管代码和非托管代码之间轻松互操作。在本地代码和运行时内运行的代码之间传递数据时，内置宏会自动转换类型。GitHub 链接，https://github.com/FractalFir/wrapped_monohttps://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-27 23:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Wrapped_mono，在 Rust 中嵌入 mono 运行时" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文作者是 Yoshua Wuyts 。在过去，我写过一篇关于 Rust 中状态机的文章。最近，还创作了一篇关于匿名枚举的文章。如果这两者互动会发生什么？结果或许会非常好，值得畅想一番。在这篇文章中，我们将讨论状态机，使其更易于使用的语言特性，以及进一步推动人机工程学的方法。State Machines II: https://blog.yoshuawuyts.com/state-machines-2/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.yoshuawuyts.com/state-machines-2/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-26 00:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "文章 - 状态机 II" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本周 Databend 发布了 v0.8.0-nightly ！Databend v0.8 的开发于 3 月 28 号开始，总计 5000+ commits，4600+ 文件变更。在过去的 5 个月中，社区的 120 余位贡献者新增了 42W 行代码，删除了 16W 行，相当于把 Databend 重写了一遍。在该版本中，社区对 SQL Planner 框架做出了重大改进，并将所有的 SQL 语句都迁移到了新的 Planner 上，提供了完整的 JOIN 和子查询支持。GitHub - datafuselabs/databend: https://github.com/datafuselabs/databendWhat's Fresh in Databend v0.8: https://databend.rs/blog/databend-release-v0.8" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://databend.rs/blog/databend-release-v0.8" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-26 00:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "项目 - Databend v0.8 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 457: https://this-week-in-rust.org/blog/2022/08/24/this-week-in-rust-457/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/08/24/this-week-in-rust-457/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-26 00:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 457" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "主要更新Routing、Extractors、Middleware。详情请看以下链接。ReadMore:https://github.com/tokio-rs/axum/blob/main/axum/CHANGELOG.mdReadMore:https://tokio.rs/blog/2022-08-whats-new-in-axum-0-6-0-rc1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://tokio.rs/blog/2022-08-whats-new-in-axum-0-6-0-rc1" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-24 23:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Axum 0.6.0-rc.1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "clap4shell是一个基于clap.getopt的替代品。clap4shell提供选项从stdin将YAML文档输入，然后将解析后的结果以新行分隔的格式打印出来。用法该模式基于clap_serde。ReadMore:https://github.com/fumieval/clap4shell" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/fumieval/clap4shell" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-24 23:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "clap4shell：独立的用于shell脚本的clap包装器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个将 Rust 异步编程应用于 Tauri App 的例子。更具体来说，实现了在 Javascript 和 Rust 任意一方的双向异步通信。ReadMore: https://rfdonnelly.github.io/posts/tauri-async-rust-process/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rfdonnelly.github.io/posts/tauri-async-rust-process/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-23 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Tauri + Async 构建桌面应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是个一个从0编写一个容器运行时的教程，写的很不错。包含如下章节：\n容器简介\n创建项目\n搭建项目骨架\n创建子进程\n定义容器环境变量\n使用 namespaces 和 capabilities\n系统调用与资源限制\n大功告成\nReadMore:  https://litchipi.github.io/series/container_in_rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://litchipi.github.io/series/container_in_rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-23 21:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 编写一个容器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个用于实时网络的可扩展、分布式、可协作的文档图数据库。特性包括：\n支持数据库 Server，或作为嵌入的包。\n支持多行、多表 ACIS 事务。\n支持单节点或高度扩展的分布式节点。\n记录链接和有向类型图连接。\n存储结构化和非结构化数据。\n用于预先计算的高级分析的增量计算视图。\n实时 API 层，内置安全权限。\n可以使用表格、文档和图等方式存储和建模数据。\n前后端开发时简单的 Schema 定义。\n直接从浏览器和客户端设备连接和查询。\n使用嵌入的 JavaScript 函数实现自定义高级功能。\n目前客户端已支持 JavaScript、WebAssembly 和 Ebmer.js；服务端已支持 JavaScript、Node.js、Golang、Rust 和 Deno。其他语言也即将支持。文档：https://surrealdb.com/docsGitHub：https://github.com/surrealdb/surrealdb" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-21 19:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "surrealdb：文档图数据库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "App source + Nix packages + Docker = ImageNixpacks 采用源目录生成一个兼容 OCI 的 image，该 image 可以部署在任何地方。核心原则：\n符合直觉的默认值：在大多数情况下，使用 Nixpacks 构建和部署应用程序应该无需任何配置即可工作。\n可定制：管道的每个部分都应该是可配置的。其中包括要添加到环境中的 Nix 包和构建/启动命令。\n易于扩展：可以使用最少的 Nix 和 Docker 知识讲新的提供者（语言）轻松添加到 nixpacks 中。\n文档：https://nixpacks.com/docsGitHub：https://github.com/railwayapp/nixpacks" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-21 19:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "nixpacks：image构建" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Pico8 是由 Lexaloffe Games 制作的梦幻可编程游戏主机，可用来制作、共享和玩小计算机游戏和程序。Pico8 网站：https://pico-8.fandom.com/zh/wiki/Pico-8_WikiaGitHub：https://github.com/jjant/runty8" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-21 19:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "runty8：Rust的克隆" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ADS-B（Automatic Dependent Surveillance-Broadcast）是一种监视技术，一般用于航空系统。飞机通过卫星导航或其他传感器确定其位置并定期广播它，使其能够被跟踪，空中交通管制地面站也可以接收到该信息，以替代二次监视雷达。它也可以被其他飞机接收。它是自动的，不需要飞行员或外部输入，它也是依赖的，依赖来自飞机导航系统的数据。GitHub：https://github.com/rsadsb/adsb_deku" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-21 19:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "adsb_deku：ADS-B解码器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GitHub：https://github.com/norepimorphism/pylon" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-21 19:37" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pylon：小巧的3D渲染器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "过去几周我一直忙于深入 Rust 生态系统并通过实际项目学习该语言。我先完成了优秀的 Rust book和 Rust Embedded Book，然后在一些 STM32 MCU 上用rust进行了修修补补。下一步，我正在寻找实际项目来进一步学习这门语言。我也尝试将其与我现在工作的研究所的日常活动结合起来。在一家制造小型卫星的机构工作，我可以使用独特的硬件，例如抗辐射 Vorago MCU...文章链接，https://robamu.github.io/post/rust-ecosystem/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://robamu.github.io/post/rust-ecosystem/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-20 21:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "将 Rust 带入太空 - 为 VA108XX MCU 系列建立 Rust 生态系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你听说过Salsa项目吗？ Salsa 是一个用于增量计算的库——它被 rust-analyzer 使用，例如，在你输入 IDE 时保持响应（我们也讨论过在 rustc 中使用它，尽管在那里需要做更多的工作）。我们现在正大力推动开发和发布 Salsa 2022，这是对 API 的重大新修订，将使 Salsa 的使用更加自然。我写这篇博文既是为了宣传正在进行的工作，也是为了呼吁大家做出贡献。 Salsa 还没有一大群维护者，我想解决这个问题。如果您一直在寻找一个开源项目来尝试参与，不妨看看我们的 Salsa 2022 跟踪问题，看看是否有您想解决的问题Github 链接，https://github.com/salsa-rs/salsa文章链接，https://smallcultfollowing.com/babysteps/blog/2022/08/18/come-contribute-to-salsa-2022/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://smallcultfollowing.com/babysteps/blog/2022/08/18/come-contribute-to-salsa-2022/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-20 21:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "快来为 Salsa 2022 做贡献吧！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "为什么用 Prettier?一旦人们开始使用 Prettier，通常会发生的事情是他们意识到他们实际上花费了多少时间和精力来格式化他们的代码。无论您正在处理的代码多么不完整或损坏，使用 Prettier 编辑器扩展程序，您始终只需按下 Format Document 键绑定和 poof，代码就会立即到正确的位置。Github 链接，https://github.com/jinxdash/prettier-plugin-rusthttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jinxdash/prettier-plugin-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-20 21:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Prettier Rust：自动纠正错误语法的代码格式化程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "@lecepin 实现了一个把图片转成 ASCII 的 WASM 工具, 可以把注释里面的佛祖高清化或者换成奥特曼了https://github.com/lecepin原文： https://rustcc.cn/article?id=d4d81502-1998-4b73-8ef5-ef01e4b9c2b9" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-20 09:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust WASM 图片转 ASCII 艺术" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该文详细介绍并对比了 c++和 Rust std 库中的提供的并发用的组件，包括 atomic、compare_exchange、constexpr Mutex constructor、Latches and barrier，并得出c++ 的并发设计持续启发 Rust 并发设计的观点。原文：https://blog.m-ou.se/rust-cpp-concurrency/#conclusionhttps://github.com/huangjj27" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-20 09:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 与 C++ 的 并发库对比" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文将讨论许多话题，从CPU架构设计到历史上的诡异事件。喝一杯吧，接下来就是下坡路了。尽管自90年代以来，这个数字已经稳步下降，但现在仍然有许多不同的、不兼容的CPU架构在使用。大多数计算机使用x86_64，几乎所有的移动设备和最近的Mac都使用某种基于ARM64的ISA（指令集架构）。不过在特定领域，还有更多奇特的：大多数路由器仍然使用MIPS（由于历史原因），一屋子的开发人员使用RISC-V，PS3使用PowerPC，20年前的一些服务器使用Itanium，当然，IBM仍然在销售他们基于S/390的大型机（现在改名为z/Architecture）。嵌入式世界的产品就更多了。AVR（用于Arduino）、SuperH（土星、Dreamcast、卡西欧9860计算器），以及可敬的8051，一个1980年的英特尔芯片，现在仍在生产、销售，甚至由第三方扩展。所有这些架构的定义特征都不同，主要的特征有\n字大小：8、16、31、32、64位，有时更多\n设计风格：RISC（指令少，操作简单），CISC（指令多，执行复杂的操作，VLIW（指令长，同时并行做很多事情）\n存储器结构：哈佛（独立的代码存储器和数据存储器），冯-诺伊曼（共享）。\n许可费用：RISC-V是开放的，可以免费使用，而X86和ARM等则需要许可费\n广义上，它们的功能集：浮点数（x87）、加密（AES-NI）、支持本地高级字节码执行（Jazelle、AVR32B）、矢量计算（SSE、AVX、AltiVec）。\n这还不算DSP架构，轻描淡写地说，它们是ISA的暮光之城（支持奇怪的算术运算、奇特的数据大小等）。更多内容: https://zdimension.fr/crabs-all-the-way-down/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://zdimension.fr/crabs-all-the-way-down/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-18 21:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在逻辑门上运行Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在这篇文章中，我们将介绍一个应用Kani Rust验证器（简称Kani，这是我们的开源形式验证工具，可以证明Rust代码的属性）到Tokio的一个例子。Tokio是Rust程序的异步运行时，这意味着它将语言的低级异步功能抽象为有用的构建块（例如为异步任务的调度和执行提供一个执行器）。Tokio的目的是提供 \"编写网络程序所需的构件，[具有]针对各种系统的灵活性，从具有几十个内核的大型服务器到小型嵌入式设备\"。在这篇文章中，我们将关注Tokio堆栈的一个底层组件和证明一个核心数据结构的属性。关于 Kani：Kani Rust验证器是一个用于Rust的位精确模型检查器。Kani对于验证Rust中的不安全代码特别有用，因为许多语言的常规保证不再由编译器检查。Kani可以验证\n内存安全（例如，空指针解除引用）。\n用户指定的断言（例如，assert!(...)）。\n没有恐慌（例如，对None使用unwrap()）。\n不存在某些类型的意外行为（例如，算术溢出）\n博文: https://model-checking.github.io/kani-verifier-blog/2022/08/17/using-the-kani-rust-verifier-on-tokio-bytes.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://model-checking.github.io/kani-verifier-blog/2022/08/17/using-the-kani-rust-verifier-on-tokio-bytes.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-18 21:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Tokio Bytes上使用Kani Rust校验器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 456: https://this-week-in-rust.org/blog/2022/08/17/this-week-in-rust-456/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/08/17/this-week-in-rust-456/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-18 21:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 456" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "与 C 的互操作性是 Rust 中最令人难以置信的事情之一。C 可以安全地调用 Rust 代码并且 Rust 可以使用具有 C 接口的知名库的能力是整个行业快速采用 Rust 的关键原因。它还允许我们通过为 rust crate 实现 C 接口来更好地分发代码，因此它可以被任何能够调用 C 的语言编写的软件使用。作者将在这里使用字符串作为示例，但是，所描述的技术也适用于将字节数组或指针传输到堆上 Box 或 Arc 类型中的结构。\nhttps://dev.to/kgrech/7-ways-to-pass-a-string-between-rust-and-c-4ieb\n\nhttps://gregoryszorc.com/blog/2022/08/08/achieving-a-completely-open-source-implementation-of-apple-code-signing-and-notarization/\nNeovim 是一个旨在积极重构 Vim 的项目，这篇文章详细解释了作者如何使用 Neovim 设置 Rust 开发环境和工作流程。\nhttps://rsdlt.github.io/posts/rust-nvim-ide-guide-walkthrough-development-debug/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-17 23:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "unwrap在很多教程里被定义为不好的(evil)，实际上， unwrap 在一些场景下是适合使用的，这篇文章从初学者的角度说了一下 unwrap 适用的场景。ReadMore: https://blog.burntsushi.net/unwrap/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.burntsushi.net/unwrap/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-16 15:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "unwrap 不是魔鬼" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "最近 Rust 官方合并了一个 RFC，通过引入 I/O 安全的概念和一套新的类型和特质，为AsRawFd和相关特质的用户提供关于其原始资源句柄的保证，从而弥补 Rust 中封装边界的漏洞。ReadMore: https://mp.weixin.qq.com/s/C7khFKUm9n7s6hXKcP-wug" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://mp.weixin.qq.com/s/C7khFKUm9n7s6hXKcP-wug" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-16 15:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RFC 导读 - 构建安全的 I/O" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个用 rust 编写的用于从海量数据中识别有用字符串的工具，相当于一个 rust 版本的 pywhat，但比原版快很多。ReadMore: https://github.com/swanandx/lemmeknow" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/swanandx/lemmeknow" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-16 15:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "lemmeknow" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "又一本Rust新书 《zero to production》被引进国内了，朋友们有没有想参加翻译的？想翻译的尽快联系 张汉东 老师，不过需要先进行试译。最终会确定最多四个名额一起翻译。https://www.zero2prod.com/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-15 19:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《zero to production》 新书翻译" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "谷歌开源的 Carbon 编程语言的目标是成为c++的继承者，它引起了Rust语言社区的巨大关注，其中的一些问题是:\nCarbon 和Rust之间的有什么不同?\n既然我们已经有了潜在的c++继承者Rust，为什么还要用 Carbon 呢?\nCarbon会完全取代c++吗?\n本文给出了非常详细的两种语言的对比.原文链接https://tipseason.com/carbon-language-vs-rust/?utm_source=rust_reddit&utm_medium=rust_reddit&utm_campaign=rust_reddit" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-15 19:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Carbon vs Rust: 详细对比" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rend3 是一个基于 wgpu的, 易于使用，可定制，高效的3D渲染库. 下面是对rend3 作者的一个采访.原文链接rend3的 github 地址https://console.substack.com/p/console-118--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-15 19:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rend3 作者的采访" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "最近为 Actix-Web 编写了一个新的速率限制中间件。这个 crate 旨在支持基本和复杂的场景：\n从请求上下文中派生一个自定义速率限制键（基于标头、客户端 IP 地址、请求路径、这些的组合，或者自己使用任意未来实现）\n您可以根据请求上下文传递动态速率限制和间隔，例如，您可以编写将用户 ID 映射到特定 RPS 限制的未来，并将其传递给速率限制器。\n提供了内存和 redis 后端，但如果你想做一些不同的事情，你也可以实现自己的后端。\n您可以设置自定义的 429 响应，并且您可以选择根据速率限制结果转换响应头（例如添加 x-ratelimit-remaining）。\n您可以选择在请求完成后根据响应代码回滚速率限制计数。例如，您可能不希望 5xx 错误计入用户的速率限制。\nGitHUB: https://github.com/jacob-pro/actix-extensible-rate-limit" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-14 09:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Actix Web 的可扩展速率限制中间件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "​\t    Rust 中使用数据库编写简单 Web 服务器的教程 (webpage_hit_counter)这是“ bestia.dev Rust 编程语言教程”系列的第 5 篇 youtube 教程。https://bestia.dev/在这些教程中，我展示了如何创建 Rust 开发环境并将其用于编码。在 youtube 上观看视频：< https://bestia.dev/youtube/webpage_hit_counter.html >所有代码和描述都可以在 Github 存储库中找到：< https://github.com/bestia-dev/webpage_hit_counter >访问我的页面以获取更多 Rust 编程教程：https://bestia.dev/教程系列剧集：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-14 09:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中使用数据库编写简单 Web 服务器的教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Github: github.com/kurbos...https://github.com/kurbos/bevy-shell-template" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-14 09:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy Shell：An opinionated, monolithic template，具有跨平台 CI/CD、native + WASM 启动器和托管跨平台部署。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "tl;drRust Sitter 是一种用 Rust 编写解析器的新方法。 通过将宏与外部编译时工具相结合，它可以使用 Tree Sitter 和绑定自动生成高效的解析器，从而将结果提取到上层用户结构中。Tree Sitter，一个解析器生成工具和一个增量解析库。https://tree-sitter.github.io/tree-sitter/博客原文，https://www.shadaj.me/writing/introducing-rust-sitter/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-13 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Sitter 轻松编写快速且健壮的解析器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "SeaQL 团队庆祝其所有 SeaQL 代码库达到 3,000 GitHub star 的里程碑！SeaQL.org 成立于 2020 年。致力于开发开源库，帮助 Rust 开发人员构建数据密集型应用程序。在过去的两年里，SeaQL 团队发布并维护了四个开源库：SeaQuery、SeaSchema、SeaORM 和 StarfishQL。每个库都旨在填补 Rust 生态系统中的一个细分市场，并且它们可以与其他 Rust 库很好地配合使用。SeaQL 博客原文，https://www.sea-ql.org/blog/2022-08-12-3k-github-stars/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-13 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SeaQL 团队庆祝 Github 获得 3k+ star" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Viz，快速、健壮、灵活、轻量级的 Web 框架。Github 链接，https://github.com/viz-rs/viz" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-13 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Viz，轻量级 Web 框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目标是探索 crates 的现状，包括静态链接的 C/C++ 库，并开始讨论如何更轻松地以安全可靠的方式在 crates 中导入外部代码。论坛原文，https://internals.rust-lang.org/t/statically-linked-c-c-libraries/17175https://github.com/lesterli" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-13 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "crates 中静态链接 C/C++ 库：可追溯性和安全问题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 1.63.0 stable 正式发布，赶快升级到最新稳定版本体验 Rust 带给你的强劲动力吧 :)简单看看有哪些值得关注的新特性吧：\nscoped threads 允许线程借用局部变量，而不仅仅是静态变量。\n为原始文件描述符/句柄提供 I/O 安全的包装器类型，如 BorrowedFd 和 OwnedFd ，允许使用这些类型来编码所有权语义。\nMutex::new，RwLock::new 和 Condvar::new 都是 const ，可以将这些类型用作静态变量。\n完成向非词法生命周期（non-lexical lifetimes）的迁移，完全删除了以前的词法借用检查器。\nAnnouncing Rust 1.63.0: https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-12 00:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.63.0 stable 正式发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pintariching 试图使用 Rust 来重写 Svelte 编译器，过去，该编译器是由 TypeScript 实现的。GitHub - pintariching/rustle: https://github.com/pintariching/rustle" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/pintariching/rustle" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-12 00:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用 Rust 重写 Svelte 编译器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 455:https://this-week-in-rust.org/blog/2022/08/10/this-week-in-rust-455/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/08/10/this-week-in-rust-455/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-12 00:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 455" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章是一份年中报告，总结了迄今为止在所有这些项目上取得的进展。ReadMore:https://blog.rust-lang.org/inside-rust/2022/08/08/compiler-team-2022-midyear-report.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/inside-rust/2022/08/08/compiler-team-2022-midyear-report.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-10 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Compiler 2022 年年中报告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust-osdev 托管的uefi-rs,x86_64,xhci等crate,有了显著变化。ReadMore:https://rust-osdev.com/this-month/2022-07/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust-osdev.com/this-month/2022-07/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-10 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust OSDev 7 月月报" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 的离线同义词库，可以使用 wordnet 和 moby 后端。https://wordnet.princeton.edu/ReadMore:https://github.com/grantshandy/thesaurus-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/grantshandy/thesaurus-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-10 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "thesaurus-rs 离线同义词库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你是否存在这样的烦恼：制作了 NES 游戏，但是您的朋友中没有一个拥有 Nintendo Switch。不用担心，本项目将解决这个问题。只需将您的 ROM 和配置放入 NES Bundler，并为 Mac、Windows 或 Linux 构建可执行文件，最终将得到单个可执行文件，拥有下面的能力：\n用于设置的简单 UI（使用 ESC 显示和隐藏）\n可重新映射的键盘和游戏手柄输入（绑定了默认映射）\n保存/恢复状态（F1 = 保存，F2 = 加载）\n网络游戏！（可选功能，如果不需要，可以禁用）\n这是一个相当有趣的项目，详细操作步骤可以参考仓库中的 README 说明。仓库地址https://github.com/tedsteen/nes-bundler" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-09 14:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "NES Bundler - 将你的任天堂游戏转换为可执行文件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Fyrox 是一个用 Rust 编写，带有场景编辑器的开源游戏引擎。其功能丰富，可用于 2D/3D 游戏的生产，以前称为 rg3d。近日，Fyrox 游戏引擎 0.27 已经发布！此版本包含许多改进，例如编译时反射、插件和脚本改进、各种编辑器修复和改进等等！感兴趣的不妨阅读以下文档。Fyrox 教程版本更新详细信息仓库地址https://fyrox-book.github.io/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-09 14:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fyrox Game Engine 发布 v0.27 版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Andrew Gallant 曾经发布了 Error handling in Rust 这篇文章，详细描述了如何在 Rust 中处理错误。https://blog.burntsushi.net/rust-error-handling/近日，他又发布了一篇博客，更加深入地探讨了，在 Rust 中如何正确使用 unwrap 这种模式，为什么 \"unwrapping isn't evil\"。感兴趣的不妨仔细阅读一下原文。原文链接https://blog.burntsushi.net/unwrap" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-09 14:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Rust 中使用 unwrap 的 Tips" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "BUS1一开始是作为Linux内核IPC模块出现的，虽然偶尔还会提交到过时的BUS1内核模块，但相关的(红帽)开发人员一直主要致力于Dbus-Broker，作为高性能的用户空间D-Bus实现，它比参考的D-Bus代码提供了更大的速度和可靠性。现在出现在BUS1保护伞下的还有“r-linux”，它是一个由rust编写的、基于功能的Linux运行时.原文链接https://www.phoronix.com/news/BUS1-r-linux" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-08 19:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "\"r-linux\": 基于Rust能力的Linux runtime" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该库是 在重力等物理力的影响下，物体动力学系统进行的二维的 N-body模拟 。完全用 Rust 编写，使用 WebGPU 和 WGSL 着色，并导出到 WebAssembly[github地址]（https://github.com/simbleau/nbody-wasm-sim)" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-08 19:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GPU N-body WASM 模拟" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "MiniRust是作者对Rust语义规范的愿景的基石。它是一种理想化的类似MIR语言，目的是作为Rust的“核心语言”。感兴趣的同学可以看看。原文链接https://www.ralfj.de/blog/2022/08/08/minirust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-08 19:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MiniRust 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "WAPM 是一个  WebAssembly 包管理器, 他和语言无关，你可以使用它来管理 wasm的版本和依赖。 作者团队开发来一个cargo的工具，用来辅助 WAPM 的发布等。原文链接https://adventures.michaelfbryan.com/posts/announcing-cargo-wapm/?utm_source=reddit&utm_medium=social&utm_campaign=announcing-cargo-wapm--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-08 19:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cargo wapm 命令发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们正在使用 Rust 构建具有富文本用户界面 (TUI) 的命令行应用程序。我们希望将终端作为生产力的地方，并为它构建各种很棒的应用程序。我们正在寻找代码的贡献者和反馈🦀。🔮 首先，我们不只是构建一个应用程序，而是构建一个库，以支持任何类型的丰富 TUI 开发，其中包含一个转折：采用非常适合前端移动和 Web 开发世界的概念，并为 TUI 重新构想它们和锈。🚀 您现在就可以开始使用这个库来构建 TUI 应用程序 - r3bl_rs_utilscratehttps://crates.io/crates/r3bl_rs_utils#tui🌎 其次，我们希望构建应用程序来提高开发人员的生产力和工作流程。以下是我们要构建的“应用程序”类型的一些示例：到目前为止，我们已经构建了以下内容：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-07 12:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "专注于开发人员生产力的 R3BL TUI 库和应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "发布了SDF Viewer App](https://github.com/Yeicor/sdf-viewer) 1.0.0 版！它允许通过代码设计 3D 模型，应用程序实时渲染和自定义，在更改代码后尽快刷新。我用它来设计用于 3D 打印的对象，但它可以用于任何 3D 建模任务。阅读上面链接的 README 以获得更多信息。主要功能是高性能渲染、跨平台支持（包括 Web），以及与任何可以编译为 WebAssembly 的语言/库的直接集成（已经为 Rust 和 Go 编写了集成）。可以使用此链接在任何浏览器上测试该应用程序。您还可以在此处和此处查看预先录制的演示。https://yeicor.github.io/sdf-viewer/?envdark" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-07 12:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SDF 查看器：快速且跨平台的符号距离函数 (SDF) 查看器，可轻松与您的 SDF 库集成" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "baymax-xhl" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我是 Rust 和 proc 宏的忠实粉丝。在 Rust 中创建 DSL 也很棒。当我一直在研究这些东西时，我一直在写文章以获取知识并在这里分享它们，希望它也能造福其他人。\nhttps://developerlife.com/2022/08/04/rust-dsl-part-1/\nhttps://developerlife.com/2022/03/30/rust-proc-macro/\n以下是我写的关于其他 Rust 主题的其他文章：\nRedux 和 Rust：https ://developerlife.com/2022/03/12/rust-redux/\nRust 和 Tokio：https ://developerlife.com/2022/03/12/rust-tokio/\n其他：https ://developerlife.com/category/Rust/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-07 12:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于 DSL 和 proc 宏的 Rust 教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "尽管 Rust 的第一个稳定版本于 2015 年发布，但其生态系统中仍然存在一些用于解决常见任务的缺失。其中之一是后台处理。在软件工程中，后台处理是解决几个问题的常用方法：\n执行定期任务。例如，传递通知、更新缓存值。\n推迟代价高的工作，以便您的应用程序在后台执行计算时保持响应\n大多数编程语言都有后台处理框架/库。例如：\nRuby -sidekiq。它使用 Redis 作为作业队列。\nPython - dramatiq。它使用 RabbitMQ 作为作业队列。\nElixir - oban。 它使用 Postgres DB 作为作业队列。\n异步编程（async/await）可用于后台处理，但如果直接使用它有几个主要缺点：\n它不能控制在任何给定时间正在执行的任务数量。因此，许多衍生的任务可能会使它们启动的一个/多个线程超载。\n它不提供任何有助于调查系统和发现瓶颈的监控\n任务不是持久的。因此，每次应用程序重新启动时，所有排队的任务都会丢失\n为了解决异步编程的这些缺点，我们在 fang 库中实现了异步处理。Github 链接，https://github.com/ayrat555/fang文章链接，https://www.badykov.com/rust/async-processing/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.badykov.com/rust/async-processing/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-06 22:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fang, Rust的一个异步后台处理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust的数据结构网格。为 Rust 提供易于使用且快速的二维数据结构。 std::vec::Vec 类型为一维向量提供的大部分功能在此 crate 中针对二维实现。Github 链接，https://github.com/becheran/grid" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/becheran/grid" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-06 22:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Released grid v0.7.0 - 感谢所有的PR :-)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "MOROS 是一个基于文本的简单操作系统，针对具有 x86-64 架构和 BIOS 的计算机。它受到 Unix 和 ITS 的启发，但在功能方面更接近现代 DOS。MOROS 0.8.0 有什么新功能？\n用户空间程序现在可以用 Rust 编写！它们还可以有命令行参数并返回退出代码\n添加了新命令：reboot、socket、time\n添加变量、别名、通配符和波浪号扩展，shell 得到了改进\nPython FUSE 驱动程序现在可以在文件系统映像中写入和删除文件\n阅读 CHANGELOG 上的完整更改列表Github 链接，https://github.com/vinc/moros/releases/tag/v0.8.0文章链接，https://www.reddit.com/r/rust/comments/whn0ol/moros_080_released/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/whn0ol/moros_080_released/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-06 22:58" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MOROS 0.8.0 Latest" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "hyper 是很多 web 框架的底层 url 请求库，本文总结了 7月份 hyper库的进展（发布了 Release v0.14.20）：\n增加了 hyper::ext::ReasonPhrase\n开始进入 1.0 稳定版开发进程\nHTTP/3 RFC 标准已经通过,1.0版本将加入 HTTP/3 支持\n原文：https://seanmonstar.com/post/691039972381294592/this-month-in-hyper-july-2022" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-05 22:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "7月份的 hyper" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者用 Rust 实现了一款支持可逆计算的编程语言 RRust，并且准备将它作为硕士论文的课题。文章首先介绍了可逆计算函数的概念，然后科普了相关研究历史，使用 Rust 的原因以及给出一些示例原文：https://blog.erk.dev/posts/rrusthttps://github.com/huangjj27" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-05 22:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "可逆编程语言 RRust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lecepin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用 Rust + Tauri 1.0 上手体验了一下，做了一个简单的小工具，整体在编码过程中的感觉还是不错的，打包过程的速度就另说了（用 Github Actions 打包在 20 min 左右），不过 Tauri 提供的脚手架是真不错，打包后的体积也是非常夸张的只有几兆，优化一下还会更小，完全吊打 Electron。下面这个工具功能挺简单的，麻雀虽小，五脏俱全。前端同学可以参考一下，后面会写一下碰到的一些注意点。\n支持下载无水印视频\n支持下载某个账号号的所有视频\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-05 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lecepin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "软件采用 Rust + Tauri 编写，安装包非常小，只有 5MB 左右。\nWindows 下载地址：douyin-downloader_0.1.0_x64_en-US.msi\nMac 下载地址：douyin-downloader_0.1.0_x64.dmg\n国内访问速度慢，可以使用以下加速地址：\nWindows 下载地址：douyin-downloader_0.1.0_x64_en-US.msi\nMac 下载地址：douyin-downloader_0.1.0_x64.dmg\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-05 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "下载软件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lecepin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如下方式使用。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-05 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lecepin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "手机端、网页端都可，点击分享按钮，把口令复制到本软件中，进行解析即可。口令类似 1.20 fBt:/ 拿好纸巾（有双倍福利呦） # 美女合集 # 气质美女 # 变装 @抖音小助手 https://v.douyin.com/23FsM5g/ 复制此链接，打开Dou音搜索，直接观看视频！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-05 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "下载单个视频" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lecepin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "网页版，进入个人页，网址类似 https://www.douyin.com/user/MS4wLjABAAAAWiOs23d6NtmiUg98zONd6wQhmPsy1WLwZn0jEaCbDL8：复制网址，粘贴到 “用户所有视频” 类型下，解析即可：点击 “全部下载” 按钮，就可以进行全部下载了：一键下载完成：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-05 18:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "下载某个账号号的所有视频" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Miguel Ojeda发布了最新的补丁系列，实现了Linux内核的Rust编程语言基础架构和初始样本代码。今天发布了Rust支持的v8版本，最初的43.6k行代码增加了可在Linux内核内使用Rust编程语言的支持。早在6月的开源峰会上，Linus Torvalds评论说，用于内核的Rust可以合并到Linux 5.20--现在被称为Linux 6.0。是否最终合并还有待观察，尤其是今天发布的v8补丁系列有许多新的补充内容，需要更多的时间来审查...... 因此，如果不是下周Linux 6.0的最后一分钟合并，Rust内核代码可能仍然需要更多的时间来准备。在任何情况下，它似乎正在一步步接近合并的目标。随着Linux内核的Rust v8系列补丁的推出，有很多代码在不断的更新，更多的内核功能现在可以通过Rust代码来实现。这些最新的补丁中的一些Rust亮点包括:\n\n升级了Rust 工具链到1.62\n\n\n将Rust的Linux内核绑定转移到他们自己的crate（命名为 \"bindings\"），以改善只有kernel crate改变时的构建时间。\n\n\n改进了rust-analyzer的运行速度。\n\n\n通过 \"fs \"模块增加了对文件系统的支持，包括各种新类型、文件系统参数支持、文件系统标志以及Rust中的文件系统示例代码。\n\n\nWorkqueues 支持也是Rust v8 Linux补丁中的新内容。\n\n\nRust v8补丁中扩展了异步支持，现在在有执行器支持、基于工作队列(workqueues)的执行器、产生执行当前任务的yield_now()，并增加了一个异步TCP echo 服务器示例。\n\n\nRust支持对中断的处理。\n\n\n最初的RCU支持。\n\n\n对延迟/睡眠(delays/sleeps)的初步支持。\n\n升级了Rust 工具链到1.62将Rust的Linux内核绑定转移到他们自己的crate（命名为 \"bindings\"），以改善只有kernel crate改变时的构建时间。改进了rust-analyzer的运行速度。通过 \"fs \"模块增加了对文件系统的支持，包括各种新类型、文件系统参数支持、文件系统标志以及Rust中的文件系统示例代码。Workqueues 支持也是Rust v8 Linux补丁中的新内容。Rust v8补丁中扩展了异步支持，现在在有执行器支持、基于工作队列(workqueues)的执行器、产生执行当前任务的yield_now()，并增加了一个异步TCP echo 服务器示例。Rust支持对中断的处理。最初的RCU支持。对延迟/睡眠(delays/sleeps)的初步支持。至于目前的状态，v8补丁系列仍然带有这样的信息: \"Rust支持仍然被认为是实验性的。然而，支持已经足够好了，内核开发者可以开始研究子系统的Rust抽象，并编写驱动和其他模块。\"对于那些对Linux内核的Rust感兴趣的人来说，更多的细节可以在内核邮件列表中看到v8补丁。https://lore.kernel.org/lkml/20220802015052.10452-1-ojeda@kernel.org/新闻: https://www.phoronix.com/news/Rust-v8-For-Linux-Kernel邮件: https://lore.kernel.org/lkml/20220802015052.10452-1-ojeda@kernel.org/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://lore.kernel.org/lkml/20220802015052.10452-1-ojeda@kernel.org/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-04 21:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Linux内核的Rust代码更新，实现了更多的功能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一篇异步Rust性能调优的文章，写的很详细，包括代码调优的背景等。博客: https://www.p99conf.io/2022/08/02/async-rust-in-practice-performance-pitfalls-profiling/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.p99conf.io/2022/08/02/async-rust-in-practice-performance-pitfalls-profiling/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-04 21:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "异步Rust的实践：性能、隐患、分析" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "嗨！在过去的几个月里，我一直在使用PGO和BOLT对Rust编译器进行优化，在此过程中，我意识到使用这些工具来优化一般的Rust代码可能有点麻烦。这就是为什么我决定创建一个Cargo子命令，使其更容易使用PGO和BOLT（BOLT支持目前还略带实验性，主要是因为你必须自己用BOLT构建LLVM，而它并不总是完美无缺地工作）。作为快速科普，PGO（配置文件引导的优化）和BOLT是提高二进制文件性能的技术。你以一种特殊的方式（使用instrumentation）编译你的二进制文件，然后你在一些工作负载上执行这个修改过的二进制文件，这就产生了配置文件，然后你使用这些收集的配置文件再次编译你的二进制文件。这将有望产生一个更快、更优化的二进制文件（通常效果可以达到1-20％的改善）。cargo-pgo子命令将负责使用正确的编译标志和设置，为你的构建启用PGO，它将指导你完成使用这些所谓的 \"反馈导向的优化 \"的工作流程。下面是一个简易的例子:该命令允许你使用PGO、BOLT以及BOLT+PGO组合。你可以用典型的方式安装该工具：你可以在这里找到这个工具。我很高兴得到任何反馈。https://github.com/Kobzol/cargo-pgoGithub: https://github.com/Kobzol/cargo-pgo" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Kobzol/cargo-pgo" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-04 21:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-pgo：Cargo子命令，用于简化PGO和BOLT优化二进制文件流程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "hot-lib-reloader允许在运行中改变Rust代码，而无需重新启动。它适用于Linux、macOS（Intel）和Windows。关于为什么，它是如何工作的，以及如何使用它（以及这种方法的局限性），请阅读下面的帖子。文末提供了一个bevy的热重载示例。热重载Rust: https://robert.kra.hn/posts/hot-reloading-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://robert.kra.hn/posts/hot-reloading-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-04 21:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "热重载Rust--为了获得乐趣和更快的反馈周期" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是关于零拷贝反序列化的有趣抽象的三部曲的第一部分，我在过去一年里一直在研究。这一部分是关于使零拷贝反序列化工作得更愉快。第二部分是关于让它适用于更多的类型；而第三部分是关于完全消除反序列化的步骤。这些文章可以按任何顺序阅读，第一篇文章里包含了对什么是零拷贝反序列化的解释。#1: https://manishearth.github.io/blog/2022/08/03/zero-copy-1-not-a-yoking-matter/#2: https://manishearth.github.io/blog/2022/08/03/zero-copy-2-zero-copy-all-the-things/#3: https://manishearth.github.io/blog/2022/08/03/zero-copy-3-so-zero-its-dot-dot-dot-negative/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://manishearth.github.io/blog/2022/08/03/zero-copy-3-so-zero-its-dot-dot-dot-negative/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-04 21:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Zero-Copy 系列博客" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 454: https://this-week-in-rust.org/blog/2022/08/03/this-week-in-rust-454/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/08/03/this-week-in-rust-454/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-04 21:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 454" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "毫无疑问，宏是 Rust 编程语言的一个重要特性。像 println!, lazy_static!、各种派生宏和许多其他宏这样的宏节省了无数小时编写繁琐的样例代码。rust 改进了声明性宏，但 Rust 也有 proc-macros（过程宏）。Proc-macros 本质上是将标记流转换为标记流的编译器的扩展。在这两者之间，您可以使用常规的 Rust 代码和任意复杂的逻辑来重新排序、创建、删除或转换令牌。几乎没有任何限制。这使得 proc-macros 在声明性宏无法处理的情况下非常强大和有用。文章为我们讲解了 proc-macros 的优劣，同时也给出了很棒的 proc-macros 代码。\nhttps://aaronerhardt.github.io/blog/posts/proc_macro_v2/\nAya 是一个 rust 的 eBPF 库，它让完全用 Rust 编写 eBPF 程序成为可能。Aya 是第一个支持在 Rust 中编写整个 eBPF 项目（包括用户空间和内核空间部分）的库，而不依赖于 libbpf 或 clang。在大多数环境中，Rust Nightly 是构建所需的唯一依赖项。rustc 不公开其内部 LLVM.so 库（即 aarch64）的某些环境需要安装共享的 LLVM 库。但是不需要 libbpf、clang 或 bcc！该文章举例了各种 bpf 的使用场景，值得一看。\nhttps://deepfence.io/aya-your-trusty-ebpf-companion/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-03 21:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇博文是关于hypher的，一个用于Rust的连字符解析库。作者正在开发一个名为Typst的纯rust实现的 LaTeX替代品。为了获得与 LaTeX 相同的解析结果，Typst 需要对连字符的支持。在 docs.rs上的快速搜索显示，真正相关的库只有一个，恰好就叫 hyphenation。这个库有很多功能，支持很多语言。然而，它也有相当大的二进制开销（2.8MB）。虽然可以在运行时加载模式文件，但单独分发模式文件显然比直接嵌入它们要复杂得多。除此之外还遇到了一些因为频繁加载导致的性能问题，于是作者决定建立一个新的crate，目标如下。没有分配，在运行时没有加载，更少的二进制开销和最小的依赖性。最终实现了将30种自然语言的音节解析塞到了1.1MB的空间内。ReadMore: https://laurmaedje.github.io/posts/hypher/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://laurmaedje.github.io/posts/hypher/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-02 20:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "hypher 将30种自然语言塞到1.1M空间内" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Koalr" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个无锁、部分无等待、最终一致、并发安全的 hashmap。极其快速的读取的代价是，当一个写被执行时，所有的读线程只有在完成他们的最后一次读并开始一个新的读时才会观察到这个写。flashmap 是为读取远远大于写入的场景而优化的，适合使用的情况包括：\n偶尔插入/删除的高频率读取\n通过内部可变性对现有条目进行高频率的修改，并偶尔的插入/删除\n高频读取，另一个线程执行适度的写入数据\n不宜 flashmap 的情况包括：\n频繁的、小规模的写入，不能分批进行\n来自多个线程的并发写访问\nReadMore: https://github.com/Cassy343/flashmap" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Cassy343/flashmap" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-02 20:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "flashmap 一个无锁的并发安全的 hashmap" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个超详细的 linux 内核的 Rust 开发教程, 快来使用 Rust 来开发你的第一个 linux 内核模块把.原文链接https://www.jackos.io/rust-kernel/rust-for-linux.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-01 19:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 开发你的第一个linux 内核模块" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 的第 10w issue 出炉了, 带着大家对 Rust 的满满的爱.Rust 第 10w 个 issue 地址https://github.com/rust-lang/rust/issues/100000" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-01 19:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust的第 10w 个 issue" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目前,一个对于 IP 地址的重大重构已经合并到主线了.总的来说，对于IPv4和IPv6, Rust现在使用它自己的，原生的表示和api来表示IP地址以及相关数据(例如netmask，套接字地址)，而不是依赖于libc。这将允许将IP功能潜在地改进优化，改进IP地址的const支持，以及一些人体工程学的改进。这也进一步减少了Rust对libc的依赖。原文链接https://github.com/rust-lang/rust/pull/78802" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-01 19:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust IP地址的重大重构" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 Arrow2 最近比较大的一个版本更新, 现在支持读取 Apache ORC 格式, 增加 COW api 提高性能.原文链接https://github.com/jorgecarleitao/arrow2/releases/tag/v0.13.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-01 19:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Arrow2 v0.13.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "sqlite-zstd 是一个用 Rust 编写的 SQLite 扩展，可以在不丢失功能的情况下减小数据库大小原文链接https://phiresky.github.io/blog/2022/sqlite-zstd/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-08-01 19:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "sqlite-zstd:  SQLite 的基于字典的行级压缩扩展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Bevy 0.8 正式发布，主要更新如下：\n新材料系统：由于新的 Material Trait 和 AsBindGroup derive，自定义着色器更加容易。\n相机驱动的渲染：每个相机都配置了它渲染的内容及渲染方式。只需几行代码就可以轻松将相机渲染层叠加，分屏或渲染到纹理。\n内置着色器模块化：可以导入许多内置着色器类型和功能。\n聚光灯：一种新的光源类型，从固定点发出锥形光。\n可见性继承：隐藏实体也会隐藏在层次结构中的所有后代。\n升级到 wgpu 0.13。\n自动网格切线生成。\n渲染器优化。\n场景包：使用普通的 Bevy 包轻松生成场景，并使用新组件和子组件对其进行扩展。\n脚本/修改进度：无类型 ECS API：迈向第三方脚本语言支持的一步，通过指针直接与 Bevy ECS 内部交互。\nECS 查询人体工程学和可用性。\nECS 内部重构。\n反射改进：支持更多类型。\n层级命令：层级结构更新使用「事务性命令」确保层级结构一致性。\nBevy UI 使用 Taffy。\n从 0.7 升级到 0.8：https://bevyengine.org/learn/book/migration-guides/0.7-0.8/网址：https://bevyengine.org/news/bevy-0-8/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-31 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy 0.8 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "indicatif 是 Rust 生态系统中最受欢迎的终端进度条库之一。除了许多小的 API 添加和修复之外，还特别努力减少了报告进度的开销。在基本测试中，最简单的进度条在 0.17.0 上比 0.16.2 快 95 倍。另外对 MultiProgress 集合的工作方式进行了许多更改，不再需要显式 join () MultiProgress，有更多方法可以将新进度条插入到集合中。减少了依赖项，删除了 lazy_static 和 regex。更新日志：https://github.com/console-rs/indicatif/releases/tag/0.17.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-31 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "indicatif 0.17.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Redis 中用于大型字符串的快速且通用的 rope 数据类型，作为本机模块分发。对于大型字符串，rope 是一种更有效的数据结构，它可以让某些操作的速度快很多：\n将字节添加到任何想要的位置。\n删除任何 rope 子串或移动到 rope 内的一个不同位置。\n将 rope 的任何子串与其他 rope 拼接。\n使用随机访问读取任何子字符串。\nrope 的背后是 splay tree，这是一种自我调整的数据结构，具有对数摊销的最坏情况性能，而最近访问的索引也可以在后续操作中快速访问。  每个展开树节点存储 64 到 127 个字节的数据。https://en.wikipedia.org/wiki/Splay_treeGitHub：https://github.com/ekzhang/redis-rope" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-31 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "redis-rope" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本项目的目标是创建一个小型、健壮且可定制的登录管理器，它可以作为图形 GNU/Linux 的前端。 Lemurs 使用 Linux PAM 作为其身份验证方法。GitHub：https://github.com/coastalwhite/lemurs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-31 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "lemurs" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 实现的包含更多特征的 tee。使用示例：GitHub：https://github.com/sanjaypra555/rustee" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-31 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustee" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nRust 和 WebAssembly：https://bojanstipic.rs/blog/01-introduction-to-webassembly-and-rust/\nRust Tutorial：https://www.youtube.com/watch?v=ygL_xcavzQ4\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-31 23:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "内存安全是当今的热门话题。虽然每个人似乎都同意内存安全非常重要，但真正构成安全的内容仍然是主观的。Jeff Schwab的文章将带领我们看看语义上等价的 Rust、C++ 和 Go 代码，比较它们的安全方法有何不同。这篇文章提供了很多代码作为屏幕截图。下载完整的代码可在Github，https://github.com/jeffs/nested/tree/main/safety。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jeffs/nested/tree/main/safety" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-31 22:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust、C++ 和 Go 内存安全性的简洁比较" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对于那些寻求高性能、内存安全以及轻松编写无错误代码所需的所有工具的人来说，Rust 是首选语言。 在本教程中，Derek Banas创建了一个完整的 Rust 编程课程。获取代码可在Github，https://github.com/derekbanas/Rust-Tutorial" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/derekbanas/Rust-Tutorial" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-31 22:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【视频】Rust 教程完整课程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "getargs 是一个库，真正零成本的参数解析器，类似于 Unix 的getopts。现在终于发布了v0.5.0。它是非常低层的，不像clap，所以它可以在几微秒内解析一个典型的命令行，而且根本不需要分配。它适合应用程序直接使用，但也可以用作更高级别参数解析器的核心。更多详情请参见链接，https://docs.rs/getargs/0.5.0/getargs/https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://docs.rs/getargs/0.5.0/getargs/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-31 22:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "getargs发布v0.5.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "继本月 GCC Rust 指导委员会批准作为 Rust 编程语言的编译器前端之后，第一个正式系列已发送审核。GCC-Rust 已经很好地融合在一起，现在在指导委员会的支持下，明年的 GCC 13 应该会有初步的 Rust 支持，但仍处于早期形式。例如，借用检查器和其他功能仍有待解决。更多信息请看原文：https://www.phoronix.com/news/GCC-Rust-Front-End-v1-Review" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.phoronix.com/news/GCC-Rust-Front-End-v1-Review" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-29 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "第一版 GCC 的 Rust 编译器前端已提交审查" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "mvsqlite 项目是一个在 FoundationDB 上运行的分布式 MVCC SQLitez 组。SQLite 是一个单写数据库——由于其基本的设计选择，这不会轻易改变。但是一组（N 个）sqlite 数据库是一个 N-writer 数据库。 mvsqlite 提供了必要的机制来执行可序列化的跨数据库事务，而无需额外的开销。跨数据库事务的逻辑还没有，所以这里有一个演示，展示了当有多个并发写入同一数据库时，MVCC 如何在 mvsqlite 中工作（以及它如何破坏事物）。更多详情请看仓库：https://github.com/losfair/mvsqlite" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/losfair/mvsqlite" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-29 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mvsqlite 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "之前，我们介绍了一种在 Rust 中为单个递归数据结构编写高性能堆栈安全递归的方法。这篇文章使用相同的想法来实现可以折叠或扩展任何递归数据结构的单个递归后端。这个通用递归后端在我的新递归仓库中实现。更多请看文章原文：https://recursion.wtf/posts/rust_schemes_2/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://recursion.wtf/posts/rust_schemes_2/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-29 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中的完全泛型递归" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章介绍了一些模式和技巧，以更好地利用 Rust 的类型系统来编写干净和安全的代码。文章会提供一些进阶用法 —— 这些模式通常需要根据具体情况进行评估，以查看成本/收益权衡是否值得。更多请看文章详情：https://www.shuttle.rs/blog/2022/07/28/patterns-with-rust-typeshttps://github.com/Jancd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.shuttle.rs/blog/2022/07/28/patterns-with-rust-types" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-07-29 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 类型的一些编程模式" }, "type": "text" }], "type": "title" } },]
