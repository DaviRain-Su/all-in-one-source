export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "很久之前，为了在  Arduino上跑 Rust，还必须安装专门经过改造支持 AVR 的 Rust 编译器 ：rust-avr  。 一个月之前，rust-avr  已经被合并到了 Rust master 分支，这意味着你在 Nightly 下就可以玩 Arduino了。并且包含了一本新书  The AVR-Rust Guidebook  ：  https://book.avr-rust.com/rust-avr 项目官网： https://www.avr-rust.com/这篇文章就是一个教程。https://dev.to/creativcoder/how-to-run-rust-on-arduino-uno-40c0via  https://t.me/rust_daily_news/4495" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Arduino Uno上面跑 Rust 程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "讨论的挺火热的，就加上来了。地址：https://www.reddit.com/r/rust/comments/igz8iv/deep_learning_in_rust/rust机器学习工作组：https://github.com/rust-ml和其他工作组一样有一个汇总网站：https://www.arewelearningyet.com/可能会用到的库：①、https://github.com/raskr/rust-autograd②、https://github.com/spearow/juice" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于Rust用于深度学习的讨论" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rapier在前两天公布源码的同时还发布了这篇blog。地址：https://www.dimforge.com/blog/2020/08/25/announcing-the-rapier-physics-engine/不仅有和box2d与physx的性能对比测试，这篇blog还将目前的功能与前作nphyscis进行了对比，并表示将在未来几个月将缺失的功能给完善。同时提供了Bevy的官方插件：https://github.com/dimforge/bevy_rapier论文中提到本来也有一个专门给Amethyst引擎实现的插件，但是目前Amethyst正在迁移他们的ECS后端。等这部分工作完成之后，才会给Amethyst提供官方维护的物理引擎插件。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rapier物理引擎的性能测试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "应该是他们可视化底层编程的书要出了，所以放出了这个小演示。地址（需要FQ）：https://www.youtube.com/watch?v=zTpzyYtE5oY" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust可视化编程的一个小演示" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read More：https://tikv.org/blog/rustconf-20/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "前几天的Rustconf 2020，Tikv官网特意做了一个汇总" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在还处于非常早期的阶段，但是已经支持了基础的SQL查询。地址: https://github.com/gluesql/gluesql" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个新的sql数据库：GlueSQL" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "include_bytes!宏大家应该都用过，作者在使用的过程中发现并不是那么好用，有些地方不能达到作者的预期，这篇blog介绍了作者遇到的一些问题，以及作者是如何修复这些问题的。Read More：https://jack.wrenn.fyi/blog/include-transmute/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "修复include_bytes!宏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者用Rayon库写了一篇在rust中线程池的一篇教程。Read More：https://pkolaczk.github.io/multiple-threadpools-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust中的多线程池" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "库的介绍文档有提到了这个库的一些原理。地址：https://github.com/moelife-coder/constany" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Constany：将任何rust函数转换为const函数的crate" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "最近在看Bevy的源码，有些有趣的地方分享给大家。看的比较少，所以只找到一些简短的地方。因为对Bevy的资产处理不是太熟悉，所以优先看了这部分的源码。这部分源码我觉得是比较有意思的，因为除了Handle结构体之外，在这部分源码中还实现了另一个结构体：大部分对Handle的操作方法都是实现在了Handle里的，那实现HandleUntyped的意义在哪里呢？源码自带的注释很好的解释了这一点：This allows handles to be mingled in a cross asset context. For example, storing Handle<A> and Handle<B> in the same HashSet<HandleUntyped>.目前我也就只看了资产的部分，比较复杂的处理应该是AssetServer这部分，不过基本都是正常的代码，没有上面这种取巧的地方了。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Bevy源码学习笔记-001" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "前几天无聊的时候刷到B站一个用Rust刷力扣题目的Up主，视频质量杠杠的。但是一个视频的播放量低的可怜，有兴趣的观众可以关注一波地址：https://space.bilibili.com/202107274/建议从力扣刷题的部分看，我个人认为这是他系列里做的最好的。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "推介一个B站Up主" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "喜闻乐见的第353期。Read More：https://this-week-in-rust.org/blog/2020/08/26/this-week-in-rust-353/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-27 17:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Trunk 是一个命令行工具，为构建 Rust WebAssembly 应用的构建提供简单、零配置的模式。目前已经支持 sass、css、icon的打包。目前项目处于开启阶段，欢迎贡献。https://github.com/thedodd/trunk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/thedodd/trunk" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-26 21:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Trunk: WASM Web 项目的构建打包工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rapier 是100%使用 Rust 开发的物理引擎，可用于游戏、动画、机器人学的模拟。提供 2D 以及 3D版本https://www.dimforge.com/blog/2020/08/25/announcing-the-rapier-physics-engine/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.dimforge.com/blog/2020/08/25/announcing-the-rapier-physics-engine/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-26 21:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rapier： 2D 以及 3D的物理引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Transmutation 推进：https://internals.rust-lang.org/t/pre-rfc-safer-transmutation/12926" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://internals.rust-lang.org/t/pre-rfc-safer-transmutation/12926" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-26 21:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pre-RFC: Safe(r) Transmutation" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "cargo build 过程图形化展示工具https://github.com/Nemo157/cargo-build-tree" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Nemo157/cargo-build-tree" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-26 21:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-build-tree" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "（标题党）这是 微软 Azure 云团队 的 Ryan Levick 在 Rust Linz 线上Rust Meetup 的分享，分享内容主要是他对Rust语言的看法，其实这些看法对于 Rust 社区的老炮来说，都是老生常谈了。我们更关注于Ryan的身份： 他是微软Azure 云团队的人。通过他，我们可以了解更多关于 Rust 在微软应用的内幕。这节视频的 Question环节（时间 42:26 ）的第一个问题，就是主持人在问：One very interesting question is in  what ways is microsoft actively developing using  Rust ?一个非常有趣的问题是，微软正在以何种方式积极使用Rust？看到这里，我才发现，原来国外 Rust 社区也非常关注这个问题。Ryan 回答：yes , so  we 've written about this a little bits . um. in the blog and MSRC and  i'm going to  go all the way back to the begnning  of the talk  ,and  go back to this graph that i showed here.是的，所以，我们已经对此进行了一些介绍。 比如，在博客和 MSRC （微软安全响应中心）中，我将回到讨论的开始，然后再回到我在此次分享中展示的那张图。this is actually from the msrc,  the microsoft security response center, which is the team in charge of security response at microsoft across all of our products, and  about  two years ago , they took a look at this graph and got very sad , and said  we've been putting a lot of money into making our sofeware safer and which has been working , we have we find a lot more vulnerabilities ourselves instend of bad people finding them , before we do which is good , that's good, but what they wouldn't it be great if this number didn't you know if this didn't exist , and we didn't have to worry about  finding them before the bad people did because they just didn't exist in the first place.and  so  looing at this number where you  see 70% of the security vulnerabilities are momory safety related and that from 2006 to 2018 , by the way 2019, was the same . we didn't update the slide but it's the same percentage roughly 70  , the number is just not going down , how can we do this . well, on possible way to do that is adopting the language that where you literally can't write memory safety bugs that could be using c# , and so one aspect of that is let's use more C# , let's use more GC languages , they get rid of these a lot of these issues as well , but  we 're writing windows and office ,  xbox games center microcontrollers  , we're " }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-25 23:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么我们应该关注 Rust 语言？（微软Azure团队成员首次透露 Rust 在微软内部 ... ... ） by 张汉东老师" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在迁移一些 C/C++ 代码到 Rust 过程中, 你是否也对切片的所有权如何从 Rust 中传递给 C 感到困惑 ?亦或是对切片的内存布局感到困惑, 从而担心是否会造成内存泄露 ?作者开始有同样的不解, 在深入了解以后,写下该篇文章帮助有同样疑惑的人.Read morehttps://codecrash.me/understanding-rust-slices" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-24 20:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "理解 Rust 的切片" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者通过自己的验证, 证实 Rust 在嵌入式领域中完全可以开发工业级标准的软件.通过一个真实的例子, 如何为两个不同的闪存设备芯片来抽象一个统一读写的接口, 来介绍如何在嵌入式中使用泛型.Read morehttps://www.ecorax.net/as-above-so-below-1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-24 20:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "裸金属上使用 Rust 泛型 1/2" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "去中心化的数字身份, 又名 身份自主权 ( Self Sovereign Identity (SSI) ). IOTA identity 是一个他的一个具体实现.他实现了 W3C 中的 DID(Decentralized Identifiers) 和 Verifiable Credentials 以及其他相关的标准.目前该项目在积极开发中,感兴趣的同学可以时刻关注其动态.IOTA Identity githubhttps://github.com/iotaledger/identity.rsDID(Decentralized Identifiers)https://www.w3.org/TR/did-core/Verifiable Credentials Data Modelhttps://www.w3.org/TR/vc-data-model/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-24 20:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "IOTA Identity 现已开源" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "jlrs 的目标是对 Julia C API 提供一个简单安全的接口. 目前该 crate 只在 Linux和Windows上测试通过, 且只支持 Julia 1.5.0, 不兼容之前版本的 Julia.有兴趣同学可以访问其 Githubhttps://github.com/Taaitaaiger/jlrs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-24 20:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Julia 的 Rust 绑定库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Linz(林茨, 奥地利北部城市) 一直有各种各样的编程语言的 meetup, 但是 Rust 并不在其中. 随着 Rust 变的越来越流行, Linz 从2020年 8 月份开始举办 Rust的 meetup. 目前已经举行了一期.八月份(2020-08-06)分享:\n\nCargo - Introduction in Rust's Package Manager\n分享者: Rainer Stropek, 微软\n\n\nWhy should I care about Rust?\n分享者: Ryan Levick\nryan 也提到微软内部有很多组都开始逐步尝试rust，但是微软目前还没准备好公开哪些组开始用rust了.\n他还提了一下微软的那个学习 rust 的 Verona 语言，说目前来说 Verona 主要是一个 research 项目，等于是 Microsoft research 通过 Verona 项目来研究memory safety。目前没有明确的信息说明Verona未来会不会真的投入使用.\n\nCargo - Introduction in Rust's Package Manager分享者: Rainer Stropek, 微软Why should I care about Rust?分享者: Ryan Levickryan 也提到微软内部有很多组都开始逐步尝试rust，但是微软目前还没准备好公开哪些组开始用rust了.他还提了一下微软的那个学习 rust 的 Verona 语言，说目前来说 Verona 主要是一个 research 项目，等于是 Microsoft research 通过 Verona 项目来研究memory safety。目前没有明确的信息说明Verona未来会不会真的投入使用.九月份(2020-09-16)的安排:\n\nGet to Know Rust: Build, debug, and test an application\n分享者: Meaghan Lewis, 微软高级程序经理.\n\n\nBuilding a digital logic analyzer from scratch with embedded rust\n分享者: Roland Ruckerbauer\n\nGet to Know Rust: Build, debug, and test an application分享者: Meaghan Lewis, 微软高级程序经理.Building a digital logic analyzer from scratch with embedded rust分享者: Roland Ruckerbauer十月份(2020-10-08)的安排:\n\nHow not to rely on inheritance\n分享者: Valentin Tolmer, 谷歌的开发人员\n\n\nWriting a kernel driver with Rust\n分享者: Matthias Heiden\n\nHow not to rely on inheritance分享者: Valentin Tolmer, 谷歌的开发人员Writing a kernel driver with Rust分享者: Matthias Heiden大家感兴趣的话可以观看线上的分享,或者观看历史回放.官网的介绍: https://rust-linz.at/#intro油管的Playlist: https://www.youtube.com/playlist?list=PL85XCvVPmGQgL3lqQD5ivLNLfdAdxbE_u--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-24 20:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Linz Rust meetup" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #graphicsRapier.rs 是一个跨平台的2D/3D物理引擎\n支持多平台物理模拟\n支持导出/导入物理模拟某一过程的瞬时快照\n（可选）使Rapier跨平台在所有符合IEEE 754-2008的32位和64位平台上具有确定性\n在@dimforge命名空间发布了wasm NPM包，可以在任何现代浏览器中运行Rapier\n我们以FOSS思维方式构建，旨在为Rust和Web社区提供有效的物理模拟框架\nRepohttps://rapier.rs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-24 13:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rapier 一个跨平台2D/3D物理引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust的官方文档对于非英语母语的开发者来说理解起来有点难，因此作者用更加通俗易懂的语言解释了Rust官方文档，目前已经完成内容进入审校阶段。Read Morehttps://github.com/Dhghomon/easy_rust/blob/master/README.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-24 13:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Easy_Rust 文档进入进入审校阶段" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #memoryRead Morehttps://github.com/usagi/rust-memory-container-cs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-24 13:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 内存容器备忘录" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#meetup8月17日在Linz举行了Rust聚会。下面的视频是ryan的分享，他提到微软内部有很多组都开始逐步尝试rust，但是微软目前还没准备好公开哪些组开始用rust。他还提了一下微软的那个学习rust的Verona语言，说目前来说Verona主要是一个research项目，等于是Microsoft research 通过Verona项目来研究memory safety。目前没有明确的信息说明Verona未来会不会真的投入使用。Ryan Levick - Why should I care about Rust?https://www.youtube.com/watch?v=OhCjnyBc448&feature=youtu.beRead Morehttps://rust-linz.at/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-24 13:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Meetup Linz" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个项目是一个从Rust中调用c++的工具，以一种高度自动化但安全的方式。这样做的目的是，在使用bindgen的一个变体从现有的c++头文件自动生成接口的同时，也具有来自cxx的所有流畅安全性。可以把autocxx看作是将bindgen插入cxx的胶水。它的目的是最终公开一个过程宏，如下所示:Github 链接，https://github.com/google/autocxx" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/google/autocxx" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-22 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "google/autocxx - 高度自动化的rust调用c++，而且安全，时尚" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "print是很重要的。如果某些东西不工作，您想知道为什么(例如，通过查看控制台输出)。当我第一次为内核驱动程序编写日志宏时，我没有考虑太多安全性问题。我只是想:“肯定没有人会用错误的格式说明符或错误的参数数量调用它，因为它的用法简单而直接”。文章链接，https://not-matthias.github.io/kernel-printing-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://not-matthias.github.io/kernel-printing-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-22 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用rust在内核print" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我在6月份写的文章2的基础上创建了一个视频系列2，在文章2中，我们使用Rust和Rocket创建了一个智能书签工具。它是初学者友好的，并且在结尾你将有一个生产rust应用部署到Heroku!文章链接，https://users.rust-lang.org/t/video-series-build-a-smart-bookmarking-tool-with-rust-and-rocket/47601https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://users.rust-lang.org/t/video-series-build-a-smart-bookmarking-tool-with-rust-and-rocket/47601" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-22 21:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "视频系列: 使用Rust和Rocket构建一个智能书签工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Oxigraph is a graph database implementing the SPARQL standard.Official website: https://github.com/oxigraph/oxigraphOxigraph是一个实现了SPARQL标准的图数据库。宗旨是为了实现一个基于RockDB和Sled的K/V仓库的兼容的，安全的，快速的图数据库。由Rust语言实现，Oxigraph同时也提供很多读，写和处理RDF文件的工具功能。Oxigraph目前正在重度活跃的开发中，很多SPARQL的查询评估还没有经过优化。Oxigraph的组件：\nlib\npython\njs\nserver\nwikibase\n安装和使用：需要最新的稳定版本的Rust和Cargo安装同时也需要clang编译RockDB。直接安装就可以：https://www.rust-lang.org/tools/install" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/oxigraph/oxigraph" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-22 06:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Oxigraph - 实现了SPARQL标准的图数据库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RustConf is online!Official website: https://rustconf.com/RustConf研讨会在线举办，大家可以科学观看和回顾：\nVideo#01 RustConf 2020 - Opening Keynote\nVideo#02 RustConf 2020 - Error Handling Isn't All About Errors\nVideo#03 RustConf 2020 - How to Start a Solo Project That You'll Stick With\nVideo#04 RustConf 2020 - Under a microscope - exploring fast and safe rust for biology\nVideo#05 RustConf 2020 - Bending the curve - a personal tutor at your fingertips\nVideo#06 RustConf 2020 - My First rust project - starting a 2d game with amethyst\nVideo#07 RustConf 2020 - Controlling telescope hardware with rust\nVideo#08 RustConf 2020 - Macros for a more productive rust\nVideo#09 RustConf 2020 - Rust for non-systems programmers\nVideo#10 RustConf 2020 - Closing keynote\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rustconf.com/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-22 06:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustConf研讨会在线举办" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "tickrs | Realtime ticker data in your terminal. Built with tui-rs.https://github.com/tarkah/tickrshttps://i.imgur.com/4Izc2dz.mp4用tui-rs打造应答机模式的实时滚动数据终端。受gotop启发，看到又搞了一个Rust语言版的ytop超级兴奋，于是自己搞了一个TUI的APP来跟踪实时股票数据。考虑到要让没有API Key的用户都可以体验，最后选择了用Yahoo Finance的后台数据。https://github.com/cjbassi/gotop\n\nCargo\n  cargo install tickrs\n\n\n\nUsage\n  tickrs 0.3.3\n  Realtime ticker data in your terminal 📈\n  \n  USAGE:\n      tickrs [FLAGS] [OPTIONS]\n  \n  FLAGS:\n      -h, --help         Prints help information\n          --hide-help    Hide help icon in top right\n      -V, --version      Prints version information\n  \n  OPTIONS:\n      -s, --symbols <symbols>...    Comma separated list of ticker symbols to start app with\n\n\n\n特别感谢：\n\nfdehau / tui-rs - great TUI library for Rust\ncjbassi / ytop - thanks for the inspiration!\n\n\nCargoUsage特别感谢：\nfdehau / tui-rs - great TUI library for Rust\ncjbassi / ytop - thanks for the inspiration!\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://i.imgur.com/4Izc2dz.mp4" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-22 06:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tickrs | 实时滚动数据终端，用tui-rs打造。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Veloren is a multiplayer voxel RPG written in Rust.代码：https://github.com/veloren/veloren官网：https://veloren.netVeloren是一款用Rust语言开发的多人立体像素角色扮演游戏。Veloren的开发受到Cube World，Minecraft和Dwarf Fortress等多款经典类似游戏的启发。这款游戏目前正在热烈和重度研发中，已经有发布版本并可以玩了。\n系统开发：\n目前游戏贡献者们的交流与沟通主要是在项目的Discord网络社区服务器上进行。想了解项目最新动态，可以加入社区走近研发人员，了解项目或者自己为项目做点贡献。任何一个认真的想投入精力的都可以加入我们的团队。不要懂得编程也可以为项目和社区做贡献。https://discord.gg/kjwJwjK\n\n有用的链接：\n\nSign Up注册用户，在这里你可以在线注册用户，用于登陆需要验证的服务器，包括Veloren官方服务器。\nBook：Veloren手册，大量关于veloren的重要资料，包括如何编译程序软件，如何分发发布等信息。\nFuture Plans，这里可以找到Veloren的开发路线和最近研发团队的主要工作。\n\n\n\n官方社交媒体和官网：\n\nWebsite\nDiscord Server\nSubreddit\n\n\n\n获得Veloren:\n\n有用的链接：\nSign Up注册用户，在这里你可以在线注册用户，用于登陆需要验证的服务器，包括Veloren官方服务器。\nBook：Veloren手册，大量关于veloren的重要资料，包括如何编译程序软件，如何分发发布等信息。\nFuture Plans，这里可以找到Veloren的开发路线和最近研发团队的主要工作。\n官方社交媒体和官网：\nWebsite\nDiscord Server\nSubreddit\n获得Veloren:官方支持64位版的Windows，Linux，MacOS版本，可以到官网下载: https://www.veloren.net由于研发更新非常快，最新发布的\"稳定版本\"并不一定兼容公开的对外服务器。如果你想自己编译Veloren可以在官方的参考书里找到相关的信息。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.veloren.net" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-22 06:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Veloren - Rust语言开发的多人版立体像素角色扮演游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新闻来源：--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-22 06:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是 www.chromium.org 上关于 chromium 内存安全的一篇博文，Chrome 工程师正在尝试 Rust。 在可预见的将来，C++ 仍然在代码库中占据主导地位，所以如果任何地方使用 Rust，都需要考虑与 C++ 相适应。这似乎提出了一些 C++/Rust 互操作性的挑战，而在这之前其他人都没有遇到过。更多详情请看：https://www.chromium.org/Home/chromium-security/memory-safety/rust-and-c-interoperability" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.chromium.org/Home/chromium-security/memory-safety/rust-and-c-interoperability" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-20 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Chrome 的 Rust 与 C++ 的互操作性" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是作者使用 Rust 在 Arduino 上实践的系列博文的第一篇，如何在 Arduino Uno 上点亮小灯💡。在撰写本文时，大约一个月前，avr-rust 分支被合并了（https://github.com/rust-lang/rust/issues/44052）。 这意味着现在可以通过仅运行cargo + nightly 构建，为目标（avr-unknown-unknown）提供一个 .cargo/config.toml 来为 avr 微控制器板编译 Rust 程序。更多请看原文：https://creativcoder.dev/rust-on-arduino-uno" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://creativcoder.dev/rust-on-arduino-uno" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-20 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust on Arduino Uno" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 的将异步代码引入语言的方法比较新颖，它没有将异步系统与语言打包在一起，例如 Golang 提供的内置 goroutine 的方法，而是提供了一个接口，供独立的库开发人员使用以实现异步给定进程的运行时。所以博文对 Futures、Tokio、async-std、smol、Actix、embrio、Bastion 这些 async 生态的库做了个总结，更多请看原文：https://runrust.miraheze.org/wiki/Async_crate_comparison#Comparison_of_Async_Ecosystems" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://runrust.miraheze.org/wiki/Async_crate_comparison#Comparison_of_Async_Ecosystems" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-20 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Async 项目比较" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "gfx-rs 是 Rust 实现的低级，跨平台图形和计算抽象库，gfx-rs 社区的目标是使 Rust 中的图形编程变得容易，快速和可靠。项目地址：https://github.com/gfx-rs/gfx" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-20 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Gfx-rs" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "stjepang 的新轮子 async-rwlock（https://github.com/stjepang/async-rwlock），异步读写锁。这种类型的锁允许在任何时间点上有多个读取器或一个写入器。示例:" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-20 22:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-rwlock" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本月8月11号，Mozilla 宣布裁员 250 人。此事件在互联网技术圈引发大量关注。大家的关注点在于， Mozilla 裁员到底对 Rust 语言及其发展会有多少影响。甚至有人传：「Mozilla 大裁员了，很多 Rust 开发被裁了 」，我真怕到明天就流传出「Mozilla 大裁员，Rust 团队被裁了」的新闻贴。。。就差这么说了：「Mozilla倒闭了，老板带着小姨子跑路了，欠下3.5个亿。我们没有办法，拿着Rust抵债。」截止到今天，也就是 8 月 19 号，Rust 核心团队也就此事在官方博客上进行了说明。那么，本文来带大家来捋一捋整个事件的过程。详情请见-公众号:https://mp.weixin.qq.com/s/36hlYYkhK7IT8uCP8iz1Yg详情请见-rust博客:https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-19 22:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「Rust核心团队官宣」为Rust的未来奠定基础" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一共九篇，作者分享了他阅读 exa 源码的一些心得，值得一看。作为Rust新手，本着学习的态度，对Rust 实现的命令行工具exa源码进行阅读分析。由于Rust经验不足，分析是基于Rust基础的语法功能以及简单用法。一些高级的用法没有涉及到，主要还是以学习为目的，了解一个Rust项目的构建流程以及模块划分。第一篇主要是介绍exa的功能以及体验效果，中间是对源码进行分析，介绍如何根据命令行参数渲染最后的结果。最后一篇，介绍exa的编译脚本以及cargo.toml文件，学习一个项目是如何进行编译配置。详情请见:https://zhuanlan.zhihu.com/c_1279213952211898368" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://zhuanlan.zhihu.com/c_1279213952211898368" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-19 22:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust exa源码阅读分析系列 文章" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章描述了如何为 Linux 流行发行版创建软件包!详情请见:https://ebbflow.io/blog/vending-linux-2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ebbflow.io/blog/vending-linux-2" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-19 22:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何为 Rust 项目创建 Linux 安装包(2/3) - 使用 Github Actions 和 Docker 进行构建" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作为我们对更安全的系统编程的持续努力的一部分,我们高兴地宣布 Clang C/C++ 编译器和 Rust 现在已经支持 Windows Control Flow Guard。\n什么是安全防护流机制?\n安全防护流在 LLVM 和 Clang 中\n安全防护流在 Rust 中\n怎样在 Rust 中启用 CFG\nCFG 的开销\n详情请见:https://msrc-blog.microsoft.com/2020/08/17/control-flow-guard-for-clang-llvm-and-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://msrc-blog.microsoft.com/2020/08/17/control-flow-guard-for-clang-llvm-and-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-19 22:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用于Clang/LLVM 和 Rust的控制流防护机制(CFG)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Mozilla和核心特队表示，要在年底之前开始基金会的第一次迭代Mozilla and the Rust Core Team are happy to announce plans to create a Rust foundation. Our goal is to have the first iteration of the foundation up and running by the end of the year.太长不看版（by Rust众群友@Ethan）Rust在各个领域各个公司有了很多应用 moz的裁员带来了很多影响0. 关于雇员。由于全世界的关注 被裁的雇员们不幸中的万幸是找下份工作的阻力由于大家的关心可能会小一点 并附了一个帮助雇员找工作的link原文：https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-18 23:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust核心团队宣布未来要成立 Rust 基金会" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "随着容器及K8s的广泛使用，越来越多的容器安全与隔离问题被暴露出来，如：容器逃逸、水平攻击、DDos攻击等严重威胁了办公和生产环境的安全与稳定，影响了业务的正常运行。安全容器技术孕育而生，产生了kata、gVisor、unikernel等多种安全容器方案。本文旨在介绍各种安全容器方案，分析各方案特点，结合腾讯在容器安全领域的实践，帮助读者选择适合自身特性的容器运行时。同时引入Rust-VMM项目，介绍 Rust-VMM 技术和生态，演示如何使用K8s调度和启用Rust-VMM安全容器运行时，展望以Rust语言实现的容器运行时的广阔前景。原文：https://mp.weixin.qq.com/s/UHZVX28rh0b12AdbRkPYiQ" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-18 23:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "基于Rust-vmm实现Kubernetes运行时" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "veloren 是一款开源的, 使用 Rust开发的多人三维像素游戏, 启发于 Cube World, Minecraft 和 Dwarf Fortress. 目前该游戏已经发布了 0.7 版本,虽然仍然在快速的开发当中,但是已经可以进行试玩.Read morehttps://veloren.net/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-17 19:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "veloren 多人三维像素游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大多数关于 WebAssembly 的教程都是关于如何在浏览器内部如何使用.但是,除此之外,还有很多场景是关于浏览器之外使用WebAssembly的.例如:这篇文章会带感兴趣的同学从头到尾开发一个浏览器之外运行的 WebAssembly 的 Rust 程序.Read morehttps://alexene.dev/2020/08/17/webassembly-without-the-browser-part-1.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-17 19:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "浏览器之外的 WebAssembly" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "kosmonaut 是一个从头开发的浏览器引擎,Rust编写.目前来说能做的事情还比较基础.仅一部分 CSS 被支持,大部分的网页应该是不能正常渲染的.https://github.com/twilco/kosmonaut" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-17 19:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "kosmonaut 从头开发的浏览器引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "LLVM IR 代码生成的越多,编译的时间越长. 这个工具可以帮你计算出每一个模板函数生成的 LLVM 中间代码的数量,从而帮助你找出可以减少编译时间的一些优化点.Read morehttps://github.com/dtolnay/cargo-llvm-lines/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-17 19:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-llvm-lines" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在最近的一次测试中，编译速度比llvm快7倍Cranelift是一个底层可重定向代码生成器。CraneliftRead Morehttps://github.com/bytecodealliance/wasmtime/tree/main/craneliftRead Morehttps://www.reddit.com/r/rust/comments/iat25g/cranelift_can_now_compile_rustc_giving_nearly_7x/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-16 23:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cranelift现在可以编译rustc，比LLVM的编译速度快7倍！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者在文中概述了Rust的unsafe关键字为何起作用，而C / C ++中的类似措施却无效的缘由。Read Morehttps://jam1.re/blog/why-rusts-unsafe-works" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-16 23:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【经验分享】Rust's Unsafe 是如何起作用的？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "将以下内容添加到settings.json文件中（假设使用的是默认主题）https://code.visualstudio.com/docs/getstarted/settings#_settings-file-locationsRead Morehttps://www.reddit.com/r/rust/comments/iak2hk/how_can_i_change_syntax_highlighting_of_rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-16 23:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【经验分享】如何在VS Code中更改rust-analyzer的语法高亮显示？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "今天排名前三的trending repos是 servo ,bevy ,libraservoRepohttps://github.com/servo/servobevyRepohttps://github.com/bevyengine/bevylibraRepohttps://github.com/libra/libra" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-16 23:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【今日热榜】Trending Rust Repos" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ffmpeg-next是一个安全的FFmpeg wrapperRead Morehttps://lib.rs/crates/ffmpeg-next" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-16 23:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ffmpeg-next 4.3.6 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "截止到今天，Rust 中每个关键字的初始文档已经完成并且内容充实，为了完整性，这些文档还包括 unsafe 以及原始类型的关键字。详细可查看这三个链接：\n标准库：https://doc.rust-lang.org/stable/std/#keywords\nunsafe 关键字：https://github.com/rust-lang/rust/pull/73943\n原始类型关键字：https://github.com/rust-lang/rust/issues/34601\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-15 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "现在 Rust Nightly 标准库文档已涵盖了每个关键字" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "还记得之前关于Rust中字符串的长文吗？这是 Amos 最新的又一篇长文，内容包括Rust的特性，生命周期等。更多参见文章，https://fasterthanli.me/articles/frustrated-its-not-you-its-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fasterthanli.me/articles/frustrated-its-not-you-its-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-15 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "学习Rust，沮丧？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "CRIU（https://www.criu.org/） 是 Linux 平台在用户空间实现检查点/还原（Checkpoint/Restore）功能的工具软件。criu-image-streamer 是用 Rust 编写的一个CLI工具，实现在检查点/恢复期间以低开销启用与CRIU之间的图像流传输，其每个子命令的图像数据流如下：\ncapture：CRIU → criu-image-streamer → shards 分片\nserve：shards 分片 → criu-image-streamer → CRIU\nextract：shards 分片 → criu-image-streamer → images-dir\nGithub链接，https://github.com/checkpoint-restore/criu-image-streamer" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/checkpoint-restore/criu-image-streamer" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-15 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust实现的CLI工具criu-image-streamer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "SongRec 是用 Rust 编写的 Linux 下的开源 Shazam 客户端。Github链接，https://github.com/marin-m/SongRechttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/marin-m/SongRec" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-15 23:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust实现的GUI应用SongRec" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者表示之前的Instancing部分写的太过繁杂，作者喜欢展示各种不同的技术导致之前该章节与之前的章节相比显得脱节，这次更新简化了该教程。教程地址：https://sotrh.github.io/learn-wgpu/beginner/tutorial7-instancing/#instancing" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://sotrh.github.io/learn-wgpu/beginner/tutorial7-instancing/#instancing" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-13 20:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Learn Wgpu 系列简化了之前Instancing的教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "群集（Bevy）引擎中的system就是普通的Rust函数，这样的设计及其符合人体工程学，就像作者本人在群集（Bevy）引擎的介绍中说的那样，目前找不到比群集引擎更符合人体工程学的ECS框架设计了。推特上有人简单分析了一下群集引擎中这部分代码的语法糖是怎么实现的，考虑到不少小伙伴并不能够随时访问推特，在这里我把大概意思搬运过来。system作为普通的Rust函数，它的参数也就代表了需要访问的那些组件的查询。群集提供的主要示例非常引人注目，系统就是函数，组件就是结构体，你不需要实现额外的trait，就能够让ECS框架正常运作。就像上面的示例一样，只要按照一定的规则写出函数，在App的构建模式中调用.system()方法就可以把函数变成系统。一个普通的Rust函数在调用.system()这个方法之后，将被转换为一个Box<dyn System>，对于群集支持的两种系统，采用IntoForEachSystem和IntoQuerySystem这两个trait进行转换。有了trait之后只需要把trait实现给我们可能会调用的函数，一个一个函数的去实现肯定是不可能的，翻看群集的这部分源码能够看到大量的使用了宏：具体的代码可以去看群集的源码，总结来说，群集实现的这种及其符合人体工程学的ECS架构，就是基于宏加上trait来实现的。宏的部分十分值得仔细研究，推特原文作者也是正在研究其中的东西，截至日报更新时还没有新的成果，后续可以直接去关注该条推特。推文链接：https://twitter.com/yaahc_/status/1293567953875505152?s=20" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://twitter.com/yaahc_/status/1293567953875505152?s=20" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-13 20:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于群集（Bevy）引擎ECS框架中system的语法糖是怎么实现的" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该文用到了plotly库，是一个可以动手实验的小教程。教程原文:https://shahinrostami.com/posts/programming/rust-notebooks/box-plots-at-the-olympics/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://shahinrostami.com/posts/programming/rust-notebooks/box-plots-at-the-olympics/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-13 20:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust写数据可视化的一个小教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "之前关注过Redox的应该知道OrbTk是他们团队给该操作系统设计的Gui库，现在这个库在crates.io发布了最新的版本，相较于之前性能更好了，也有了新的主题切换引擎可以选择。还更新了三种UI组件（ProgressBar，NumericBox，TabWidget）。Read More:https://github.com/redox-os/orbtk/releases/tag/0.3.1-alpha3" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/redox-os/orbtk/releases/tag/0.3.1-alpha3" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-13 20:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "OrbTk 0.3.1-alpha3发布了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者见过GNOME的用户（通常是在C库上工作了很长时间的人）表达以下问题：作者是那种认为大部分基础设施都应该用Rust重写的人，所以这些问题，也是作者本人非常关注的事。因此作者写了一篇关于这个问题文章。Read More:https://people.gnome.org/~federico/blog/rust-stable-abi.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://people.gnome.org/~federico/blog/rust-stable-abi.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-13 20:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "“Rust没有稳定的ABI”" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "docs.rs更新了文档覆盖功能在这个位置可以看到：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-13 20:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "docs.rs 已经更新了文档覆盖功能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个关于构建者模式的简短介绍。以及提供了三个实际项目中的用例。Read More：https://matklad.github.io/2020/08/12/who-builds-the-builder.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://matklad.github.io/2020/08/12/who-builds-the-builder.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-13 20:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于构建者模式的一个简短介绍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "每周官方都会更新的This Week in Rust又更新了。这已经是第351期了。基本上最近有关Rust的动向里面都收集了，个人一直比较关注的是Tooling类的动向吧，rust-analyzer越来越好用了。其他动向日报基本都涉及过了，这里不再提及，主要说两个，一个是每月都会更新一次的Rust GameDev，以及最近才更新的区块链相关动向。感兴趣的可以直接下面的链接到文章。Rust GameDev:https://rust-gamedev.github.io/posts/newsletter-012/Blockchain:https://rustinblockchain.org/newsletters/2020-08-05-are-we-smart-contract-yet/Read More：https://this-week-in-rust.org/blog/2020/08/11/this-week-in-rust-351/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2020/08/11/this-week-in-rust-351/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-13 20:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Process file descriptors (pidfd) 是 Linux 无竞争进程管理方式，async-pidfd 为 pidfd 提供了 Rust 支持。https://github.com/joshtriplett/async-pidfd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/joshtriplett/async-pidfd" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-12 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-pidfd: Rust版的pidfd" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nReddit 话题 ：How do Mozilla layoffs affect Rust?https://www.reddit.com/r/rust/comments/i7stjy/how_do_mozilla_layoffs_affect_rust/\nRust 视界：https://t.me/s/rust_daily_news?q=Mozilla\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-12 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Mozilla 裁员会怎样影响 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Sana是Rust的词法生成器，提供了一种简单的方法来为语言创建词法分析器。https://github.com/suhr/sana" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/suhr/sana" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-12 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Sana: 更简单的词法生成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://code.camdenreslink.com/dev/implementing-the-dot-net-profiling-api-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://code.camdenreslink.com/dev/implementing-the-dot-net-profiling-api-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-12 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "博客：Rust 实现 .NET Profiler" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://evrone.com/steve-klabnik-interview" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://evrone.com/steve-klabnik-interview" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-12 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 核心团队贡献者 teve Klabnik 访谈" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://ferrous-systems.com/blog/21st-century-embedded-tooling/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ferrous-systems.com/blog/21st-century-embedded-tooling/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-12 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "21世纪的Rust 嵌入式开发工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "独立游戏开发者卡特·安德森发布了群集引擎（Bevy引擎）。这个引擎能用于开发游戏和应用程序，它是免费的开源项目。它的架构充分地利用了Rust语言模块化、速度和开发周期短的特点，可以跨平台、三维渲染，相比竞品，它的编译时间更短，功能更丰富。本次发布引擎的文章给出了性能测试的简单报告。在迭代速度方面，群集引擎比其它项目都要快一到两倍；在世界准备方面，群集引擎超过竞争品的平均值。这要归功于群集引擎的工程设计——它将相同类型的组件内存紧压在一起，提高程序的空间局部性，从而提高处理器缓存的效率。它还使用了无锁并发的开发模式，提高并行计算的速度。文章还给出了大量的示例代码，来展示群集引擎的基本使用方法。针对传统的“实体——组件——系统”（ECS）思想，群集引擎扩展出线程本地系统、多队列、过滤器等开发模式，而且给出了更适合Rust语言的编写方式。群集引擎的开发使用了特殊的“函数系统”写法，可以在用户给定的任何函数指针上扩展函数，从而方便地包装任意函数到引擎需要的编程对象。这是通过为函数扩展函数，返回一个装箱好的结构体来实现的。文章还给出了图形界面的简单应用。在平面图形方面，绝对和相对位置、父子关系、流式排版、文字图形和可交互事件等常见的平面设计元素，都是被这个引擎兼容的。这款引擎很好地支持游戏开发常见的“精灵表单”概念。它也支持立体图形的复杂模块、平滑锯齿等等高级特性。一个非常好的功能是，这款引擎能动态重载场景，这尤其适合快速开发和需要更换材质包的场合。群集引擎还包括游戏音效等等诸多功能模块。另外，它针对快速编译也有特殊的修正。未来，它还将支持安卓、iOS、网页等等平台。“群集”的名字来自开发者对引擎发展的期望，希望未来它能吸引更多的开发者，扩展自己的社区。这款引擎已经有详细的文档，作者卡特·安德森希望更多的游戏开发者都加入到群集引擎的生态里来。https://bevyengine.org/news/introducing-bevy/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://bevyengine.org/news/introducing-bevy/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-11 16:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "“群集”引擎：数据驱动的游戏引擎和应用框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Meili SAS是2018年11月成立的初创公司，希望能开发一套搜索引擎接口，替代当前的托管式云搜索引擎竞争品。本次他们从LocalGlobe、Seedcamp、Kima & Tiny.vc几个投资机构融资150万欧元，希望能建设开源搜索引擎MeiliSearch的社区，以吸纳更多的用户和贡献者。MeiliSearch是一款高效开源的全文搜索引擎，值得一提的是，它也使用社区的汉字分词库“结巴”，对汉字词语的搜索支持有特殊的设计。与竞品Algolia等等不同的是，MeiliSearch是开源项目。为了举例子，这个引擎在官网给出了一个快速的crates.io搜索引擎，它的搜索和呈现过程加起来仅需数毫秒，几乎可以做到输入字母的同时就已经搜索完毕。这个项目最初是路易威登公司在巴黎赞助的黑客松活动诞生的。没错，就是卖时尚手包的那家路易威登公司——那次活动结束后，项目的三位作者分别获得了一个路易威登的包包作为奖品。MeiliSearch社区已经公开了后续开发的路线图。他们希望扩展更多的功能，而且能在任何地方快速搭建开发环境。这个社区也非常欢迎开发者的贡献，重视开源社区的价值。https://blog.meilisearch.com/meili-fundraise/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.meilisearch.com/meili-fundraise/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-11 16:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "初创公司Meili投入150万欧元，探究Rust语言编写的开源搜索引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "网页汇编（WebAssembly）是常见的网页编程方式，十分之九以上的浏览器都支持它。本篇文章里，作者尝试搭建只有一个网页、一两行JavaScript代码的网页应用。这样的应用应该只在一个页面里加载内容，就可以访问多个模块，而不需要页面刷新，能复用多个网页的用户交互模块，还能同时更新不同层次的用户页面。作者给了出这种前提下的设计方法，还提供一个设计好的网购网站作为例子。完成整个开发流程，需要安装Rust和它与网页汇编相关的工具链。文章挑选了Rust语言的yew项目作为开发框架，将网购的商品、购物车、交互信息等等都抽象成Rust语言的结构体和枚举类型，最终完成开发目的。每次用户交互，都会通过一个特殊的“生命圈”方法传给状态机，最终状态机将重新绘制用户界面，达到更新用户界面的目的——比如按下加入购物车的按钮，侧边栏的总价信息将会相应改变。本篇文章的开发方法中，初始化部分的信息也是由接口提供的。后端服务将访问后续的结构，得到所有的信息，通过应用程序接口和消息结构返回，如果出错也会给出错误的类型。不同的页面之间通过层次结构相互关联，但不同层次的结构共同维护一个全局状态存储空间，以给出数据同步的解决方案。在文章的例子里，所有页面共享同一个购物车内容，这是通过全局状态实现的。状态还可以提升到不同的层级，比如提高侧边栏页面的状态，我们就能在所有页面同时显示一个相同、统一的侧边栏。文章使用了yew社区提供的大量方便的抽象设计，这和Rust语言灵活的宏系统是分不开的。虽然文章给出的设计方法仍有一定提升空间，作者也在探究问题的解决方案，他希望将来这能作为流行的Vue、React等网页设计框架的替代品。http://www.sheshbabu.com/posts/rust-wasm-yew-single-page-application/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "http://www.sheshbabu.com/posts/rust-wasm-yew-single-page-application/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-11 16:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust与单页面网页应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洛佳" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust语言的异步（async）特性是非常棒的，一旦异步代码出现情况，我们可以用更好的方法处理错误，也有相应的方法完成调试、测速过程。文章详细描述了Rust异步开发里常见的几个工具，包括如何让错误提示更漂亮；还有一些异步开发常见的问题，包括相同的任务是否曾被传送到不同的线程执行。这些方法对调试Rust异步代码都是相当有帮助的。https://fasterthanli.me/articles/surviving-rust-async-interfaces" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fasterthanli.me/articles/surviving-rust-async-interfaces" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-11 16:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《异步求生》：Rust语言异步开发与调试技巧" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者都帮你整理好了:更多详细内容 Read morehttps://github.com/paulkernfeld/contiguous-data-in-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-10 18:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Rust 中存储连续数据?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "图文并茂的讲述 并且 使用 Rust 来实现一个 Bloom Filter.Read morehttps://onatm.dev/2020/08/10/let-s-implement-a-bloom-filter/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-10 18:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 实现 Bloom Filter" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "从零到生产 是一个使用 Rust 进行 Web API 开发的系列文章. 目前更新到第三章,使用 actix-web 来实现邮件订阅的 API 部分.Read morehttps://www.lpalmieri.com/posts/2020-08-09-zero-to-production-3-how-to-bootstrap-a-new-rust-web-api-from-scratch/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-10 18:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "从零到生产: 使用 Rust 进行 API开发系列" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read morehttps://beyondtheloop.dev/rust-second-language/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-10 18:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么 Rust 作为第二门语言非常棒" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "想找本书学习一下 Rust,这里有非常齐全的 Rust books, 从新手到进阶. 不过基本上都是英文哒, 英文好的同学可以参考一下.Read morehttps://github.com/sger/RustBooks" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-10 18:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust books" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "SPIR-Q 0.4.2 released. SPIR-Q 是一个轻量级的 SPIR-V reflection 库.Read morehttps://github.com/PENGUINLIONG/spirq-rs--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-10 18:03" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SPIR-Q 轻量级的SPIR-V reflection 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust1Password Linux版本，后端完全使用Rust重写，并且项目中使用了ring crypto库。使用下面的命令可以在ubuntu上安装1Password。小编已经严重依赖1Password了，前不久1Password的浏览器插件，也使用了Rust开发的was m模块进行了重构。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-09 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "1Password Linux版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "@mreimsbach在Linux玩魔兽世界时，想要一个TUI（Terminal User Interface）工具来管理插件，尽管已经有类似的项目了，可他还是用Rust重写了一个。玩了一会儿魔兽，才发现还是Rust香。Read Morehttps://github.com/MR2011/wowAddonManager" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-09 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "wowAddonManager - 管理Linux上《魔兽世界》的插件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #learn一个学习Rust的项目，通过不同的练习，学习Rust Book中提到的相关概念，从类型基础到泛型，线程都有详细的介绍Read Morehttps://egghead.io/playlists/learning-rust-by-solving-the-rustlings-exercises-a722" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-09 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "教程：Rust练习题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#securityRustLab 2019的分享的topic，众所周知Rust是一门安全的语言，似乎耳朵已经起茧子了，但开发者如何才能享受到Rust的安全呢？Rust在安全方面到了多了哪些事情？来这个视频一探究竟。关注RustLab油管频道，还有其他的精彩topic：\nMake life easier with Derive and other tools\nWriting a Nintendo 64 emulator in Rust\nSafe and Simple Rust Smart Contract in Near\n...\nRead Morehttps://m.youtube.com/watch?index=3&list=PLkgYzo_ZZ7KACuiy-AW_ClsEzGMKdkDu7&v=4Y9aK8bSJrEv" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-09 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "视频：使用Rust无惧安全问题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust微软正在内部推广Rust，包括一些service和原生的windows应用，可能还会有操作系统的一些核心组件，更多关于Rust在微软推广的文章请看。Read Morehttps://medium.com/the-innovation/how-microsoft-is-adopting-rust-e0f8816566ba" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-09 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "微软是如何使用Rust的？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "嗨，大家好！我一直在为rust的taskwarrior开发终端用户界面，我想在这里分享。您可以在发布页面上找到源代码和预编译的二进制文件。github链接https://github.com/kdheepak/taskwarrior-tui" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-08 18:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用rust制作的一个Taskwarrior终端用户界面" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一段时间以来，我一直想用Rust编写一个大项目作为学习练习，实际在2018年末开始了一个项目(FUSE服务器实现)。但后来生活发生了变化，我变得很忙，从来没有带着它去任何地方。由于某些特定的世界环境，我目前花了很多时间在室内，所以rust-fuse (docs)现在已经存在，足以编写基本的hello-world文件系统。文章链接https://john-millikin.com/first-impressions-of-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-08 18:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust的第一印象" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大多数Rust的程序员都听说过Rayon，它是一种使向程序引入并行性变得非常容易的一个包。在本文中，我们将研究如何将Rayon应用于基本流处理。要运行这篇博客文章中的示例，创建一个目录，在其中运行cargo init -—bin并编辑生成的货物。toml包含以下依赖项:示例中的代码将被转到src/main.rs。您可以使用cargo run -release来运行它。文章链接https://morestina.net/blog/1432/parallel-stream-processing-with-rayongithub链接https://github.com/rayon-rs/rayon" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-08 18:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rayon的并行流处理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Hello，与tokio和async-std相比，我试图更好地了解smol（和相关依赖包）背后的动机。更笼统地说，我想确保对当前的异步世界有足够的了解！文章链接https://www.reddit.com/r/rust/comments/i5hppj/smol_vs_tokio_vs_asyncstd/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-08 18:19" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "smol vs tokio vs async-std;" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "AWS IoT Core 提供了一种方便的方式将 ESP32 等 IoT 设备连接到云。 通常，使用 MQTT 协议。我们在使用 Rust 将那些 MQTT 消息传输到其他实际上可以对它们有用的服务,如 AWS SQS 队列，这样我们就可以实现监测楼层温度等等。详细实现请看原文：https://andres.svbtle.com/passing-messages-between-aws-iot-and-sqs-queue-using-lambdas-written-in-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-06 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 编写的 Lambdas 在 AWS IoT 和 SQS 队列之间传递消息" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在这个（第五个）Crust of Rust 视频中，我们通过重新实现标准库中的某些 std :: sync :: mpsc 类型，介绍了多产品/单消费者（mpsc）channels。 作为其中的一部分，我们将介绍 channel 的用途，它们在更高级别上的工作方式，不同的通用 channels 的变体以及通用 channels 实现。 在此过程中，我们介绍了一些常见的 Rust 并发原语，例如 Mutex 和 Condvar。YouTube地址：https://www.youtube.com/watch?v=b4mS5UPHh20" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-06 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Crust of Rust 系列视频" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "博客原文：https://blog.aclysma.com/rust-on-ios-with-sdl2/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.aclysma.com/rust-on-ios-with-sdl2/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-06 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 和 SDL2 构建一个 iOS 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "教程中，我们将用 Rust 编写高性能函数，将它们编译成 WebAssembly，并在你的 Deno 应用程序中运行它们。更多详情请看原文：https://www.secondstate.io/articles/deno-webassembly-rust-wasi/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-06 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "教程：使用 WebAssembly, Rust 和 WASI 编写 Deno 应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者在 Rust 中尝试并看到了各种 Web 应用程序前端框架。老实 说，这些框架很好，工作也做得很好。但它们也有一些缺点，比如理解 API 需要一条陡峭的曲线，随着应用程序大小的增长，代码会变得越来越复杂。基于这些原因，作者实现了 valerie 项目，一个使用 Rust 写 web 应用程序的前端框架。该框架有如下特点：\n没有虚拟DOM。\nUI可以以一种简单的方式生成，即遵循MVVM体系结构而不是MVC体系结构。\n使用状态变量在需要时更新UI。\n没有任何不安全的代码。\n目前尚处于早起开发阶段：https://github.com/emmanuelantony2000/valerie使用示例：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-06 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "valerie 项目 - 让我们在 Rust 中重新思考 Web 应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "stjepang 最近刚刚开源的新项目, Portable interface to epoll, kqueue, and wepoll。地址：https://github.com/stjepang/polling" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-06 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "polling 项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "LLVM 的速度直接影响 rustc 的速度,因为rustc使用LLVM作为后端。详情请见:https://blog.mozilla.org/nnethercote/2020/08/05/how-to-speed-up-the-rust-compiler-some-more-in-2020/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.mozilla.org/nnethercote/2020/08/05/how-to-speed-up-the-rust-compiler-some-more-in-2020/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-05 23:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何在2020年进一步加快 Rust 编译器的速度" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pgx 是用于再 rust 中的 PostgreSQL 框架,并尽可能做到安全和符合惯用的习惯。pgx支持 Postgres v10,v11 和 v12。详情请见:https://github.com/zombodb/pgx/releases/tag/v0.0.9" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/zombodb/pgx/releases/tag/v0.0.9" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-05 23:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pgx 0.0.9 版本发布了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章描述了如何为 Linux 流行发行版创建软件包!\n\n1.后台守护程序\n\n\n2.无依赖\n\n\n3.用发行版\n\n\n4.自动化构建 (下篇文章讲)\n\n1.后台守护程序2.无依赖3.用发行版4.自动化构建 (下篇文章讲)详情请见:https://ebbflow.io/blog/vending-linux-1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ebbflow.io/blog/vending-linux-1" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-05 23:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何为 Rust 项目创建 Linux 安装包(1/2)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "reddit:https://www.reddit.com/r/rust/comments/i44ahg/google_engineers_just_submitted_a_new_llvm/llvm.org:https://lists.llvm.org/pipermail/llvm-dev/2020-August/144012.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://lists.llvm.org/pipermail/llvm-dev/2020-August/144012.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-05 23:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Google工程师提交了新的LLVM优化思路，平均可提高2.33％的性能" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 与 内存泄漏学习 Rust 语言的一个很大的收获就是： 「预防大于治疗」。内存泄漏并不是 Rust 语言要解决的问题，但是 Rust 语言也不大容易发生内存泄漏。写 Rust 代码如何避免内存泄漏呢？ 两点：如何做好预防：及早发现：一旦如果发生了泄露，那就只能借助日常性能检测工具发现问题了，但是在这之前你可以先检查下刚提到的样板化检查区域的代码，再用一些性能测试工具逐步收集信息，缩小范围，逐渐排查。检测工具推荐：Valgrind、gperftools、ltrace、rr、gdb回放线上流量，对流量做二分找到有内存泄漏的部分请求，加压重放加速问题显露，然后二分注释代码找最小的泄露区域人肉排查。（此条经验  via DCjanus）" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-04 23:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "预防优于治疗 — 来自张汉东老师对于内存泄漏问题的观点" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者写了一个 CLI, 用 go 和 rust 各自写了一遍, 还附带总结.：https://cuchi.me/posts/go-vs-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-04 23:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Go VS Rust — 一个cli 写两遍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "《Rust唠嗑室》第6期 - Rust FFI 经验介绍主讲人：Mono Wang内容：主要介绍 Rust FFI 进阶使用技巧和实现要点。以及踩过的坑。以及还没解决的内存泄漏。时间: 2020/8/4 20:30-21:30形式: 在线 腾讯会议App大家错过了不要紧，敬请关注Mike Tang 老师在 B站 的唠嗑视频更新哈" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-04 23:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 唠嗑第六期： Rust FFI" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "小编周末的时候重梳理了一下去年对异步书的翻译，病重新更新翻译到最新的版本，请各位读者大人多多指教，欢迎 issue 和 PR翻译文档链接： https://huangjj27.github.io/async-book/index.html仓库链接：https://github.com/huangjj27/async-book" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-04 23:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【小编私货】Rust异步书翻译更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一篇对 Rust 新手非常友好的 error handling 指南. 从基本的小例子开始,循序渐进,由浅入深地引导出 Rust 中是如何处理错误的.新手的错误处理指南http://www.sheshbabu.com/posts/rust-error-handling/如果读完还有疑问, 还可以结合另外一篇 Rust 2020 错误处理.https://nick.groenen.me/posts/rust-error-handling/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-03 20:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust新手的错误处理指南" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 的一项核心特性就是 内存安全. 这篇文章清晰的告诉你 Rust 在内存安全方面能够做什么, 也同时提醒我们哪些地方是 Rust 做不到的而需要我们自己来注意的.reddit 观众高度评价: 最近读到的最好的分析之一.Read morehttps://tiemoko.com/blog/blue-team-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-03 20:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "What is \"Memory Safety\", really?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "gurk-rs 是一个使用 Rust 编写的 Signal Messenger  命令行客户端. 可以体验一下命令行下聊天的快乐.https://signal.org/Read morehttps://github.com/boxdot/gurk-rs--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-03 20:36" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 写的 Signal Messenger 命令行客户端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在带有SiFive FE310 RISC-V微控制器的HiFive1板上学习嵌入式Rusthttps://www.sifive.com/boards/hifive1RISC-V Rust快速启动项目：Repohttps://github.com/riscv-rust/riscv-rust-quickstartRead Morehttps://k155la3.blog/posts/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-02 22:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "通过构建RISC-V驱动的机器人来学习嵌入式Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "teloxide 是一个功能齐全的，用来创建 tg-bot 的框架。Repohttps://github.com/teloxide/teloxideRead More%5Bdocs.rs/teloxide/%5D(https://docs.rs/teloxide/)" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-02 22:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "teloxide：一个优雅的Telegram bot框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "了解更多有关 Webference Rusty Days 2020 的信息Is it safe to use unsafe?Is Rust ready for mainstream usage in backend development?Leveraging Rust to build cross-platform mobile librariesetc, YouTubeRead Morehttps://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-02 22:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rusty Days 2020 演讲录播" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Lanpeng" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一篇来自【思否社区 SF】的帖子，适合初学者学习。Read Morehttps://segmentfault.com/a/1190000023464786" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-02 22:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust+VS Code+WSL2+LLDB 安装/配置/调试指南" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Headcrab 项目的目标是为 Rust 提供一个新的模块化且可组合的调试器库。从 Delve 和 MDB 等项目中汲取了灵感，大约3周前开始的一个新项目，在不到4周的时间里，已经看到了令人激动的进步！详情可看项目的7月份进度报告，链接，https://headcrab-rs.github.io/2020/07/31/july-update.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://headcrab-rs.github.io/2020/07/31/july-update.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-01 19:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 调试器库 Headcrab 7月进度报告" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Shell 是每个程序员的必备工具，对其越熟悉效率就越高。一些用 Rust 实现的命令行工具，旨在为现有的 shell 命令提供现代的，通常也更快的替代方案。\nbat 是具有语法高亮和集成Git的新型cat，可在 Windows，MacOS 和 Linux 上使用。\nfd是一种快速而用户友好的新型find。按名称查找特定文件，fd PATTERN而不是find -iname 'PATTERN'。默认情况下忽略隐藏目录.gitignore等。\n。。。\nnushell 是个基于Unix原理的，Rust 实现的一种新型 shell。\n更多参见文章，https://zaiste.net/posts/shell-commands-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://zaiste.net/posts/shell-commands-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-01 19:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用 Rust 重写的一系列命令行工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Alacritty 是一款跨平台，GPU加速的终端仿真器，非常注重简单性和性能，当前支持的平台有：macOS，Linux，BSD和Windows。v0.5 新增功能：\nmacOS上默认Command + N键盘绑定SpawnNewInstance\n用于正则表达式搜索，复制文本和打开链接的 vi 模式\n。。。\nGithub链接，https://github.com/alacritty/alacritty" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/alacritty/alacritty" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-01 19:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Alacritty 发布 v0.5" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在The Virtual World播客中，Rust 核心组成员 Steve Klabnik 聊 Rust 语言及生态现状。播客链接，https://anchor.fm/the-virtual-world/episodes/Ep-6--The-State-of-Rust-with-Steve-Klabnik-ehf8mkhttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://anchor.fm/the-virtual-world/episodes/Ep-6--The-State-of-Rust-with-Steve-Klabnik-ehf8mk" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-08-01 19:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【播客】Steve Klabnik 聊 Rust 语言及生态现状" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "上次1.45稳定版发布后没多久有人在github爆出了一个似乎动摇到Rust根基的bug（可变借用失效），后来发现主要原因是之前一个重构和整理const propagator的PR引入的问题（具体见Rust Stable 1.45 中的 神奇 Bug 解读），官方博客提到在发布release版之前进行的crater测试（crater测试会用即将发布的版本把crates.io所有的crate全部跑一遍，预计花费4到7天的时间）都没有检测到这个bug，说明在正常状态下几乎不太会触发到这个bug，因为它的条件必须满足如下两条：https://mp.weixin.qq.com/s/Qr3x-NbhOTlUtYyzlPQ4iQ\n可变借用的值必须是常量\n可变借用到使用该可变借用之间的代码不能包含任何控制流和函数调用\n所以1.45.1版就是为了解决这个问题。然而今天又报了一个新的bug，估计会再发布一个1.45.2，详情见PR 74954。https://github.com/rust-lang/rust/issues/74954链接：https://blog.rust-lang.org/2020/07/30/Rust-1.45.1.html1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2020/07/30/Rust-1.45.1.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-31 12:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.45.1发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本RFC 宣布Rust 2021版本的计划，此后每3年定期发布一次版本。无论是否有重大更改，Rust 官方都将推出一个Edition 版本。与Rust 2018不同，将避免使用 Edition 作为将高优先级项目联系在一起的“deadline”。取而代之的是，我们接受了“火车模型（train model）”，但是Edition实际上是“更大的发行版”，使我们有机会概述过去三年中进行的所有工作。为Edition lint 指定节奏。\nEdition N 的“ Edition idiom” lint 将警告N之前的Edition，并在Edition N中默认为“ Deny ”。\n由于现在为Rust 2018引入默认deny lint 将具有破坏性，因此将Rust 2018 lint 重新用于Rust 2021 Edition lint中。\n指定了一项有关保留关键字和其他预期更改的政策。简而言之，保留关键字仅允许作为活跃项目组（active project group）的一部分。链接：https://github.com/rust-lang/rfcs/pull/2966" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-lang/rfcs/pull/2966" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-31 12:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RFC 2966已提交: 2021 Edition 及以后的 Edition 计划" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "无船同志2019年7月份写了一篇博客最近好像又被人翻出来了，这篇博客是关于Smaller Rust的思考。许多人在接触过甚至写过rust之后对这门语言仅仅停留在有好感却远远没达到特别热爱这种程度，他们或多或少会有这种感觉：Rust作为一门系统级的语言确实很多优点，但是代价是其语言复杂性和学习曲线。所以或许我们需要一门Rust的简化版语言（Smaller Rust）：这门语言在尽可能遵循Rust的核心理念的前提下，让语言特性更少更简单，同时不追求那么高的性能，更易于使用等。无船同志也赞同这个观点，所以他这篇博客就是主要探讨如果是他设计这门Smaller Rust语言，他该怎么取舍和权衡。推荐一读！链接：https://without.boats/blog/notes-on-a-smaller-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://without.boats/blog/notes-on-a-smaller-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-31 12:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "无船同志关于Smaller Rust的思考" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust的Vec在使用索引的时候总会触发边界检查，在某些时候降低了程序的性能。通常解决方法是尽可能使用迭代器来处理数组。本文通过Ghosts of Departed Proofs这篇论文中讨论的技术来减少Rust中冗余边界检查。https://kataskeue.com/gdp.pdf具体内容https://github.com/Torrencem/fixed_vec/blob/master/post.md在文末有提到了性能差距，如果只想看看效果如何的，可以直接跳到文末代码示例Github仓库https://github.com/Torrencem/fixed_vec" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "fixed_vec一个减少数组冗余边界检查的库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "主要是移除了libgcc.so  的依赖，换成了纯 Rust 的gimlihttps://github.com/rust-lang/rust/pull/74682https://github.com/gimli-rs/gimli消息来自 Google 工程师Benjamin的推：https://twitter.com/Brittain_Ben/status/1288193388588740615" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 标准库准备从 libbacktrace 迁移到 gimli" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个很大的进步，意味着Rust的借用检查器可以在web里大展拳脚了。Read Morehttps://hacks.mozilla.org/2020/07/firefox-79/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Firefox 79现在支持WebAssembly线程和引用类型！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "视频内容大概有actix、rocket等一系列web线管的实战视频，挺有意思的。油管博主主页：Genus-v Programminghttps://www.youtube.com/channel/UCSkHbGjrjJmuAbDPhIQ5T0AB站有人搬运：Rust web框架教程https://www.bilibili.com/video/BV1sD4y1S7QL?p=1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在油管发现一个专门更新Rust实战相关视频的博主" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在github该仓库页面有地图编辑器的使用示例Amethyst是rust编写的游戏引擎，最近一年的更新动静较小，主要是集中力量完成了对wasm的支持。在一月份对wasm支持之后开始有了点动静。Github仓库https://github.com/amethyst/voxel-mapper" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Amethyst更新了一个地图编辑器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "图形后端用的是wgpu目前正在积极开发中主页http://c-obrien.org/richter/Github仓库https://github.com/cormac-obrien/richter" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Richter雷神之锤游戏的Rust实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Deno现在使用SWC（一个Rust写的TS/JS编译器），类型剥离的性能从之前的大约1s变成了现在的大约70msRead Morehttps://github.com/denoland/deno/issues/5432#issuecomment-665591700" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Deno最近更新了typescript使用的编译器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章分为两部分，第二部分还没有发出来Read Morehttps://ebbflow.io/blog/vending-linux-1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为Linux系统打包Rust项目" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "hawk 是Knoldus公司的一个 Rust 应用案例，它是一个物联网安全门禁系统。基于Rust、S3、Rekognition、Lambda等服务实现，这些都是亚马逊提供的云服务。整个项目的逻辑是这样的：门禁卡那有个树莓派，给雇员拍一张照片，然后雇员的RFID 卡扫描以后，会触发树莓派里的照片上传到S3，然后通过lambda根据雇员id，去另一个S3里调用员工的照片，然后用 第三方图片识别服务，把树莓派拍摄的照片和S3里存储的照片进行相似性比对，返回一个分数，返回到树莓派上面，这个值大于一定值就开门。项目的源码不是很多，可以学习下。Read Morehttps://www.knoldus.com/work/case-studies/hawk-rust-iotGithub仓库https://github.com/knoldus/hawk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "hawk： Rust 在物联网领域的一个学习案例" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "活动地址https://rusty-days.org/agenda/部分录播地址the rust borrow checker 大概在2:24左右开始https://www.youtube.com/playlist?list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ这两天刚举办的rusty days线上 Rust 大会，steve 讲了一个Topic，需要有2021-edition吗？ 这里做一些关键点梳理：里面提到 Edition 的作用范围： 允许增加新的关键字，改进语法，但不允许去对语言一致性、标准库等进行根本性破坏。回顾编译器的编译过程：a. rustc 是多道编译器，从源码到 AST -> HIR(大部分检查、类型检查、方法查找) -> MIR（借用检查） -> LLVM IRb. rustc 是 基于查询 (query-based) 的编译器对于 编译器来说，所有 Edition 的代码，在 MIR 层面都不允许存在差异，即， MIR 是多个Edition的通用语言。对于 人类开发者来说，Edition 之间会有差异，但不会太多。生态系统也不会搞的像主版本变化那样分裂。Rust 的发布周期是比较固定的，Nightly是每晚，beta和stable是每六周发布一版。但是 Edition现在还没有确定。那什么时候用 Edition呢?回顾过去的Rust 2018，可以说是即成功又不成功。成功是说，Rust 团队达成了既定目标，并且完成了一个艰巨的任务。不成功的地方在于，发布的东西其实并不是计划的全部，并且团队成员长期工作带来了巨大的疲劳和怠倦。Rust 团队想做的太多，但是他们低估了投入成本。不过，steve表示， 我们应该有一个 Rust 2021 Edition。但它应该比Rust 2018更小的版本，小版本优点会大于缺点。并且在未来保持一个「发行列车」，即便三年内没有什么大的特性，也会坚持发布一个Edition。对于不使用 Rust 的人，不应该来频繁地关注Rust Edtion的发布信息，他们只需要知道 Rust 已经很稳定就够了！ 对于使用Rust的人来说，每三年的 Edition，其实就是一个 「总结」。2021 edition 应该有什么特性呢？steve表示其实他并不在意，不必要非得刻意规定什么特性来证明Edition的合理性，哪怕有一个特性错过了发布，那么三年后发布就可以了。但是，Rust 官方会在 10月份以后发布一个 RFC 的，目前主要是 Niko 和 Steve 在做这个，当然，Niko 还是主力担当。为什么是三年呢？一年一次有点过，五年一次太长，三年节奏刚刚好，这一点 c++ 已经证明了。视频地址注意这个视频是 33 分钟以后才开始的https://www.youtube.com/watch?v=XFhrb-qLX_8&list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ&index=2&t=0s" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rusty days活动" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "分享者：Nell Shamrell-Harrington ，Mozilla员工该Topic议程分为两部分： Rust编译器概述 和 深入借用检查器介绍了编译阶段：词法、解析、语义分析、优化、代码生成Token -> AST -> HIR -> MIR -> LLVM IR在 AST 阶段主要做的工作：宏展开、去糖、处理各种模块导入HIR的数据结构：  Crate(CrateNum) < Definition(DeId) < Node (HirId) >  >MIR 的数据结构： Control Flow Graph < bb0(statement -> statement -> terminator ) -> bb1(statement -> terminator ) -> bb2 ((statement > terminator )...  >详细内容可以参阅： https://rustc-dev-guide.rust-lang.org/优化主要在 MIR 和 LLVM IR 阶段完成，最终由 LLVM IR 通过 LLVM 生成机器码。深入借用检查：借用检查器的工作：（看完后发现，好像也没有很深入）视频地址注意这个Topic 在 2小时以后https://www.youtube.com/watch?v=XFhrb-qLX_8&list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ&index=2&t=0s" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "首届 Rusty Day 线上大会散记： 深入借用检查器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "从代码看上去似乎是通过函数空指针调用了函数代码Playgroundhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=5ecc01ed5c00f707a9d2d53224db6c9a作者本人对这部分代码能够正常运行感到疑惑，特别是为什么foo函数能够被caller<F>()函数里强制转化成nullptr调用。已经有大神对这个问题做出了解释，太长了我直接贴地址。中文社区的大佬如果对这个问题感兴趣，可以帮忙在这里回复一下。可能有小伙伴访问StackOverflow比较缓慢，这里我复制高赞回复的原文：This program never actually constructs a function pointer to anything but caller- it always invokes foo and those two closures directly.Every Rust function, whether it's a closure or a fn item, has a unique, anonymous type. This type implements the Fn/FnMut/FnOnce traits, as appropriate. The anonymous type of a fn item is zero-sized, just like the type of a closure with no captures.Thus, the expression create(foo) instantiates create's parameter F with foo's type- this is not the function pointer type fn(), but an anonymous, zero-sized type just for foo. In error messages, rustc calls this type fn() {foo}, as you can see this error message.Inside create::<fn() {foo}> (using the name from the error message), the expression caller::<F> as fn() constructs a function pointer to caller::<fn() {foo}>. Invoking this function pointer is the same as calling caller::<F>() directly, and this is also the only function pointer in the whole program.Finally, in caller::<fn() {foo}> the expression closure() desugars to FnMut::call_mut(closure). Because closure has type &mut F where F is just the zero-sized type fn() {foo}, the 0 value of closure itself is simply never used(注释1), and the program calls foo directly.The same logic applies to the closure || println!(\"Okay...\"), which like foo has an anonymous zero-sized type, this time called something like closure@src/main.rs:2:14: 2:36.The second closure is not so lucky- its type is not zero-sized, because it must contain a reference to the variable val. This time, FnMut::call_mut(closure) actually needs to dereference closure to do its job. So it crashes(注释2)https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=2c3" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-30 21:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Stackoverflow里有人探索Rust中的函数指针魔法，写出了一个奇怪的东西" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个教程叫你如何用 rocket.rs 和 diesel.rs 构建一个CRUD程序，其中用 rocket.rs 作为 web 服务器，用 diesel.rs 作为 PostgreSQL 的 ORM 。https://medium.com/@luis_50157/a-simple-crud-on-rust-with-rocket-rs-and-diesel-rs-e885672cb23d" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://medium.com/@luis_50157/a-simple-crud-on-rust-with-rocket-rs-and-diesel-rs-e885672cb23d" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-29 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "教程：用Rust创建一个简单的CRUD" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用 Rust 写的甜甜圈程序https://www.a1k0n.net/2011/07/20/donut-math.html源码：https://gist.github.com/Daniihh/cb550f402a6f4b80de8cf53184ea5625" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gist.github.com/Daniihh/cb550f402a6f4b80de8cf53184ea5625" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-29 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 甜甜圈" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大多数Rust程序员应该都听过Rayon，一个可以轻松将 并行应用到程序当中的 crate。这篇文章中，作者将会介绍如何用Rayon处理一些基本的流https://morestina.net/blog/1432/parallel-stream-processing-with-rayon" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://morestina.net/blog/1432/parallel-stream-processing-with-rayon" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-29 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "博客：用 Rayon 处理并行流" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://gitlab.com/news-flash/news_flash_gtk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gitlab.com/news-flash/news_flash_gtk" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-29 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "NewsFlash: Rust 构建的 RSS 阅读器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://pnevyk.github.io/posts/query-system-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://pnevyk.github.io/posts/query-system-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-29 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "博客：用 Rust 写一个简单的查询系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://www.redox-os.org/news/public-announcement-gdb/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.redox-os.org/news/public-announcement-gdb/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-29 18:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用 GDB 在 Redox 操作系统上调试程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在可以在命令行下浏览StackOverflow了！通过Cargo安装：快来试试吧！Read morehttps://github.com/samtay/so" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-28 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SO：在命令行下浏览StackOverflow" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "官方宣布：现在可以在Redox OS上使用GDB调试了！在过去的几个星期，作者通过GDB调试了他们的动态链接器(ld.so)并找到了不少共享库的问题。Read morehttps://www.redox-os.org/news/public-announcement-gdb/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-28 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "现在可以在Redox OS上用GDB调试了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章教你如何用Rust从头写一个文件系统。https://blog.carlosgaldino.com/writing-a-file-system-from-scratch-in-rust.html文章中介绍了文件系统中用到的概念，以及在实现自己的文件系统的过程中这些概念是如何运用的。代码看这里：carlosgaldino/gotenksfshttps://github.com/carlosgaldino/gotenksfs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-28 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust从头写一个文件系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust Days 2020的录播。2018年，Rust引进了\"edition\"系统。这让Rust能够以一种可选的、不影响开源生态的方式做出不兼容的改动。而Rust 2018 edition是在2015年Rust最初发布的三年后出现的，所以就有人好奇在2021年我们会有一个新edition吗？Read morehttps://www.youtube.com/watch?v=7LynNMrS8Z0&list=PLf3u8NhoEikhTC5radGrmmqdkOK-xMDoZ&index=3&t=0s" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-28 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rusty Days 2020 - Steve Klabnik: 我们会有一个Rust 2021 edition吗?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": ".rs的域名太贵，于是作者自己买了一个cli.rs域名，并免费帮 Rust 社区的人提供二级域名。只需要按项目内的说明进行操作，然后给他发 PR 即可。Read morehttps://github.com/zackify/cli.rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-28 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "{something}.cli.rs 免费为Rust社区提供二级域名" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "whfuyn" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "手把手带你构建一个Redis的客户端和服务端来学习Tokio。Read morehttps://tokio.rs/tokio/tutorial" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-28 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio官方新教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n2020.07.27\nRust crates 私有化部署指南\nasync-fs 异步版本的 std::fs, stjepang 出品\nRust 中的 Data Oriented Design 介绍\nRusty  Days | 首届网络 Rust Conf 即将开幕\nRust语言CUDA device编译时检查\nRust CI迁移到Github Action\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-27 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【Rust日报】2020.07.27 async-fs，tch-rs, Data Oriented Design, Rust CI" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "想在公司内部大范围推广 rust, 必然会遇到依赖私有 crate的情况. 这边文章会告诉你如何使用 Alexandrie 来搭建你的私有 registry.https://hirevo.github.io/alexandrie/introduction.htmlRead morehttps://zhuanlan.zhihu.com/p/163940004" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-27 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust crates 私有化部署指南" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "stjepang 大神的又一个基础库,新鲜出炉. 和 std::fs几乎一样的 API和性能. 而且不依赖smol, 主要依赖 blocking.在和 tokio的简单对比下(创建一个文件写入并且读回).\nasync-fs - 1.26 sec  code\ntokio - 2.67 sec  code\nGithub 以及 Reddit 上的更多有意思的讨论https://github.com/stjepang/async-fs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-27 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-fs 异步版本的 std::fs, stjepang 出品" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Data-oriented design 是通过仔细的考虑数据结构在内存中的布局, 自动向量化影响 以及 CPU 缓存的使用等方式来优化程序的一种方法. 注意不要和 Data-driven Desgin混淆哦. 更多见 wikipedia 解释https://en.wikipedia.org/wiki/Data-oriented_design本文通过下面 4 个例子,并且使用 criterion来进行性能测试, 来阐述 一些 Rust 中的 Data-oriented design 概念.\nStruct of arrays vs. array of structs\n在一个 loop 中做分支选择的代价\nLinked List vs. Vector iteration\n动态分发(dynamic dispatch)的代价 vs. 单太化( monomorphisation )\nRead morehttp://jamesmcm.github.io/blog/2020/07/25/intro-dod/#en" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-27 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中的 Data Oriented Design 介绍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Compile time CUDA device checking in Rusthttps://m-decoster.github.io/2020/07/24/compile-time-cuda/Rust语言CUDA device编译时检查。Rust稳定版马上就可以使用const generics了，对有些特定的BUG这可以节省大量的编译时间。这样的BUG有类似PyTorch用来操作CUDA devices数据的时候就会常常出现，这里我们用tch-rs libtorch的Rust语言绑定来看看。libtorch的rust语言绑定tch-rs类似PyTorch但是是用Rust语言来完成的。https://github.com/LaurentMazare/tch-rsRead morehttps://m-decoster.github.io/2020/07/24/compile-time-cuda/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://m-decoster.github.io/2020/07/24/compile-time-cuda/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-27 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust语言CUDA device编译时检查" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust's CI is moving to GitHub Actionshttps://blog.rust-lang.org/inside-rust/2020/07/23/rust-ci-is-moving-to-github-actions.htmlRust基础设施团队宣布Rust的CI（Continue Integration)已经迁移到了Github Action上了。长期以来，Compiler研发最头疼的就是对各种PRs的Merge合并工作。为了保证Master Branch全面安全飘绿，Rust团队研发采取的是从PR队列中一个一个PR测试并审核通过。Rust的CI是很广泛的，57台服务器同时开动编译和测试，涵盖各个Rust支持的不同的操作系统。迁移前的环境一个Build至少需要3-4个小时才能Build编译完成。这样测试集成一个PR需要至少一天的时间。Read morehttps://blog.rust-lang.org/inside-rust/2020/07/23/rust-ci-is-moving-to-github-actions.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/inside-rust/2020/07/23/rust-ci-is-moving-to-github-actions.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-27 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust CI迁移到Github Action" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "日期 7.27 - 8.2此次大会还有个在线Hackathon活动详情： https://rusty-days.org/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-27 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rusty  Days | 首届网络 Rust Conf 即将开幕" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "qwy16" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2020-07-27 20:56" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } },]
