export const propertiesForNewPages = [{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是 2021 年 12 月底发布的最新论文，主要比较了四种浏览器架构，同时指出近十年来浏览器中内存安全问题依然是主流。但是观察 Firefox 通过 Oxidation 项目（Rust）替换了 12% 的组件。自2015年以来，Firefox的内存安全漏洞数量出现了小幅但稳定的下降，其中，渲染器的内存安全漏洞明显下降。这算是看到 Rust 内存安全的初步成果了吧？论文里建议浏览器供应商遵循这一最佳实践，并逐步将他们的浏览器转向内存安全的语言。详情请看：https://arxiv.org/abs/2112.15561"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://arxiv.org/abs/2112.15561"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-13 00:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Web 浏览器安全分析"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Apache NuttX 是一种嵌入式操作系统【ps：一个实时嵌入式操作系统 RTOS】，可在许多平台（如：8 位到 64 位平台）上移植，并且像 Linux 的小型版本一样工作（因为它符合 POSIX 标准）。现在，我们可以在 NuttX 上使用 Rust 创建更安全的嵌入式应用程序，也可以定制自己的驱动程序。详细资料请看：https://lupyuen.github.io/articles/rust2"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://lupyuen.github.io/articles/rust2"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-13 00:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 与 NuttX 操作系统"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Quickwit 0.2 版本发布，将支持 ClickHouse 和 Kafka 的全文搜索，同时新版本主要介绍以下功能：\n准确一次性提取 Kafka 原生数据\n搜索流 API\nPostgreSQL 元存储\n标签修剪\n适当的索引管道\n更多请看原文：https://quickwit.io/blog/quickwit-0.2/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://quickwit.io/blog/quickwit-0.2/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-13 00:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Quickwit 0.2 版本发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个快速、forbid(unsafe_code)、无依赖、异步执行器。目前是一个实验性质的项目，不过观察下来，执行器与其他执行器相比表现出奇的好，同时作者在努力优化它并为tokio提供一个插入式 API。项目地址：https://github.com/kprotty/uasync/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/kprotty/uasync/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-13 00:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"uAsync 异步运行时"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"整合了另一个版本的 grpc 压测，在原来基础上做了调整，结果直接戳：https://www.reddit.com/r/grpc/comments/s22jh2/20220111_grpc_benchmark_results/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/grpc/comments/s22jh2/20220111_grpc_benchmark_results/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-13 00:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"gRPC 压测实验结果"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 度过了美好的一年。从用户数量、领域多样性、用户承诺、用户规模等方面来看，Rust 现在拥有非常稳固的用户基础。Rust 还拥有大量慷慨的赞助商，无论是通过基金会还是通过公司支付民间费用。社区大多是健康的。在技​​术方面，Rust 语言、库和工具现在都非常可靠，2021版也顺利发布。2022 年的 Rust，需要关注些什么呢？2022 年，要解决的重要问题是项目领导问题和组织债务，并重新关注 Rust 的成熟度。同时，需要继续做下面这些正确的事：原文链接：https://www.ncameron.org/blog/rust-in-2022-2/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-11 10:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rust in 2022"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"有的人可能知道，jynelson 在成为 rustdoc 团队成员的 2 年后（后来成为联合负责人），最近辞去了该团队的领导职务。他在 rustdoc、docs.rs 和 rustc dev-guide 上的工作（通常是吃力不讨好的）有助于使 rust 成为一种令人惊叹的语言，可以为每个人编写和阅读文档。出于这个原因，我想花几分钟来强调一些我们有时认为理所当然的重大变化。毫无疑问，最显而易见的功能改进是文档内链接。这允许您像路径导入一样（例如 [Foo](foo::Foo)）编写指向其他位置的链接，轻松无压力。这个概念已经进行了很长时间，但它曾经从根本上被破坏并且在多个方面无法使用。在超过 54 个 PR 中，文档内链接从一个破碎的概念变成了编写 Rust 文档的基本特征。像所有组成 rust 治理的优秀团队成员一样，Joshua 也一直站在 FCP、PR、问题、RFC 等的前沿。在后台进行的这项繁琐的工作有助于使 rust 成为一种很棒的语言，然而无聊而且常常吃力不讨好。还有无数的内部修复，以使 rustdoc 更少错误、更快、更清洁等。或者他在 docs.rs 和 rustc 开发指南上的工作。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-11 10:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"感谢 Joshua Nelson 为 rustdoc 所做的工作"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本教程是关于 Nom 的，它是我最喜欢的Rust解析库。它使用解析器组合子方法:开始编写匹配单个数字或字符的小型解析器。这些将成为更大的解析器的构建块，用于匹配，比如日期或电话号码。通过将许多小型解析器组合在一起，您可以构建一个大型解析器，将文件或流解码为漂亮的Rust结构和枚举。在本教程中，我们将使用Nom解析输入文件到一个Advent of Code的谜题。原文链接https://blog.adamchalmers.com/nom-chars/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-10 20:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Nom 解析文本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"出于好奇，作者最近开始关注Bevy的开发，Bevy是一个用Rust编写的游戏引擎。今天作者想谈谈Bevy如何使用Rust特性让用户非常方便地为元素添加标签。注意: 这里的实现实际上是非常通用的, 您可以很容易地将其应用到任何其他Rust项目原文链接https://deterministic.space/bevy-labels.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-10 20:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Bevy是如何使用 Rust traits 来添加标签的"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是一个 Serde Playground, 上面可以快速验证自己的序列化结果.原文链接https://hkalbasi.github.io/serde-rs.github.io/playground.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-10 20:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Serde Playground"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rexie 是一个易于使用的、基于特性的的 IndexedDB 包装器，可以编译成 webassembly。github 地址https://github.com/devashishdxt/rexie"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-10 20:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rexie: IndexedDB wrapper"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"让 cargo 编译和运行 iOS 的 apps.例如, 只要很小的改动,就可以使用 xcodebuild 来运行 bevy/miniquad/wgpu/etc..运行步骤:\n启动一个模拟器\ncargo xcodebuild run\n--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-10 20:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo-xcodebuild: 编译和运行 iOS 的 apps."},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\n使用 Cow<str> 作为返回类型\n使用 Crossbeam channels 取代标准库\n使用 Scopeguard 实现类似 Golang 的延迟运算\n使用 Cargo-make 打包\n自定义和链接 Panic 处理程序\n在 VSCode 中使用 Rust Analyzer\n用到闭包时使用 impl Trait\n在保存时为 VSCode 启用 Clippy\n使用 thiserror 和 anyhow 处理惯用错误\n使用 dbg!() 替换 println!()\n使用 include_str!() 和 include_bytes!() 宏在编译时读取文件\n使用 cc crate 与 C/C++ 代码交互\n链接：https://federicoterzi.com/blog/12-rust-tips-and-tricks-you-might-not-know-yet/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-09 22:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"12个Rust的Tips"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"又又又一个 Rust 教程：对 Rust 语言进行全面且深入的讲解，辅以生动的示例和习题。教程地址：https://course.rs/GitHub：https://github.com/sunface/rust-course"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-09 22:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust语言圣经"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"通过基于 arena 的 scapegoat tree（内存高效、自平衡二叉搜索树）实现的有序集合和映射数据结构。\n嵌入式友好：默认 #![no_std]\n安全：#![forbid(unsafe_code)]，包含所有依赖\n针对标准库的 BTreeSet 和 BTreeMap，通过差分模糊验证\n两个 API：\n有序 Set SgSet，BTreeSet 的子集\n有序 Map SgMap，BTreeMap 的子集\n分享 Slide：https://tiemoko.com/slides/SafeAndPortableDataStructureDesign_CodeAndSupply_Dec2021.pdfGitHub：https://github.com/tnballo/scapegoat"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-09 22:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"scapegoat"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"RedisJSON 是一个 Redis 模块，实现了 ECMA-404 JSON 数据交换标准作为原生数据类型。它允许从 Redis 键（文档）存储、更新和获取 JSON 值。主要特点：\n完全支持 JSON 标准\n在文档中选择元素使用类似 JSONPath 的语法\n文档存储为树结构中的二进制数据，允许快速访问子元素\n所有 JSON 值类型支持类型化原子操作\n基于 RediSearch 的二级索引支持\n文档：https://oss.redis.com/redisjson/GitHub：https://github.com/RedisJSON/RedisJSON"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-09 22:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RedisJSON"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"又一个并行处理库，适用于在一个已有的 iterator 中加入多线程处理；如果有许多已经存储在 collection 的值，想要执行大量计算，最好使用 rayon。博客：https://dpc.pw/adding-parallelism-to-your-rust-iteratorsGitHub：https://github.com/dpc/pariter"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-09 22:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"dpc_pariter"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我刚刚发布了OctaSine的0.6.0版本，这是我的免费和开源调频合成器VST2插件。以前的版本有两个问题需要解决。一个是小型音频缓冲区处理不当，还有一个是笔记与样本的时间安排不正确。因为修复这些问题意味着改变音频输出，所以我决定在同一版本中也做其他影响声音生成的更改和修复。Github 链接，https://github.com/greatest-ape/OctaSine文章链接，https://www.reddit.com/r/rust/comments/rza76q/octasine_060_released_with_major_bug_fixes_and/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/rza76q/octasine_060_released_with_major_bug_fixes_and/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-09 07:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"OctaSine 0.6.0 发布：修复了主要的bug和一些其他变化"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"欢迎收看新一期的“This Month in Rust OSDev”。在这些帖子中，我们定期概述Rust操作系统开发生态系统中的显著变化。本系列是在GitHub上公开开发的。请随意打开PR，包含您希望在下一期中看到的内容。如果您在本页发现一些问题，请通过创建issue或使用本页底部的评论表单来报告。在本节中，我们将概述rust-osdev组织下的项目的显著变化。x86_64crate为x86_64系统提供了各种抽象，包括CPU指令的包装、对处理器特定寄存器的访问以及特定于体系结构的结构（如页表和描述符表）的抽象类型。我们在十二月合并了以下变更：\n修复build错误在最新的nightly版本\n删除const_assert !替换为std的assert!\n...\nGithub 链接，https://github.com/rust-osdev/homepage/文章链接，https://rust-osdev.com/this-month/2021-12/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://rust-osdev.com/this-month/2021-12/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-09 07:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust OSDev本月进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"cargo-release用于自动完成crate的release过程。例如，使用clap，我所做的就是添加变更日志，并运行cargo release修补程序，cargo release负责更新文件、发布到crates.io、标记和推送。上一个版本是0.17。自那时以来的亮点包括:\nWorkspaces:用new shared-version = true配置标志\n...\nGithub 链接，https://github.com/crate-ci/cargo-release文章链接，https://www.reddit.com/r/rust/comments/ryjmhh/cargorelease_v019/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/ryjmhh/cargorelease_v019/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-09 07:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo-release v0.19"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"自旋锁是最基本的同步实现之一，也是实现操作系统时首先要考虑的组件之一。文章将简要回顾自旋锁的基础知识，如何在 Rust 中为自制操作系统实现它，以及它相对于 C 语言的优势。\nhttps://vmm.dev/en/rust/spinlock.md\nSNAFU 是一个库，可以在添加上下文的同时轻松地将底层错误分配到特定于域的错误中。可以类似这样处理错误：1 月 4 日 SNAFU 0.7 发布，更新了包括：使用结构和枚举的自定义错误类型，上下文选择器可以放在一个模块中等。\nhttps://users.rust-lang.org/t/snafu-0-7-released/69766\nRustix 是一个具有多个后端的系统调用包装库。它有一个原始的 Linux 系统调用后端，以及一个 libc 后端，其他后端正在开发中。Rustix 专为内存安全、I/O 安全和性能而设计。rustix 简化了与 C 整数类型大小相关的系统调用 API 中的一些小缺陷。举个例子：将会变成这将重点放在send操作上，而没有unsafe、原始指针、wrlen_t类型和cvt错误处理的干扰。Rustix 还能够从 Rust 代码直接进行 Linux 系统调用。比如 origin 是一个 Rust 库，它能够启动和关闭进程和线程（类似于 crt1.o 和 libpthread）。有了这些，我们就有了在 Linux 上运行 Rust 程序所需的所有东西。\nhttps://blog.sunfishcode.online/port-std-to-rustix/\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-07 22:10"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"include_dir这个crate提供了一个include_dir!()宏，用于在编译时将整个目录树嵌入你的二进制文件中。这就像include_str!()，但针对整个目录。https://crates.io/crates/include_dir我最近做了大量的工作来改善这个crate，增加了想要的功能，改善了编译时间，并巩固了它的核心目标，所以我觉得有必要进行项目更新。我也想利用这篇博文作为一个机会，征求大家的评论。如果有更多的人关注这个crate，那将是非常好的，而使用像CREV这样的公共审查系统会让人们更有信心在生产中使用include_dir。你可以查看入门指南以了解更多。https://web.crev.dev/rust-reviews/Read More: https://adventures.michaelfbryan.com/posts/bringing-include_dir-into-the-modern-era/?utm_source=reddit&utm_medium=social&utm_campaign=modern-include-dir"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://adventures.michaelfbryan.com/posts/bringing-include_dir-into-the-modern-era/?utm_source=reddit&utm_medium=social&utm_campaign=modern-include-dir"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-06 21:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"【博文】把include_dir带入现代"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者的第一个Rust项目，发了一个帖子，热评帮忙做了代码review，给出了一些建议。我记性不是很好，因此平时做了一些笔记。这是一些小建议，在你将来写Rust时应该会有帮助。\n\nhttps://github.com/craciuncezar/git-smart-checkout/blob/main/src/git_client.rs#L7 这些都可以只是函数。Rust不是OOP，所以如果你不需要状态，不需要用结构把所有这些东西绑定在一起也是可以的。\n\n\n对于GitBranch，你可以只需要[derive(Clone)]而不是自己实现它。https://github.com/craciuncezar/git-smart-checkout/blob/main/src/git_client/git_branch.rs#L4 参考文献：https://doc.rust-lang.org/rust-by-example/trait/derive.html\n\n\n在Rust中，如果你能在可能的情况下将clone给调用者负责，而不是自己去做，那是最好的，在 https://github.com/craciuncezar/git-smart-checkout/blob/main/src/git_client/utils.rs#L3 ，我认为to_vec在底层做了一个clone。我的意思是，如果你需要某个东西的明确拷贝，就用所有权而不是引用，但让调用者决定他是想给你所有权还是克隆这个值给你。\n\n\n在这个只在一个地方使用的fn的具体案例中，我认为你一般不需要它，但如果你要在多个地方使用它，你可以把Vec传成可变的，并立即排序，不需要clone。你也可以将Vec<GitBranch>包装成一个新的类型，并为其实现fn https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html。\n\n\n你的模块和类型的另一种构造可以是git、git::client、git::client::switch_to_branch、git::Branch。\n\n\n当把一个Vec引用传递给一个函数时，通常作为切片接收：branches: &[GitBranch]更方便。调用代码保持不变，但现在可以传递数组以及Vec去调用该函数。通常情况下，String和&str也是如此。\n\n\n我看到你有很多的unwrap。我建议是试一下anyhow。你会发现错误处理会变的容易。\n\nhttps://github.com/craciuncezar/git-smart-checkout/blob/main/src/git_client.rs#L7 这些都可以只是函数。Rust不是OOP，所以如果你不需要状态，不需要用结构把所有这些东西绑定在一起也是可以的。对于GitBranch，你可以只需要[derive(Clone)]而不是自己实现它。https://github.com/craciuncezar/git-smart-checkout/blob/main/src/git_client/git_branch.rs#L4 参考文献：https://doc.rust-lang.org/rust-by-example/trait/derive.html在Rust中，如果你能在可能的情况下将clone给调用者负责，而不是自己去做，那是最好的，在 https://github.com/craciuncezar/git-smart-checkout/blob/main/src/git_client/utils.rs#L3 ，我认为to_vec在底层做了一个clone。我的意思是，如果你需要某个东西的明确拷贝，就用所有权而不是引用，但让调用者决定他是想给你所有权还是克隆这个值给你。在这个只在一个地方使用的fn的具体案例中，我认为你一般不需要它，但如果你要在多个地方使用它，你可以把Vec传成可变的，并立即排序，不需要clone。你也可以将Vec<GitBranch>包装成一个新的类型，并为其实现fn https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html。你的模块和类型的另一种构造可以是git、git::client、git::client::switch_to_branch、git::Branch。当把一个Vec引用传递给一个函数时，通常作为切片接收：branches: &[GitBranch]更方便。调用代码保持不变，但现在可以传递数组以及Vec去调用该函数。通常情况下，String和&str也是如此。我看"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://libreddit.spike.codes/r/rust/comments/rwwa35/media_my_first_rust_app_git_smart_checkout_fuzzy/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-06 21:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"我的第一个Rust应用，git智能签出，模糊搜索分支，我有点喜欢这门语言❤️🦀"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我在twitter上进行了一次极其科学的民意调查，并确定这不是它的发音: https://twitter.com/at_tcsc/status/1476643344285581315确实, 它本质上是一个Vec<T, A>， 发音为 Veck-tah。 😛听着，我搬离波士顿是为了避免这类事情😆。-the8472 和 Thom Chiovoloni 在 github 上评论https://github.com/rust-lang/rust/pull/92463#discussion_r777059401Read More: https://this-week-in-rust.org/blog/2022/01/05/this-week-in-rust-424/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2022/01/05/this-week-in-rust-424/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-06 21:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"本周周报"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"hyper 维护者 seanmonstar 写了一篇 hyper 的2021年终总结：\n提供了 C 接口，并作为 curl 的后端使用\n对 http/0.9 支持得更好\n提升了 http/2 的性能\n正在加入对 http/3 的支持\n1.0 快来了\ntower 稳定下来了\n基于 tower 诞生了 Axum\nwarp 仍然能工作，在继续维护\n发布了 tokio console，有助于调试 tokio async 应用的具体 task 的状态\n进展非常大。https://seanmonstar.com/post/672473147126300672/hyper-ish-2021-in-review"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://seanmonstar.com/post/672473147126300672/hyper-ish-2021-in-review"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-05 22:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"hyper的2021年终总结"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"《An Introduction To Session-based Authentication In Rust》 先睹为快。链接：https://www.lpalmieri.com/posts/session-based-authentication-in-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.lpalmieri.com/posts/session-based-authentication-in-rust/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-05 22:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"从零到产品-使用Rust 样章第10章"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"pngquant/libimagequant 的作用把这个库使用 Rust 重写了。他发现使用 Rust 写的版本，更容易移植。这个库是用来处理 png 图片压缩的其中一步的。https://pngquant.org/rust.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://pngquant.org/rust.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-05 22:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 比 C 代码更容易移植"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这篇文章讲了为什么 Valgrind 对 Rust 是有用的。\nValgrind 不止是内存错误探测工具\nRust 并不是完全内存安全的（因为有的时候 unsafe 代码不可避免）\nhttps://nnethercote.github.io/2022/01/05/rust-and-valgrind.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://nnethercote.github.io/2022/01/05/rust-and-valgrind.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-05 22:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 和 Valgrind 配合使用"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一篇有关解析器 parser 的文章，学习。https://cantortrading.fi/rust_decimal_str/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://cantortrading.fi/rust_decimal_str/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-05 22:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"让数字解析快 4 倍"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"也就是裁减编译后的二进制文件体积大小。https://github.com/rust-lang/cargo/pull/10088"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rust-lang/cargo/pull/10088"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-05 22:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo 的 strip 指令稳定下来了"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"又一个用 Rust 写的操作系统！https://github.com/Andy-Python-Programmer/aero"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/Andy-Python-Programmer/aero"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-05 22:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Aero - 一个现代、实验性、unix-like 的操作系统"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"洛佳同学提供。好耶，approve了。https://github.com/rust-lang/rust/pull/92574（模块pr：https://github.com/rust-lang/stdarch/pull/1271）现在在rust标准库上就能做risc-v的内核开发和宿主机（虚拟机）开发了，具体来说是标准库支持了hypervisor和supervisor的扩展指令。顺便加了个is_riscv_feature_detcted!宏，能在用户态检测riscv扩展是否存在，已经在真机上跑通，合理利用检测宏，能彻底解决“生态碎片”问题。如果rollup顺利，能进明天的nightly，然后1.59的stable。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rust-lang/rust/pull/92574"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-05 22:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"现在在rust标准库上就能做risc-v的内核开发和宿主机（虚拟机）开发了"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Dioxus 是一个新的 Rust GUI 工具包，用于 Web、桌面、移动、SSR、TUI，关注开发人员体验，有下面几点优势：\n熟悉：提供类似 React 的心智模型和 API\n健壮：借助 Rust，将规则和错误处理移入类型系统来避免运行时错误\n高性能：可扩展到最大的应用程序\n高效：全面的文档、快速重新编译和深度集成的工具\n可扩展：适用于所有平台的可重用 hook 和组件\n官网链接https://dioxuslabs.com/blog/introducing-dioxus/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-04 10:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Dioxus v0.1 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"简要介绍一下 zbus 是什么：D-Bus 是一种在 Linux（尤其是桌面和嵌入式系统）上非常流行的进程间通信 (IPC) 机制。 而 zbus 是一个纯粹的 Rust 库，旨在使 D-Bus 处理尽可能简单，许多服务（例如 systemd、NetworkManager、Geoclue 等）都使用它，所以如果你发现自己在 Rust 中与它们交互，你可以使用 zbus。而大家期待已久的2.0 稳定版发布了！ 😎 虽然 1.x 版本很受欢迎，但缺少异步 API。 2.0 使用了全新的设计，将异步 API 作为主要的 API，阻塞 API 只是一个包装器。docs.rs 链接zbus book 链接https://docs.rs/zbus/latest/zbus/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-04 10:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"zbus 2.0 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Fuzzing 可以完全自动化地发现对安全至关重要的错误。而 LibAFL 是从零开始用 Rust 编写的 fuzzing 框架，可以创建几乎所有的模糊测试器。在谷歌的 fuzzbench 基准测试中，它已经超过了许多著名的覆盖引导模糊器，包括 honggfuzz、libfuzzer/entropic 以及 old-skool afl。最重要的是，LibAFL 可以更好地跨内核和机器扩展。您还可以使用它在 Windows、Android、macOS 和 LibAFL 上对纯二进制目标进行模糊测试，也完全与 no_std 兼容。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-04 10:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"LibAFL - 高性能 Rust fuzzer"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"mmids (multimedia Ingestion and Distribution System)是一个功能强大、用户友好、开源的实时视频工作流服务器。目前 mmids 能做什么?\n通过RTMP 接收音频/视频\n提供RTMP 音频/视频服务\n从外部源接收音频和视频\n直播视频转码\n生成视频的HLS流\n将实时视频推到外部RTMP服务器。\ngithub地址https://github.com/KallDrexx/mmids/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-03 20:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"mmids: Rust编写的多媒体收发系统"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Blackjack 是一个3D程序建模应用程序, 100% Rust, 而且可以 link 到 C.演示链接github 地址https://gfycat.com/unsungnegativecub-3dmodelling-houdini-blender-gamedev-rust"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-03 20:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Blackjack: 一个3D程序建模应用程序"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"目前以下均有实现或者正在实现.\nComplex number\nQuaternion\nAffine Transform 2D\nVector 2\nVector 3\nVector 4\nMatrix 2\nMatrix 3\ngithub 地址https://github.com/Aandreba/llml--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-03 20:16"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"LLML: Low Level Math Library"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"lidongjies"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 中文社区一直在不断发展，持续地向外输出：\n2021 年，Rust 中文社区共发表日报 326 篇，累计阅读数十万次，涵盖 Rust 各个方面，详情可查看：https://rustcc.cn/section?id=f4703117-7e6b-4caf-aa22-a3ad3db6898f\n社区的张老师投身 Rust 界多年，他在 2021 年发布了《Rust 编码规范》，参与商用 Rust 项目落地，创办《Rust 精选》，筹备《Rust China Conf 2021》大会，并创建中文社群，组织线上沙龙。与此同时还完成了诸多图书和课程工作，为 Rust 的发展和推广起到了不可磨灭的作用。详情可查看：https://mp.weixin.qq.com/s/eBYlvokJ5Q-Up87OP7qVUw\n2021 年 6 月 3 日，RustSBI 在 GitHub 成立组织，RustSBI 是 RISC-V 平台下的引导程序实现，它完全由 Rust 编写，并已经被录入 RISC-V SBI 国际标准。来自社区的维护者洛佳表示，“RustSBI 可以完成硬件到硬件的兼容性，从而延长硬件的生命周期，降低管理和迭代更新成本。”详情可查看：https://github.com/rustsbi/rustsbi\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-02 21:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust中文视界2021年总结"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"lidongjies"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"来自社区的张汉东老师对文章进行了总结：链接：https://blog.rust-embedded.org/this-year-in-embedded-rust-2021/GitHub：https://github.com/rust-embedded/wg另外，也有一些新的创业公司，比如这个专注于 GUI 的 Sixty FPS，该 GUI 工具库面向全平台，目标之一是取代 Qt。2022 年他们可能要长足支持嵌入式。链接：https://sixtyfps.io/blog/2021-in-review.htmlGitHub：https://github.com/sixtyfpsui/sixtyfps"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-02 21:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust嵌入式工作组2021年总结"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"lidongjies"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"链接：https://towardsdatascience.com/nine-rules-for-writing-python-extensions-in-rust-d35ea3a4ec29"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-02 21:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust写Python扩展的9个原则"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"lidongjies"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"可以使用单个定义来定义多个不同版本的 Struct，并生成一个枚举来统一它们：文档：https://sigp.github.io/superstruct/intro.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-02 21:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Superstruct：处理版本化数据"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"lidongjies"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"支持查询、插入、更新和删除。以查询为例，使用方法如下：GitHub：https://github.com/ddddddO/qoo"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-02 21:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"面向对象的Query"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"lidongjies"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者使用一个带有简单单元测试的 repo 增强对这个主题的理解。其中，包含了一个简单例子和一个复杂例子。GitHub：https://github.com/blasrodri/atomic-story"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-02 21:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"了解原子和内存排序的工作原理"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"lidongjies"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本次发布的主要内容：\n阅读原文 https://github.com/emilk/egui/blob/master/CHANGELOG.md\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-02 21:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"egui 0.16.0 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"lidongjies"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Kira 是用 Rust 编写的用于游戏开发的音频库，并且具有不太常见的功能，例如平滑的补间参数和声音的精确定时，作者正在用它来制作一个动态生成的音乐游戏。github.com/tesselode/kira\nRepo github.com/tesselode/kira\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-02 21:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Kira, 一个用于游戏开发的音频库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"lidongjies"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\nRead More https://internals.rust-lang.org/t/pre-rfc-add-comparator-api-for-ordered-collections/15889\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-02 21:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一个用于有序集合的比较器 pre-RFC"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"clap 3.0，一个 Rust CLI 参数解析器Github 博客链接,https://epage.github.io/blog/2021/12/clap3/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://epage.github.io/blog/2021/12/clap3/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-01 21:12"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"clap v3.0 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"支持 SSE4.1、AVX2、ARM NEON、Aarch64 NEON 和 WASM SIMD128！比 fast-hex、base64 和 radix64 更快！Github 链接,https://github.com/Nugine/simd基准测试：https://github.com/Nugine/simd/blob/main/docs/benches-v050.md"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/Nugine/simd/blob/main/docs/benches-v050.md"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-01 21:12"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"SIMD 加速操作"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Pixels 是一个小的硬件加速像素帧缓冲区。它广泛用于模拟器、软件渲染器、2D 像素艺术游戏和桌面实用程序。0.9 版本带来了一些重大变化。 值得注意的是 wgpu 已更新到 0.12，我们现在需要 2021 版。Github 链接，https://github.com/parasyte/pixels详细信息参见版本说明，https://github.com/parasyte/pixels/releases/tag/0.9.0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/parasyte/pixels/releases/tag/0.9.0"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-01 21:12"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"pixels v0.9 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"博客文章链接：https://pkolaczk.github.io/server-slower-than-a-laptop/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://pkolaczk.github.io/server-slower-than-a-laptop/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-01 21:12"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一行代码如何让 24 核服务器比笔记本电脑还慢"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2022-01-01 21:12"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"祝大家元旦快乐！"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"chilipepperhott/generative-art 是一个全新的交互式生成艺术服务，用 Rust 编写，可以编译为 wasm 。访问 https://elijahpotter.dev/art/ 即可在线体验。GitHub - chilipepperhott/generative-art: https://github.com/chilipepperhott/generative-art"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/chilipepperhott/generative-art"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-30 22:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Rust 编写的生成艺术服务"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一年年末，正是回顾 2021 的好时候，让我们一起看一下 Rust Analyzer 在这一年内的重大变化吧。\n（过程）宏和属性\n局部项\nChalk 集成\n允许创建不可变语法树的可变副本\nIDE 体验的改进\nPS: 尽管目前 RA 还没有成为官方的 Rust 项目，但据文章透露，这一切也许会在明年初发生变化。rust-analyzer in 2021: https://rust-analyzer.github.io/blog/2021/12/30/2021-recap.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://rust-analyzer.github.io/blog/2021/12/30/2021-recap.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-30 22:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rust-analyzer in 2021"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 423: https://this-week-in-rust.org/blog/2021/12/29/this-week-in-rust-423/https://github.com/PsiACE"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2021/12/29/this-week-in-rust-423/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-30 22:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week in Rust 423"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Infinitree 是一个嵌入式加密数据库。\n默认线程安全\n透明地处理热/温/冷存储层；目前支持 S3 兼容的后端\n可以使用Iterator trait查询,无需完全加载的版本化数据结构\n加密所有磁盘数据，仅在使用时解密\n专注于性能和灵活\n可扩展的自定义数据类型和存储策略\nReadMore:https://github.com/symmetree-labs/infinitree"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/symmetree-labs/infinitree"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-30 09:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"infinitree - 嵌入式加密数据库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"随着 2021 年接近尾声，我们认为我们会回顾过去一年在 Embedded Rust 中发生的事情，无论是在工作组内还是在更大的社区中。\n会议\n通讯\n平台支持\n其他嵌入式项目\n资料库\nReadMore:https://blog.rust-embedded.org/this-year-in-embedded-rust-2021/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.rust-embedded.org/this-year-in-embedded-rust-2021/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-30 09:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"嵌入式 Rust 的 2021"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我尝试从结构向量填充 HashMap 的下两个场景之间的区别。第一个使用for工作正常,并且resolvers填充了 HashMap第二个我试图into_iter代替for，但resolvers总是空的。--后一段代码 map 是惰性的,需要触发才能运行,比如用collect。或者直接用 for_each来代替 mapReadMore:https://www.reddit.com/r/rust/comments/rqln6n/for_vs_into_iter/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/rqln6n/for_vs_into_iter/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-30 09:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"for vs into_iter - 新手对 map 的误解"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"odd-cat"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Mocking HTTP Services in Rusthttps://dev.to/alexliesenfeld/mocking-http-services-in-rust-58ee本文展示了如何使用mock库来模拟HTTP服务。如何使我们在自动化测试期间验证应用程序发送的HTTP请求是否符合我们的期望，并且还可以模拟来自依赖服务的HTTP响应，以确保我们的应用程序能够相应地处理它们。此外，作者还展示了模拟工具如何在开发过程中替换不可用的HTTP服务，并使它们能够同时被许多应用程序访问。多功能模拟工具可以在开发生命周期的多个阶段中实用，而不仅仅是集成测试。然而，它们对于增强基于HTTP的API客户端特别有用，并允许我们测试很难复现的边界case。作者介绍了一些可以做mock的开源库，并做了对比："},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-28 20:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"在Rust中模拟HTTP服务"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"odd-cat"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Generate a Blockchain Key Pair Address in Rusthttps://dev.to/yceethetechie/generate-a-blockchain-key-pair-address-in-rust-4871在本教程中，读者将了解如何使用Rust编程语言生成区块链密钥对地址。依赖：\nSecp256k1: Secp256k1是Pieter Wuille的Secp256k1椭圆曲线的一个实现；\nanyhow: 用来优雅的处理错误;\nCargo.toml示例"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-28 20:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"在Rust中生成区块链密钥对地址"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"odd-cat"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"现在我们有了一种语言：Rust，一种游戏引擎：Bevy，还有一种类型：Platformer。这一系列文章将是我用这些工具构建一个小型平台游戏之旅的日志。\n在Rust中制作游戏.第1部分.Bevy和ECS\n在Rust中制作游戏.第2部分.绘图材料和照相机\n在Rust中制作游戏.第3部分.地板和重力\n在Rust中制作游戏.第4部分.跳跃\n在Rust中制作游戏.第5部分.运动\n在Rust中制作游戏.第6部分.生成地图\n更新中...\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-28 20:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"《在Rust中制作游戏》系列教程"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"odd-cat"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Options for Rust REPL that's easy to installhttps://www.reddit.com/r/rust/comments/rpha3k/options_for_rust_repl_thats_easy_to_install/\nevcxr: 一个Rust REPL执行环境；\nIRust: 跨平台Rust REPL；\nRust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-28 20:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"能快速安装的Rust REPL汇总"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是来自 Code and Supply Lighting Talk 的一个演讲, 主题是如何 设计一个数据结构, 他能够在任意的系统和任意的嵌入式设备.原文链接https://tiemoko.com/slides/SafeAndPortableDataStructureDesign_CodeAndSupply_Dec2021.pdf"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-27 20:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 安全可移植的数据结构设计"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Youki 是一个用Rust编写的底层容器运行时，实现了OCI运行时规范。简单地说，youki是一个可以创建容器的命令行工具。您可能听说过的其他同类运行时包括 runc 和 crrun。当您使用Docker或Podman创建容器时，实际的容器创建被委托给 youki 这样的工具。原文链接https://www.utam0k.jp/en/blog/2021/12/27/youki_first_release/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-27 20:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Hello, youki!"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者使用 Rust + WASM 在浏览器中回执了一个会动的环面.展示地址https://parametric-surfaces.herokuapp.com/源代码地址https://github.com/solidiquis/parametric_surfaces"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-27 20:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用Rust + WASM在浏览器中绘制一个环面"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新增 cargo cache verify , 将尝试在cargo载缓存中找到损坏或修改的 crates.原文链接https://www.reddit.com/r/rust/comments/rp0jb0/cargo_cache_080_released_now_with_cache_source/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-27 20:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo cache 0.8.0 released"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者详细描述了自己如何使用 Rust 编写 prometheus的 exporter 到存储和画图的过程.原文链接https://mateusfreira.github.io/@mateusfreira-writing-a-prometheus-exporter-in-rust-from-idea-to-grafana-chart/--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-27 20:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Rust 编写prometheus exporter"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"lidongjies"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"gfx-rs 是一个为 Rust 带来高效跨平台图形的项目，这篇文章包含该项目的主要里程碑、概念和回顾。Wgpu\n\n从 gfx-hal 转移到新创建的 wgpu-hal 并重组了代码仓库以将所有内容保持在一起。 与此同时放弃了 SPIRV-Cross 以支持 naga，实现纯 Rust 技术堆栈。在 0.10 发布帖子中了解更多信息，归功于@kvark。\n\n\n同时，@cwfitzgerald 使用 Rust 集成测试和示例快照改进了我们的测试基础设施。 最重要的是，wgpu 已经与 Deno 紧密集成（感谢 Deno 团队的努力！），开辟了在真正的 CTS 上进行测试的道路，现在可以在 CI 中使用。\n\n\nWebGL 适配变得可用，现在 wgpu-rs 示例可以使用 WebGL 在线运行。\n\n\n阅读原文 https://gfx-rs.github.io/2021/12/25/this-year.html\n\n从 gfx-hal 转移到新创建的 wgpu-hal 并重组了代码仓库以将所有内容保持在一起。 与此同时放弃了 SPIRV-Cross 以支持 naga，实现纯 Rust 技术堆栈。在 0.10 发布帖子中了解更多信息，归功于@kvark。https://gfx-rs.github.io/2021/08/18/release-0.10.html同时，@cwfitzgerald 使用 Rust 集成测试和示例快照改进了我们的测试基础设施。 最重要的是，wgpu 已经与 Deno 紧密集成（感谢 Deno 团队的努力！），开辟了在真正的 CTS 上进行测试的道路，现在可以在 CI 中使用。https://github.com/cwfitzgeraldWebGL 适配变得可用，现在 wgpu-rs 示例可以使用 WebGL 在线运行。阅读原文 https://gfx-rs.github.io/2021/12/25/this-year.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-26 21:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Year in Wgpu - 2021"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"lidongjies"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\nRepo https://crates.io/crates/edn-format\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-26 21:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Edn-format: a more complete library to parse EDN in Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"12-25.md"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-25 21:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"它会记住你最常使用的目录，所以你只需敲击几下键盘就可以“跳转”到这些目录。Gitlab 链接，https://github.com/slightlyoutofphase/staticvec"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/slightlyoutofphase/staticvec"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-25 21:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"zoxide: 一个只能的cd命令, 灵感来自于autojump"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Snui是一个简单的2D UI库。虽然计划支持xdg_shell，但目前snui只提供了一个实现wlr_layer_shell协议扩展的Wayland后端。要创建GUI，首先需要创建一个widget 树。此树中的widget处理鼠标输入或消息等事件。构建widget的场景图，与之前的场景图进行比较，然后进行渲染。Gitlab 链接，https://gitlab.com/snakedye/snui"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://gitlab.com/snakedye/snui"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-25 21:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Snui: 一个简单的2d ui库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"xremap是Linux的key remapper。与xmodmap不同，它支持特定于应用程序的重映射和Wayland。\n快速- Xremap是用Rust编写的，比Python等无jit解释器更快。\n跨平台- Xremap使用evdev和uinput，无论你使用X11还是Wayland都可以。\n语言无关— 配置文件是json兼容的。可以从任何语言生成，例如Ruby, Python。\n...\nGitlab 链接，https://github.com/k0kubun/xremaphttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/k0kubun/xremap"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-25 21:50"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"𝑋𝑟𝑒𝑚𝑎𝑝: 是Linux的key remapper"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 作为一种开发语言已经确立让开发人员能够编写快速和安全的代码的声誉现在。像 Mozilla、Microsoft、Dropbox 和 Amazon（仅举几例）这样的大型组织都依赖 Rust 为他们的客户提供一流的性能，同时避免许多影响用 C 或 C++ 编写的程序的安全问题。性能是 Rust 成为大多数人选择语言的一个主要原因。然而，仅仅用 Rust 编写代码并不能保证高性能。Rust 是好的，但它不是魔法。它是一种工具，与任何工具一样，我们必须有效地使用它才能获得最佳结果。在这篇文章中，我们将研究 Rust 代码性能不佳的常见原因，即使是资深开发人员也可能会遇到这种情况。也就是说，默认情况下，不缓冲文件的读取和写入。\nhttps://era.co/blog/unbuffered-io-slows-rust-programs\n在 Rust 中开发 Lambda 函数的标准方法是使用 AWS 提供的自定义 Lambda 运行时并在部署之前交叉编译所有内容。这里介绍如何在 macos 上进行开发 Lambda 函数。然后，在您的环境中设置这些变量（例如在bashrc 中）：现在cargo build --target aarch64-unknown-linux-gnu将在 macOS 上按预期工作，并生成准备部署到 AWS Lambda 的二进制文件 - 无需 Docker\nhttps://noserve.rs/rust-lambdas-macos/\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-25 01:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这个是上周三即12月15日发布的消息了，目前官方透露的信息很少，给了一个简陋的官网：https://zed.dev/同时官方在该帖下透露了一些有趣的信息。在正式介绍相关信息之前，我想多说几句，为什么都过了一周了，又把这个信息扒出来，之前的时候我以为这个信息热度挺高的，一定会发日报吧，没仔细看，知道后面想看看大家对这件事的评论的时候，才发现居然没发日报。索性今天我值班，就由我来给大家说说这个旧闻。Atom大家应该有听说过，是GitHub开发的一个代码编辑器，早年我还在大学的时候折腾过各种编辑器，对这个的印象实在是不怎么好，现在回想起来，第一个感觉就是卡，真卡。同时，由于该团队开发Atom的时候，需要一个前端框架，于是有了大名鼎鼎的Electron，早先的名字叫做Atom Shell，名气上应该是要大于Atom本身的。对于这个框架，我的感受，还是卡，因为有用过Linux各种桌面发行版的经历，很多软件为了跨平台支持，都是Electron开发的，很卡。现在这个团队，要用Rust开发一个代码编辑器，和前段时间的Fleet不一样的地方在于，前端的部分，也是Rust写的，同时因为Rust的GUI生态很薄软，他们直接开发了一个Rust前端框架，叫做GPUI，直接放原文：我们最初计划使用Electron作为为Zed提供跨平台GUI的便捷手段，同时用Rust构建应用程序的核心。但每当这时，我们发现网络技术是实现惊人性能的瓶颈。最后，我们决定建立一个由GPU驱动的可完全控制的并简单的UI框架，以满足我们的需求。我们称它为GPUI。我们从Mozilla的Webrender项目中得到了很多灵感。关键的见解是，现代图形硬件可以以高帧率渲染复杂的3D图形，那么为什么不利用它来渲染相对简单的2D用户界面，并采用即时模式架构呢？Rust的所有权模型要求我们重新思考我们在其他UI编程范式中所学到的很多东西，但其结果是一个框架，使用起来很有成效，而且非常容易推理。控制每一个像素是一种解放，而以闪电般的速度推动这些像素则是一种冲动。(It’s liberating to control every pixel, and it’s a rush to push those pixels at lightning speed.)单单是上述官方的博文，仍然无法确定这个GUI框架是用Rust写的，但是该帖子下有这样的回复：Rust迫切需要一个好的UI框架，让每个人都觉得用起来很舒服......现在有一些很棒的独立解决方案，但没有一个听起来适合每个人的。这样大概率是Rust的UI框架解决方案了。相对于这个编辑器本身，我对该UI框架的兴趣更为浓厚，也正是有了很大的期望，所以如果最后一些偏差，比如该框架不是给Rust做的、比如该框架不是像宣传所说的很简单易用，那会让我很失望，索性把这个旧闻翻出来，让对Rust进行GUI开发感兴趣的同志们一齐期待，比我最后一个人可能失望要好的多。Read More: https://libreddit.spike.codes/r/rust/comments/rgyss8/an_code_editor_written_in_rust_by_the_atom_devs/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://libreddit.spike.codes/r/rust/comments/rgyss8/an_code_editor_written_in_rust_by_the_atom_devs/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-23 22:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"【旧闻】一个由Atom开发者用Rust编写的代码编辑器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Reddit 上有个讨论很有意思，同属于更好的C的类型的语言，Zig提供了很多有趣的设计思路，甚至于Rust语言团队也需要从中吸取经验，用以改进Rust，这部分讨论收录在这里：我还没有深入研究过Zig，但与Rust相比，它似乎是一种非常简单的语言，就系统编程语言而言，它是相当有能力的。Rust有什么是Zig所没有的？高赞回复：Rust有什么是Zig所没有的？编写代码时不需要经常考虑内存管理问题的能力。Zig让内存管理变得非常明确，比如强迫你处理分配失败的情况，这很好......但是，这并不是我在PC平台上做游戏时真正要处理的问题。一旦Rust的基本借用规则成为第二天性，代码就几乎不存在内存管理部分了......一切都会自动地做 \"正确的事情\"。在使用Rust这么长时间后，我觉得要传递内存分配器，要存储指向内存分配器的指针都是很麻烦的。不要误会我的意思，它是一个非常棒的项目（就像Jai、Odin和所有其他即将推出的\"更好的C\"一样），但是不断有走错路的危险，我觉得很难再回去了。而且这还没有触及多线程的问题Read More: https://libreddit.spike.codes/r/rust/comments/rlj9zl/what_do_you_think_about_zig/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://libreddit.spike.codes/r/rust/comments/rlj9zl/what_do_you_think_about_zig/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-23 22:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust有什么是Zig所没有的？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"今天早些时候，我阅读了Tyler Mandry的《Rust中的上下文和能力》，我非常喜欢我看到的内容。但是我和很多人一样，有很多问题。这将如何影响语言？这是否会损害定位性/可读性？需要什么来使之适应？https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/所以这里是我到目前为止的想法的探索。Read More: https://jam1.re/blog/thoughts-on-contexts-and-capabilities-in-rust"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://jam1.re/blog/thoughts-on-contexts-and-capabilities-in-rust"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-23 22:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"【博文】关于Rust中上下文和能力的思考"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"与螃蟹有关的重要诊断改进在nightly版本启用@rustlanghttps://twitter.com/rustlang-- Mara Bos 发表的推特https://twitter.com/m_ou_se/status/1471077145258647554Read More: https://this-week-in-rust.org/blog/2021/12/22/this-week-in-rust-422/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2021/12/22/this-week-in-rust-422/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-23 22:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"本周周报"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"它不但是一个命令行工具，还是一批 crates，你可以基于它开发自己的 git 工具。git 本身可以作为一套版本管理系统或数据库存在，二次开发打开了一道新大门。https://github.com/Byron/gitoxide"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/Byron/gitoxide"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-22 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"gitoxide - 一个体验和性能更好的git工具套件"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"https://github.com/devmatteini/dag"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/devmatteini/dag"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-22 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"dag - 从github release上下载资源的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Podman 是一个容器引擎，用于在 Linux 上开发，管理和运行 OCI 容器。https://github.com/vv9k/podman-api-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/vv9k/podman-api-rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-22 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"podman-api  Rust的podman api"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作为 Rust 的忠实拥护者，Embark Studio 的工程师们正在使用 Rust 开发渲染引擎和游戏，并且贡献了 rust-gpu 这个项目。在这篇技术博客中，一位来自 Embark 的工程师讲述了如何处理用户创建的世界的 3D 渲染，以及 Rust 如何帮助他们更好地实现这个目标。原文链接https://medium.com/embarkstudios/homegrown-rendering-with-rust-1e39068e56a7"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-21 15:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Embark Studio 使用 Rust 进行本地渲染"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"涉及 Rust 的讨论经常以一个无休止的问题告终：抱怨 Rust 的“炒作”。但 rust 确实是一门可以解决问题的语言，回想当年 Java 流行的时候，大家也有很多抱怨，但仍然被 Java 吞噬了整个行业接近 20 年。作者在这篇文章中告诉大家，要辩证地看待 Rust 的炒作，停止抱怨，理性地审视问题！原文链接https://thenewwazoo.github.io/whining.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-21 15:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"停止抱怨 Rust 炒作"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Robyn 是一个用 Rust 编写的快速异步 Web Python 框架。 作者从今年 5 月开始编写 Robyn，今天发布了 v0.10.0。 根据他的基准测试，它是最快的 Python 框架之一。目前已经添加了 WebSockets、MultiCore 扩展（以及更多）等功能！欢迎大家尝试和贡献！github 链接发布链接https://github.com/sansyrox/robyn"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-21 15:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Robyn 发布 v0.10 版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust的众多优势之一是，它可以与Python无缝集成，并提高关键代码段的速度。作者最近写了一个小型库，它具有高效的不规则数组数据类型，它将成为一个很好的例子，说明如何使用 PyO3 和 maturin 与 numpy 互操作来设置 Rust Python包。原文链接https://www.reddit.com/r/rust/comments/rk12bg/writing_rust_libraries_for_the_python_scientific/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-20 20:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"为Python科学计算生态编写Rust库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"CEDICT 格式是一种简单的、创造性的、通用许可的中/英词典文件格式。虽然有很多只支持普通话的CEDICT解析器，但在英语编程世界中，基本上不支持粤语的jyutping。作为一个希望在节目中使用广东话发音的人，一开始作者被困住了。最终,作者自己动手写了一个解析器.原文链接https://briankung.dev/2021/12/07/building-a-cedict-parser-in-rust-with-nom/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-20 20:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用 Nom 在 Rust 中构建一个 CEDICT 解析器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者从微软的一些 API 中获得灵感, 开了一个 可以 从 schema 文件生成 类型化和极其高效的api的库.github 地址https://github.com/muscache/zetro"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-20 20:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Zetro: 从 schema 中生成高效的 API"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"codasai 可以让你使用 git 的历史记录来创建编程指南，这样读者就可以在任何给定的时间点查看程序的状态。github地址https://github.com/emi2k01/codasai--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-20 20:33"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"codasai: 使用 git 的历史记录来创建编程指南"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个用 Rust 编写的用于以太坊应用程序开发的快速、便携和模块化的工具包。包括：\nForge：以太坊测试框架（如 Truffle、Hardhat 和 Dapptools）。\nCast：瑞士军刀，用于与 EVM 智能合约交互、发送交易和获取链数据。\n特点：\n快速、灵活的编译管道\n\nSolidity 编译器版本自动检测安装\n增量编译和缓存：仅重新编译更改的文件\n并行编译\n非标准目录结构支持\n\n\n测试是用 Solidity 编写的\n使用收缩输入和打印反例的快速模糊测试\n快速远程 RPC forking 模式利用 Rust 的异步基础架构\n灵活的 Debug 日志\n\nDapptools 风格，使用 DsTest 发出的日志\nHardhat 风格，使用流行的 console.sol 合约\n\n\n便携 (5-10MB) & 易于安装静态链接的二进制文件，无需 Nix 或任何其他包管理器\n抽象的 EVM 实现（目前支持：Sputnik、EvmOdin）\n\nSolidity 编译器版本自动检测安装\n增量编译和缓存：仅重新编译更改的文件\n并行编译\n非标准目录结构支持\n\nDapptools 风格，使用 DsTest 发出的日志\nHardhat 风格，使用流行的 console.sol 合约\nGitHub：https://github.com/gakonst/foundry"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-19 23:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"foundry：以太坊应用程序开发工具包"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个简单的 Rust 2D 平台游戏，使用了 Gate 和 Collider 库。\nhttps://crates.io/crates/gate\nhttps://crates.io/crates/collider\n介绍视频：https://www.youtube.com/watch?v=SR-Yx6nTfZY在线 Demo：http://www.luduminis.com/chirperjax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-19 23:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"chirperjax：简单的2D游戏平台"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"关于为什么要写一个新的 Shell，作者觉得 Nushell 对只想要一个 Shell 的人来说确实有好处，但如果只想要 Rust 写的 bash 呢。vsh 就是要将 bash 的功能都实现，人们用起来还是 bash，而不会掉到一个新的空间（说的是 Nushell）。感兴趣的同学可以关注下。GitHub：https://github.com/Vaimer9/vsh"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-19 23:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"vsh：UnixShell"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\n检查地址和端口的 GUI 小工具：https://github.com/shijimasoft/netport\n一个操作二叉树的小 library：https://github.com/Gabriel-Rosmart/RusTree\n\n可以处理数字和字符串\n在树上插入新数据\n查找是否包含某值\n获取树的深度\n引用树上的数据\n合并两棵树\n从 vector 创建树\n从树创建 vector\n\n\n检查编译的局限性：https://github.com/adam-mcdaniel/harbor\n\n可以处理数字和字符串\n在树上插入新数据\n查找是否包含某值\n获取树的深度\n引用树上的数据\n合并两棵树\n从 vector 创建树\n从树创建 vector\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-19 23:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rustacean小项目"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\nHow not to learn Rust：https://dystroy.org/blog/how-not-to-learn-rust/。这是一篇反向思维的文章，作者列举了一些可能导致初学者无法成功学习 Rust 的错误。\nRust Error Handling：https://www.unwoundstack.com/blog/rust-error-handling.html。这是一篇 Rust 错误处理的最佳实践。\nRust as a platform for IoT：https://blog.ysndr.de/posts/essays/2021-12-12-rust-for-iot/。这是一篇针对物联网应用的 Rust 生态系统的概述。\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-19 23:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rustacean文章推荐"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-19 23:25"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust冰山"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"上周（12月10日），Ryan Levick 和 Mara Bos 代表 Rust 项目向 Rust 项目的所有成员（包括所有工作小组）发送了一封电子邮件，用来跟进审核问题。TL;DR:\n这封邮件是 Mara Bos 代表 Rust 项目高级别的团队负责人、新的审核团队、基金会的项目主管和核心团队写的；\n这批小组成员目前正试图处理审核问题；\n问题是前审核团队和核心团队之间关于审核问题的分歧；\n目前计划是制定一套涵盖解决这一具体分歧的通用规则。\n博文链接，https://blog.rust-lang.org/inside-rust/2021/12/17/follow-up-on-the-moderation-issue.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.rust-lang.org/inside-rust/2021/12/17/follow-up-on-the-moderation-issue.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-18 20:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 项目审核问题的后续工作"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Spiderfire 是一个用 Mozilla 的 SpiderMonkey 引擎和 Rust 构建的 JavaScript 运行时，Spiderfire 的目标是颠覆服务器端的 JS 运行环境。Github链接，https://github.com/Redfire75369/spiderfire"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/Redfire75369/spiderfire"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-18 20:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Spiderfire， JS运行时"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"YAAR，Yet Another Asynchronous Runtime 专注于#![forbid(unsafe_code)]和扩展性，目前这个 crate 正在开发中。作者决定挑战自己，为 Rust 编写一个不使用unsafe的异步运行时，但仍然会依赖 parking_lot, crossbeam, arc-swap。目标是做出一个#![forbid(unsafe_code)]在性能上与 tokio 有竞争力的异步运行时。这首先是一个研究项目，其次才是一个库。Github链接，https://github.com/kprotty/yaar/tree/forbid_unsafe_std3https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/kprotty/yaar/tree/forbid_unsafe_std3"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-18 20:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"YAAR，异步运行时"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"huangjj27"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"熟悉小编的朋友知道小编最近又转到了测试岗位的工作，在进行性能测试的时候由于 Jmeter 多线程模型占用了极大量的资源才能 打出并发量比较高的测试压力，于是找到了 Python 的 Locust（蝗虫）框架，用起来还算顺手，但资源占用对于在办公室里的笔记本电脑来说实在是弱了些。另外，由于 Python 的 GIL 原因，使得Locust 在单机上只能使用单核单进程，要想利用多核只能开启 Locust 的分布式配置于是，在 @PotatoTooLarge 的指点下，发现 Goose这个 Rust 的框架，它由如下特点：https://github.com/tag1consulting/goose\n文档齐全，一如 Rust 社区的作用\n基于 Reqwest，可以异步发起请求\nLocust 报告里有的指标，Goose 的报告里面基本都有\n资源消耗极小，适合在没有资源的情况下发起测试压力\n但是，该框架仍有以下不足：\n没有配置文件（以及profile）\n没有 locust 的实时监控 WebUI\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-17 23:26"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Goose: 由 locust 框架启发的性能测试框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"huangjj27"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该仓库下包含了一个 TurboWish/tokio-console 的实现，它时一个是分析与调试的工具，为异步 Rust 程序设计。分析套件包括几个组件：\n\n一个 wire protocol，为了串流来自被分析应用到分析工具的分析数据。这个格式是用了 gPRC 和 protocol buffer 定义的，为了高效地在 wire 上传送，以及为了保证不同数据生产者和消费者之间的互操作性。\nconsole-api 库包含了 wire format 的自动生成代码，用的是 tonic gPRC。此外，使用其他 gPRC 代码生成器的项目（包括使用其他语言实现的！）能够自行依赖 protobuf 定义。\n\n\n从进程收集分析数据并通过 wire format 暴露它的instrumentation。 仓库中的 console-subscriber 库包含了作为tracing-subscriber 层的 instrumentation 端API，给用 Tokio 和 tracing 的项目使用。\n\n\n用来展现和探索分析数据的工具，使用 console wire protocol 实现成了gPRC 客户端。console 库实现了一个非交互式的命令行工具来消费这些山上，但是其他实现，例如图形化的或者基于web 的工具，也是可用的。\n\n一个 wire protocol，为了串流来自被分析应用到分析工具的分析数据。这个格式是用了 gPRC 和 protocol buffer 定义的，为了高效地在 wire 上传送，以及为了保证不同数据生产者和消费者之间的互操作性。console-api 库包含了 wire format 的自动生成代码，用的是 tonic gPRC。此外，使用其他 gPRC 代码生成器的项目（包括使用其他语言实现的！）能够自行依赖 protobuf 定义。从进程收集分析数据并通过 wire format 暴露它的instrumentation。 仓库中的 console-subscriber 库包含了作为tracing-subscriber 层的 instrumentation 端API，给用 Tokio 和 tracing 的项目使用。用来展现和探索分析数据的工具，使用 console wire protocol 实现成了gPRC 客户端。console 库实现了一个非交互式的命令行工具来消费这些山上，但是其他实现，例如图形化的或者基于web 的工具，也是可用的。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-17 23:26"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"tokio-rs/console 发布 v0.1"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"来自 Signal 支持多达 40 人的群视频通话，并采用端到端加密技术。值得一提的是，在 Signal 开展业务时，市面上并没有满足需求现成软件。所以他们自己构建了一套开源的 Signal Calling Service ，当然，使用 Rust 构建。这篇文章详细描述了该服务的工作原理。GitHub - Signal Calling Service: https://github.com/signalapp/Signal-Calling-ServiceHow to build large-scale end-to-end encrypted group video calls: https://signal.org/blog/how-to-build-encrypted-group-calls/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://signal.org/blog/how-to-build-encrypted-group-calls/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-16 23:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"文章 - 如何构建大规模端到端加密群视频通话"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"mold 是一个更加现代的链接器，它是由 C++ 编写的，但能够与 Rust / Cargo 生态完美协作，提供更快地链接过程。你可以使用 mold --run cargo build 来尝试它，或者将下述内容添加到 ~/.cargo/config.toml：GitHub - mold: https://github.com/rui314/mold"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rui314/mold"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-16 23:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"现代链接器 mold v1.0 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 421: https://this-week-in-rust.org/blog/2021/12/15/this-week-in-rust-421/https://github.com/PsiACE"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2021/12/15/this-week-in-rust-421/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-16 23:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week in Rust 421"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"支持http 和 websocketReadMore:https://github.com/actix/actix-web/tree/master/awc"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/actix/actix-web/tree/master/awc"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-15 23:30"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"awc - 一个基于 actix 生态构建的 HTTP 和 websocket 库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"它目前支持以下操作系统：\n安卓\nIOS\nLinux\nmacos\n树莓派\nwindows\n例子:ReadMore:https://github.com/GuillaumeGomez/sysinfo"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/GuillaumeGomez/sysinfo"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-15 23:30"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"sysinfo - 一个用于获取系统信息的库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"从世界各地的多个位置向指定地址发送 ping 请求。ReadMore:https://gitlab.com/shodan-public/geonet-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://gitlab.com/shodan-public/geonet-rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-15 23:30"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"geoping - shodan开发的多地ping工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"odd-cat"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Lightning-fast and Powerful Code Editor written in Rusthttps://www.reddit.com/r/rust/comments/rg3k9o/lightningfast_and_powerful_code_editor_written_in/Lapce完全是用Rust编写的，它的UI使用Druid，它使用Xi编辑器的Rope Science技术进行文本编辑，并使用Wgpu进行渲染。https://github.com/linebender/druid特性：\n作为一等公民的模态编辑(类似Vim)支持（也可以关闭）；\n内置LSP(语言服务器协议)支持；\n内置远程开发支持（受VSCode远程开发启发）；\n插件可以用任何能编译成WASI格式的编程语言编写；\n内置终端；\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-14 21:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Lapce: 用Rust编写的闪电般快速且功能强大的代码编辑器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"odd-cat"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Deno Joins TC39https://www.reddit.com/r/rust/comments/rfem07/deno_joins_tc39/Deno 是 Ryan Dahl 在2017年创立的(Ryan Dahl 同时也是 Node.js 的作者)，旨在为JavaScript和TypeScript构建一个简单、现代、安全的运行时，Deno是用Rust实现的，内置V8引擎。Deno基本上是为现代JavaScript构建的：Promises、async/await、ES模块和异步迭代器等在Deno中都是一等公民。为了确保JavaScript的未来发展将继续适用于Deno和服务器端JavaScript运行时，Deno公司已加入负责JavaScript标准（ECMA-262）的ECMA国际标准组织，并参与到TC39工作组的工作中，Luca Casonato(卢卡·卡索纳托)将是Deno在TC39的主要代表。在TC39工作组中，Deno将与其他ECMA成员和更广泛的JS社区合作开发下一代JavaScript，并将推动该语言的功能和改进，使每个人受益，尤其是服务器端JavaScript的用户。TC39是指第39号技术委员会。它是ECMA的一部分，该机构根据“ECMAScript”规范标准化JavaScript语言。参考资料：\nDeno joins TC39\nDeno Land\ntc39.es\nTC39, ECMAScript, and the Future of JavaScript\nDeno 运行时入门教程：Node.js 的替代品\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-14 21:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Deno加入ECMA国际组织的TC39工作组"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"odd-cat"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"cbor4ii: A new CBOR serialization cratehttps://www.reddit.com/r/rust/comments/rg2qgg/cbor4ii_a_new_cbor_serialization_crate/CBOR：简明二进制对象表示法（CBOR）是一种数据格式(RFC8949)，其设计目标包括实现极小的代码大小、相当小的消息大小和无需版本协商的可扩展性。https://www.rfc-editor.org/rfc/rfc8949.htmlcbor4ii是一个新的用Rust语言实现的CBOR格式序列化库，它没有针对性能进行专门优化，但基准测试表明，它的性能略优于serde_cbor。https://github.com/pyfisch/cbor而且它支持零拷贝反序列化和反序列化任何支持deserialize_ignored_any的serde，因此在某些情况下，它的性能可能比不支持此功能的serde要好。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-14 21:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cbor4ii：一种新的CBOR格式序列化库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"odd-cat"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Cratesinquire: crates.io insight and explorer.https://www.reddit.com/r/rust/comments/rfk25y/cratesinquire_cratesio_insight_and_explorer/www.cratesinquire.com是一个crates.io的辅助功能网站，以Bundlephobia为灵感，搜索crate包并检查其细节。https://www.cratesinquire.com/它能做什么？\n向crates.io的API发送请求，并处理数据；\n显示从crates.io扩展的额外数据；\n显示数据比较图表；\n深入显示crate的依赖；\n洞察crate的特征。\n立刻体验，请访问这里：www.cratesinquire.comhttps://www.cratesinquire.com/Rust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-14 21:00"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Cratesinquire: 搜索并分析crates.io"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本文主要分析 Rust 生态系统对物联网的准备情况.Rust是一种年轻的编程语言，有很多前景，包括成为普适计算的物联网的可行平台。这篇文章将介绍普适计算和物联网，然后绘制出与这些领域相关的当前Rust生态系统的图片，最后分析这个生态系统如何能够满足该领域的需求。原文链接https://blog.ysndr.de/posts/essays/2021-12-12-rust-for-iot/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-13 20:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 作为 IoT 的平台"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"多年来，Rust中的错误处理一直是一个讨论的话题。有一个专门致力于此的工作小组，似乎很活跃，但老实说，我并没有听到很多来自他们的消息。然而，关于这方面的最佳实践的文章和帖子却源源不断。当我重新考虑我自己的 mpdpopm 错误处理策略时，我对它们进行了调查，并从中选取了一些内容，但没有一个作者真正抓住了我的想法。这样，我就把自己的想法扔到那堆东西上原文链接https://www.unwoundstack.com/blog/rust-error-handling.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-13 20:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"又一篇 Rust 错误处理的文章"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者记录了自己如何从使用开源到贡献力量到开源社区的历程. 如果你也想贡献力量到开源社区,可以参考一下.原文链接https://www.raykochenderfer.com/posts/my-first-contribution-to-open-source"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-13 20:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"我对开源的第一个贡献"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者使用 Derive 宏 和 Actix 来构建 REST Api.原文链接https://ctprods.cyprientaque.com/blog/a-rust-api-pattern-actix"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-13 20:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一个 Rust Api 模式"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该仓库包含几个 AMD 图形相关的工具:\namdfand - fan speed daemon\namdvold - voltage and overclocking tool\namdmond - monitor daemon\n目前 1.0.8 版本发布了.原文链接https://www.reddit.com/r/amdgpud/comments/rf9whu/announcing_108/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-13 20:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"AMD GPU tools: 1.0.8 版本发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Yew是一个现代的Rust框架，用于使用WebAssembly创建多线程前端web应用。目前 0.19.3 版本已经发布.原文链接https://github.com/yewstack/yew/releases/tag/yew-v0.19.3--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2021-12-13 20:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"yew: 0.19.3 版本发布"},"type":"text"}],"type":"title"}},]
