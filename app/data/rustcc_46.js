export const propertiesForNewPages = [{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustRustConf期间，来自Mozilla、Microsoft、Google、Facebook等大公司工程师和Rust核心开发者（Niko、Manish 和 Alex）的讨论Rust在他们公司的使用现状。大公司的工程师总有一些特殊的需求是一般开发者碰不到的，所以他们与Rust核心开发者一起交流，确定这些需求并一起讨论解决方案是一种很好的方式。如果你感兴趣的话，可以点击下文链接，找到更多会议记录。Read Morehttps://gist.github.com/rylev/0e3c3895dcb40b6a1c1cf8c427c01b5e"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-08 22:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"【会议记录】Rust在大公司使用的现状"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #clistructopt 是一个基于结构体配置的命令行工具开发框架，0.3版本有两个主要的变化：Read Morehttps://github.com/TeXitoi/structopt/blob/master/CHANGELOG.md"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-08 22:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"structopt 升级到了0.3版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#wasm #rust如题，激动的热泪盈眶，甚至测试代码也支持async/await啦。Read Morehttps://github.com/rustwasm/wasm-bindgen/pull/1741"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-08 22:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"wasm-bindgen 正在集成std::future"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustrosoto是 ASW 的 Rust SDK，其作者@matthewkmayer 想找更多的人一起参与这个项目，他可以帮你把环境搞起来然后运行，分享给你文档之外的知识，这并不意味着他撒手不管这个项目了，他只是希望有更多优秀的人让这个项目越来越好。https://github.com/matthewkmayerRead Morehttps://github.com/rusoto/rusoto/issues/1496"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-08 22:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rusoto 正在寻找项目维护者"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者开发一个应用时发现编译一次要花好长时间，真的太痛苦了，他尝试从几个方面解决编译时间问题，比如删除一些宏，将一些简单的正则表达式替换为rust标准库的API，删除一些其他的create等，虽然方法并不通用，但思路也有可取之处。Read Morehttp://antoyo.ml/compilation-time-dependencies\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-08 22:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何为一个crate减少编译时间"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"NLL指的是non-lexical lifetimes非词法生命周期，即新的借用检查规则和实现。NLL接受不安全代码，之前是使用警告和弃用通知的方式。现在这已经转为了一个hard error错误，因为NLL已经提出了一段时间。具体如下：\n在1.39中对Rust 2018发出NLL警告hard error。\n在1.40的对Rust 2015发出NLL警告hard error。\n有关更多详细信息，请阅读#63565https://github.com/rust-lang/rust/pull/63565#issuecomment-528563744"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-07 19:21"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 2018: NLL migrate mode => hard error"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Linux.Fe2O3，这是用Rust编写的POC ELF预装器。作者喜欢在其学习的语言上编写预编程器，并发现一些有趣的事。至于名称，Fe2O3是Rust的化学式，作者认为这个名字很合适的。（小编注：Rust的字面意思是铁锈）\n原博文链接\nGithub地址\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-07 19:21"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Linux.Fe2O3: 一个Rust编写的“病毒”"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该代码库包含两个属性宏：default_trait_impl定义默认的trait实现，trait_impl使用定义的默认trait实现。这在测试中尤其有用，当你有许多被mock类型具有非常相似的trait实现，但又不希望规范的默认trait实现使用mock值时。Github地址https://github.com/hainish/multi-default-trait-impl"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-07 19:21"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"测试中有用的两个属性宏"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Starship是任何shell的最小，极快，极其可定制的提示工具！提示会在工作时显示需要的信息。官方网站https://starship.rs/--https://rust.cc/section?id=ce0fe0fb-1ac6-413a-b535-59e4a8e74b6c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-07 19:21"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Starship，Rust编写的shell提示工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者之前寫過 MUDdy 像MUD的純文字互動遊戲，但只是單機的Read morehttps://web.archive.org/web/20080212201605/http://shortcircuit.us/muddy-kinda-like-a-mud-but-single-player/最近也用Rust寫了 RCRPGRead morehttps://github.com/pistacchio/rcrpg-rust這是一個 Rosetta Code 裡的題目，Rosetta Code是一個把基礎的程式問題用各種語言實作一遍的網站，大家有興趣也可以來幫忙Rust的實作更完整。Read morehttp://rosettacode.org/wiki/Rosetta_Code"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-06 12:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"文字RPG"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"libfastwfc 是一個學術用波函數折疊的庫目前還非常的小 codebase 也才400行 應該是可以直接用Rust快速重寫的庫Read morehttps://github.com/rickyhan/fastwfc-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-06 12:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"fastwfc-rs: libfastwfc 的 Rust 綁定庫"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Read morehttps://github.com/hecrj/iced"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-06 12:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Iced 與渲染無關的GUI庫，專注於簡單與類型安全。參考Elm"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"這個團隊使用rust來開發各種功能，且用UE4開發他們的場景Demo，非常厲害的團隊。Read moregithubyoutubehttps://www.reddit.com/r/rust/comments/d00jof/announcing_texture_synthesis_crate_from_embark/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-06 12:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Texture Synthesis 材質合成補完的庫 來自 embark.games"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"給定函數 Test：（T） - > Bool，它會試圖找到一個回傳false或導致崩潰的T類型的值。比如你有個長的很醜的函數長這樣然後去給他跑，他就跑出一個NEW     180086  score: 493      pool: 48        exec/s: 132713  cplx: 79792NEW 表示將新輸入添加到有興趣的輸入池中180086 是到目前為止執行的迭代次數得分：493 是池中所有輸入引起的總代碼覆蓋率的度量pool：48 是池中的輸入數exec / s：132713 是每秒執行的平均迭代次數cplx：79792 是池中輸入的平均複雜度最後他會找到return false的條件而這個1c10daa13e9b1721.json檔裡面會長這樣[0, 167, 200, 103, 56, 78, 2, 254]跟我們的程式碼條件一樣Read morehttps://github.com/loiclec/fuzzcheck-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-06 12:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Fuzzcheck 針對Rust功能的覆蓋率提升工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我有大量（1000+）個protobuf類型分佈在數百個不同的.proto文件中。不知道有什麼庫可以一次幫這所有的 .proto 文件全部轉成 rust 宣告？目前已經試過 prost, rust-protobuf 但感覺差強人意prost的問題是沒辨法處理大量複雜相依的 .protorust-protobuf可以處理大量複雜相依的 .proto，但他發現一個問題發了一個PR但沒人理他覺得這些專案的維護者是不是不想讓他們的庫愈來愈好？Read morehttps://www.reddit.com/r/rust/comments/czxny2/which_protocol_buffers_crates_to_invest_in/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-06 12:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rust 中哪個 protobuf庫 比較好用?"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"hyper 0.13 alpha 版本发布,它是一个使用 Rust 编写的成熟 HTTP 库，并且是速度最快的 HTTP 库之一，同时因其正确性得到了许多人的认可。https://github.com/hyperium/hyper/releases这个 alpha 版本为 std::future::Future 提供了支持。让人兴奋的是，这意味着可以使用即将在 Rust 1.39 版本中稳定的 async/await 语法。https://doc.rust-lang.org/std/future/trait.Future.html如下是一个使用示例：Read morehttps://seanmonstar.com/post/187493499882/hyper-alpha-supports-asyncawait"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-05 22:10"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"hyper 0.13 alpha 版本发布，支持 async/await"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"WebAssembly 很有前景也很有吸引力，但它也带来了新的挑战，例如：如何调试 .wasm 二进制文件。在 Mozilla，我们一直使用传统工具（如 GDB 和 LLDB ）对 .wasm 文件进行源级调试的方法进行原型设计。如下视频（https://youtu.be/PevI_Mn-UUE） 演示了使用 Wasmtime 和 LLDB 来调试使用 Rust 编写并最终编译为 WebAssembly 的程序：Read morehttps://hacks.mozilla.org/2019/09/debugging-webassembly-outside-of-the-browser/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-05 22:10"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"在浏览器之外调试WebAssembly"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Fluvio 是一个云端原生动态数据平台，可在 Kubernetes 上运行。它带来了集中控制，可以在整个组织内连接，转换和分发实时数据。https://github.com/infinyon/fluvio它具备一下特性：\n声明式管理 - 独特的数据管理方法。\nCloud Native  - 为 Kubernetes 而建。\n实时架构 - 完全异步设计，适用于低延迟和高吞吐量环境。\n灵活部署 - 控制器可以同时管理云和内部部署服务。\n功能强大的 CLI  - 用户友好且易于使用的命令行界面。\n用 Rust 编写 - 安全，快速，小尺寸：专为高性能分布式系统而构建。\n与 Kafka 兼容 - 与 Kafka 客户端和服务器 API一起使用。\nFluvio CLI 用于管理 Kafka 主题，以及生成和使用 Kafka 日志。\n了解更多https://www.fluvio.io/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-05 22:10"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Fluvio"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在第1部分中，我们介绍了如何将 Rust 中的异步 fns 编译为状态机。 我们看到内部编译器实现使用 generator 和 yield 语句来促进这种转换。 我们还看到在内存中布置其中一个状态机的最佳方法是使用类似枚举的表示，类似于以下内容：https://tmandry.gitlab.io/blog/posts/optimizing-await-1/存储在此枚举中的每个变量都是我们原始函数的局部变量，用于跟踪状态机的内部状态。 这里，关键点是 iter0 和 iter1 不会同时使用，因此我们可以回收 iter0 的字节，当我们的状态机转换到下一阶段时，将它们用于 iter1。Read morehttps://tmandry.gitlab.io/blog/posts/optimizing-await-2/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-05 22:10"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 如何优化 async/await（二）：程序分析"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #cpp\n5.继承与组合 - 下\n4.继承与组合 - 中\n3.继承与组合 - 上\n2.类与结构体\n1.起步\nRead Morehttps://zhuanlan.zhihu.com/c_1139487758685900800"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-04 23:36"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"CPP工程师的Rust迁移之路"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #crateregex1.3允许禁用Unicode等影响性能的特性，这可以减少超过1MB的二进制文件大小，将编译时间缩短一半，并将依赖关系树减少到一个包。我们可以从一个issue#613中了解这些改动的原因：https://github.com/rust-lang/regex/pull/613这些变化的另一个动机是允许正则表达式的用户缩小其依赖树，如果他们希望交换运行时性能。 虽然这可能听起来不像是一个很好的交换，但是存在许多实际上不需要高性能正则表达匹配的情况。 例如，如果使用正则表达式来过滤一小组微小的ASCII字符串，那么禁用所有正则表达式的crate功能是完全合理的。 最终结果是它将大大缩小二进制大小，缩短编译时间并将正则表达式的依赖树缩小到单个包（正则表达式语法）。发起这个PR的是BurntSushi大神。https://github.com/BurntSushiRepohttps://www.reddit.com/r/rust/comments/cz7u0j/psa_regex_13_permits_disabling_unicodeperformance/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-04 23:36"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"regex 1.3的改动"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#test #rust我们可以通过两组测试代码看一下这个框架是如何工作的Read Morehttps://github.com/la10736/rstest"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-04 23:36"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"retest 一个基于 fixture 的rust测试框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #wasm看过 rustwasm 文档的小伙伴应该都看到过 conway's game of life（康威生命游戏）的实现过程，有很多文章介绍了如何将 WebAssembly 应用运行在分布式虚拟机/智能合约平台Wavelet上运行，本文介绍如何改造一个现有的 WebAssembly 应用运行在智能合约平台Wavelet上。康威生命游戏小编也做过，周末按照这个教程改造试试。Read Morehttps://medium.com/perlin-network/turning-existing-webassembly-applications-into-distributed-programs-33b817462aa6\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-04 23:36"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"将现有的WebAssembly应用程序转换为分布式程序"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"LacneQin"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"如果在编译工程的时候未正确指定依赖项，Fac可以在多次尝试之后将工程成功编译。该项目创立于2014年，最开始用C编写，2017年后开始使用rust。Fac的灵感来自于通用编译工具make，它利用ptrace来枚举所有依赖项，并将所有源文件添加到（git）repo中。Fac的一个重要特性是它能够自动处理依赖关系，而不会像传统的编译工具一样在工程的依赖性上报错。目前，fac仅能够在Linux系统上运行，但它非常易于使用。Read More:https://github.com/droundy/fachttp://physics.oregonstate.edu/~roundyd/fac始终一致地应用抗锯齿处理图像非常耗费资源，因此通过这个算法可以将此过程轻松实现自动化选择。大致步骤分为：Read More:Ricky Han bloghttps://rickyhan.com/jekyll/update/2019/09/01/pixel-art-algorithm-selective-outlining-anti-aliasing.htmlrxrust是一个Rust实现的Reactive Extensions。ReactiveX是一个用于通过使用可观察序列来编写异步和基于事件的程序的库。除了对象必须将流的第一个闭包打包之外，他几乎是0开销的。它扩展了观测模式以支持数据“与/或”事件序列，并添加了允许以声明方式组合序列的运算符，同时抽象出对低级线程同步、线程安全、并行数据结构和无阻塞I / O等问题的补充。Read More:https://github.com/M-Adoo/rxRust/blob/master/CHANGELOG.mdReactive Extensions官网：http://reactivex.io/heim是用于系统信息获取的Rust跨平台异步库，已经发布一个多月，能够获取Rust crates生态系统中的系统信息（例如，CPU，内存，磁盘或进程统计）。heim 有几个关键目标来奠定他的发展基础和公共接口：1.异步优先2.跨平台。3.模块化设计。4.符合用户习惯且易于上手。现在可以使用新模块heim::process查询系统进程：Read More:https://github.com/heim-rs/heim/看看这个月发布了什么新的rust小游戏：Way of Rhea Trailer and Steam WishlistVeloren 0.3RUZZT还有更多：https://rust-gamedev.github.io/2019/09/02/newsletter-001.html\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://rust-gamedev.github.io/2019/09/02/newsletter-001.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-03 21:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust目前最火的两个web框架就是Actix-Web和Rocket， 众所周知，Rocket的优势在于易用性，Actix-web在于性能，最近，Rocket的人员正在迁移到异步后端。因此，作者想看看异步分支和主分支如何的性能如何同时和Actix-Web进行比较是很有趣的。测试使用的项目用Rocket编写的hello world应用程序Cargo.toml的差异（同步和异步）同步下面的程序用于测试Actix-Web我还引入了Wrap结果我运行了二个应用程序使用了 cargo run --release  并用了wrk -t20 -c1000 -d30s http://localhost:8000Rocket 同步Rocket 异步Actix-WebWarp结论虽然async Rocket的性能仍然不如Actix-Web，但是async极大地提高了它的性能。我非常希望看到Rocket的性能提高到这样的程度：作为一名开发人员，从此就不需要在易用性和性能之间做出选择。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-02 21:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rocket和Actix-Web的异步性能测试"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这个类库提供了宏的扩展，能够根据rustc编译器版本进行条件编译的宏。使用案例更多信息可以前往GitHub了解一哈https://github.com/dtolnay/rustversion"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-02 21:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rustversion - 根据rustc编译器版本进行条件编译"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个用rust编写的从.mobi格式电子书中提取数据的库使用案例访问基本信息输出更多信息可以前往GitHub了解一哈https://github.com/wojciechkepka/mobi-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-02 21:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"mobi-rs - 用于解析和操作.mobi格式的Rust库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Persy是一个用rust编写的事务性存储引擎。示例更多信息可以前往GitLab了解一哈https://gitlab.com/tglman/persy\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-02 21:55"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"persy - 用Rust编写的简单事务性存储引擎"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Wavelet 是 perlin-network 的一个子项目。https://github.com/perlin-networkWavelet is an open ledger for writing scalable mission-critical, decentralized WebAssembly application (https://wavelet.perlin.net/).作者尝试了基于 wavelet 来构建一个去中心化的博客，也算是迈向 w3 过程中的一个尝试。Read More: https://docs.qq.com/doc/DQkZhQ2lEVGVlTlNO"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://docs.qq.com/doc/DQkZhQ2lEVGVlTlNO"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-01 23:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 React, Gatsby 和 Wavelet 构建一个去中心化的博客"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"if_rust_version 是这样一个项目，可以根据 rust 的版本，来编译运行不同分支中的代码。像下面这样：https://github.com/ogoffart/if_rust_versionRepo: https://github.com/ogoffart/if_rust_version"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/ogoffart/if_rust_version"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-01 23:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"根据版本来编译分支代码？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"SoundSense 是 《矮人要塞(Dwarf Fortress)》的声音引擎，作者用 Rust 重写了（Rust重写一切！）。http://df.zweistein.cz/soundsense/Repo: https://github.com/prixt/soundsense-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/prixt/soundsense-rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-01 23:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"SOUNDSENSE-RS - SoundSense 的 Rust 复刻版"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"通常，Rust 对于编译时已知大小的结构体，都默认在栈上分配内存。在实际编码过程中，往往存在向堆中复制的过程。这会降低效率，而这个库提供了标注：#[derive(DefaultBoxed)] ，可以使得被标注的结构体直接在堆上分配内存。像下面这样：Repo: https://github.com/upsuper/default-boxed"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/upsuper/default-boxed"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-01 23:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"default-boxed - 让结构体定义的时候，直接分配在堆上"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"编译到 X86 指令集上，算是一个练手项目。Repo: https://github.com/JoshMcguigan/nerve"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/JoshMcguigan/nerve"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-01 23:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"又一个 brainfuck 编译器 - nerve"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"思路类似 structopt，不过这次是解析环境变量，其实很简单，就看你想不想得到，这是一种设计模式。Repo: https://github.com/zoranzaric/envopt\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/zoranzaric/envopt"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-09-01 23:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"envopt - 把环境变量解析到结构体中"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"大多数人对Rust的最大问题之一是编译时间长。原因之一是许多项目使用crates.io中相当多的依赖项。帮助缓解crates.io上的依赖膨胀是cargo-udeps的目标之一。小编在自己的项目上试用了一下，遇到问题尚待解决。毕竟目前还是v0.1.0，期待这个插件进一步完善。Gist详情https://gist.github.com/est31/3d9e880be746c3a443c699d9ff1888d2"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-31 11:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo-udeps，缓解Rust依赖膨胀的插件"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"由Brian St. Pierre编写的 Introduction to Rust Web Applicationshttps://erwabook.com/一个快速且简单的指南，使用 Rust 全栈开发 Web 应用：\nDiesel 作为 ORM\nRocket 作为 Web 框架，\nSeed 作为 [WebAssembly] 前端\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-31 11:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust全栈开发Web应用"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"structopt 是一个库，其通过定义结构体来解析命令行参数。v0.3 较大的两个变化是：\n错误提示的显著改进；\n移除了raw属性；\n有关更详细的信息，查看Githubhttps://github.com/TeXitoi/structopt/blob/master/CHANGELOG.md"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-31 11:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"structopt v0.3 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 编写 3D 游戏引擎。它包含的功能：\nFBX Loader（ASCII和二进制）\nTTF字体加载器\n延迟着色渲染器（基于OpenGL 3.3 Core）\n...\n由于其 API 未稳定，该引擎还没有在crates.io上发布。\n引擎演示链接\n正在编写的3D射击游戏\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-31 11:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rg3d，3D游戏引擎"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"RustCrypto项目，本周发布了4个新的crates，这些是加密算法的纯Rust实现或trait：\nchacha20poly1305：流行的身份验证的加密模式，由RFC 8439定义。此包也支持XChaCha20Poly1305扩展的nonce变体。\naead：使用关联数据进行身份验证加密(Authenticated Encryption with Associated Data, AEAD)的trait，chacha20poly1305包是根据这些trait实现的。\npolyval：AES-GCM-SIV（RFC 8452）使用的通用散列函数。\nuniversal-hash：通用散列函数的trait。\n自行承担使用风险。一般来说，使用任何加密库的0.1版本，可能是一个非常糟糕的主意。https://rust.cc/section?id=ce0fe0fb-1ac6-413a-b535-59e4a8e74b6c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-31 11:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RustCrypto：chacha20poly1305，aead，polyval，universal-hash"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Josh Triplett (Linux主要開發者之一)在一次的演講提到了Rust的可能性，但他強調他不是要大家一定要使用Rust，他只是覺得Rust可以給Linux帶來更多可能性，Josh也跟Greg Kroah-Hartman(Linux主要開發者之一)談過，Greg說他願意接受內核中用於在Rust中編寫驅動程序的框架看來大家在未來有很大的機會可以使用Rust來編寫Linux Kernel。Read morehttps://lwn.net/Articles/797558/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-30 19:35"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Linux 未來可以使用 Rust 開發內核"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"可以讓 php, node js, rust, c++ 直接執行wasm的一個runtime影片裡用 markdown 的庫展現了 wasmtime 的可能性從四種語言語言呼叫 wasm 裡編譯好的函數，非常方便Read morehttps://wasmtime.dev/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-30 19:35"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Wasmtime  在 WebAssembly & WASI上運行的容量小速度快的執行 runtime"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"使用rust nightly功能包括 Compiler 與 Runtime開發Lumen的主要動機是將基於BEAM的應用程序（即用Elixir，Erlang，LFE，Alpaca等編寫的程式）編譯成WebAssembly模塊原因是官方BEAM的實現與WebAssembly的現有技術不兼容，就是Emscripten編譯C / C ++程式的這部份一個問題是WebAssembly中運行VM執行bytecode會產生不小的開銷（BEAM bytecode由BEAM VM解釋，BEAM VM作為WASM執行，它被瀏覽器WebAssembly引擎編譯執行）。這也要求每個BEAM模塊要能讓能夠從瀏覽器執行並由VM加載。即使BEAM VM可以直接編譯為WASM，這些問題也沒有簡單的解決方案。Lumen的BEAM bytecode是用AOT執行，而不是在JIT。這避免了BEAM bytecode的膨脹，產生出的WASM模塊可以直接加載，並且沒有JIT的runtime 開銷。Read morehttps://github.com/lumen/lumen"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-30 19:35"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Lumen：針對WebAssembly的Erlang VM"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"讓人在#[feature(param_attrs)] 小括號中加入參數可以做到程式碼裡，依不同作業系統編譯不同的程式碼。Read morehttps://github.com/rust-lang/rust/pull/64010"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-30 19:35"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"param_attrs 將在Rust 1.39.0版本穩定"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"程式碼裡序列化成jsonRead morehttps://github.com/maplant/aljabar/blob/master/tests/serde_tests.rs\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-30 19:35"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"在rust 1.39 nightly 你可以使用aljabar的矢量來自動序列化任何大小的數組。"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"OSINT 就是“公开资源情报”，常见于安全和黑客领域。这个 sn0int 是给 IT 安全专业人士和 bug 捕获者设计的 OSINT 框架及包管理器。它用于对给定的目标或你自己搜集情报，生成统一的格式，给后续的研究使用。Rust 已经悄悄占领安全/黑客领域了。https://sn0int.readthedocs.io/en/stable/Repo: https://github.com/kpcyrd/sn0int"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/kpcyrd/sn0int"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-29 23:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"sn0int - 半自动化 OSINT 框架和包管理器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Snapshots tests (also sometimes called approval tests) are tests that assert values against a reference value (the snapshot). This is similar to how assert_eq! lets you compare a value against a reference value but unlike simple string assertions snapshot tests let you test against complex values and come with comprehensive tools to review changes.Snapshot tests are particularly useful if your reference values are very large or change often.快照测试（有时也被称作赞成性测试）就是把值与一个引用值（快照）进行断言。有点像 assert_eq!。但是 assert_eq! 只是简单的字符串等类型的测试，快照测试支持进行复杂类型值的断言，并提供全面的功能进行更改校审。快照测试在对值对象非常大或者改动非常频繁的时候，非常有用。Repo: https://github.com/mitsuhiko/insta"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/mitsuhiko/insta"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-29 23:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"insta - 快照测试库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"可以解析和操作 .mobi 文件。比如：Repo: https://github.com/wojciechkepka/mobi-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/wojciechkepka/mobi-rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-29 23:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"mobi-rs - 查看 .mobi 格式电子书的 Rust 库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"luminance 致力于让图形渲染变得简单优雅。它最初由 @phaazon 使用 Haskell 实现，在 2016 年的时候，移植到了 Rust 上面。https://hackage.haskell.org/package/luminanceWhere gfx-hal provides you with an experience focused on down-to-metal performance and an API very similar to Vulkan’s, luminance provides an API that is, for sure, a bit less low-level — and hence, yes, it’s likely you will not have the same performances as with gfx-hal (even though no benchmarks have been done so far), and the API is not Vulkan-based — but easier to start with, especially if you don’t already have a background experience with OpenGL or Vulkan.Repo: https://github.com/phaazon/luminance-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/phaazon/luminance-rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-29 23:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"luminance-rs - 类型安全/type-level和无状态的 Rust 图形框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"用来将已有素材，转换，合成标准的 icon 规范的图标。像下面这样：Repo: https://github.com/GarkGarcia/icon-pie"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/GarkGarcia/icon-pie"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-29 23:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"icon-pie - 用命令行产生应用程序图标"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Typescript 的 Result 实现，完全借鉴自 Rust。Repo: https://github.com/vultix/ts-results"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/vultix/ts-results"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-29 23:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"ts-results - Rust 对 Typescript 的影响之一，Result"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"打飞机！效果还行吧！Repo: https://github.com/amethyst/space_shooter_rs/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/amethyst/space_shooter_rs/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-29 23:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"space_shooter_rs - 用来演示 Amethyst 游戏框架的又一个游戏：打飞机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Wasmer 那帮人真的是疯狂，在我们都还在畅想 wasm 的应用场景的时候，他们已经将 wasm 塞进了 postgres。postgres-ext-wasm 是一个 pg 扩展，用来执行 wasm 二进制文件。目测，项目想法是想用任何语言完成之前只有 PL/pgSQL 才能完成的事情！文章中就用 Rust 写了一个例子展示，不过目前只支持 + 法。小编觉得 pg 这个智慧的结晶，真的值得好好挖掘一下的。Repo: https://github.com/wasmerio/postgres-ext-wasmhttps://github.com/wasmerio/postgres-ext-wasm?\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-29 23:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"postgres-ext-wasm - 在 Postgres 中运行 WebAssembly"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#C #FFi两篇文章介绍了如何绑定C库，并且将其抽象为安全的方法调用。Part I: https://medium.com/dwelo-r-d/using-c-libraries-in-rust-13961948c72aPart II:   https://medium.com/dwelo-r-d/wrapping-unsafe-c-libraries-in-rust-d75aeb283c65"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://medium.com/dwelo-r-d/using-c-libraries-in-rust-13961948c72a"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「系列文章」在Rust中使用C库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #tcp作者通过创建了一个TCP客户端的项目Clobber来体验将在1.39中稳定的Async/Await的功能，结论：体验非常好，非常期待Rust异步稳定之后，社区将会带来什么变化。\nRead More：https://ragona.com/posts/clobber_async_await\nClobber : https://github.com/ragona/clobber\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用async/await构建高性能TCP客户端"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#Elixir #AVL一个Elixir程序员开始学习Rust，在看完Too Many LinkedList之后，进一步实现更复杂的数据结构：AVL树（自平衡二叉查找树），以此来学习Rust的所有权机制。\nRead More: https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/\nCodes:  https://github.com/FrancisMurillo/avl_tree_set_rs\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"通过AVL树来理解Rust的所有权"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#TreeSitterTreeSitter是 GitHub 团队的解析器项目, 目的在于给 GitHub 及 Atom 编辑器提供高效以及跨语言的语法解析支持, 采用 GLR 算法, 支持消歧, 从错误中恢复, 增量解析等功能。TreeSitter支持多种语言，且支持增量解析，它的出现降低了自己实现语言的门槛。该文章简单介绍了Rust中使用TreeSitter的方法。\nRead More: https://rfdonnelly.github.io/posts/using-tree-sitter-parsers-in-rust/\ntree-sitter: https://tree-sitter.github.io/tree-sitter/\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"在Rust中使用Tree-sitter解析器生成器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#Crevcargo-crev是一个代码审查工具，旨在构建信任的生态网络。但它并不局限于Rust社区，C/Cpp也可以使用。https://github.com/dpc/crev/tree/master/cargo-crev该工具可以判断你项目中依赖crate的安全性、质量和发现的问题。可以在公共的git仓库里发布可验证的review信息。通过这种方式期望在Rust生态系统中构建可信任的网络。将不会有人再受到未经审查和不受信任代码的困扰。想想npm因为依赖包出了多少次安全事故。这个工具ms不错，但是否真的可以解决问题？Read More: https://wiki.alopex.li/ActuallyUsingCrev"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://wiki.alopex.li/ActuallyUsingCrev"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Crev的使用教程"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#game一位使用Rust开发游戏的妹纸，最近6个月内使用ggez框架开发自己的个人游戏项目，这篇文章简单介绍了她的一些感想，比如如何坚持做自己的项目、ECS很棒之类的。重点是她之前写的另一篇文章：24小时游戏开发，介绍了如何使用ggez框架在24小时内开发一款小游戏。感兴趣的看看吧。Read More: https://iolivia.me/posts/6-months-of-rust-game-dev/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://iolivia.me/posts/6-months-of-rust-game-dev/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用Rust进行游戏开发6个月之后收获到了什么？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#Ruby兼容MRI。Artichoke core提供了一个与实现无关的Ruby运行时，任何实现都可以加载它。Artichoke core中的运行时将100%通过core和标准库Ruby规范。运行时将以Rust和Ruby的混合方式实现。Artichoke中的Regexp实现就是这种方法的一个典型例子。\nRepo: https://github.com/artichoke/artichoke\n在线演示：https://artichoke.run/\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"artichoke: Rust实现的Ruby"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#PixelEditor像素编辑器一般用于对小图片进行编辑制作的工具。\nRead More: https://cloudhead.io/rx/\nRepo: https://github.com/cloudhead/rx\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rx： 一个Rust实现的可扩展的现代像素编辑器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#learning #oop这位博主打算写一系列主题是Rust for OOP的文章，主要是针对有一定OOP语言开发经验的人来学习。已经写了多篇，本文是关于闭包。Read More：https://oribenshir.github.io/afternoon_rusting/blog/closures"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://oribenshir.github.io/afternoon_rusting/blog/closures"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「系列」Rust for OOP系列：闭包"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#raftRaft是一种分布式共识协议。该作者的目标也是想做分布式数据库。Repo: https://github.com/railgun-rs/actix-raft"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/railgun-rs/actix-raft"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"actix-raft: 基于actix框架实现的raft库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async该文作者通过研究栈回溯信息发现，Rust的异步代码基于轮询(Poll)模型，意味着我们总是有「异步调用者」在轮询期间，等待「异步被调用函数」在栈上完成。这个属性使得调试异步代码在Rust中相比于其他语言更加容易。（该文比较了JavaScript中的异步栈回溯信息Read More: http://fitzgeraldnick.com/2019/08/27/async-stacks-in-rust.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"http://fitzgeraldnick.com/2019/08/27/async-stacks-in-rust.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust异步代码的优势：相比于其他语言更加容易调试"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#python演讲的重点是：pyo3 和 milksnake\nVideos: https://www.youtube.com/watch?v=4h8Ll9_-SZY\nPyO3 : https://github.com/PyO3\nmilksnake: https://github.com/getsentry/milksnake\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「视频」使用Rust扩展Python"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#Struct这个小小的问题，涉及日常编写代码需要考虑的两个问题：性能 vs 人体工程学我们是追求性能呢，还是追求代码的可读性和维护性等？该文作者通过大篇幅的讨论，甚至深入到C++中探讨，得出结论：还是By-Copy吧。至于原因，还需要仔细阅读他的文章。Read More: https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「思考」对于小的结构体，传值（By-Copy）还是传引用（By-Borrow）？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#BerkeleyYACC作者的练手项目Repo: https://github.com/sivadeilra/racc/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/sivadeilra/racc/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-28 20:07"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RACC: Berkeley YACC解析器生成器移植到Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"LacneQin"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust初学者，欢迎大家一起学习交流。以下是简单用法Read More: https://github.com/godcrying/scel2rimeADL（代数数据语言）系统可以在简单但功能强大的DSL中定义数据模型，然后为各种编程语言生成相应的代码。一致的序列化确保可以在语言环境之间无缝传输值。现在ADL正式支持rust了！这意味着它目前支持：\n\nhaskell\n\n\njava\n\n\ntypescript\n\n\nc++\n\n\nrust\n\nhaskelljavatypescriptc++rust虽然现有的语言目标是为了更高效的生产，但是此rust后端应该有些试验性的。开发人员正在学习一些嵌入式系统项目的知识，并打算使用rust 来搭建 ADL。在某些方面，Rust已经证明拥有它最简单的后端，因为ADL序列化模型可以完全由serde序列化库派生。感谢rust和serde！Read More: https://github.com/timbod7/adlPathDSL，一个专注于使PathBuf api易于使用的库，同时保持与自己编写相同的效率。API由一个宏path!和一个#[repr(transparent)]包装器组成PathBuf - PathDSL。该包具有零依赖性并且构建非常快。https://crates.io/crates/path-dsl创建路径非常简单：如果您在任何常见类型中都有已存在的路径，则可以无需任何开销来集成它们。它还会自动安全地将字符串文字连接到单个推送操作中以进行优化：结果类型是PathDSL替代的替代物PathBuf。以下文档中提供了更多示例和用法信息：docs.rscrates.iogithubhttps://docs.rs/path-dsl/*/path_dsl/仅需简单几步，git clone下来体验一下~Read More: https://github.com/alborrajo/sheetesia\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/alborrajo/sheetesia"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-27 22:03"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"以下是现场图片，大家感受一下气氛，最后一张图片是东哥用脑图梳理的知识点"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-26 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"北京Rust线下读书会，第一次举办"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Criterion.rs是一个能够快速准确的检测和测量性能的改进或回归（甚至是小型）来帮助您编写快速代码。 从而可以放心的进行优化，了解每个更改如何影响代码的性能输出仓库地址：https://github.com/bheisler/criterion.rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/bheisler/criterion.rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-26 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"criterion.rs - 统计驱动基准测试库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"pastel是一种用于生成，分析，转换和操作颜色的命令行工具。 它支持许多不同的颜色格式和颜色空间，如RGB，HSL，CIELAB，CIELCh以及ANSI 8位和24位表示。仓库地址：https://github.com/sharkdp/pastel"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/sharkdp/pastel"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-26 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"pastel - 用于生成，分析，转换和操作颜色的命令行工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该工具旨在成为构建和使用Rust的WebAssembly的一站式商店， wasm-pack可以帮助您构建Rust的WebAssembly包，您可以将它们发布到npm仓库或者与您已经使用的工作流中的任何javascript包一起使用，例如webpack或greenkeeper。仓库地址：https://github.com/rustwasm/wasm-pack"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rustwasm/wasm-pack"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-26 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"wasm-pack - wasm工作流程工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"ripgrep是一种搜索工具，可以递归搜索当前目录中的正则表达式模式。 默认情况下，ripgrep将尊重您的.gitignore并自动跳过隐藏的文件/目录。 ripgrep在Windows，macOS和Linux上拥有一流的支持，每个版本都有二进制下载。 ripgrep类似于其他流行的搜索工具，如The Silver Searcher，ack和grep。以下是在Intel i7-6900K 3.2 GHz的系统上的性能测试数据更多详情请参照仓库地址详情仓库地址：https://github.com/BurntSushi/ripgrep\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/BurntSushi/ripgrep"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-26 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"ripgrep - 高性能的在目录中正则表达式搜索工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustL-System（Lindenmayer system）是一种生成分形图案的方法。与迭代函数系统生成分形依靠数字的迭代不同，L-System依赖的是字符的迭代。字符间也有迭代公式，可以将字符换成某个字符串，随着迭代次数的增加，字符串长度越来越大，而字符串中的每一个字符，都代表着一种对线条的操作，如延伸、旋转等。最后将字符串依次执行一遍，便会得到一张分形图案，比如下图中的树Repohttps://github.com/Piripant/Lystem"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-25 22:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Lystem - Rust 实现生成分形图案的方法"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustwasm作者用rust实现了mesh-mesh和triangle-triangle的相交检测的库，目前只有两个API。Repohttps://www.npmjs.com/package/intersection-wasm"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-25 22:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"intersection-wasm 一个网格和三角形相交检测库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#node.js #rust@Jack Lo Russo搜索Javascript开发者学习Rust的资源，用来打发未来几天的休闲时光，结果发现了这个项目。https://twitter.com/lol_russoRead Morehttps://github.com/Mercateo/rust-for-node-developers"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-25 22:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust-for-Node-developers - 写给Node开发者的Rust教程"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust平时我们用command+S保存网页时，会生成一个html文件和一个资源文件夹，这样的好处是我们可以快速找到我们需要的图片。monolith 会将一个网页中的所有资源嵌入到一个文件中，如果是html中img标签的链接，会变成dataurl，CSS中的图片则不会，它还可以移除图片，排除javascript文件。Read Morehttps://github.com/Y2Z/monolith"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-25 22:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"monolith - 将网页的内容都保存到一个html文件里"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust@lrlna为Rust Conf特别制作的杂志图，描绘了Rust中异步编程状态，包括Futures、async/.await，以及关于Async Runtime如何工作的。https://github.com/lrlnaRead Morehttps://github.com/lrlna/sketchin/blob/master/zines/async-rust.md\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-25 22:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 异步流程杂志图"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"RustConf 2019，在8月22日-8月23日期间，在美国波特兰举办的第四届Rust活动，它的活动主页 RustConf 2019。https://rustconf.com/400多位世界顶级Rust开发人员汇聚于此。第一天是由Rust社区领导者进行的专业知识培训与主题探讨，第二天是核心团队成员及社区主要贡献者的主题演讲及特色演讲。上两张图，大家感受下："},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-24 12:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RustConf 2019"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Nushell，简称为Nu。为什么还需要它？直接上图：对Nu来说，一切都是数据。 它从经典的Unix管道哲学，PowerShell的结构化数据方法，函数式编程，系统编程等方面汲取灵感。关于Nu的更多信息：\ncrates.io\n书\n博客\nGithub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-24 12:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Nushell: 一个用Rust编写的新shell"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是Sylvain Kerkour关于Rust GUI生态系统的概述。他，为Bloom（Rust中的免费和开源Google）构建桌面应用程序，在查找有关目前Rust最佳GUI选项的信息时，他没有发现任何令人信服/足够的争论，所以他做了自己的研究。他基于各种条件，测试了很多框架（Qt，Electron，Gtk ...）。详细信息，排名和代码示例参见：Gitlabhttps://gitlab.com/z0mbie42/rust_gui_ecosystem_overview"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-24 12:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust GUI生态系统“测评报告”"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在之前的日报中，提到新成立的Rust游戏开发工作组(非官方)，该工作组正在努力更好地了解生态系统的状况。其第一个提案正在进行中，可以提供反馈！Github issuehttps://github.com/rust-gamedev/rust-gamedev.github.io/issues/6#issuecomment-524086008"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-24 12:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust游戏开发工作组(非官方)发布第一个提案"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"moxie，是一个用Rust编写的轻量级平台无关的UI运行时，它支持强类型的声明性编程风格，具有最小的交互延迟。moxie旨在通过手动管理有状态，可变对象的图形，顺利地弥合无状态工具和“传统”UI之间的差距。其设计与最近宣布的UI框架Jetpack Compose和SwiftUI有许多有趣的相似之处。获取项目更多信息参见：Githubhttps://github.com/anp/moxie--https://rust.cc/section?id=ce0fe0fb-1ac6-413a-b535-59e4a8e74b6c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-24 12:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"moxie，Rust编写的轻量级平台无关的UI运行时"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一個把C code轉換成  rust code的小程式，現在可以用cargo 下載安裝。簡單的程式還可以，有用到動態指標動態載入的庫就爆了。小編自己的感覺是玩具等級不怎麼實用。Read morehttps://immunant.com/blog/2019/08/introduction-to-c2rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-23 17:26"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"C2Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"小編我曾經在gateway team工作過，rust其實非常適合寫這種在需要穩定執行的程式。這篇文章講解了很多跟C庫打交道的技巧，包含FFI, call c function, impl Drop, return pointers, error handle蠻實用的Read morehttps://medium.com/dwelo-r-d/wrapping-unsafe-c-libraries-in-rust-d75aeb283c65"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-23 17:26"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Dwelo如何在Rust中重寫 IoT gateway"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Read morehttps://www.youtube.com/watch?v=r5K2pwRHnP4"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-23 17:26"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一個youtube短片教你如何使用gtk-rs (gtk 4.0)"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"獎勵：500美金如何獲得獎勵？您需要將Fuzzit與Go語言或Rust語言項目集成，星星超過1.5k。其它細節請看原文。Read morehttps://fuzzit.dev/2019/08/12/announcing-rewards-for-go-rust-oss-projects/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-23 17:26"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Fuzzing獎勵計劃"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"相信大家用linux 常常會遇到按tab，然後terminal卡住的經驗。現在shellac解決了這個問題，實作上就是盡量在使用者打出字來之後依據當前打出來的字來做分支預測在演算法上有命令分支爆破的問題命令常有可選的選項，並且可以按任何順序放置。實際上，這意味著要測試的潛在分支的數量會爆炸。例如，帶有opt1，opt2和opt3的binary [options] 只能出現一次，需要轉換為 | opt1 | opt2 | opt3 | opt1 opt2 | opt1 opt3 | opt2 opt1 | opt2 opt3 | opt3 opt1 | opt3 opt2 | ...，如果沒有採取任何措施來規避問題，將導致性能下降。解決方案是使預測分支線程都攜帶一組計數器。每個測試操作都能夠檢查和更新線程的計數器。這樣，opt1，opt2和opt3都可以擁有自己的計數器，16個分支可以減少到（opt1 | opt2 | opt3）*，只有4個（每個選項1個，循環1次）。但這是完整參數匹配。 但是這對於分組參數不起作用（例如GNU樣式二進製文件，其中-a -b -c可以縮短為-abc）解決方案是先匹配已有的組合。 例如，短參數定義為/  - （[a-z]）+ /，並且根據有效選項集檢查每個捕獲的字符。 這樣可以輕鬆定義分組參數，而不會失去一般性。目前團隊希望討論出好的shell-shellac協議，因為每種shell都會根據自己的假設實現自己的解析器，他們希望做一個統一好用的介面以保持向後兼容。Read morehttps://www.redox-os.org/news/rsoc-ion-ux-3/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-23 17:26"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Shellac(redox 作業系統下的shell) 自動完成所需時間在 1ms 以下"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"有關 WebGPU的庫目前的toolchainwgpu-rs -> wgpu-native -> gfx-backend-xxx -> native API未來希望wgpu-rs -> wgpu-native -> gfx-backend-gl -> glow -> WebGL -> Browser但我們應該wgpu-rs -> WebGPU -> Browser在Firefox上是Firefox -> wgpu-remote -> wgpu-native -> gfx-backend-xxx -> native APIRead morehttps://users.rust-lang.org/t/wgpu-v0-3-is-released/31682"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-23 17:26"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"wgpu-0.3"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"閃電回合\n用C++, Haskell 是最快的\n評審獎\nSound! TypeSystem\n他們使用多種語言協同 Rust, C++, Python, JavaScript, and Go\n完整比賽\n第一名  Unagi 使用 rust\n第二名 CowDay 使用 C++\n比的是 Bit Rotting Problem對於給定的地圖，給出一個覆蓋整個表面的移動軌跡，同時盡可能走最少步\n油漆工有三個機械手\n它可以向四個方向移動\n（但不是透過牆壁）。\n油漆工可以轉身\n機械手可折疊展開地圖的狹窄部分。\n附加一個額外的機器人手，擴大其範圍\n油漆工可以開一次兩倍加速，持續50步。\n油漆工可以製作隧道牆壁和障礙一次，持續30步。\n比賽時間 72小時Read morehttps://icfpcontest2019.github.io/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-23 17:26"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"ICFP 2019編程競賽 團隊使用Rust贏得第一"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"系统中装的软件/组件/服务多了，难免会有很多配置文件。这样，就会有一些工具来帮助统一管理这些配置文件。vaccum 就是这样一个工具。项目刚启动，还不成熟。Repo: https://github.com/idursun/vacuum"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/idursun/vacuum"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-22 21:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"vaccum - 系统全局配置文件搜集工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"https://play.rust-lang.org/ 是 Rust 官方提供的用于在云端就可以玩（演示）rust 代码的服务。cargo play 也起到同样的功能，但是是在本地，这样，本地不用创建一个 cargo 工程就可以快速看到代码效果了（节约了两分钟）。Repo: https://github.com/fanzeyi/cargo-play"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/fanzeyi/cargo-play"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-22 21:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo-play - 本地用的 Rust Playground"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者的物理学PhD论文是关于偏振研究的，他写了一个库来进行模拟计算。这个库也可以算作是小规模科学计算的尝试。作者的心路历程在这里：https://tinkering.xyz/polsim/祭图镇楼：Repo: https://github.com/zmitchell/polsimhttps://github.com/zmitchell/polarization"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/zmitchell/polarization"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-22 21:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"polsim - 物理偏振模拟库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Libra 核心开发者 bmwill，在 libra 的论坛上总结了这篇帖子，讲了为什么在 libra 中直接上 async/await 的心路历程：缘由，过程，体会，仍然存在的不足。强烈推荐看原文。Read More: https://community.libra.org/t/async-await-in-libra-core/1566"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://community.libra.org/t/async-await-in-libra-core/1566"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-22 21:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Libra 中使用 async/await 的心路历程"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这个库可以用来打开树莓派摄相头，然后拍一张照存储到磁盘上。Repo: https://github.com/pawanbisht62/raspicam"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/pawanbisht62/raspicam"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-22 21:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"raspicam - 控制树莓派 webcam 的库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"mozilla 的工程师太激进了。这次由美女工程师 Lin Clark 写一一篇万字长文，设想并描述了一个新的中间组件：WebAssembly Interface Types。这个东西一时半会儿讲不清，我上三张图大家一下就明白了：远古时代近代未来容小编来瓶雪碧压压惊。万字长文，强烈推荐。Read More: https://hacks.mozilla.org/2019/08/webassembly-interface-types/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://hacks.mozilla.org/2019/08/webassembly-interface-types/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-22 21:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Mozilla 万字长文：WebAssembly Interface Types - 万物互操（作）"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Raph Levien 就是 Google 那位 Xi Editor 的主要作者。据小编观察，这是一位很有思想的人。最近他决定接收一个 pr，这个pr（与国际化/本地化相关） 会使编译时间增加 3 倍，编译后的大小增加  2 倍。他说，一个编辑器没有国际化本地化的话，就是一个玩具，所以他必须接受这个pr。但是接受这个 pr 的代价，让他心生不悦。于是，开始了哲学思考。这个问题其实我们经常会碰到。强烈建议阅读一下作者的思考，也许会对你有所启发。Read More: https://raphlinus.github.io/rust/2019/08/21/rust-bloat.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://raphlinus.github.io/rust/2019/08/21/rust-bloat.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-22 21:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Raph Levien 在 Rust 膨胀上的思考"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我觉得对我们还是有用的，可以关注一下。Read More: https://internals.rust-lang.org/t/update-on-rust-crates-io-and-us-economic-sanctions/10834\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://internals.rust-lang.org/t/update-on-rust-crates-io-and-us-economic-sanctions/10834"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-22 21:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"sgrif 发起的关于美国经济制裁对 Rust 和 crates.io 影响的一些讨论"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #stable目前，相关的PR已被合并。Read More: https://github.com/rust-lang/rust/pull/63209#issuecomment-523113079"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rust-lang/rust/pull/63209#issuecomment-523113079"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」async_await将在Rust 1.39稳定版中发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async_std并打算在2019年9月26日前发布1.0版。该库附带了一本书和完善的应用编程接口文档，并将很快提供一个稳定的接口来支持异步库和应用程序。虽然我们在1.0版本之前没有承诺过应用编程接口的稳定性，但是我们也不期望做出任何突破性的改变。该库由Rust异步生态系统工作组成员 stjepang 开发，他也是crossbeam的主要开发者，同时也供职于Rust咨询公司Ferrous Systems。\nRead More: https://async.rs/blog/announcing-async-std/\nBook: https://book.async.rs/\nDocs: https://docs.rs/async-std/0.99.3/async_std/\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"宣告：async-std 异步标准库的测试版"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#Go #C #performance基于问题：对于给定的图像，在图像中找到流行的颜色，这样用户就可以根据它的颜色来浏览图像。使用算法：histogram最终测试结果：结论：在实现高效算法方面，Rust似乎处于最佳状态。它不会在抽象之中隐藏任何东西，你仍然可以像Go一样高效开发。\nRead More: https://medium.com/@marek.michalik/c-vs-rust-vs-go-performance-analysis-945ab749056c\nhistogram算法： https://spin.atomicobject.com/2016/12/07/pixels-and-palettes-extracting-color-palettes-from-images/\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"性能测评： C vs Rust vs Go"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#cpu #atomics #ordering本文简要地解释了CPU内存顺序是如何工作的，以及它们是做什么的，这对于理解Rust中的原子类型和Mutex锁比较重要。Read More: https://fy.blackhats.net.au/blog/html/2019/07/16/cpu_atomics_and_orderings_explained.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://fy.blackhats.net.au/blog/html/2019/07/16/cpu_atomics_and_orderings_explained.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"CPU原子和顺序解释"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#linear #algebraglam是一个用于游戏和图形的简单快速Rust线性代数库。mathbench是一组单元测试和基准测试。性能相比于cgmath和nalgebra，有一定的优势。并且有SIMD支持。\nRead More: http://bitshifter.github.io/2019/07/10/introducing-glam-and-mathbench/\nGlam: https://docs.rs/crate/glam/0.7.1\nMathbench-rs: https://github.com/bitshifter/mathbench-rs\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"介绍Glam和Mathbench"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#CompilerTeam该网站记录了Rust官方编译器团队的一些活动记录、文档、会议等信息，感兴趣的可以关注。Read More: https://rust-lang.github.io/compiler-team/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://rust-lang.github.io/compiler-team/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」Rust编译器团队活动页"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tips #fun<_>::v::<_> 像个猫头鹰（面试题 +1）原始代码：网友改进：你看懂了吗？HinT:Read More: https://chrismorgan.info/blog/rust-artwork-owl/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://chrismorgan.info/blog/rust-artwork-owl/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"<_>::v::<_>： 一件有趣的Rust「艺术品」"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#openAI\nRepo: https://github.com/MrRobb/gym-rs\ngym: https://github.com/openai/gym\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"gym-rs: OpenAI gym的Rust绑定"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#CoverageReport #CI #review本文教你一种使用覆盖率报告阅读项目源码的方法，以alacritty的代码为示例，使用kcov来说明。\nRead More: https://www.joshmcguigan.com/blog/coverage-reports-code-reading-tool/\nalacritty: https://github.com/jwilm/alacritty\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"测试覆盖率报告作为代码阅读工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#actix #multipart是对actix-multipart的包装，方便使用Repo: https://crates.io/crates/awmp"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://crates.io/crates/awmp"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"awmp：用于在actix-web中处理文件上传"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#functional #3D #HomotopyMap什么是同伦（Homotopy）映射?同伦是两个函数之间的连续变形。考虑将两个函数f和g与一个在0和1之间的参数结合起来，这样把参数设为0就得到f，把参数设为1就得到g。换句话说，它让你可以在函数之间平滑地插值。这个库使用了一个简化的同伦版本，用于构建三维几何。Repo: https://github.com/pistondevelopers/construct"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/pistondevelopers/construct"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"construct: 一个用同伦映射构造三维几何的高阶函数编程库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#react #yew #wasmRepo: https://github.com/hobofan/yew-react-example"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/hobofan/yew-react-example"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一个Yew使用react组件的示例"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#cargo #registryRepo: https://github.com/mcorbin/meuse"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/mcorbin/meuse"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Meuse: 一个免费的Rust私有Cargo注册仓"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#git用于在shell提示符中显示关于Git仓库的信息Repo: https://github.com/glfmn/glitter/tree/v0.2.0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/glfmn/glitter/tree/v0.2.0"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Glitter: 漂亮地输出Git仓库状态信息"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async官方在稳定Rust异步async/await的过程中，解决了很多问题。其中之一是从异步到状态机的转换，目前不是最优的方法。所以，这导致状态变得比需要的大得多。由于状态大小实际上是超线性增长的，所以当状态大小增长超过正常系统线程的大小时，可能会触发实际栈上的栈溢出。该文作者过去几个月主要是解决这个问题，他写下这篇文章来告诉大众该问题的优化过程。好事多磨。\nRead More: https://tmandry.gitlab.io/blog/posts/optimizing-await-1/\n相关issues： https://github.com/rust-lang/rust/issues/52924\n相关issues： https://github.com/rust-lang/rust/issues/62149\n\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-21 11:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「系列文章」Rust中如何优化async/await Part I"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"LacneQin"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rezolus是一种收集详细系统性能遥测数据，通过高分辨率的遥测技术探测突发情况的工具。Rezolus不仅能够监测基本系统指标，还提供了性能计数器和对eBPF（extended Berkeley Packet Filter）遥测的支持。测量是提高性能的第一步。twitter/rezolushttps://github.com/twitter/rezolus举一个现实世界的例子：当你去一些快餐店时，一旦你订购，你会得到一张餐券（占位符），一旦你的用餐准备好，你就可以得到实际的食物（future）。使用占位符来热reload资产和代币：read morehttps://www.reddit.com/r/rust/comments/csm2jn/return_a_future_with_a_placeholder_value_to_use/用于Rust的GDB远程串行协议服务器，该项目旨在搭建一个简单的GDB服务器，能够运行在Rust重写的x86_64体系结构上运行的Linux和Redox。Redox OS内部机制还没有实现，但是一旦Linux运行起来它应该很容易。一个用Rust编写的gdbserver替代方案半成品https://gitlab.redox-os.org/redox-os/gdbserver\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-20 22:17"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust将底层控制，卓越性能和现代构建工具相结合，使其成为游戏开发人员的一个令人兴奋的选择。 多年来，多次提出了一个支持这个新兴社区的工作组的想法，我们很高兴地宣布，一个团队终于成立了！我们的章程列出了两个主要目标：\n改善Rust游戏开发者的体验。\n为不是游戏引擎开发人员的人分享更多的知识降低他们的上手难度\n原文文章：https://rust-gamedev.github.io/2019/08/18/introducing-the-rust-game-development-working-group"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://rust-gamedev.github.io/2019/08/18/introducing-the-rust-game-development-working-group"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-19 21:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust游戏开发工作组成立了！（非官方）"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"System76一直在开发一个简单易用的工具来更新Pop!_OS和System76硬件。今天终于发布了，该工具可以通过设置检查和更新固件上的Pop!_OS并通过固件管理器GTK应用程序在System76硬件上运行其他基于debian的发行版。文章：https://blog.system76.com/post/187072707563/the-new-firmware-manager-updating-firmware-across"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.system76.com/post/187072707563/the-new-firmware-manager-updating-firmware-across"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-19 21:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"System 76 发布了用Rust编写的新GTK固件管理器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"TiSpark 是 PingCAP 为解决用户复杂 OLAP 需求而推出的产品。它借助 Spark 平台，同时融合 TiKV 分布式集群的优势，和 TiDB 一起为用户一站式解决 HTAP (Hybrid Transactional/Analytical Processing) 的需求。TiSpark 依赖于 TiKV 集群和 Placement Driver (PD)，也需要你搭建一个 Spark 集群。该版本主要添加的特性：\n修复表扫描中的成本模型\n修复固定索引Bug\n通过双读下推来禁止聚合或分组\n修复了HDP版本的反射错误\n修复scala编译器版本\nGitHub：https://github.com/pingcap/tispark"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/pingcap/tispark"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-19 21:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"TiSpark v2.1.3 - TiSpark 是 PingCAP 为解决用户复杂 OLAP 需求而推出的产品"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该项目是用Clojure编写的Rust私有仓库项目，并提供了API来管理用户、Token、类别，目前处于alpha状态，尚未准备好用于生产，谨慎使用。该版本主要添加的特性：\n新的API\n修复了很多小问题\n集成测试\n改进搜索\n添加了healthz端点\n更换数据库连接池为HikariCP\n更多\nGitHub：https://github.com/mcorbin/meuse"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/mcorbin/meuse"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-19 21:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Meuse v0.1.0 - 免费的私人Rust Registry"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在过去的TiDB一周合并了41个PR，TiKV合并了31个PR，具体细节可阅读原文文章：https://pingcap.com/weekly/2019-08-19-tidb-weekly/#weekly-update-in-tikv-and-pd\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://pingcap.com/weekly/2019-08-19-tidb-weekly/#weekly-update-in-tikv-and-pd"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-19 21:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"PingCAP 周报"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者在研究一个科学应用，有时需要在非常大的图像上面进行操作，在作者目前的Pyhton工作版本中，对于大图像的处理很慢，最后作者得出测试Rust要快很多。使用Python中的time模块和Linux for Rust上的time命令进行测量GitHub : https://www.reddit.com/r/rust/comments/crkz3y/is_the_rust_image_library_faster_than_python/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/crkz3y/is_the_rust_image_library_faster_than_python/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-18 18:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Image比Python Pillow更快吗？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Ruffle是一种用Rust编程语言编写的Adobe Flash Player模拟器。 Ruffle使用WebAssembly来定位桌面和Web，项目目前处于概念验证阶段，目前只可以运行早期Flash动画。GitHub : https://github.com/ruffle-rs/ruffle"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/ruffle-rs/ruffle"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-18 18:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"ruffle - 用Rust写的Flash Player 模拟器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该项目是使用Rust实现的命令行工具，用于分析SQL中的日志文件目前处于alpha阶段，作者欢迎大家PR目前支持的格式有:\nAWS经典弹性负载平衡器\nSquid 原生格式 （初步支持）\nGitHub : https://github.com/MnO2/logq文章: https://blog.paulme.ng/posts/2019-08-16-logq---analyzing-log-files-in-sql-with-command-line-toolkit%2C-implemented-in-rust.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.paulme.ng/posts/2019-08-16-logq---analyzing-log-files-in-sql-with-command-line-toolkit%2C-implemented-in-rust.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-18 18:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"logq - Rust实现的命令行工具，用于分析SQL中的日志文件"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这个工具是cargo的一个扩展，使用它可以通过命令行的方式修改Cargo.toml文件来进行添加、删除和升级依赖。该版本新增的特性如下：\n现在可以通过cargo add 的--sort选项来顺序添加依赖\ncargo add 和cargo upgrade 支持离线模式了，只需要添加选项--offline\nGitHub :  https://github.com/killercup/cargo-edit"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/killercup/cargo-edit"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-18 18:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo-edit v0.4 - 用于从命令行依赖关系的实用扩展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Graphlib是一个使用Rust实现的图库，该项目提供一个通用API，用于构建，变异和迭代图形，类似于Rust中的其他数据结构，即Vec，HashMap，VecDeque等。该版本新增的特性如下：\n增加了Graph::tips迭代器\n性能优化\nGitHub : https://github.com/purpleprotocol/graphlib/releases"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/purpleprotocol/graphlib/releases"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-18 18:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"graphlib v0.4.0 - Rust的简单但功能强大的图形库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"yuequan1997"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Surf是一个使用Rust实现的友好HTTP客户端， 它是完全模块化的，使用async / await构建， 无论是快速脚本还是跨平台SDK，Surf都能让它发挥作用。GitHub : https://github.com/rustasync/surf\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rustasync/surf"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-18 18:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"surf - 友好的HTTP客户端"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustChaos: 今天刚看到Facebook内部meetup流出的Slides，原文标题很有意思：Bringing Rust Hometo Meet the Parents （带Rust去见父母）。该分享主要是讲了Facebook引入Rust的过程，我也没有看过Meetup的内容，只是想通过Slides来解读并还原一下Facebook引入Rust的历程。https://zhuanlan.zhihu.com/p/78549374Read Morehttps://docs.google.com/presentation/d/1RLNyr3riO2LyqQsMAOvMMyGTllhx1wPmfkXXcbtOB00/edit#slide=id.p"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://zhuanlan.zhihu.com/p/78549374"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-17 20:18"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Facebook内部meetup流出：Rust如何走进Facebook"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust@heavypackets 用emoji学习Rust Iterator，下面是其中一个例子。https://github.com/heavypacketsRead Morehttps://github.com/heavypackets/rust-iterator-emoji"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-17 20:18"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用emoji学习Rust Iterator"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#asyncasync-rs组织今日发布了一篇博客，介绍了他们开发的 async-std beta版本，下面是标准库读文件和async-std读取文件的代码示例对比，热泪盈眶呀！https://github.com/async-rsRead Morehttps://async.rs/blog/announcing-async-std/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-17 20:18"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"async-rs 在重写异步标准库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust@hsiaosiyuan0用Rust实现JavaScript引擎来学习Rust，对于喜欢JavaScript又喜欢Rust的人来说，这真是个两不误的绝佳方式，点赞👍。https://github.com/hsiaosiyuan0Read Morehttps://github.com/hsiaosiyuan0/naive"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-17 20:18"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用Rust实现js引擎来学习js"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust@Herschel使用Rust+Wasm开发的 Flash Player模拟器。https://twitter.com/Herschel/Read Morehttps://github.com/ruffle-rs/ruffle"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-17 20:18"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust开发的Adobe Flash Player 模拟器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust@ly.lee介绍了他使用vscode开发的可视化嵌入式开发程序的经验。只需要安装一个插件，即可在vscode中通过拖动Block，生成嵌入式开发的代码。https://medium.com/@ly.leeRead Morehttps://medium.com/@ly.lee/visual-embedded-rust-programming-with-visual-studio-code-1bc1262e398c"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-17 20:18"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用vscode可视化Rust嵌入式开发"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustLinux驱动的嵌入式或物联网系统上的设备驱动程序在内核空间中执行，因此必须完全受信任。 驱动程序中的任何错误都可能会对整个系 但是，第三方嵌入式硬件制造商通常会使用其嵌入式设备发布其专有设备驱动程序。 由于缺乏代码审计，这些树外设备驱动程序通常质量较差。因此他们提出了一种方法，可以帮助第三方开发人员在不修改内核的情况下提高设备驱动程序的可靠性和安全性：使用名为Rust的内存安全编程语言重写设备驱动程序。Read Morehttps://github.com/lizhuohua/linux-kernel-module-rust\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-17 20:18"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"百度x-lab发布了一个用Rust编写Linux内核模块的框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\n現在可以使用 type 製作別名\n\n而在實作（实现）函數中 Self 可以當成目前結構的別名\n\n現在可以有匿名的變數在巨集（宏）中\n首先編譯時 rustc 加入  -C profile-generate然後執行這個程式跑一跑你的測試資料後會產生記錄檔再來第二次編譯 rustc 加入  -C profile-use會根據你剛剛跑的結果來最佳化編譯https://doc.rust-lang.org/rustc/profile-guided-optimization.html\n現在將編譯出執行檔做為預設(缺省)行為\n如果你沒打 --bin 也可以編\nenum 也可以對齊了\n\n下面的函數穩定了\nread morehttps://blog.rust-lang.org/2019/08/15/Rust-1.37.0.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-16 19:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 1.37.0 稳定版已发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"任天堂也用Rust了。這是任天堂的 rust tool chain跟庫的集合這些庫還不成熟，還在開發中，非常需要有時間的人幫忙開發歡迎大家的加入\nreddit 讨论\nGitHub Org: https://github.com/rust-wii/\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-16 19:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Grand Star v0.6.0"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"damody"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\n現在html <div class=\"marker\" /> 可以使用/>來對tag做描述，\n現在 SVG 命名空間可以使用\nProperties 可以被整合編譯\n詳細請看 changelogread morehttps://github.com/yewstack/yew/releases/tag/0.8.0\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-16 19:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Yew v0.8"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这不是闹着玩儿的操作系统了，这可是面向商业的正式的操作系统（一个 Linux 发行版）。官网地址在这里https://system76.com/pop他们用 Rust 实现了下面这些：`firmware daemon, firmware manager, firmware itself, a multi-USB flasher, power daemon, upgrade daemon, distribution installer, disk manager, etc```而且，显得特别兴奋。还会继续写更多组件的。Repo: https://github.com/pop-os/system76-power"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/pop-os/system76-power"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-15 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"system76-power - system76 操作系统使用 Rust 写了很多组件"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这个东东类似于 include_bytes!/include_str!，但是它在编译时不展开，而是在运行时再展开，因此特别适用于那些对体积要求严格的程序。Repo: https://github.com/SOF3/include-flate"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/SOF3/include-flate"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-15 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"include-flate - 又一个黑魔法"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"从此，可以用 Rust 读写 Warcraft III 地图格式了。开不开心。Repo: https://github.com/ElusiveMori/ceres-mpq"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/ElusiveMori/ceres-mpq"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-15 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"ceres-mpq - Blizzard 的 MoPaQ (MPQ) 包格式读写库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"tokio 官方写的，讲了为什么在异步环境下，日志的搜集和处理有什么不同。导致了 tokio-tracing 库的出现。强烈推荐阅读。https://github.com/tokio-rs/tracingRead: https://tokio.rs/blog/2019-08-tracing/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://tokio.rs/blog/2019-08-tracing/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-15 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"重要文章：为什么我们需要一个异步 tracing 库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"NVIDIA PhysX 是一个成熟的物理碰撞（检测）库。这个加是对其的绑定。Rust 社区中，还有另外一个  nphysics 库，但是还不够成熟。https://www.nphysics.org/Repo: https://github.com/EmbarkStudios/physx-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/EmbarkStudios/physx-rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-15 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"physx-rs - NVIDIA PhysX 库的绑定"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"可生成 TypeScript GraphQL 代码。Repo: https://github.com/notarize/qlc/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/notarize/qlc/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-15 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"qlc - GraphQL 代码生成库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"tokio 发布了 0.2.0 alpha1。小编今天看了一下，hyper 也已经跟进了。大家快来跟进吧，早跟早受益。反正小编的使用体验就是两个字：很爽！"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-15 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"欢迎使用最新的 async/await"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"酷炫不。Repo: https://github.com/JoshMcguigan/maze\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/JoshMcguigan/maze"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-15 23:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"maze - 用 Rust 实现一个迷宫"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#StdExtendRepo: https://github.com/sivadeilra/vec_option"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/sivadeilra/vec_option"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"VecOption: 与Vec<Option>等价但更高效的库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#macro #synSyn 和 Quote 此次 1.0 稳定，意味着API接口稳定，但是，并不代表着Rust的语法树稳定。Syn和Quote内部还是会随着Rust的变化而改动，只不过不会影响 Syn 和 Quote 的 API稳定。注意： Syn和Quote的1.0版本最低依赖Rust 1.31版本。发布日志里还记录了一些Break change，需要注意。Read More: https://github.com/dtolnay/syn/releases/tag/1.0.0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/dtolnay/syn/releases/tag/1.0.0"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Syn 和 Quote 1.0 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#docsDash和Zeal都是著名的编程语言文档集工具Repo: https://github.com/Robzz/cargo-docset"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/Robzz/cargo-docset"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cargo-docset: 可以生成支持Dash和Zeal的文档集"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #stream #tokioRepo: https://github.com/tokio-rs/async-stream"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/tokio-rs/async-stream"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"async-stream: 提供了stream!宏方便编写异步流"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#stackoverflow问题：下面代码当 CAPACITY >= 240 的时候，与 CAPACITY >= 239 相比，性能慢了80倍。Rust编译器专门为240以内的长度做了优化？ 使用 rustc -C opt-level=3 进行编译。解答：总结：低于240，LLVM完全展开内部循环，可以优化掉重复循环，增加性能。分析：这是一个神奇的阈值，超过该阈值LLVM将停止执行某些优化。阈值是 8字节* 240 = 1920字节 (数组是usizes数组，因此长度乘以8字节，假设 x86-64 CPU)。在该问题中的基准测试中，是仅针对长度239执行的一个特定优化，所以导致了巨大的性能差异。比如这段代码：你在 godbolt 编辑器中查看生成的汇编代码，比较240和239，会发现有很大区别。比如当239的时候生成：https://rust.godbolt.org/z/VKL9MS就是所谓的循环展开: LLVM将循环体粘贴一段时间，以避免执行那些“循环管理指令”，即循环变量的增量，检查循环是否结束和跳转。（可以自行对比一下240的输出）。但是，即便循环不展开，也不会造成80倍的性能差异。所以，实际上那个性能测试代码嵌套循环导致的（LLVM生成的代码基本上首先只执行内部循环(计算总和)，然后通过多次累加总和来模拟外部循环！）。最好要使用Rust的惯用法： arr.iter().sum()，这样就不会产生80倍的性能差异了。Read More: https://stackoverflow.com/questions/57458460/why-is-there-a-large-performance-impact-when-looping-over-an-array-over-240-elem"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://stackoverflow.com/questions/57458460/why-is-there-a-large-performance-impact-when-looping-over-an-array-over-240-elem"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「SO问答」对超过240个元素的数组进行循环时，为什么会有很大的性能影响？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#Stable新版本中有一些新特性：\ncfg 和 cfg_attr 中可以用泛型参数了\n可以对枚举值使用类型别名了\n\n可以用_来定义常量：const _: u32 = 5;\nRust 2015 edition 的宏现在支持 ?语法\nmem::MaybeUninit和T已经实现ABI兼容，MaybeUninit共享T的大小、对齐方式和ABI。\n1.37 Release Notes: https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1370-2019-08-15"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1370-2019-08-15"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 1.37 预发布测试"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#Facebook该贴主提到，他看了Facebook工程总监在CppCon 2017的分享，其中谈到Facebook中经常出现的Bug，他认为，这些Bug是用Safe Rust完全不会写出来的Bug。以下是这些bug的概述:\nBug #1: 越界访问。C++的std::vector的索引运算符不进行边界检查。演讲者称之为“可能是每个代码库中问题的最大原因”。Rust's Vec总是进行边界检查，除非您使用Unsafe。\nBug #2: 如果你搜索的关键字不在map中，那么std::map的索引运算符将创建一个默认元素。真奇怪。Facebook发生了两起重大事故，Map显示了一些设置，打印设置时偷偷插入了值为0的新设置。Rust的哈希映射不可能做到这一点。要在Rust中获得这样的行为，您必须使用entry() API对其进行显式编程。\nBug #3: 试图避免不必要的复制通常会导致对已经不存在的临时成员的引用（悬垂指针）。C++没有借用检查器来检测这一点。Rust会。\nBug 4: volatile。它不会使代码线程安全，但是人们还是这样使用它。Safe Rust根本没有volatile。\nBug 5: std::shared_ptr线程安全吗？是像Rc还是像Arc？嗯，这很复杂。它很像Arc，但是如果你实际上在多线程环境中使用它，你仍然有可能出错。Rust既有rc又有Arc，它会阻止你将Rc发送到不同的线程。\n赠送的Bug : 人们经常解引用std::shared_ptr，并在不保留std::shared_ptr的情况下对结果进行引用。Rust的借用检查在这里拦住你。\nBug #6: 由于C++语法中的一个怪癖，很容易编写看起来像std::mutex的代码，但是实际上它正在创建一个与std::mutex同名的std::unique_lock，隐藏它但不锁定它。这里真正的问题是，在C++中，std::mutex没有连接到它所保护的数据，而在Rust中，如果不锁定它，就根本不可能访问受Mutex<T>保护的数据。\n附送的Bug : 在C++中，很容易意外地对事物进行深度复制(Clone)。演讲者和听众中的一个人理所当然地指出，这真的没什么大不了的，事实上，许多bug(见bug #3)都是通过避免不必要的拷贝而引入的。尽管如此，Rust在这里对你也有帮助，因为如果你想克隆一些东西，你通常需要显式地做。\n附送的又一个bug:“我们有很多与异步编程相关的生命周期问题，”演讲者说。他称之为“非常关键”和“最重要的缺陷之一”。如果说Rust擅长什么，那就是“与异步编程相关的生命周期问题”。\n演讲中从未提到Rust，但如果里面提到Rust的话，该演讲就是Rust最好的广告了 ：D（Libra 选择 Rust，某种意义上，可能也是苦C++久矣）\nRead More: https://www.reddit.com/r/rust/comments/cq9rco/cppcon_2017_curiously_recurring_c_bugs_at_facebook/\nCppCon 2017 视频 ： https://www.youtube.com/watch?v=lkgszkPnV8g\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Reddit讨论：CppCon 2017 - 在Facebook上反复出现的 C++ bug"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tnefTNEF 以 application/ms-tnef 类型的 MIME 附件的形式出现在邮件中。Repo: https://github.com/newpavlov/tnef"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/newpavlov/tnef"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"tnef: 一个纯Rust的 TNEF 解析器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#android头一次知道还有这个AppRead More: https://play.google.com/store/apps/details?id=com.bmco.cratesiounofficial&hl=en_us"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://play.google.com/store/apps/details?id=com.bmco.cratesiounofficial&hl=en_us"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「非官方」Google Play市场的 Crates.io 安卓App 已经更新到了1.5版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async供学习使用Repo: https://github.com/Byron/github-star-counter"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/Byron/github-star-counter"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust异步编程尝试：GitHub star计数工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#git自动生成 CHANGELOG.mdRepo: https://github.com/rustic-games/jilu"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rustic-games/jilu"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Jilu: 根据Git仓库的状态生成改变日志"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tokiotokio-i3ipc的作者写了篇文章记录了此事，也算是一个升级参考。\nRead More: https://leshow.github.io/post/async_await/\nRepo: https://github.com/leshow/tokio-i3ipc/\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"tokio-i3ipc更新到了async/await"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#assert该库可以实现编译时断言。Repo: https://github.com/nvzqz/static-assertions-rs\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/nvzqz/static-assertions-rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-14 22:49"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"static-assertions-rs 发布 0.3.4 版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustRust安全、高性能等优点吸引到很多优秀的开发者和公司将原有项目的部分或全部用它重写，下面是知乎上关于该问题的回答，如果你有重写的经验和想法，欢迎分享。CPU+内存密集型的应用，比如数据压缩领域的gzip、bzip2、xz 等等。我已经把自己的数据压缩应用orz用rust重写了（https://github.com/richox/orz），整体上来看，当前的rust性能已经完全匹敌c/c++，而且开发过程释放了大量脑力，涉及到对内存精细操作的地方不再需要像c/c++那样心惊胆战，也不需要处理c++的长篇编译错误，编译通过基本上就不会再出异常了。这个项目可以做为rust性能的一个实战验证，目前压缩速度快于gzip、压缩率高于bzip2，在整个压缩领域已经处于pareto frontier 的位置了。——知乎作者 鱼你太美类似OpenSSL这样的基础软件，几乎已经成了事实上的标准，大家都在用都依赖，堆积了差不多20多年的C代码，据说里面各种古怪的旧代码，奇怪的东西。其实可以考虑重写了的。不过假如重写了之后，原来的攒了20年的OpenSSL的兼容性应该是会丢了，也就不是OpenSSL了。其实以Rust写的目标是替换或者兼容OpenSSL的项目是有的，而且在慢慢的发展。这种东西不是一天两天能完成替换或者取代的。——知乎作者 杨小小小小小明推荐阅读知乎上另一个讨论【如何看待Rust应用前景？】https://www.zhihu.com/question/30407715/answer/48032883Read Morehttps://www.zhihu.com/question/305486448/answer/772421721"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/richox/orz"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-13 21:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"哪些软件应用值得用Rust重写？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#cratestarship 是一个非常小、极快shell的提示，可以定制，并且支持任何shell。Read Morehttps://github.com/starship/starship"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-13 21:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"starship 一个小而美的shell提示工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustwasm日报曾经发过这个项目，后来发现作者开发过程中的一些疑问都得到了回答，推荐给正在用rust开发wasm项目的小伙伴看看。\nLarge wasm file sizes, potential causes, and how to avoid them?\nIs there a better way to store global state?\nIs there a better or faster way to send text from Rust to js?\nHow do you send text from js to Rust?\nRead Morehttps://github.com/jakedeichert/wasm-astar/issues"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-13 21:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"wasm-astar rust+wasm实现的迷宫"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustwasmblurhash可以将编码后的图像数据通过canvasContext2D.putImageData绘制在canvas画布上。目前该项目还未完成，希望以后能加上benchmark。Read Morehttps://blurhash-wasm.netlify.com/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-13 21:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"blurHash rust+wasm实现的blurhash算法"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#wasmwasm 是一个WebAssembly 包管理工具，可以安装、管理、发布WebAssembly项目。Read Morehttps://github.com/wasmerio/wapm-cli\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-13 21:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"wapm —— WebAssembly 包管理工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tokio新版本支持async/awaitRead More: https://tokio.rs/blog/2019-08-alphas/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://tokio.rs/blog/2019-08-alphas/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Tokio alpha 版发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#fullstack这篇文章比较系统的介绍了Yew、ws-rs（websocket）、serde等工具使用Rust编写一个Chat Web App。Read More: https://www.steadylearner.com/blog/read/How-to-write-Full-Stack-Rust-code"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.steadylearner.com/blog/read/How-to-write-Full-Stack-Rust-code"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何写全栈Rust代码"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#gfxgfx-rs并不是纯Rust编写。它依赖的一个复杂而重要的组件是用C和C++的混合语言编写的: SPRIV-Cross。它一个着色器翻译库，由 @TheMaister 和一些 Khronos 成员开发，虽然不是 Khronos 的官方产品，但需要它从SPIR-V源生成特定于平台的着色器。它有一个测试套件，它的后端主要由MoltenVK开发和使用。SPRIV-Cross 在我们的性能报告中出现了很多次(例如在Dota2上)。它的编写方式也与惯用的Rust相去甚远: 代码更喜欢大的可变数据结构，这使得它很难模块化、测试、优化，尤其是在C/C++ FII之后进行交互。虽然它发展很快(就贡献而言)，但它在使用高级后端功能方面限定了我们可以做什么和不能做什么，例如内嵌、参数缓冲区等。它使我们的构建过程变得复杂，尤其是在需要单独的Emscripten构建(Rust代码不需要)来生成WASM模块的网络上，成为开发人员和用户的一个痛点。所以，gfx-rs团队认为，是时候攻克gfx-rs中C++代码的最后一个堡垒了。标杆项目就是关于“飞出墙外的SPIR”（A SPIR that flies above the garden walls，意指，被扔出去了。。。）。这是一个非常复杂的软件，我们还没有取得很大进展。然而，我们再次感到Rust是着色器翻译工作的最佳工具: 它是关于解析的，处理字节和数据结构，具有进行单元和模糊测试的能力，并且没有外部依赖性。Read More: https://gfx-rs.github.io/2019/07/13/javelin.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://gfx-rs.github.io/2019/07/13/javelin.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"gfx-rs标杆项目开启"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#cpp文章不长，用作者的话来总结：与其把Rust看作是一门语言，倒不如将其看作是一个生态系统。他对Rust这个生态系统未来的成长感到非常excited。\nFacebook用Rust写区块链:  Libra\nGoolge用Rust写操作系统:  Fuchsia\n亚马逊用Rust写虚拟化技术: FireCracker\n微软推，崇业界都应该使用Rust语言。\n看见了吗？ 四大巨头的未来主要核心业务都交给或准备交给Rust了。这也是这个10年Cpp程序员开始学习Rust的原因：未来。Read More: https://blog.aclysma.com/my-first-three-months-with-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.aclysma.com/my-first-three-months-with-rust/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"十年Cpp程序员学了三个月Rust之后的感想"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#HKTRead More: https://gist.github.com/edmundsmith/e09d5f473172066c0023ef84ee830cad"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://gist.github.com/edmundsmith/e09d5f473172066c0023ef84ee830cad"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「跟进」Rust中模拟高阶类型（HKTs）"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#IoT文章里这个类比比较经典（普罗米修斯盗了天火，为世界带来了光明，但与此同时也带来了灾难）：我们本可以用C++重写我们的物联网平台应用。使用C就像用蜡烛照明一样。它的基本属性是众所周知的，它从文明之初就存在了，如果你滥用它，它会让你周围的房子着火。(在这个比喻中，C++将是“所有可以被点燃产生光的东西的集合”。)该文的作者是智能家居系统公司Dwelo的IoT工程师，该文主要罗列了一些Cpp编写嵌入式应用可能拥有的问题。这篇文章为系列第三篇。\nPart III https://medium.com/dwelo-r-d/designing-around-our-flaws-e0fccd7070af\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「系列文章」用Rust重写物联网网关 Part 3: Safe Rust 如何跳过C/Cpp的陷阱"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#discord该项目是从Python到Rust的一个重写项目Repo: https://github.com/Sreyas-Sreelal/Cosmic"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/Sreyas-Sreelal/Cosmic"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Cosmic： 多功能discord机器人"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#GameRust游戏工作组是社区自愿发起的一个组织，这次他们发起调查，是为了更好地支持Rust游戏开发生态，游戏开发者们可以去参与。Read More: https://users.rust-lang.org/t/survey-from-the-rust-game-development-working-group/31270?u=erlend_sh"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://users.rust-lang.org/t/survey-from-the-rust-game-development-working-group/31270?u=erlend_sh"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「社区」Rust游戏工作组的调查"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tokioDocs: https://docs.rs/stubborn-io/0.1.3/stubborn_io/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://docs.rs/stubborn-io/0.1.3/stubborn_io/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"stubborn-io： 对tokio的AsyncWrite/AsyncRead进行了包装"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#wasm由Rust和Wasm实现\nonline demo: https://alugocp.github.io/donut/\nRepo: https://github.com/alugocp/donut\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"可以将任何文件进行Hash然后生成一个甜甜圈图案"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#podcast话题关于Matrix，一个开放和分散的通信协议，以及他在Rust中的实现Ruma。该作者之前也出了视频课程，地址在这里：https://youtu.be/76BE1P8B1UU\nRead More: https://rustacean-station.org/episode/001-ruma/\nRuma: https://github.com/ruma/ruma\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://youtu.be/76BE1P8B1UU"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"PodCast：采访Jimmy Cuadra"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ZhangHanDong"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#reload有些程序运行时间很长。对于这些，重启它们来改变配置不是你愿意做的事情。想象一个网络服务器或数据库服务器。这种东西总是处理大量的查询，重启会杀死所有当前正在执行的查询，这会导致最终用户出错，或者由于某些地方的重试而导致性能不佳。作者的思考：\n需要从一个或多个文件中加载配置\n需要某种触发器来重新加载配置，然而，使用inotify之类的工具监视配置文件更改的做法不是最佳实践\n需要一个手动触发器\nunix守护进程约定是向进程发送一个SIGHUP信号，对于命令行应用程序，此信号意味着终端消失了，你可能想要终止它。unix守护进程没有终端，所以它被重用了。在SIGHUP上，守护程序通常会重新加载其所有配置并重新打开日志文件(这是为了与logrotate集成)\n推荐使用signal-hook来侦听信号，因为信号一般很容易被错误使用，这个库屏蔽了信号使用的大部分问题。\n或者，程序可以通过某种方式发送一些触发重载的RPC命令\n配置文件有三种应用场景：初始化/ 每次都需要加载/ 需要主动更改的配置\n根据上面的思考，作者开发了Spirit框架。但是该框架还有很多工作要完善。（目测该框架会对Rust在自动化运维方向起到促进作用）\nReddit 讨论： https://www.reddit.com/r/rust/comments/couwju/runtime_configuration_reloading/\n原文： https://vorner.github.io/2019/08/11/runtime-configuration-reloading.html\nsignal-hook https://crates.io/crates/signal-hook\nSpirit: https://github.com/vorner/spirit\n\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-12 21:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust项目中如何在运行时重载配置"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust知乎专栏C++工程师的Rust迁移之道继承与组合部分第二篇更新。https://zhuanlan.zhihu.com/c_1139487758685900800\n组合与继承 上\n组合与继承 中\nC++中的多态面临的问题在使用静态派发时，由于完全依赖重载，当编写对应的代码时，很难保证你的类完整实现了调用代码的要求，再加上了深度模版的使用，导致出错信息非常难以阅读；为了解决这个问题C++标准委员会在C++ 20标准中加入了concepts的概念，它可以显式的提出约束，使用的例子可以参见上一篇文章 https://zhuanlan.zhihu.com/p/75755125，而更多的信息，大家可以参见cppreference[2]；在使用动态派发时，由于vptr存在，它会破坏对象本身的内存结构，当你的对象还需要与其他库（特别是C语言编写的库）进行交互的时候，内存结构就会称为一个显著的问题；由于C++是一个非常成熟的语言，而concept又是在下一个标准中才会加入进来的概念，所以对于静态派发和动态派发的约束是完全不一样的语法，而且对于同样的约束，如果我们需要同时使用静态和动态派发的话，必须写两遍（一遍虚基类，一遍concepts）。对于上述提到的3个问题，在Rust中有一个统一的解决方案，那就是trait系统， 更多内容请看正文。Read Morehttps://zhuanlan.zhihu.com/p/76740667"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-11 22:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"C++工程师的Rust迁移之道 组合与集成"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#crateMimbleWimble是一个区块链隐私保护的格式和协议，是一种可以防止区块链泄露个人信息的技术，名字来源于《哈利波特》。grin是MimbleWimble协议的最小实现。Read Morehttps://github.com/mimblewimble/grin"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-11 22:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"grin 一个 MimbleWimble 协议的最小实现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#crateamethyst 是一种数据驱动和面向数据的游戏引擎，旨在尽可能快速且可配置，文档写的很详细，下面是由它实现的两个项目：\nEvoli - 3D, ecosystem simulator\nSpace Menace - 2D, action platformer\nRead Morehttps://github.com/amethyst/amethyst"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-11 22:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"amethyst 面向数据和数据驱动的游戏引擎"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#cratetracing 是一个框架，用于检测Rust程序以收集基于事件的结构化诊断信息。 跟踪由Tokio项目维护，但不需要使用tokio运行时。instrument 属性提供了一种向函数添加跟踪跨度的简便方法。 使用 instrument 注释的函数将在每次调用函数时创建并输入具有该函数名称的span，并使用fmt::Debug将该函数的参数记录为字段。Read Morehttps://twitter.com/mycoliza/status/1159620476823433216"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-11 22:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"tracing 更新"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"makeco"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust最近在用 Rust 玩树莓派，找到了一份比较好的Rust + Raspberry Pi教程。Read Morehttps://github.com/rust-embedded/rust-raspi3-OS-tutorials\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-11 22:11"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 和 Raspberry Pi教程"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Chaos （汉东）今天发起了一项线下活动。如下：为了帮助大家更好的学习Rust，我发起了一个「Rust同城读书学习会」，规则如下：目前北京回龙观群友已经在策划这样的活动，先尝试一段时间看看。想要参与此活动（Rust同城读书学习会）的，请与 Chaos（QQ号：247026628）联系。注意：读书会属于特定主题的线下学习型组织，特点：主题专一（至少某个阶段）/ 每周学习/ 学习报告/   全员产出这点有别于线下Meetup组织，感兴趣者加入。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-10 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"号外：Rust同城读书学习会"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"随着 Rust 蓬勃发展，全国各城市对 Rust 线下 Meetup 的呼声越来越强烈。之前在北京、上海、杭州、成都等地都陆续有一些活动。现在，Rust.cc社区准备把这件事情提上日程，呼吁在全国各城市建立起这样一个个（松散的）Rust线下Meetup组织。有兴趣参与或组织的同学，请与我联系：Mike wx: daogangtang, qq 624910278，全凭志愿。现在已经有如下城市的QQ群/微信群：\n北京\n上海\n成都\n深圳\n南京\n武汉\n广州\n想要加入的，请与Mike联系，同时期待更多的城市建立进来。让我们看到 Rust 星星之火燎原之势。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-10 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"号外：Rust.cc中文社区开始组织全国性的线下分部，寻觅组织者"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"根据 Reddit 上的问答整理的：https://docs.qq.com/doc/DQll1bmZPclJ2UGZT"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://docs.qq.com/doc/DQll1bmZPclJ2UGZT"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-10 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"How does Tokio schedule tasks?"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者又造了一个轮子，因为他用其它JSONRPC的时候，有一点不顺心，所以就换自己喜欢的组合封装了一个新的库，感兴趣的可以了解。Repo: https://github.com/kardeiz/jsonrpc-v2"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/kardeiz/jsonrpc-v2"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-10 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"jsonrpc-v2 - 又一个JSON-RPC轮子"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"只针对这两个进行操作，效率上进行了提速（内部使用 u32/u64 进行存储）。Repo: https://github.com/zbraniecki/tinystr另外一个可以参考的库：https://github.com/rust-analyzer/smol_str"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rust-analyzer/smol_str"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-10 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"tinystr - 只操作长度不超过4或8的ASCII字符串"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"提供多种方式生成随机列表，可用于各种场景。提供：Random，Fairly Random，ShuffleRandom，PlaylistRandom，TrueRandom，Recurrence Interval等。Repo: https://github.com/AberrantWolf/droprate"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/AberrantWolf/droprate"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-10 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"droprate - 一个随机列表生成库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"地址在这里：https://store.steampowered.com/app/1110620/Way_of_Rhea/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://store.steampowered.com/app/1110620/Way_of_Rhea/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-10 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Way of Rhea - Steam 上的游戏，用Rust写的算法引擎哦"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"模糊测试（fuzz testing）是一种安全测试方法，他介于完全的手工测试和完全的自动化测试之间。模糊测试充分利用了机器的能力：随机生成和发送数据；同时，也尝试将安全专家在安全性方面的经验引入进来。从执行过程来说，模糊测试的执行过程非常简单：而 Rust 中提供了集成工具 https://github.com/rust-fuzz/cargo-fuzz例子在这里：https://github.com/fuzzitdev/example-rust"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/fuzzitdev/example-rust"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-10 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"fuzzitdev example - 持续模糊测试平台 fuzzit.dev 的Rust例子"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Mike Tang"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Snapshots tests (also sometimes called approval tests) are tests that assert values against a reference value (the snapshot). This is similar to how assert_eq! lets you compare a value against a reference value but unlike simple string assertions snapshot tests let you test against complex values and come with comprehensive tools to review changes.Snapshot tests are particularly useful if your reference values are very large or change often.学习Rust让小编学到好多新名字，新概念，新术语。长见识了。Repo: https://github.com/mitsuhiko/insta\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/mitsuhiko/insta"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2019-08-10 23:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"insta - Rust 快照测试库"},"type":"text"}],"type":"title"}},]
