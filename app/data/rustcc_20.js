export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一篇 OpenCV 在 Rust 中的使用指导, 非常的详尽.原文链接https://jonte-osterberg.medium.com/rust-and-opencv-bb0467bf35ff" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-14 18:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 和 OpenCV" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个 Rust 编写的 Flappybird.github地址https://github.com/JerzySpendel/flappybird" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-14 18:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 编写的 Flappybird" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "zestors 是 一个简单、快速、灵活的 actor 框架，用于构建健壮的分布式应用程序，深受 Erlang 的启发。刚刚开源.github地址https://github.com/Zestors/zestors" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-14 18:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "zestors: 一个新的 actor 框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rusty-tesseract 是一个 Google Tesseract 的 Rust wrapper.\n为Rust带来所有相关的命令行tesseract功能\n基于tesseract的Python包装器(即https://github.com/madmaze/pytesseract)\n允许测试一个预先训练的tesseract模型，并以不同的格式输出结果，如字符串、边界框、字典或数据帧。\ngithub地址https://github.com/thomasgruebl/rusty-tesseract" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-14 18:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rusty-tesseract: Google Tesseract 的 Rust wrapper" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ctv 是一个用 Rust 编写的高度可配置的树视图可视化命令行工具!github地址https://github.com/angelina-tsuboi/ctv--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-14 18:55" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ctv: 高度可配置的 树视图可视化命令行工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 是一种作为开源项目实现的编程语言。它结合了 C 等系统编程语言的性能和资源效率与 Java 等语言的内存安全性。 Rust 于 2010 年作为 Mozilla 的一个研究项目开始，Rust 1.0 于 2015 年推出。2020 年，对 Rust 的支持从 Mozilla 转移到 Rust 基金会，这是一个由 Amazon Web Services, Inc (AWS) 、谷歌、华为、微软和 Mozilla 合作创建的非营利组织。基金会的使命是支持 Rust 的成长和创新，成员公司从创始的 5 家公司发展到第一年的 27 家公司。在 AWS，Rust 迅速成为大规模构建基础设施的关键。AWS 正在投资 Rust 的可持续性，并认为应该使用这种语言来构建可持续和安全的解决方案。原文链接，https://aws.amazon.com/cn/blogs/opensource/sustainability-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://aws.amazon.com/cn/blogs/opensource/sustainability-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-13 23:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Amazon：Rust的可持续性" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Amos的新作长文，从基础语法开始，涉及：Clone and Copy，锁，死锁，async等。（小编还没看完）博客链接，https://fasterthanli.me/articles/a-rust-match-made-in-hell" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fasterthanli.me/articles/a-rust-match-made-in-hell" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-13 23:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Amos：A Rust match made in hell" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Julia 即将推出安装程序 Juliaup，它由两个二进制文件组成：juliaup 和 julialauncher。juliaup 创建者在 Julia 更新计划中讲述了他为什么用 Rust 编写它。juliaup 本身最初是用 Julia 编写的，然后使用 PackageCompiler.jl 进行编译。但这从来都不是一个真正顺利的体验，原因有很多。生成的二进制发行版非常庞大（几百 MB），这对于一个简单的小型命令行工具来说确实不理想，启动延迟不是很好（不可怕，但不是很好），编译时间真的很长，这一切都只是真的粗糙的。因此，在某个时候，当我已经将 julialauncher 移植到 Rust 时，我也将其余部分也移植了过来。我对这个选择非常非常满意，静态类型，非常不同的错误处理模型等，使其成为科学代码的完全非入门者，但对于像 Juliaup 这样的东西来说，它是一个非常好的匹配（比像 Julia、IMO 这样的动态语言要好得多）。—— juliaup creator: David AnthoffJulia 编程语言，https://julialang.org/Julia 更新计划链接 ，https://discourse.julialang.org/t/plans-for-updating-julia/75880/15https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://discourse.julialang.org/t/plans-for-updating-julia/75880/15" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-13 23:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Juliaup，Rust开发的 Julia 安装程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "随着 NextRoll 越来越多地采用 Rust 编程语言，工程师通常将 Hack Week 用作获得实践经验的机会。另一个流行的选择是开发视频游戏，正如您可能已经猜到的那样，我们经常看到它们在 Rust 视频游戏项目中结合使用。去年，一群人致力于扩展 rpg-cli 游戏。不过，这一次，他们想通过一个可以发挥 Rust 一些优势的项目来提升它的一个档次：低级编程、密集计算和 C 数据互操作性。所以他们决定将经典的Wolfenstein 3D 游戏移植到 Rust。\nhttps://tech.nextroll.com/blog/dev/2022/02/02/rustenstein.html\n链接为 github rust-protobuf 项目，最新提交在 5 天前，文章记录了 rust-protobuf 成立的原因，以及面对的问题，并阐述了将来的计划。\nhttps://github.com/stepancheg/rust-protobuf/blob/master/doc/past-present-future.md\nupdate-informer 是一个主要为使用 Rust 编写的 CLI 工具创建的库，例如 dotenv- linter 、datanymizer。它检查已发布的新版本，并在发现更新时发送通知。update-informer由开源爱好者 Mikhail Grachev 开发。CLI 代表命令行界面——一个命令行程序，它读取您输入的命令并执行请求的操作。一般来说，任何可以通过终端命令使用的程序都属于这一类。\nhttps://evrone.com/update-informer\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-11 23:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "SeaORM 刚刚发布 0.6.0 版本，具有以下新特性：\n支持迁移\n模型中支持 DateTimeUtc 和 DateTimeLocal\n模拟 Join 结果\n支持最大连接生存期选项\nSeaORM CLI 和 Codegen 更新\ncrates.io - sea-orm: https://crates.io/crates/sea-ormWhat's new in SeaORM 0.6.0: https://www.sea-ql.org/SeaORM/blog/2022-02-07-whats-new-in-0.6.0/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.sea-ql.org/SeaORM/blog/2022-02-07-whats-new-in-0.6.0/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-11 00:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SeaORM 0.6.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "JLess 是一个命令行 JSON 查看器，专为阅读、探索和搜索 JSON 数据设计。\n美化输出 JSON 并附加语法高亮。适合在探索外部 API 或调试请求有效载荷时使用。\n展开/折叠对象和数组，有助于掌握 JSON 文档的高级/低级结构。得益于大量受 Vim 启发的命令，探索数据变得轻而易举。\n支持基于表达式的全文搜索。能够在长字符串值中快速查找数据，或者在相同对象键之间跳转。\nGitHub - PaulJuliusMartinez/jless: https://github.com/PaulJuliusMartinez/jlessjless — a command-line JSON viewer: https://pauljuliusmartinez.github.io/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://pauljuliusmartinez.github.io/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-11 00:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "jless：命令行 JSON 查看器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 429: https://this-week-in-rust.org/blog/2022/02/09/this-week-in-rust-429/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/02/09/this-week-in-rust-429/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-11 00:26" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 429" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "kind 和 hvm 的作者由于更新慢而被社区有人批评，感到很愤怒。我TM的做开源这么久了，没有得到一块钱资助，你有什么资格批评。社区今天的热帖，欢迎围观。https://github.com/kindelia/kind最近发生了太多这样的事情，导致很多作者感觉做开源，真的没意思。这其实已经成了一个开源界世界的问题。link: https://www.reddit.com/r/rust/comments/snzu0w/please_keep_in_mind_there_is_zero_funding_for_my/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-09 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "热议帖 － 我TM的做开源没有得到任何资助" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust非常适合写命令行程序，有木有。https://www.oreilly.com/library/view/command-line-rust/9781098109424/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.oreilly.com/library/view/command-line-rust/9781098109424/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-09 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "新书速递－使用Rust开发命令行程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "法国一群人搞的项目，分布式对象存储，S3兼容。理想很美好，为了对抗巨头科技公司的集权。现实还不知道怎样呢。repo: https://git.deuxfleurs.fr/Deuxfleurs/garage" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://git.deuxfleurs.fr/Deuxfleurs/garage" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-09 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "garage - 全球分布式存储项目，rust实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust实现的固件。repo: https://github.com/nviennot/turbo-resin/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/nviennot/turbo-resin/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-09 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "turbo-resin - resin 3D打印机的固件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者使用Rust来开发一个音乐播放程序的前端。尝试了Seed和Dioxus。把使用过程记录了下来。blog: https://blog.urth.org/2022/02/08/my-rust-frontend-experiences/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.urth.org/2022/02/08/my-rust-frontend-experiences/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-09 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我的Rust前端开发经历" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一款经典arcade风格的wave防守游戏。大家去玩玩。Steam link: https://store.steampowered.com/app/1651500/Harvest_Hero_Origins/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://store.steampowered.com/app/1651500/Harvest_Hero_Origins/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-09 23:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Harvest Hero Origins - Rust开发的游戏上线Steam" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Is there some cli program like neofetch written in rust?https://www.reddit.com/r/rust/comments/smpr0n/is_there_some_cli_program_like_neofetch_written/neofetch是一个用bash 3.2+编写的命令行系统信息工具；https://github.com/dylanaraps/neofetch以下是一些使用Rust编写的命令行工具的替代品：\nferris-fetch - A system information tool for Rustaceans.\nfreshfetch - A fresh take on neofetch.\nfsi - FSI (Fetch System Info) cli tool written in Rust.\nmacchina - A system information fetcher, with an emphasis on performance and minimalism.\nonefetch - Git repository summary on your terminal.\nrfetch - A fast and minimal fetch program.\nrsfetch - A WIP rewrite of rsfetch from scratch.\nscrftch - Screenfetch in Rust.\n以下是ferris-fetch的效果：各类语言编写的fetch工具的完整列表：https://beucismis.github.io/awesome-fetch/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://beucismis.github.io/awesome-fetch/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-08 15:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "获取系统信息的命令行工具汇总" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust Lecture Series with Imperial College London's Department of Computing Societyhttps://www.reddit.com/r/rust/comments/smt5ef/rust_lecture_series_with_imperial_college_londons/我很高兴有机会与80多名伦敦帝国理工学院的学生（以及其他大学的一些学生）分享我对Rust的热爱！第一堂课得到了大量反馈，许多人表达了他们对Rust编程语言的新兴趣！明天我将主持第二次讲座，我非常激动！youtube地址：Rust 101 Lecture Serieshttps://www.youtube.com/playlist?list=PL-zQguBgjr2O4d-B9g_b0WYh1fyXr6MMq" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-08 15:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust101: 与伦敦帝国理工学院计算社会系合作的Rust系列讲座" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Puff - a Rust-based CLI tool to store apps' configs in one common place for easy transfer to another machinehttps://www.reddit.com/r/rust/comments/smowot/puff_a_rustbased_cli_tool_to_store_apps_configs/Puff是一个CLI工具，用于管理正在开发的应用程序的配置文件。通常，这些配置与项目的源代码一起使用。由于它们可能包含的密码/密钥，它们通常被排除在版本控制系统之外。Puff管理这些文件并将它们存储在一个公共位置，从而更容易将它们传输到另一台开发机器。你的应用程序通过Puff创建的符号链接访问配置文件。详细使用说明请参考：https://crates.io/crates/puff" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/puff" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-08 15:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Puff——一个基于Rust的CLI工具，用于将应用程序的配置存储在一个公共位置，以便轻松传输到另一台机器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Memory mapped files in Rusthttps://www.reddit.com/r/rust/comments/sn4zl4/memory_mapped_files_in_rust/作为一名Rust新手，作者想在自己的第一个项目中处理一些非常大的二进制文件，读取它们，遍历它们，等等。但是作者在搜索支持内存映射文件的Rust库时发现，memmap有超过700万次下载，但是它已经超过3年没有更新。以下是作者的一些顾虑：其实针对这个问题，RUSTSEC上已经有条目(RUSTSEC-2020-0077)针对这个风险作出了提示，并给出了两个可选的替代开源库:https://rustsec.org/advisories/RUSTSEC-2020-0077.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-08 15:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust中的内存映射文件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "An optimization storyhttps://tinkering.xyz/fmo-optimization-story/作者把物理模拟速度提高100倍。作者用其最好的NumPy技能将其速度提高了4倍，在Rust中进行了一些其他优化后，速度提高了50倍。作者坦言，如果他有两个以上的CPU，速度可能会达到100倍。Rust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-08 15:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个性能优化的故事" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "由 张汉东 老师编写的《Rust 编码规范》更新到 V0.2 ， 欢迎大家持续评审、补充和参考原文链接https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-07 18:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《Rust 编码规范》更新到 V0.2 版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文探讨了 Rust 中的热加载在 windows 和 Linux 上的不同差异.原文链接https://johnaustin.io/articles/2022/hot-reloading-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-07 18:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 的热加载" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "经过4年的设计和开发，我们团队很高兴地宣布CADBase项目正式启动(https://cadbase.rs/)。CADBase设计用于存放图纸和相关材料(标准、供应商、支持文件)的信息。资源的主要部分是包含以下数据的组件页面:\n组件的基本信息、特性和相关文件。\n修改组件的参数和相关文件。\nCAD和其他程序解决方案的文件集。\n组件相关材料信息: 标准、供应商、目录、关键词。\n原文链接https://www.reddit.com/r/rust/comments/slv1d7/announcing_cadbase_platform_we_use_crates_actix/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-07 18:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "CADBase 平台发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rust-protobuf 是作者 7 年前开始的 Rust protobuf 的实现. 在 Rust 中使用过 protobuf的人都知道, 存在着两个实现,一个是 rust-protobuf, 另外是一个 Prost 为基础的其他实现. 两个实现都有各自的优缺点. 作者同时也表达了自己未来对该库的迷茫.也许未来,多个 protobuf 的实现会合并也不一定.原文链接https://github.com/stepancheg/rust-protobuf/blob/master/doc/past-present-future.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-07 18:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-protobuf: 过去,现在和未来" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在异步 tokio 环境中使用类似cron的调度。也可以在一个瞬间安排任务，或者在固定的时间内重复它们。原文链接https://github.com/mvniekerk/tokio-cron-scheduler/releases/tag/0.4--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-07 18:39" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ttokio-cron-scheduler: 0.4 版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Gyroflow是一个应用程序，可以通过使用来自陀螺仪和可选的加速度计的运动数据来稳定您的视频。现代相机在内部记录运动数据（GoPro，Sony，Insta360等），这个应用程序通过使用这些数据稳定了捕获的镜头。它还可以使用来自外部源的陀螺数据（例如，从betaflight Blackbox）。Github 链接，https://github.com/gyroflow/gyroflow#gh-light-mode-only文章链接，https://www.reddit.com/r/rust/comments/skbvqx/announcing_gyroflow_an_advanced_video/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/skbvqx/announcing_gyroflow_an_advanced_video/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-05 20:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "宣布Gyroflow - 用GPU加速和跨平台UI用Rust编写的高级视频稳定工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust中有一个编译器类型错误，发生在尝试传递返回Result类型的闭包时。如何解决这个问题的线索已经在错误消息中了——我们需要添加类型注解。但为什么会这样？假设你有一个Wrapper，它在执行时接受一个闭包:文章链接，https://blog.aloni.org/posts/rust-turbofish-closure-return-type/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.aloni.org/posts/rust-turbofish-closure-return-type/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-05 20:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Turbofis：闭包返回类型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我很高兴宣布jotsy - 一个自托管，免费和开源（Apache-2.0）的笔记程序，使用Skytable，Axum和Tokio构建。jotsy最重要的目标是简单，专注于最重要的事情，记笔记。文章链接，https://www.reddit.com/r/rust/comments/skizcp/jotsy_a_selfhosted_notes_app_powered_by_skytable/Github 链接，https://github.com/ohsayan/jotsyhttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0Rustcc论坛: 支持rsshttps://rustcc.cn/微信公众号：Rust语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ohsayan/jotsy" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-05 20:21" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Jotsy:一个由Skytable、Axum和Tokio支持的自托管笔记应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "张汉东老师对 官方异步Rust改进计划博客的翻译。原博客先给出我们在 2024 年应该可以如何使用异步 Rust 的场景，然后再回过头来看看我们对异步 Rust 已经走到了哪一步、还需要完成什么工作。https://blog.rust-lang.org/inside-rust/2022/02/03/async-in-2022.html翻译博客：https://zhuanlan.zhihu.com/p/463908626" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-04 23:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【官方】2022年异步Rust的改进计划" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "预先发布内容详见这里，这次版本有如下要点：https://github.com/rust-lang/rust/blob/8d95b305fa16e693ba7773c6496f568142715770/RELEASES.md\n可以给泛型常量添加默认初始值\n可以在初始化新变量的时候，运用解构的方式来拆开原变量，并将成员转移到被赋值的组成部分\n可以给带有泛型参数的私有类型实现公开的 trait，只要泛型参数收到前述公开 trait 的约束\nasm! 与 global_asm! 宏（对 x86, x86_64, ARM, Aarch64 和 RISC-V 平台的支持）稳定\n--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-04 23:18" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "v1.59.0 待发布内容已经发送了 PR" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ReadMore:https://this-week-in-rust.org/blog/2022/02/02/this-week-in-rust-428/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/02/02/this-week-in-rust-428/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-03 21:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 周报 428" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "《Rust Magazine 中文精选 2021》 坚持了一年，虽然受到社区广大朋友欢迎，但投稿数量不是很理想，所以本来在 2022 年不打算继续维护。然而，一些朋友私聊我说，Rust Magazine 内容不错，值得继续搞，我接受这这个建议，但是从之前的月刊，改为季刊！https://rustmagazine.github.io/rust_magazine_2021/同时，也欢迎大家投稿和贡献！ 可以直接发 PRReadMore:https://github.com/RustMagazine/rust_magazine_2022" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/RustMagazine/rust_magazine_2022" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-03 21:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《Rust Magazine 中文精选 2022》季刊 征稿说明" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nrvv-encode  RISC-V V 扩展指令库\nrvv-asm  RISC-V V 扩展指令过程宏\nrvv-as RISC-V V 扩展指令的命令行工具\nReadMore:https://github.com/TheWaWaR/rvv-encoder" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/TheWaWaR/rvv-encoder" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-03 21:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RVV 编码器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我有信心说，在两周内，如果没有发现任何重大问题，我们将能够稳定Actix Web v4.0我鼓励你开始升级你的应用程序和库到rc.1，并请在我们的Discord服务器上提供反馈；这对制定迁移指南和加强所需的文档会有很大的帮助。就个人而言，感谢你们在这个极其漫长的测试期中的耐心和支持；终点就在眼前，看到它的发布将是一种极大的安慰。Github: https://github.com/actix/actix-web/releases/tag/web-v4.0.0-rc.1Read More: https://libreddit.spike.codes/r/rust/comments/shqser/actixweb_published_its_first_v400_release/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://libreddit.spike.codes/r/rust/comments/shqser/actixweb_published_its_first_v400_release/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-02 19:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "actix-web 发布v4.0预发布版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好! 我只是觉得我应该分享这个，这样我可以得到关于我的代码的反馈。我创建了一个undo tree的程序--基本上，这个程序允许你把一个目录结构进行可视化，并把它实例化为一个实际的目录结构!我注意到，过去我不得不重新创建目录结构，以便回答问题或在目录上运行测试。例如，忽略某些类型的文件，它提供了一个目录结构作为参考。文件本身并不是由问问题的人提供的，也不需要提供，但目录结构本身与问题有关。untree允许你完全复制目录结构，只需粘贴给定的目录树。除了允许你回答关于目录结构的问题，untree还适合于快速创建目录结构，以模拟输入其他程序。Read More: https://libreddit.spike.codes/r/rust/comments/si7qhk/i_created_a_program_to_undo_tree/Github: https://github.com/codeinred/untree" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/codeinred/untree" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-02 19:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "undo tree" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你好！我最近偶然发现了imgui-inspect，我非常喜欢这个包，即能够在结构中放入一些派生宏和属性宏，以生成大量的模板代码来检查结构。https://github.com/aclysma/imgui-inspect受到启发，我发布了我的第一个crate: egui_inspect。我的目标是创建一个非常简单的API，在项目中易于使用。目前仍然很粗糙（例如，没有文档，错误报告相当于不存在），但我为我在48小时内完成的工作感到自豪，并希望得到一些反馈。在我的代码中，最困扰我的是如何检测内部处理的类型标识符，因为现在它需要大量的字符串比较，使代码臃肿，而且似乎使Vec<T>难以支持。感谢你的阅读，我希望你会对这个crate感兴趣Github: https://github.com/Meisterlama/egui_inspect" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Meisterlama/egui_inspect" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-02 19:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "egui_inspect 一个通过egui查看和编辑结构的工具箱。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 日报小组给大家拜大年了println!(\"祝 Rust 步步高升，Rust 社区越来越好，你的 Rust 越来越6\");" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-01 16:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "为什么你的 Rust Benchmark 可能出现问题，如何正确使用标准库中的 std::hint::black_box 呢？ Gendignoux 在一篇文章中分享了他在深入挖掘Benchmark 出现的问题之后得出的结论。原文链接https://gendignoux.com/blog/2022/01/31/rust-benchmarks.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-01 16:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust Benchmarks 小技巧" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "人们在使用 Rust 异步时，经常抱怨的一件事就是取消，Rust Team 的 niko 分享了他对 Panics 和 canncellation 的理解，以及如何更好地处理异步取消这个棘手的问题原文链接-连载中https://smallcultfollowing.com/babysteps//blog/2022/01/27/panics-vs-cancellation-part-1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-01 16:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Panics vs cancellation" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Symphonia 是一个音频解码和媒体解复用库，支持 AAC、ALAC、FLAC、MKV、MP3、MP4、OGG、Vorbis、WAV 和 WebM 多种格式。类似 FFMpeg，不过是用纯 Rust 来实现的。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-02-01 16:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Symphonia 发布 v0.5" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "祝大家新年快乐!" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 19:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者一直迷恋 Drift 屏幕保护程序，自从它出现在macOS Catalina。作者使用 Rust 和 wasm 重新在浏览器中创建了该效果.flux github 地址https://github.com/sandydoo/flux原文链接https://www.reddit.com/r/rust/comments/sglru6/recreating_macoss_drift_screensaver_with_rust_and/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 19:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "flux: 用 Rust 和 wasm 重新创建 macOS的 Drift 屏幕保护程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 中的string 们, 总是会让新手们感到困惑. 所以作者专门写了该文章来扫清大家的疑惑.原文链接https://medium.com/@alisomay/strings-in-rust-28c08a2d3130" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 19:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中的 string 们" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "很多从其他语言转过来的人都感觉 Rust 的标准库很少,尤其是对比 go 语言. 该文章解释了为什么 Rust 语言只有一个很小的标准库但是他却是 ok 的.原文链接https://blog.nindalf.com/posts/rust-stdlib/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 19:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么 Rust 只有一个很小的标准库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "dtmf是一个无std 的 DTMF解码器。可以在 microcontroller 或普通PC上使用。crate地址https://crates.io/crates/dtmf--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 19:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "dtmf: 一个无std 的 Rust DTMF解码器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "将平板电脑或智能手机用作计算机上的图形输入板 / 触摸屏。主要特征：\n使用平板电脑控制鼠标\n将屏幕镜像到平板电脑\n使用物理键盘发送键盘输入\n硬件加速视频编码\n上述功能在所有操作系统上都可用，但 Weylus 在 Linux 上效果最好。Linux 上的其他功能包括：\n支持手写笔 / 笔（支持压力和倾斜）\n多点触控：尝试使用支持多点触控的软件，如 Krita\n捕获特定窗口并仅绘制到它们\n更快的屏幕镜像\n平板电脑作为第二个屏幕\nGitHub：https://github.com/H-M-H/Weylus" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 12:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Weylus：移动设备作为输入板/触屏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\ncargo clippy\nOption 代替空值返回\n使用 impl 创建更灵活的 API 参数\n使用 Debug, Default 等通用 Traits\ncargo check 检查是否按约定命名\n视频：https://www.youtube.com/watch?v=zdT3bUljGQw" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 12:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "给Rust新人的五个Tips" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用 Rust 构建快速的 Wikipedia 机器人。相关文章：https://blog.legoktm.com/2022/01/21/building-fast-wikipedia-bots-in-rust.htmlGitHub：https://gitlab.com/mwbot-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 12:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mwbot-rs：快速构建WikiBot" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "FunDSP 是一个专注于可用性的音频 DSP（数字信号处理）库。可用于：\n游戏和应用程序的音频处理和合成\n教育\n音乐制作\n声音 hacker 和音频 golfing\nDSP 算法原型\nGitHub：https://github.com/SamiPerttu/fundsp" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 12:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "fundsp：音频DSP库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如何使用：\ncargo msrv 或 cargo msrv --linear 在当前工作目录中查找 Cargo 项目的 MSRV\ncargo msrv --path <dir> 在 <dir> 目录中查找 Cargo 项目的 MSRV\ncargo msrv -- <command> 使用 <command> 作为兼容性检查\ncargo msrv --verify 验证由 crate 作者指定的 MSRV\ncargo msrv list 列出作者指定的依赖项的 MSRV\ncargo msrv show 显示当前指定的 MSRV\n文档：https://foresterre.github.io/cargo-msrv/index.htmlGitHub：https://github.com/foresterre/cargo-msrv" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 12:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo-msrv：为项目查找支持的最低 Rust 版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个强大的、可定制的、高效且易于使用的命令行应用程序，用于对文本进行 uwu'ify！特点：\n默认允许重复结果\n不包括 URL 和 Email\n处理本地可用的文件\n完全可定制的修饰符\nGitHub：https://github.com/sgoudham/uwuifyy" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 12:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "uwuifyy命令行工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nType-Driven Development：https://duesee.dev/p/type-driven-development/\nRust 并发和并行：https://swatinem.de/blog/futures-n-tasks/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-31 12:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "文章推荐" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Amazon Prime Video 通过 8k 多种设备类型向数百万客户提供内容，例如游戏机、电视、机顶盒和流媒体棒。当想要进行应用更新时，需要在可更新性和性能之间做出艰难的权衡。过去一年，Amazon Prime Video 使用了 WASM 和 egui，他们认为对 Rust 和 WebAssembly 的投资得到了回报，经过一年的开发，共编写了 37,000 行 Rust 代码，显著地提高了性能、稳定性和 CPU 消耗并降低了内存利用率。原文链接，https://www.amazon.science/blog/how-prime-video-updates-its-app-for-more-than-8-000-device-types" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.amazon.science/blog/how-prime-video-updates-its-app-for-more-than-8-000-device-types" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-29 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Amazon Prime Video 使用 Wasm 和 egui" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Fornjot 是创建下一代 Code-CAD 应用程序，它目前属于一个早期项目。博客链接，https://www.fornjot.app/blog/fornjot-0-5-0/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.fornjot.app/blog/fornjot-0-5-0/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-29 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Fornjot 发布v0.5" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "1769年，欧拉提出了欧拉猜想（sum of powers）。1966 年，L. J. Lander 和 T. R. Parkin 用他们使用 CDC 6600 大型计算机发现的反例反驳了这个猜想。 众所周知，他们的论文只包含两句话。2022年，你用在手机上的浏览器，就可在2秒左右找到他们的反例，以及更多反例。可以通过该网页 https://carlkcarlk.github.io/shortestpaper/ 亲自尝试。 该页面使用 Rust 和 WASM。https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-29 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用 Rust 和 WASM 重建世界上最短的数学论文" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "2022 年对于成为 Rust 程序员来说是伟大的一年。Rust 还不是很主流，但凭借其忠实的用户群和在科技界不断增长的用例，很容易看出 Rust 将如何在 2022 年继续发展壮大。我们列出了许多值得期待在 Rust 世界中发生的事情。列出了几个会议以及对 Rust 本身的一些改进。此外，我还介绍了 Rust 编程语言的一些主要采用点。Rust 北美首屈一指的会议是 RustConf。该会议传统上于 8 月或 9 月在俄勒冈州波特兰举行。2022 年的会议以线上会议的形式举行，并且大家都可以作为参与者参加了会议。目前还没有宣布其他会议。微软已经与 Rust 合作了几年。他们发现，推送到服务器的安全补丁中有 70% 是为了修复与内存相关的错误，微软认为 Rust 能够在开发阶段捕获这些错误。从那时起，微软已经委托一些工程师用 Rust 重写 Windows 的一些组件，以慰藉一些开发人员的情绪。内存管理是 Rust 被越来越多地采用的主要原因之一。微软甚至为那些希望了解更多关于 Rust 的开发人员创建了一个学习渠道。我们可以在这里阅读。期待微软使用 Rust 获得更多。https://docs.microsoft.com/en-us/learn/modules/rust-introduction/去年底，Rust 成为 Linux 内核的第二个官方语言。Linux 内核最初是用 C 编写的。现在 Rust 可用于进一步的内核开发。成为第二语言的目的不是替换或重写整个 Linux 内核，这只是可以被认为是 Linux 内核一部分的新特性现在可以用 Rust 或 C 编写。Rust 程序主要负责的区域是驱动程序。它们对主要内核包的影响最小。这样慢慢地Rust 将更多地成为核心包功能和开发的一部分。对于所有对 Linux 内核感兴趣的程序员来说这应该很有趣，它是工具箱中的另一个工具，可以说用于为 Linux 编写代码。2021 年 12 月 9 日，Rust 基金会宣布他们将创建一个 Rust 社区资助计划。他们的意图是推广 “Rust 编程语言的广泛使用，Rust 开发者社区是过去两年增长最快的。因为目前对于维护和贡献开源 Rust 项目及其生态系统的工作仍然有很高的需求，所以 Rust 基金会的财政支持将专注于最能展示 Rust 卓越能力的有影响力和可持续的工作。” (From the Rust Foundation website)如此多的 Rust 运行在 Crate 上。Crates.io 的下载量超过 100 亿次，crate 是 Rust 编程生态系统中使用最多的系统。显然 crate 是必需的，crate 24/7 的支持也是如此，Rust 基金会已经挺身而出，支持整个 Rust 社区的这种需求。现在世界各地使用 Rust 的程序员可以期待他们的问题得到解答。更多关于这里的发展。https://foundation.rust-lang.org/posts/2021-10-18-crates-io-oncall-ferrous-systems/亚马逊网络服务、微软 Azure 项目和谷歌云等会为 Rust 维护者提供免费积分。这将进一步使 Rust 维护者能够为整个 Rust 社区测试他们的解决方案。Rust 维护者来自个人和各个组织，他们决心继续在 Rust 编程语言的不同方面进行工作。访问这些服务意味着那些创建使 Rust 运行良好的代码的人现在能够在或多或少类似于实际工作情况的环境中测试他们的代码。这真是一件好事。感谢您的阅读！\nhttps://chester-beard.medium.com/rust-programming-what-to-look-forward-to-in-2022-2e041258f750\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-28 12:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 编程，2022 年的展望" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "抢占式调度是指任务的调度不受开发人员控制，完全由运行时管理。无论程序员是启动同步任务还是异步任务，代码都没有区别。例如，Go编程依赖于抢占式调度。它的优点是更容易学习：对于开发人员来说，同步代码和异步代码之间没有区别。此外，几乎不可能误用：运行时会处理所有事情。通过协作调度开发人员负责告诉运行时一个任务何时需要花费一些时间等待 I/O。await 这是关键字的确切用途。这是运行时（和编译器）的指示，该任务将花费一些时间等待操作完成，因此计算资源可以同时用于另一个任务。它的优点是速度极快。基本上开发人员和运行时正在协同工作，以充分利用可支配的计算能力。协作调度的主要缺点是它更容易被误用：如果 aawait 被遗忘（幸运的是，Rust 编译器会发出警告），或者如果事件循环被阻塞超过几微秒，它会对系统的性能产生灾难性的影响。文章对两种调度进行了更细致的介绍：\nhttps://kerkour.com/cooperative-vs-preemptive-scheduling/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-28 12:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-await：协作式调度 vs 抢占式调度" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Ayush Singh 将为 KConfig 开发一个 Rust wrapper 。有了这个 wrapper ，以及针对 qmetaobject 和 ki18n 的现有 wrapper ，在 Rust 中开发 KDE 应用程序将变得更加容易。可以在 kde-devel 邮件列表中找到更多信息。crates.io - qmetaobject: https://crates.io/crates/qmetaobjectcrates.io - ki18n: https://crates.io/crates/ki18nkde-devel 邮件列表: https://mail.kde.org/pipermail/kde-devel/2022-January/000875.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://mail.kde.org/pipermail/kde-devel/2022-January/000875.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-28 11:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "KDE 正在为 KConfig 开发一个 Rust wrapper" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Meilisearch 是一个开源的搜索引擎项目，并使用 Rust 作为首选开发语言。Meilisearch 接下来的计划包括：\n向开发者提供需要的工具和支持，使他们能够用 Meilisearch 创建令人惊叹的网站和应用程序。\n继续研发 Meilisearch Cloud，帮助用户使用由 Meilisearch 团队管理的实例并进行优化。\nGitHub - Meilisearch: https://github.com/meilisearchMeilisearch raises a $5M Seed to change the world of user-facing search: https://blog.meilisearch.com/meilisearch-raised-5meu-seed-fundraising/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.meilisearch.com/meilisearch-raised-5meu-seed-fundraising/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-28 11:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Meilisearch 获 500 万美元种子轮融资" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 427: https://this-week-in-rust.org/blog/2022/01/26/this-week-in-rust-427/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/01/26/this-week-in-rust-427/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-28 11:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 427" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个内存问题是初代 pkexec 引入的，2009年，至今已有12年之久。linux内存安全之雷，不知道有多少。https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-26 22:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pkexec被发现内存安全问题，影响所有主流Linux发行版" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有人说，未来的编程语言设计会越来越简单？走向简单易用是趋势？非也。这篇文章为复杂的编程语言进行了辩护。作者非常喜欢Rust。https://viralinstruction.com/posts/defense/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-26 22:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为复杂的编程语言辩护" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "(Basic) Segment Trees with beautiful diagrams!https://www.reddit.com/r/rust/comments/scf592/basic_segment_trees_with_beautiful_diagrams/给定一个长度为N的数组arr，如果有以下操作：则可以使用线段树来高效解决上述场景的查询和更新需求；线段树的时空复杂度：Rust实现：参考链接：\n\n(Basic) Segment Trees;\n\n\nsegment-tree;\n\n(Basic) Segment Trees;https://desmondwillowbrook.github.io/blog/competitive-programming/dsa-explanations/basic-segment-tree/segment-tree;https://crates.io/crates/segment-tree" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-26 12:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "（基础）精美图表详解线段树！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Thalo.rs - Event Sourcing in Rusthttps://www.reddit.com/r/rust/comments/sbvpn1/thalors_event_sourcing_in_rust/Thalo是一个基于以下模式构建大型系统的事件溯源框架：\n事件溯源\nCQRS\n事件驱动\n事务发件箱\nDDD\n它的设计是模块化的，带有实现大多数功能的额外库。官方提供的库：\n核心库\n\nthalo: 核心框架\nthalo-testing:  thalo的测试组件；\nthalo-macros: 实现trait的宏（可以通过macro特性开关在核心库中打开此功能）；\n\n\n事件存储\n\nthalo-postgres: 为Postgres实现EventStore trait；\nthalo-inmemory: 内存实现EventStore；\nthalo-filestore: 为filestore实现EventStore；\n\n\n事件流\n\nthalo-kafka:为kafka实现EventStream；\n\n\n\nthalo: 核心框架\nthalo-testing:  thalo的测试组件；\nthalo-macros: 实现trait的宏（可以通过macro特性开关在核心库中打开此功能）；\n\nthalo-postgres: 为Postgres实现EventStore trait；\nthalo-inmemory: 内存实现EventStore；\nthalo-filestore: 为filestore实现EventStore；\n\nthalo-kafka:为kafka实现EventStream；\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-26 12:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Thalo.rs —— Rust中的事件溯源库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "E-mail parsing and building in Rusthttps://www.reddit.com/r/rust/comments/sbyqci/email_parsing_and_building_in_rust/作者刚刚发布了一个名为mail-builder的新库，可以在Rust中轻松生成MIME电子邮件。这个库与作者在几周前发布的邮件解析器mail-parser相结合，为构建和解析Rust中任何复杂的RFC5322电子邮件提供了全面支持。https://crates.io/crates/mail-buildermail-builder: https://crates.io/crates/mail-buildermail-parser: https://crates.io/crates/mail-parser" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/mail-parser" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-26 12:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "电子邮件解析和生成库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Slas v0.2.0 - Static Linear Algebra Systemhttps://www.reddit.com/r/rust/comments/sbtn4t/slas_v020_static_linear_algebra_system/提供静态分配的向量、矩阵和张量类型，高效的实现了blas/blis接口，默认情况下使用写时复制行为（又名cow）。与v0.1.1版本相比，新版本的Slas有很多突破性的变化和功能，包括：\n模块化后端；\n更好的性能；\n支持矩阵和张量（张量仍然做不了多少）；\n向量支持可选的COW行为；\n更好的基准测试和文档；\n项目地址：https://github.com/unic0rn9k/slasRust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/unic0rn9k/slas" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-26 12:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Slas v0.2.0 —— Rust静态线性代数系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cube.js 是一个开源的分析 API 平台。  它主要用于构建内部商业智能工具或将面向客户的分析添加到现有应用程序中。Cube.js 旨在与无服务器数据仓库和查询引擎（如 Google BigQuery 和 AWS Athena）一起使用。多阶段查询方法使其适用于处理数万亿个数据点。 大多数现代 RDBMS 也可以与 Cube.js 一起使用，并且可以进一步调整性能。GitHub：https://github.com/cube-js/cube.jsDocument：https://cube.dev/docs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-24 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "分析API平台cube.js" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "主要针对 tide 和 actix-web：https://github.com/http-rs/tideVideo：https://www.youtube.com/watch?v=3iA1G0l4PEw" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-24 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "WebAPI Benchmarking" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个用来控制线程调度策略和线程优先级的库。目前支持主流操作系统。最小实例——将当前线程优先级调至最低：GitHub：https://github.com/vityafx/thread-priority" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-24 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "线程优先级控制thread-priority" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个简单的音频控制和通知守护进程，通过 libnotify 发送报告 pulseaudio 状态的通知。GitHub：https://github.com/ZenTauro/sacand" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-24 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "简单音频控制守护进程sacand" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "snarkOS 是一个用于私有应用程序的去中心化操作系统。它构成了 Aleo 的主干，使应用程序能够以可公开验证的方式验证和存储状态。GitHub：https://github.com/AleoHQ/snarkOS" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-24 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "去中心化操作系统snarkOS" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GitHub：https://github.com/golmman/uisge" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-24 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "双人棋盘游戏Uisge" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n二叉树插入：https://dawchihliou.github.io/articles/binary-tree-insertion-in-rust\n为 Web 编写一个 Tiny Rust 游戏引擎：https://dev.to/stevepryde/create-a-desktop-app-in-rust-using-tauri-and-yew-2bhe\n使用 Tauri 和 Yew 创建一个桌面应用：https://dev.to/stevepryde/create-a-desktop-app-in-rust-using-tauri-and-yew-2bhe\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-24 23:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "教程文章" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "最近在Linux内核中发现了一个堆溢出错误。该补丁现在可以在大多数主要的Linux发行版中使用。在这个例子中，Linux内核的 fs/fs_context.c 程序中的 legacy_parse_param 有一个堆溢出错误。在Linux文件系统中，该参数在创建超级块用于挂载和重新配置超级块用于重新挂载期间使用。超级块记录文件系统的所有特征，如文件大小、块大小、空的和已填的存储块。所以，是的，这很重要。legacy_parse_param () PAGE_SIZE - 2 - size 计算, 错误地将其设置为无符号类型。这意味着较大的“size”值将导致较高的正值，而不是预期的负值。哎呦。Rust被纳入Linux的一个重要原因是，Rust使得这种内存错误更难发生。每个C开发人员都知道，在C程序中，内存分配很容易出错。原文链接https://www.zdnet.com/article/nasty-linux-kernel-bug-found-and-fixed/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-24 20:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "讨厌的Linux内核错误" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一篇由 /r/rust 网站2019年5月的一个问题引发的短文，询问rust程序自我修改的方法。想象一下，将高分列表直接存储在可执行文件中是多么有趣。当你复制一份程序并传给你的朋友时，你的高分会被保存下来。这是一篇很有趣的文章, 请把他当做是聚会的小把戏,不要真正的去使用他.原文链接https://blog.dend.ro/self-modifying-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-24 20:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "自我修改的 Rust 可执行程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "QCell 是 RefCell 和 RwLock 替代品.QCell 在运行时不会像使用 RefCell 那样会 panic 的 Cell 类型, 相反他会给出编译错误，或者使用 RwLock 交换细粒度锁定，以获得单独的所有者对象的粗粒度锁定。github地址https://github.com/uazu/qcell" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-24 20:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "QCell: 0.5.0 版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Doteur是一个CLI工具，其目的是将SQL模式呈现为好看的图形。这将帮助您轻松地理解大型数据库的结构，并理解项目幕后发生的事情。github 地址https://github.com/nag763/doteur--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-24 20:48" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Doteur: 一个将  SQL schemas 渲染成关系图的工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RamFS是Linux中基于Ram的文件系统。它被描述为一个简单的文件系统，用于学习创建新的Linux文件系统（link）所需的最小实现。在2021年秋季与弗吉尼亚理工大学的张宇民博士一起学习高级 Linux 内核编程。Connor Shugg 和我(Chase Minor)将它从c移植到Rust，以了解移植到内核内部的过程。我们在这里提供我们的资源和知识，以供使用，包括或学习。我们工作的主要贡献是RAMFS文件系统的移植。但是，我们也向内核添加了各种其他东西，这可能对其他使用Rust的Linux开发人员有益。Github 链接，https://github.com/acminor/linux/tree/ramfs-rust/fs/ramfs_rust文章链接，https://austincminor.com/20211030000942-ramfs_rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://austincminor.com/20211030000942-ramfs_rust.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-22 09:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Linux RamFS文件系统移植到Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "SixtyFPS是一个工具包，可以有效地为任何显示器（嵌入式设备和桌面应用程序）开发流畅的图形用户界面。我们支持多种编程语言，如Rust、C++和JavaScript。今天，我们将发布SixtyFPS的0.1.6版本，其中包含新功能和一些错误修复。让我们看一下亮点。Github 链接，https://github.com/sixtyfpsui/sixtyfps文章链接，https://sixtyfps.io/blog/sixtyfps-0.1.6-released.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://sixtyfps.io/blog/sixtyfps-0.1.6-released.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-22 09:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SixtyFPS 0.1.6 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你不应该关闭borrow checker在Rust中，并且你也不应该想要关闭。然而，如果你想要在某些学习场景中假装borrow checker不存在。这个宏将在它所应用的代码中抑制许多(尽管不是全部)借用检查错误。Example文章链接，https://docs.rs/you-can/0.0.1/you_can/attr.turn_off_the_borrow_checker.htmlhttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://docs.rs/you-can/0.0.1/you_can/attr.turn_off_the_borrow_checker.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-22 09:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "宏 you_can::turn_off_the_borrow_checker" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "欢迎来到Rust GameDev工作组的第29期月报。Rust是一种追求三要素的系统语言：安全、并发和速度。这些目标与游戏开发非常吻合。我们希望为任何希望在开发过程中使用Rust的人建立一个有吸引力的生态系统。想参与进来吗？加入Rust GameDev工作小组吧。https://github.com/rust-gamedev/wg#join-the-funRead More: https://gamedev.rs/news/029/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gamedev.rs/news/029/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-20 21:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "这个月的Rust GameDev #29 - 2021年12月" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "正如库minifb的流行所显示的那样，以一种与平台无关的方式将2D缓冲区/图像放在窗口上是很有用的。然而，minifb本身做窗口管理的方法是有代码重复的问题的。我们在Rust生态系统中已经有了非常高质量的相关库（比如winit），而minifb的窗口管理实现却并不理想。例如，它在某些平台上偶尔会发生缓冲区故障，并且缺少一些关键的功能，如设置窗口图标的能力。虽然有可能将这些功能添加到minifb中，但使用标准的窗口处理系统更为合理。https://crates.io/crates/minifbSoftbuffer与raw-window-handle这个crate集成，允许以跨平台的方式写入窗口，同时使用Rust生态系统中非常高质量的专用窗口管理库。https://crates.io/crates/softbufferRead More: https://users.rust-lang.org/t/new-library-for-gpu-less-2d-display-in-winit-softbuffer-is-now-ready-for-use/70591Crates.io: https://crates.io/crates/softbuffer" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/softbuffer" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-20 21:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用于winit中无GPU的2D显示的新库，Softbuffer现在可以使用了!" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "通常情况下，Rust会自己弄清楚萨特问题。https://davedevine.wordpress.com/2011/01/20/the-sartre-joke/-kornel 在 rust-users 上评论https://users.rust-lang.org/t/type-ascription/70214/4本周引语比较晦涩，大概意思是想说Rust在通常情况下会自动推导合适的范型结果。其中提到的萨特问题指的是关于法国哲学家萨特的一个冷笑话，感兴趣的可以通过链接跳转到相关页面了解内容。Read More: https://this-week-in-rust.org/blog/2022/01/19/this-week-in-rust-426/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/01/19/this-week-in-rust-426/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-20 21:25" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周周报" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Pijul 是一个免费的开源 (GPL2)分布式版本控制系统。经过了 53 个alpha版本的Pijul 1.0 beta终于发布了ReadMore:https://pijul.org/ReadMore:https://nest.pijul.com/pijul/pijul" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://nest.pijul.com/pijul/pijul" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-20 09:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pijul 1.0 beta 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "编程语言设计界的人们努力使他们的语言更具表现力，拥有强大的类型系统，主要是为了通过避免最终软件中的代码重复来提高工效；然而，他们的语言变得越有表现力，重复就越渗透到语言本身。ReadMore:https://hirrolot.github.io/posts/why-static-languages-suffer-from-complexity" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://hirrolot.github.io/posts/why-static-languages-suffer-from-complexity" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-20 09:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么静态语言会受到复杂性的影响" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Sandbox 是一个像素物理模拟器，灵感来自Sandspiel和Noita等其他模拟器。\n使用Vulkano的 Vulkan 渲染器\nGui 与Egui使用egui_winit_vulkano\n使用计算着色器进行细胞自动机模拟\n.png来自图像的可变形像素对象\n简单的物理引擎 Rapier\nReadMore:https://github.com/hakolao/sandbox" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/hakolao/sandbox" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-20 09:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Sandbox - 像素物理模拟器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Paudle: A Wordle-like in Rust using Yewhttps://www.reddit.com/r/rust/comments/s6gvv2/paudle_a_wordlelike_in_rust_using_yew/Paudle是对Josh Wardle的优秀文字游戏Wordle的重新实现。这个版本是用Yew和Rust制作的。作者仿照了Wordle的颜色和布局（当然还有游戏逻辑），但实现都是原创的。与最初的版本不同，这一版本完全是基于客户端的，因此没有什么可以阻止你作弊——如果你能找出如何从运行的WASM中提取当前单词的话。运行步骤：关于Wordle：Wordle 和填字游戏都属于字谜游戏的一种。这个游戏每天更新一期，玩家唯一目标，就是在六次尝试机会之内，猜出一个五个字母的单词。为此，游戏界面是一个 5×6 的方块阵列。玩家通过下方键盘输入猜测结果后，游戏会给字母方块标上颜色，提示猜测的准确性：绿色 🟩：说明答案里有这个字母、所在位置也正确；黄色 🟨：说明答案里有这个字母、但不在这个位置；灰色 ⬜️：说明答案里没有这个字母。然后，玩家根据获得的提示继续尝试，直到猜对答案，或者用尽六次机会。参考：\nwordle: https://www.powerlanguage.co.uk/wordle/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-19 10:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Paudle: 使用Yew编写的类似Wordle的猜字谜游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust For Linux Kernel Patches Revised With Upgraded Rust Toolchain, Build Improvementshttps://www.phoronix.com/scan.php?page=news_item&px=Rust-For-Linux-v3Miguel Ojeda已经发布了他的第三次补丁迭代，这些补丁实现了支持Linux内核中Rust编程语言的基本基础设施。早在12月份就有了v2补丁，而现在刚刚过了一个月，3版补丁就可以进行测试了。随着Rust编译器版本已经确定，更新后的Rust for Linux内核代码现在迁移到了Rust 1.58版本。此次补丁新增特性包括自动检测是否有合适的Rust工具链可用、其他构建系统改进、改进的文档以及其他通用代码清理和改进。Miguel指出，在Rust方面也有一些改进，“我们需要的一个不稳定的特性，-Zsymbol-mangling-version=v0将在Rust 1.59.0中得到稳定。另一个特性，maybe_uninit_extra 可能会在Rust 1.60.0中得到改进。”Linux内核的Rust基础设施以及一些基本的示例代码目前使这个v3修补程序系列有33.5k行新代码。请参阅内核邮件列表上的v3补丁以供查看。https://lore.kernel.org/lkml/20220117053349.6804-1-ojeda@kernel.org/希望今年Rust能够进入Linux内核的主线！" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-19 10:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust For Linux内核补丁使用升级的Rust工具链进行修订，构建改进" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Porting ruby YJIT to Rusthttps://www.reddit.com/r/rust/comments/s6eo3b/porting_ruby_yjit_to_rust/YJIT 是用于 Ruby 的 JIT 编译器，它采用了惰性基础块版本管理 (lazy Basic Block Versioning, LBBV) 架构。与当前的 CRuby 解释器相比，在进行实际基准测试时，YJIT 的平均速度大约提升了 23%。现在YJIT团队希望探索使用Rust来帮助开发YJIT。而CRuby的其余部分将继续使用非Rust的工具链进行构建，而且构建Ruby应用时仍然支持YJIT开关。价值主张：\nRust的类型系统将尽早捕获更多的bug，有助于防止新的bug；\n更易于管理日益复杂的YJIT；\n更容易维护代码库；\n对于新手来说更容易，因为编译器捕获了更多的bug；\n更好的性能，因为我们可以实现更复杂的优化；\n更容易添加对新平台的支持（这增加了复杂性）；\nRust拥有成熟且易于安装的工具，如源代码格式化程序和编辑器插件；\nRust作为一个编程语言社区，其背后有着巨大的热情。这可以转化为对YJIT和Ruby的更大热情。\n集成：\nYJIT将只依赖于Rust语言和标准库，而不依赖于其他依赖项；\nYJIT将能够在没有互联网连接的情况下进行构建；\nRust对交叉编译有很好的支持；\nRust在我们计划使用YJIT支持的所有平台（Mac、Linux、Windows）上都受支持；\n已编译的CRuby二进制文件不会对共享库有任何新的依赖项；\n在禁用YJIT的情况下，CRuby仍然可以在没有rustc的情况下进行构建\n完整的意见说明参阅：Porting YJIT to Rust (request for feedback)https://bugs.ruby-lang.org/issues/18481" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-19 10:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "将Ruby 的 JIT 编译器YJIT迁移到Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "lipstick: a Rust-like syntax frontend for Chttps://www.reddit.com/r/rust/comments/s650qz/lipstick_a_rustlike_syntax_frontend_for_c/lipstack将Rust的语法汇编成C。尽管它没有借用检查器或生命周期管理，但它并不是一个“Rust语法子集”。它只是C语言的一个Rust的语法前端。可以在Playground来实战体验它是怎样运作的。https://jrvidal.github.io/lipstick/参考：\nGithub：https://github.com/jrvidal/lipstick\nPlayground: https://jrvidal.github.io/lipstick/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-19 10:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "lipstack: 面向C语言的类Rust语法前端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "A new Relm 4 you: announcing Relm4 v0.4!https://aaronerhardt.github.io/blog/posts/announcing_relm4_v0.4/Rust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-19 10:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个新的Relm 4：宣布Relm4 v0.4!" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个教学视频, 使用 Opencv 和 Rust 进行面部和眼部识别.需要自己科学上网, 关注相关方面的小伙伴可以看看.油管视频https://www.youtube.com/watch?v=iWficV_pmxY" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-17 20:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Opencv 和 Rust 进行面部和眼部识别" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新的一年, gtk-rs 发布了最新的版本. 其中一条重要的信息是, 现在最小的Rust 的版本是 1.56.更多的信息请见原文链接.原文链接https://gtk-rs.org/blog/2022/01/16/new-release.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-17 20:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gtk-rs: 新的一年,新的发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "QuickRef.ME 是一个汇聚了大部分语言的语法索引页, 其中也包含了 Rust, 可以帮助大家快速找到想用的语法.原文链接https://quickref.me/rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-17 20:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "quickref.me Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GStreamer 是一个音视频框架库, gstreamer-rs 是他的 Rust binding, 目前 0.18.0 发布了.原文链接https://gstreamer.freedesktop.org/news/#2022-01-16T11:00:00Z" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-17 20:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GStreamer Rust bindings 0.18.0 发布了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Mako是一个数据处理库，主要用于机器学习。它提供了高效的 pipe 来构建有向非循环数据流图，并提供了一个 DataLoader 来在单独的线程中运行该图。它还提供了通用的标记器和批处理工具来处理文本数据。github地址https://github.com/Sidekick-AI/mako--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-17 20:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Mako: 机器学习的数据处理库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "令人惊叹的实现！Repo: https://github.com/doukutsu-rs/doukutsu-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/doukutsu-rs/doukutsu-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "劲爆！doukutsu-rs - 洞穴物语完全重制版" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "传送门：https://youtu.be/3oL1xokuHBE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://youtu.be/3oL1xokuHBE" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "教程：Hazard Pointers 在 Rust 中的实现，视频教程" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家呼唤很久了，现在 diesel 的维护者亲自开坑了。https://github.com/weiznich/diesel_async" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/weiznich/diesel_async" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "diesel_async - diesel 的异步版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个简易的教程，对想使用Rust进行前端App开发的同学有帮助。经验分享：https://dev.to/stevepryde/create-a-desktop-app-in-rust-using-tauri-and-yew-2bhe" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://dev.to/stevepryde/create-a-desktop-app-in-rust-using-tauri-and-yew-2bhe" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "博文：使用 Tauri 和 Yew 创建一个桌面应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有关 Rust 目前在各个领域的状态的汇总。https://wiki.mozilla.org/Areweyet" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://wiki.mozilla.org/Areweyet" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Areweyet 列表更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Repo：https://github.com/setzer22/blackjack" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/setzer22/blackjack" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "blackjack - 3D 建模器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "强烈推荐，非常深入的一篇文章：https://ysantos.com/blog/malloc-in-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ysantos.com/blog/malloc-in-rust" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "博文：深入探讨Rust中的内存分配" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "结合 Rust，OSRM, OpenStreetMap 的一次尝试。https://blog.dend.ro/mapping-my-walks-osrm-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.dend.ro/mapping-my-walks-osrm-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 将你的步行数据可视化到地图上" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://mbuffett.com/posts/generating_chess_puzzles/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://mbuffett.com/posts/generating_chess_puzzles/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 和 Stockfish 快速创建棋盘迷题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用 AI 来写代码！牛逼不？比如：生成：https://github.com/vongaisberg/gpt3_macro" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/vongaisberg/gpt3_macro" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 和 GPT3 在编译期生成代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者开发了一个 USB 硬件密码存储器。https://github.com/sjm42/blackpill-usb-pwdstore" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/sjm42/blackpill-usb-pwdstore" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一次 Rust 硬件开发的尝试" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "传送门：https://youtu.be/m_phdVlkr6U" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://youtu.be/m_phdVlkr6U" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-16 23:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "视频：基于类的OOP与Traits的不同" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Monaco 编辑器是 VS Code 支持的代码编辑器，现在可以在 Playground 中使用了。可以在配置 Config 菜单中选择喜欢的编辑器。https://microsoft.github.io/monaco-editor/Monaco 编辑器，https://microsoft.github.io/monaco-editor/Playground，https://play.rust-lang.org/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://play.rust-lang.org/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-15 22:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Playground 现支持 Monaco 编辑器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Arrow2 是 Apache Arrow 的 Rust 实现，是继 C++ 实现之后，Arrow 功能最完整的实现。v0.9 的主要更新：https://arrow.apache.org/\n\n由 std  Vec 支持，从而使其成为：\n\n与 Rust 生态的其它的零拷贝\n更少的 unsafe\n更符合人体工程学\n编译速度更快\n相同的性能\n\n\n\n支持同步和异步读取和写入 Apache Avro\n\n\nflatbuffers 依赖被 planus 取代，这是 Rust 中 flatbuffers 规范的重新实现\n\n\n安全性改进和常规维护\n\n由 std  Vec 支持，从而使其成为：\n与 Rust 生态的其它的零拷贝\n更少的 unsafe\n更符合人体工程学\n编译速度更快\n相同的性能\n支持同步和异步读取和写入 Apache Avroflatbuffers 依赖被 planus 取代，这是 Rust 中 flatbuffers 规范的重新实现安全性改进和常规维护完整的更改列表：https://github.com/jorgecarleitao/arrow2/releases/tag/v0.9.0Apache Datafusion 正在考虑采用它作为其后端，请参阅 https://github.com/apache/arrow-datafusion/issues/1532" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-15 22:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Arrow2 发布 v0.9" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "背景知识：我在一个由 5 名工程师（4 名 C++ 开发人员，1 名 Python 开发人员）组成的 C++ 团队中。 我们的主要\"产品\"是个 C++20 服务，为了让其他团队和我们自己的生活更轻松，我们想创建这个服务的\"mock\"。我们投票决定为这个有前途的新项目选择使用哪种语言开发。 我们中只有两个人知道 Rust，但我们没想到会如此获胜，C++ 的票数为零。Reddit 原文链接，https://www.reddit.com/r/rust/comments/s3w461/rust_adoption_milestone_c_team_doesnt_want_to/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/s3w461/rust_adoption_milestone_c_team_doesnt_want_to/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-15 22:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 采用里程碑：C++ 团队不想再用 C++ 编写" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RustTalk，国内的第一档 Rust 播客。播客链接，https://rusttalk.github.io/podcast/000/https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rusttalk.github.io/podcast/000/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-15 22:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustTalk" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们现在可以通过修改 crosvm 来虚拟化 Linux 中的 GUI 应用程序和操作系统，这是一个基于 rust 的出色开源 VMM，并且作者想分享我们是如何做到的。2.如果你想要demo中的音频，修改主机上的pulseaudio server config以接受来自VM的TCP连接并使用  systemctl restart pulseaudio 重新启动它构建可能需要一段时间，但一旦完成，您应该会看到一个 firefox 窗口打开主机上的任何媒体文件都会在 VM 内的 VLC 中打开它并且音频播放正常5、运行 Ubuntu 桌面以下文章将介绍 crosvm 中启动 VM 的示例\nhttps://blog.openw3b.org/crosvm-for-os-and-app-virtualization-on-linux/\n随着摩尔定律的终结，但是我们对特定领域计算（例如机器学习）的兴趣仍在加速增长——迫使我们从根本上重新思考我们的编译器设计。围绕单一，千篇一律的 IR 构建的通用编译器框架的时代已经结束。这种情况激发了 MLIR 编译器框架的创建，该框架使编译器工程师能够设计和集成捕获特定抽象的 IR。\nhttps://arxiv.org/abs/2201.03611\n\nhttps://mojosd.medium.com/what-does-a-rustc-reading-club-do-8c9f9b336ff4\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-15 11:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Glicol 可以帮助您使用代码制作音乐。您可以简单地连接不同的节点以形成循环，用 Rust 编写，得益于 WebAssembly，它可以在浏览器中丝滑运行。glicol.org: https://glicol.org/GitHub - glicol: https://github.com/chaosprint/glicol" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/chaosprint/glicol" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-14 09:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Glicol - 以图为导向的音乐实时编程语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 1.58 在格式字符串中引入了捕获的标识符、对 Windows 上的搜索路径的更改、 #[must_use] 标准库中的更多注释以及一些新的库稳定性。另外在 release note里一些编译器和库的改进也值得一看，比如：（感谢张汉东老师供稿）Announcing Rust 1.58.0: https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.htmlChangelog - Version 1.58.0 (2022-01-13): https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1580-2022-01-13" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1580-2022-01-13" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-14 09:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.58.0 稳定版发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 425: https://this-week-in-rust.org/blog/2022/01/12/this-week-in-rust-425/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2022/01/12/this-week-in-rust-425/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2022-01-14 09:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 425" }, "type": "text" }], "type": "title" } },]
