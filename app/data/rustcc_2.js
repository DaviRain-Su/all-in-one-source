export const propertiesForNewPages =  [{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"WASIX最近新增了对TLS客户端的支持,这使reqwest、hyper、rustls等库可以完全在WASIX环境下编译运行。WASIX是一个WASI的超集,旨在加速WASI生态系统的发展。新增的TLS支持使基于WASM的应用可以访问HTTPS、MQTT、IRC等TLS端点,为WASM在服务器端开启了更多可能性,比如安全的API访问、数据库连接、第三方服务集成等。详情: https://www.reddit.com/r/rust/comments/15mw1j6/tls_clients_fully_work_with_wasix_now/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/15mw1j6/tls_clients_fully_work_with_wasix_now/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-10 23:23"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"TLS在WASIX中的支持"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"社区讨论了OpenCL和CUDA在Rust中的使用情况。目前使用rust-cuda可以将CUDA内核完全使用Rust实现。而对于OpenCL,仍需要使用OpenCL C语言编写内核。希望能有编译器将Rust编译为OpenCL,实现类似rust-cuda的功能。详情: https://www.reddit.com/r/rust/comments/15n79o6/opencl_and_cuda_in_rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/15n79o6/opencl_and_cuda_in_rust/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-10 23:23"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"OpenCL和Cuda的Rust接口"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"SpacetimeDB是一个结合关系型数据库和应用服务器功能的新型数据库。它允许直接在数据库内通过存储过程实现应用逻辑。客户端可以直接连接到数据库并在数据库内执行应用逻辑,无需部署独立的应用服务器。SpacetimeDB专注于最大化速度和最小化延迟,可用于实时应用如游戏、聊天等场景。其全部后端使用一个Rust模块实现。详情: https://github.com/clockworklabs/SpacetimeDB"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/clockworklabs/SpacetimeDB"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-10 23:23"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"SpacetimeDB - 使用Rust的多人实时数据库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Mozilla的UniFFI库新增对JS绑定的生成支持,这有助于Firefox桌面端实现跨平台组件的单一实现。以往需要为每个平台编写不同语言的绑定包装器,这带来了大量的bug。利用UniFFI可以快速安全地生成各语言的绑定。这使得Firefox桌面版也能使用针对Android和iOS的共享组件。详情: https://hacks.mozilla.org/2023/08/autogenerating-rust-js-bindings-with-uniffi/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://hacks.mozilla.org/2023/08/autogenerating-rust-js-bindings-with-uniffi/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-10 23:23"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用UniFFI自动生成Rust到JS的绑定"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust周刊#507发布,内容包括编译器性能改进、新增diagnostics、RFC完成和进入PR阶段、本周事件预告等。其中编译器性能得益于LLVM 17升级,内存降低4-7%,速度提高3-5%。详情: https://this-week-in-rust.org/blog/2023/08/09/this-week-in-rust-507/请关注我们的更新，以便了解更多有关Rust的新闻和动态！"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2023/08/09/this-week-in-rust-507/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-10 23:23"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust周刊#507发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"FRand 是一个用 Rust 编写的非常快速、小巧且简单的伪随机数生成器。FRand 使用简单的运算：异或、移位和乘法。比的SmallRng 快 7-40%，比 ThreadRng 快 2-3 倍。使用 FRand 的优点是它每秒可以比其他库生成更多的随机数。它还使用快速的非加密哈希算法生成高质量的随机数。ReadMore:https://github.com/engusmaze/frand#example"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/engusmaze/frand#example"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-09 21:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"FRand - 快速简单的伪随机数生成"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者决定切换到 Rust 主要是出于以下三个原因：在团队中工作时，不可能雇用与高级团队成员一样擅长编写安全代码的初级团队成员。他们可以在指导和经验下编写安全的代码，但教他们需要很多时间。Rust 的内存安全会自动修复许多可能发生的错误。C/C++ 缺乏构建系统，使用第三方库时会非常痛苦。....第三方库经常有错误，或者开发人员不知道如何安全地使用库，经常会导致内存泄漏、数据损坏或条件竞争。....ReadMore: https://www.reddit.com/r/rust/comments/15lft59/long_term_c_dev_moving_to_rust_and_my_reasons/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/15lft59/long_term_c_dev_moving_to_rust_and_my_reasons/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-09 21:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"十年 C++ 经验的开发人员转 Rust 的心路历程"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"2022 年度的 Rust 调查报告新鲜出炉，主要分为以下几个方面：调查的参与情况：调查共有 11,482 份回复，其中 9,433 份完成了所有问题。调查提供了 11 种语言，其中英语占了 77%，中文占了 6%。调查的回复者来自世界各地，最多的是美国（25%），其次是德国（12%）和中国（7%）。Rust 的使用情况：超过 90% 的回复者表示自己是 Rust 用户，其中 47% 每天都使用 Rust。30% 的 Rust 用户可以写简单的程序，27% 可以写生产级的代码，42% 认为自己使用 Rust 很高效。使用 Rust 的主要原因是它可以写出“无 bug 的软件”（86%），它有很好的性能（84%），以及它有安全和可靠的保证（69%）。76% 的回复者还表示使用 Rust 是因为它很有趣和享受。Rust 在工作中的使用情况：越来越多的组织在 2022 年使用了 Rust。29.7% 的回复者表示他们在工作中主要使用 Rust，这比去年增加了 51.8%。使用 Rust 的回复者中，72% 表示它帮助他们实现了团队的目标，75% 计划在未来继续使用它。但是，Rust 的学习曲线也是一个重要的考虑因素；39% 的回复者表示学习 Rust 是“有挑战性的”，9% 的回复者说在工作中采用 Rust “拖慢了他们的团队”。不过，60% 的高效用户认为 Rust 值得付出学习的代价。对 Rust 未来的担忧和期待：回复者中有 26% 担心 Rust 的开发者和维护者没有得到适当的支持，这比去年下降了 30% 多。38% 担心 Rust “变得太复杂”，只有少数人担心文档、企业干预或演进速度等问题。34% 的回复者对 Rust 的未来没有任何担忧。与此同时，对 Rust 在行业中的应用的担忧也下降了 21%，说明人们对 Rust 的持久性和通用性有更多的信心。感谢所有参与调查和为 Rust 做出贡献的人，并鼓励大家继续关注和支持这门语言。\n2022 Rust 年度调查报告 - 原文\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-08 22:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 2022 年度调查报告"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"pgvecto.rs 是一个 Postgres 扩展，使用 Rust 编写，用于在 Postgres 中实现向量相似性搜索。它的 HNSW 算法在90％的召回率下比 pgvector 快20倍。但速度只是开始，我们已经将其作为可扩展架构，使得添加新算法也非常轻松，以便贡献者可以快速实现新索引，并期待开源社区将 pgvecto.rs 推向新的高度！pgvecto.rs 的核心是一组定义向量索引所需行为（例如构建、保存、加载和查询），目前带有两种内置索引类型:但是，任何人都可以引入其他索引，例如 RHNSW、NGT，或针对特定用例量身定制的自定义类型。可扩展架构使 pgvecto.rs 适应新向量搜索算法的出现。它还允许您选择适合您数据和性能需求的正确索引。 pgvecto.rs 提供了框架，使 Postgres 中的向量搜索尽可能灵活和未来。基准测试显示，pgvecto.rs 比现有 Postgres 扩展（如 pgvector）提供了巨大的速度改进。在测试中，其 HNSW 索引表现出高达25倍于 pgvector ivfflat 索引的搜索性能。灵活的架构还允许使用不同的索引算法来优化最大吞吐量或精度。我们正在开发量化 HNSW，请也请关注！\ngithub 仓库地址\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-08 22:34"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"pgvecto.rs: 更快的速度，更好的可扩展性"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本文介绍了如何使用 Rust 编写 absolut 库，该库可以自动生成字节级的 SIMD 查找表。\nSIMD 查找表可以用于高效地扫描字节数组，并找到其中特定字节的索引。\nabsolut 库使用 SMT 求解器来自动生成 SIMD 查找表。\nabsolut 库还支持自定义字节类，并可以生成不同长度的 SIMD 查找表。\n本文还给出了 absolut 库的使用示例。\n原文链接https://www.fuzzypixelz.com/blog/absolut/absolut 的 github地址https://github.com/fuzzypixelz/absolut"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-07 18:41"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"自动生成字节级的 SIMD 查找表"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这篇文章作者对 Rust 中 Allocator trait 的现状有一些疑问。作者认为，Allocator trait 还不稳定，存在一些根本性的问题。作者还列出了一些具体的问题，例如:\n使用 &self 而不是 &mut self。作者认为，这会导致非 ZST Allocator 的性能问题。\nLayout 是否应该是 NonZeroLayout？作者认为，答案可能是“是”，但也应该探索其他途径。\n等等更多...\n作者最后表示，他打算在未来几篇文章中对这些问题进行更详细的讨论原文链接https://shift.click/blog/allocator-trait-talk/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-07 18:41"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"让我们谈一谈 Allocator trait"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"kinded库可以帮你自己生成不带变量的 enum, 例如下面例子中, DrinkKind就是自动生成的.原文链接https://www.greyblake.com/blog/handling-rust-enum-variants-with-kinded-crate/github地址https://github.com/greyblake/kinded"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-07 18:41"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用kinded库来处理 enum"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"ratatui 是一个 Rust 库，用于构建丰富的终端用户界面和仪表板。它是原始 tui-rs 项目的社区分支日前, tui-rs 上的一个 commit 已经正式在其 README 上添加说明, 宣布 tui-rs已经不再维护, 请使用社区维护版本 rataui.https://github.com/fdehau/tui-rs/commit/335f5a4563342f9a4ee19e2462059e1159dcbf25rataui github 地址https://github.com/ratatui-org/ratatui--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-07 18:41"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rataui: tui-rs 的社区继承版本"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我刚刚发布了OctaSine v0.9.0，支持滑音/滑音和单声道模式，并修复了语音结束时相位未重置的错误。https://www.octasine.com/完整发行说明：Added\n添加单声道语音模式（一次仅激活一次语音）。在此模式下，当包络重新启动时，攻击将从之前的音量开始，而不是从零开始\n添加滑音（滑音）\n\n适用于和弦和单声道语音模式\n可以设置为 OFF、LEG（仅在演奏连奏时滑音）或 ON（始终滑音）\n支持线性恒定时间（LCT）和线性恒定速率（LCR，每倍频程时间）模式\n支持时间/速率的可选 BPM 同步\n在单声道模式下滑动时可以选择重新触发包络和 LFO\n\n\n\n适用于和弦和单声道语音模式\n可以设置为 OFF、LEG（仅在演奏连奏时滑音）或 ON（始终滑音）\n支持线性恒定时间（LCT）和线性恒定速率（LCR，每倍频程时间）模式\n支持时间/速率的可选 BPM 同步\n在单声道模式下滑动时可以选择重新触发包络和 LFO\nChanged\n将补丁设置覆盖替换为用于切换替代可见控件的按钮\nFixed\n语音阶段结束时重置。这解决了以下问题：没有中间参数更改的后续按键不会产生相同的声音。\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-06 21:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"OctaSine v0.9.0（免费开源频率调制插件）：滑音、单声道模式、错误修复"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"在过去一周左右的时间里，我一直在研究 ksync，这是一个“不错的文件同步解决方案”，使用 Tokio 异步框架和 sled 数据库用 Rust 编写：https: //github.com/jcbsnclr/ksynchttps://github.com/jcbsnclr/ksync现在还处于早期阶段，但它支持：\n通过 CLI 实用程序向服务器上传/下载\n从服务器检索文件列表及其元数据\n清除服务器的数据库\n双向（客户端 <-> 服务器）同步\n文件去重\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-06 21:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"ksync - 文件同步解决方案，用 Rust 编写"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"baymax-xhl"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"dora-rs 是一个用 Rust 编写的实验性 ROS2 替代品，使用我们自己的共享内存服务器和 Apache Arrow 来实现零复制。零复制使 dora-rs 非常快，与 Python 中的 ROS2 相比快达 17 倍！在 Github 上了解更多信息： https: //github.com/dora-rs/dora在我们的文档网站上了解更多信息：https: //dora.carsmos.ai/https://github.com/dora-rs/dora"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-06 21:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"dora-rs：Python 的实验性 ROS2 替代方案，速度提高了 17 倍，用 Rust 编写 ☺️"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"StackOverflow 称，Rust 已经连续七年成为最受推崇的编程语言。但是它也因为编译时速度慢而臭名昭著。这是设计好的，而且有充分的理由; 编译器强制执行约束，使 Rust 在运行时安全。但是编译时间慢的问题是，如果忽略它，等待时间会增加，运行 CI/CD 的成本会增加，反馈循环会逐渐延长。我们不希望 Rust 编译器窃取我们的生产力！最终，我们希望使用消耗更低的 CI/CD。如果您碰巧在修复生产环境中的一个 bug，您将意识到更快的迭代和更快的 CI/CD 的重要性。在本文中，我们将重点讨论在 Rust 项目中可以使用的优化 CI/CD 管道的不同策略。文章链接，https://blog.logrocket.com/optimizing-ci-cd-pipelines-rust-projects/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.logrocket.com/optimizing-ci-cd-pipelines-rust-projects/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-05 22:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"优化 Rust 项目中的 CI/CD pipelines"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"有人吗！我想和大家分享一下我在假期间所做的工作: 一个类似 Redis 的键值缓存数据库。我的主要目标是更好地学习 Rust (尤其是 Tokio) ，但它发展成了一个稍微大一点的东西。到目前为止，我已经用一些基本命令和一个 cli 客户端实现了服务器。如果有人对此感兴趣，我会在假期后继续研究它，并实现一些针对 Rust、 Python 等的 SDK。文章链接，https://www.reddit.com/r/rust/comments/15ivp7s/cachewdb_an_inmemory_key_value_database/Github 链接，https://github.com/theopfr/cachew-db"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/theopfr/cachew-db"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-05 22:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"CachewDB-用 Rust 实现的内存键值数据库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个易于使用的、健壮的库，用于在终端中显示spinners。Install:Usage:文章链接，https://www.reddit.com/r/rust/comments/15hzpct/spinoff_version_08_is_out/Github 链接，https://github.com/ad4mx/spinoffhttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/ad4mx/spinoff"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-05 22:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"spinoff - version 0.8"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 安全响应工作组收到提醒，Cargo 在类 UNIX 系统上提取 crate 档案时不遵守 umask。如果用户下载了一个包含任何本地用户均可写入的文件的包，则另一个本地用户可以利用它来更改当前用户编译和执行的源代码。此漏洞已分配为 CVE-2023-38497。详情请看：https://blog.rust-lang.org/2023/08/03/cve-2023-38497.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.rust-lang.org/2023/08/03/cve-2023-38497.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-05 01:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Cargo 安全公告 (CVE-2023-38497)"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 对泛型的使用使开发人员能够编写灵活且可重用的代码。泛型允许定义函数、结构和枚举，而无需指定它们将操作的数据类型。这意味着单个实现可以处理各种类型的数据，从而使代码更加通用。此外，泛型提供了更好的类型安全性并减少了错误的可能性。详情请看：https://earthly.dev/blog/rust-generics/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://earthly.dev/blog/rust-generics/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-05 01:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Rust 泛型编写灵活且可重用的代码"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Leptos 是一个全栈同构 Rust 网络框架，利用细粒度的反应性来构建声明式用户界面。详情请看：https://github.com/leptos-rs/leptos/releases/tag/v0.4.8"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/leptos-rs/leptos/releases/tag/v0.4.8"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-05 01:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"leptos-rs 项目 v0.4.8 版本更新"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"spinoff，易于使用、强大的 Rust 库，用于在终端中显示微调器，例如可以在中间做一个 loading 得小动画。项目地址：https://github.com/ad4mx/spinoffhttps://github.com/Jancd"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/ad4mx/spinoff"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-05 01:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"spinoff - 0.8 版本已经发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"@kobzol 的新文章，介绍了关于优化 Rust 编译器构建、测试和性能监视基础设施的方案和实施情况。https://github.com/kobzol根据作者的工作，文章内容分为三类： Rust 编译器（rustc）构建配置、 Rust 基准测试套件（rustc-perf）和 rustc  持续集成工作流。How to improve Rust compiler's CI in 2023 ：https://kobzol.github.io/rust/rustc/2023/07/30/optimizing-rust-ci-2023.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://kobzol.github.io/rust/rustc/2023/07/30/optimizing-rust-ci-2023.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-04 08:18"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"文章：2023 年对 Rust 编译器 CI 的改进"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Polars 最开始是 @ritchie46 的个人玩具项目，用于学习关于查询引擎、Apache Arrow 和 Rust 编程语言的相关知识。时至今日，已经成为发展最快的数据处理项目之一，并且也是最快的开源 OLAP 查询引擎之一。https://github.com/ritchie46Polars 近日宣布已经获得由 Bain Capital Ventures 领投的约 400 万美元种子轮融资，致力于实现由 Rust 支撑的计算平台，以在任何规模硬件和数据上运行 Polars 。Polars is starting a company: https://www.pola.rs/posts/company-announcement/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.pola.rs/posts/company-announcement/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-04 08:18"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"新闻：Polars 获约 400 万美元种子轮融资"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 506: https://this-week-in-rust.org/blog/2023/08/02/this-week-in-rust-506/https://github.com/PsiACE"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2023/08/02/this-week-in-rust-506/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-04 08:18"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Week In Rust 506"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"CnosDB 是一款高性能、高压缩率、高易用性的开源分布式时序数据库。主要应用场景为物联网，工业互联网，车联网，IT运维等。所有代码均已在GitHub开源。今天发布了 v2.3.2 版本。\n添加监控指标“http_data_out”；\n在客户端添加分块模式；\n向 WAL 添加了新的日志类型：DROP VNODE 和 DROP TABLE。\n\n\n改进了 Flight-sql 实现，添加了 do_put_prepared_statement_update 接口的实现；\n\n\n增强的元观察和优化查询之间的交互；\n\n\n升级 datafusion 版本至27.0.0 ；\n\n\n向 Flatbuffers 模型添加了额外的方法。\n\n\nhttps://github.com/cnosdb/cnosdb/releases/tag/v2.3.2\n\n改进了 Flight-sql 实现，添加了 do_put_prepared_statement_update 接口的实现；增强的元观察和优化查询之间的交互；升级 datafusion 版本至27.0.0 ；向 Flatbuffers 模型添加了额外的方法。https://github.com/cnosdb/cnosdb/releases/tag/v2.3.2"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-02 23:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"cnosdb 2.3.2 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"ReadySet 是一个轻量级 SQL 缓存引擎，位于您的应用程序和 Postgres 或 MySQL 数据库之间，甚至可以将最复杂的 SQL 读取转变为闪电般快速的查找。与其他缓存解决方案不同，ReadySet 会自动使缓存保持最新状态，并且无需更改应用程序代码。ReadySet 将查询结果存储在内存中，并随着底层数据库的变化自动保持这些结果最新。ReadySet 可以自动执行此操作，因为它侦听数据库的复制流。这意味着：\n\n无需额外代码即可保持缓存和数据库同步\n\n\n没有额外的代码来驱逐过时的记录\n\n\n无需设置 TTL - 您的缓存与复制延迟一样最新\nReadySet 与 MySQL 和 Postgres 有线兼容。\n\n\nhttps://github.com/readysettech/readyset\n\n无需额外代码即可保持缓存和数据库同步没有额外的代码来驱逐过时的记录无需设置 TTL - 您的缓存与复制延迟一样最新ReadySet 与 MySQL 和 Postgres 有线兼容。https://github.com/readysettech/readyset"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-02 23:32"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"ReadySet -- 基于 Rust 的轻量级 SQL 缓存引擎"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这篇文章大致上是标题相关的内容，但首先，让我简单介绍一下关于 SIMD 的故事。对于SIMD的工作原理，可以分为三个层次的理解（至少我目前处于第三层）：最近我从第二层级升级到了第三层级，这让我意识到编译器在优化过程中使用的模型在我的脑海中一下子明了起来。在这篇文章中，我想解释一下关于静态语言（如Rust或C++）编译器优化的一般框架。之后，我将运用这个框架来讲解自动向量化。ReadMore: https://matklad.github.io/2023/04/09/can-you-trust-a-compiler-to-optimize-your-code.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://matklad.github.io/2023/04/09/can-you-trust-a-compiler-to-optimize-your-code.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-01 17:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"编译器优化后代码能够被相信吗"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Ubiquity是一个用 Rust 编写的免费开源的 Markdown 编辑器。它使用了 Yew、Tauri、Tailwind 和 DaisyUI。这是一次重大更新，带来了令人兴奋的新功能和改进。新功能:\nMarkdown表格生成器 - 由Luka Kerr的mdtg提供。\nPDF导出 - 您现在可以将Ubiquity的精美HTML预览导出为PDF。只需点击标题栏中的保存图标，然后从下拉菜单中选择 Export as PDF 。这将打开您浏览器的打印对话框，您可以选择将文件保存为 .pdf 或打印出来。\n错误提示 - 如果应用程序发生错误，Ubiquity现在会为您提供错误提示。\n改进:\n为桌面用户界面的文本编辑器标题栏添加了分隔符；改进了标题栏对屏幕尺寸的处理。\n在主应用程序标题中添加了工具提示。\n将编辑器字体大小和预览字体大小的图标更改为更易于理解的放大镜图标。\nReadMore: https://ubiquity.rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://ubiquity.rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-01 17:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Ubiquity v0.4.0 更新"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"为了方便对开源项目做出贡献，第一步是找到它的公共版本控制系统（Version Control System，VCS），而现在通常都在 GitHub 上。特别是 Rust 的 crate 应当在其元数据中包含一个指向其 VCS 的链接。我在 2023 年 6 月 17 日 11:08:42 +0300 开始编写 Rust Digger，距今已经一个多月了。由于刚开始学 Rust，一开始进展非常缓慢，但几周后开始有了一些形式。我甚至找到了一些 crate，它们链接到了 http://github.com（而不是 https），或者链接到了 www.github.com 而不是 github.com。这些都不是大问题，但我提交了一些 Pull Request 来修复这些问题，我认为大多数 PR 都被接受了。这是基于 Rust Digger 收集的数据的第一个报告。下面是统计页面的副本。一些亮点：我们找到了 120,484 个 crates。其中近 80% 的 crates 都有一个指向其代码库（公共版本控制系统）的链接。另外 3% 在主页字段中有一个值，很多情况下那实际上是指向其代码库的链接。17.17% 的 crates 既没有代码库链接，也没有主页链接。还有 313 个 crates（总数的 0.26%）使用了一个 http 链接来连接它们的 git repo。这不是个大问题，毕竟 VCS 主机很可能会重定向到 https 版本，但使用 https 链接更为正确。你可能会问，80% 是高还是低。我在 PyDigger 上的统计数据显示，只有 63.49% 的 Python 包有指向其 VCS 的链接，而这只涵盖了最近上传的 115,321 个包。对于较旧的包来说，这个比例可能更低。因此，80% 比 Python 的比例要好得多，但仍意味着对于 17-20% 的 crates，我们没有非常简单的方式来找到它们的代码库。几乎 75% 的 crates 都使用 GitHub 作为它们的代码库，其余的 5% 分布在其他服务上。GitLab 占 2.68%。还有 1,821 个 crates（占所有 crates 的 1.51%）我们还没有对其代码库进行分类，这需要进行一些手动工作。其中一些 crate 使用了链接到 github.com 的 http 链接。ReadMore: https://rust-digger.code-maven.com/news/first-report"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://rust-digger.code-maven.com/news/first-report"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-08-01 17:45"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"统计报告：超过80%的仓库发布在公共VCS上"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这篇文章主要介绍了Rust中流处理的概念、方法和优化。作者介绍了流处理的基本概念，以及Rust中常用的流处理库，并使用这些库实现了一个流处理程序。最后，作者介绍了如何通过测量空闲和阻塞时间来优化流处理程序的性能。作者还提供了一些其他的优化建议，例如：\n在实际系统中，应该考虑将线程固定到CPU内核上，或者使用一种版本的绿色线程来减少上下文切换。\n在处理流时，通常需要为结果分配内存。内存分配是昂贵的，所以在以后的文章中，作者将会介绍一些优化内存分配的方法。\n原文链接https://noz.ai/hash-pipeline/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-31 17:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust中的高吞吐量流处理"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这篇文章介绍了一种实现并发向量的方法。该方法使用一个共享计数器来分配下一个元素的索引，并使用一个原子标志来表示元素是否已初始化。这种方法完全是无锁的，并且可以实现非常cheap的读取操作。文章还介绍了如何在内存中存储并发向量。最简单的方法是使用一个链表，但是这种方法会导致随机访问的性能很差。另一种方法是预先分配一个数组，并在需要时延迟分配每个元素。这种方法可以通过使用leading zeros指令来有效地计算元素的索引。文章最后讨论了如何在并发向量中实现写操作。最简单的方法是使用一个Mutex来同步对chunk的分配。另一种方法是使用一个lock-free的算法，但是这种方法在高并发的情况下可能会导致不必要的开销原文链接https://ibraheem.ca/posts/a-lock-free-vector/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-31 17:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一个无锁 Vector"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"iced 是一个 Rust 跨平台 GUI 库, 拥有 20k⭐️. 他拥有以下特性.\n简单、易用、开箱即用的 API\n类型安全、响应式编程模型\n跨平台支持（Windows、macOS、Linux 和 Web）\n响应式布局\n内置小部件（包括文本输入、可滚动控件等）\n自定义小部件支持（创建您自己的！）\n带有性能指标的调试叠加层\n对异步操作（使用 futures！）的首选支持\n...\n目前 0.10 版本发布.原文链接https://github.com/iced-rs/iced/releases/tag/0.10.0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-31 17:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"iced 0.10发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"dui 是一个可交互式的 du 命令的实现. 可以让你更快的发现哪个目录占据了大量的磁盘.原文链接https://stegosaurusdormant.com/dui/--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-31 17:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"dui: 一个可交互的 du"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Lemmy 与 Reddit、Lobste.rs 或 Hacker News 等网站类似：你可以订阅你感兴趣的论坛，发布链接和讨论，然后进行投票或评论。但在幕后，Lemmy 和他们不同 —— 任何人都可以很容易地运行一个服务器，所有服务器都是联邦式的（想想电子邮件），并连接到 联邦宇宙。https://github.com/LemmyNet/lemmy本版本对数据库查询进行了重大优化，显着降低了 CPU 使用率。网站: https://join-lemmy.org/GitHub: https://github.com/LemmyNet/lemmy"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/LemmyNet/lemmy"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-30 23:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Lemmy v0.18.3发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"jlrs 是一个提供对大多数 Julia C API 的访问的 crate，它可用于将 Julia 嵌入 Rust 应用程序中，并在 Rust 中编写可调用函数时使用它提供的功能。本版本主要关注性能。GitHub: https://github.com/Taaitaaiger/jlrs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/Taaitaaiger/jlrs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-30 23:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"jlrs v0.19发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"DropZone 是一个用户友好的 CLI 工具，旨在促进跨多个设备的无缝数据共享。无论是简单的文本还是剪贴板内容，无论什么操作系统，这款轻量级云剪贴板都能满足我们的需求。特点如下：\n在多台机器之间轻松共享文本和剪贴板数据。\n与大多数操作系统兼容。\n可配置数据过期时间（默认值为 5 分钟）。\nGitHub: https://github.com/arjunkomath/DropZone"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/arjunkomath/DropZone"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-30 23:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"DropZone云剪贴板"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个非常轻巧的终端贪吃蛇游戏。GitHub: https://github.com/Rodrigodd/tiny-snake.rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/Rodrigodd/tiny-snake.rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-30 23:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"贪吃蛇"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是一个系列博客，学习目的，用Rust些一个Java虚拟机。Blog: https://andreabergia.com/series/writing-a-jvm-in-rust/GitHub: https://github.com/andreabergia/rjvm"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/andreabergia/rjvm"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-30 23:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用Rust实现JVM"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 基金会的安全计划于 2022 年创建，旨在支持 Rust 编程语言生态系统的安全改进。 近期发布了第一份安全计划报告，基金会详细介绍了最近的 Rust 安全重点领域、里程碑和即将推出的计划。报告下载链接，https://foundation.rust-lang.org/static/publications/security-initiative-report-july-2023.pdf"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://foundation.rust-lang.org/static/publications/security-initiative-report-july-2023.pdf"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-30 19:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 基金会发布首份安全计划报告"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Chidori 是一个用于构建 AI 代理的响应式运行时。 它提供了一个用于构建响应式、可观察和鲁棒性的人工智能代理的框架。它支持使用 Node.js、Python 和 Rust 构建代理。目前处于 alpha 阶段，尚未准备好用于生产使用。GitHub 链接，https://github.com/ThousandBirdsInc/chidori"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/ThousandBirdsInc/chidori"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-30 19:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Chidori，构建 AI 代理运行时"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"直播中，Jon 将揭开 axum 的外壳——探索它的界面、结构和机制。 讨论 tower::Service、Handler、Routers 和 State 提取器，还探讨了 axum 在编译时确保所有处理程序都可以访问它们在运行时所需的状态的方式。https://github.com/tokio-rs/axum/YouTube链接，https://youtu.be/Wnb_n5YktO8https://github.com/lesterli"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://youtu.be/Wnb_n5YktO8"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-30 19:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"【视频】解读 Axum"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"去年，作者致力于改进用于构建 Rust 编译器的配置文件引导优化 (PGO) 工作流程。在这样做的过程中，虽然 PGO 对于 Rust 工作得很好，但它并不像希望的那样易于使用和发现。这促使我创建了 cars-pgo，这是一个 Cargo 子命令，可以更轻松地使用 PGO（和 BOLT，见下文）优化 Rust 二进制文件。更多请看原文：https://kobzol.github.io/rust/cargo/2023/07/28/rust-cargo-pgo.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://kobzol.github.io/rust/cargo/2023/07/28/rust-cargo-pgo.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-29 01:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Cargo-PGO 优化 Rust 程序"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该项目将 Meta 的大型语言模型 Llama2 移植到 Rust 深度学习框架 Burn。具体来说，该项目包含将 Llama2 模型的权重转换、加载和验证为与 Burn 框架兼容的参数所需的 Python 和 Rust 脚本。项目地址：https://github.com/Gadersd/llama2-burn"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/Gadersd/llama2-burn"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-29 01:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"llama2-burn 项目"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Jancd"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rerun 是一个用于记录计算机视觉和机器人数据的 SDK，与可视化工具配合使用，可随时间探索该数据。它可以让您用最少的代码调试和了解系统的内部状态和数据。Rerun 记录图像、点云等，并轻松实现可视化，使用 Rust 中构建。项目地址：https://github.com/rerun-io/rerunhttps://github.com/Jancd"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rerun-io/rerun"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-29 01:42"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rerun 0.8 版本发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"portrait库发布了derive_delegate derive filler,它可以为任何拥有#[portrait::make]属性的trait派生出trait实现,通过委托给struct/enum的所有字段来实现trait。这可以看作是许多标准库derive宏的通用版本。derive_delegate的行为类似于标准库中的许多宏。一个全能的示例代码是:这样就可以自动为Fields派生Foo的实现,通过委托给其字段。更多信息见:derive_delegate通用derive宏 ↗: https://users.rust-lang.org/t/derive-delegate-the-generic-derive-macro-for-all-traits/97570"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://users.rust-lang.org/t/derive-delegate-the-generic-derive-macro-for-all-traits/97570"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-28 00:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"推出通用的derive宏portrait"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"mold并行链接器发布2.0版本。它可以显著加速Rust编译时的链接过程。此外,mold的许可证也从AGPL改为了更宽松的MIT。mold linker利用并行化可以大幅提升链接速度,对于大型代码库编译时间的改善尤为明显。更多信息见:mold 2.0发布 ↗: https://www.reddit.com/r/rust/comments/15ahlpy/mold_parallel_linker_200_released_mold/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/15ahlpy/mold_parallel_linker_200_released_mold/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-28 00:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"并行链接器mold 2.0发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本文介绍了如何使用Bazel构建Rust工作空间,其中涉及到配置Bazel工作空间、编写BUILD文件、处理依赖等内容。文章以ripgrep项目为例,详细介绍了如何从Cargo移植到Bazel,包括构建和测试二进制、编写BUILD文件、处理外部依赖等。这为打造大型Rust项目提供了一种更灵活可扩展的构建系统选择。更多信息见:Bazel构建Rust工作空间 ↗: https://www.tweag.io/blog/2023-07-27-building-rust-workspace-with-bazel/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.tweag.io/blog/2023-07-27-building-rust-workspace-with-bazel/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-28 00:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Bazel构建Rust工作空间"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本文请求对C++协程提案P2300和Rust的Zero-cost抽象进行详细比较,包括相似点和不同点等。文章分析了两者在延迟计算、组合futures、运行时开销等方面的区别,以帮助读者深入理解P2300提案。更多信息见:P2300和Rust零成本抽象比较 ↗: https://www.reddit.com/r/cpp/comments/15aqz09/request_a_detailed_comparison_between_p2300_and/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/cpp/comments/15aqz09/request_a_detailed_comparison_between_p2300_and/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-28 00:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"C++协程与Rust Zero-cost Abstraction比较"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust周报的最新505期发布,其中收录了许多Rust社区的近期动态,包括RFC批准、新CRATE推荐、会议信息等。周报为跟进Rust社区进展提供了很好的渠道。更多信息见:Rust周报505期 ↗: https://this-week-in-rust.org/blog/2023/07/26/this-week-in-rust-505/请关注我们的更新，以便了解更多有关Rust的新闻和动态！"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2023/07/26/this-week-in-rust-505/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-28 00:27"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust周报第505期发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"手动内存管理和内存安全过去是不相容的。但是，我们可以设计在编译时提供内存安全的编程语言和类型系统，将高级语言的安全性与 C 语言等语言的性能和底层控制结合起来。Rust是第一种成功使用所有权类型实现内存安全的工业语言。Move 语义Rust 每个值都是一棵以程序变量为根的树，每个值都是owned和affine。trait告诉编译器如何销毁值及其相关资源。Drop当一个值离开作用域时，它就被Drop了。Rust 会插入对相应析构函数的调用。可以通过实现trait对Drop进行自定义，这样就可以在析构函数:Drop 中进行 RAII 和关闭网络套接字等操作。....ReadMore:https://borretti.me/article/type-systems-memory-safety#rust"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://borretti.me/article/type-systems-memory-safety#rust"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-26 18:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"内存安全的类型系统"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"什么是 IPFS 引导节点引导节点是IPFS网络上的受信任对等节点，IPFS节点通过该节点了解网络上的其他对等节点。连接数对计算机的 CPU 使用率没有显著影响。节点\t每个连接的内存。< 300 kbyteReadMore: https://blog.ipfs.tech/2023-rust-libp2p-based-ipfs-bootstrap-node/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.ipfs.tech/2023-rust-libp2p-based-ipfs-bootstrap-node/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-26 18:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"由 Rust 开发的 IPFS 网络的节点"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Ruffle是一个用Rust编写的Flash Player模拟器。Ruffle 可以在所有现代系统中作为一个单独的系统运行，并可以通过WebAssembly运行在所有现代浏览器上。 利用现代浏览器沙箱的安全性和 Rust 的内存安全保证， 我们认为可以避免Flash的所有安全陷阱。安装使用官方的 Ruffle CDN，或从我们的下载中下载 Ruffle 的“独立”版本， 并在 Flash 内容的页面上包含以下 JavaScript：<script src=\"https://unpkg.com/@ruffle-rs/ruffle\">或者<script src=\"path/to/ruffle/ruffle.js\">ReadMore: https://ruffle.rs/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://ruffle.rs/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-26 18:53"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Ruffle - 一个用Rust编写的Flash Player模拟器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"作者 Nethercote 之前尝试通过对并行后端进行修改来加速 Rust 编译器，但大部分尝试都未能成功。文章中提到，Rust 后端会将生成的 MIR 代码分割成代码生成单元（CGUs），然后使用 LLVM 生成机器代码。 他所尝试的 CGU 分割算法，试图将代码均匀地分割成 CGUs，但估计 LLVM 编译每个 CGU 所需的时间是困难的。当前的估计函数经常会低估或高估，这可能会影响编译时间。作者希望通过数据分析技术来改进这个估计函数，他自己也做了一些简单的尝试，不过没有得出什么有价值的结论，因此希望有专业知识的人能够帮助。希望更多的人可以参与到 Rust 编译器的优化工作中来，为 Rust 社区做出贡献。作者之前所做的尝试-博客原文链接https://nnethercote.github.io/2023/07/11/back-end-parallelism-in-the-rust-compiler.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-25 22:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何给 Rust 编译提速？需要数据分析的帮助！"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust-Traverse 是一个基于终端的文件管理器，主要受到 NNN 这个项目的启发。https://github.com/jarun/nnnRust-Traverse 使用了 Ratatui 构建终端的图形界面, 同时将 Crossterm 作为终端的后端。目前，其不仅支持完整的增删改查等基本的功能，还有模糊搜索，书签，文件预览等实用的特性，可配置化和极快的运行速度也是其卖点之一。github仓库地址https://github.com/dmcg310/Rust-Traverse"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-25 22:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust-Traverse：一个功能丰富的终端文件管理器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"rust 日报 babpstep"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 是一种注重安全性的编程语言，但在某些情况下，开发人员可能需要使用 unsafe 关键字来执行某些操作。unsafe 可以提供更高的性能，但可能会牺牲安全性。因此，开发人员在使用时需要非常小心。Geo Ant 列举了几个使用 unsafe 的常见场景，如访问裸指针、调用外部C函数等，并提供了一些建议和最佳实践，以确保在使用 unsafe 时不会引入潜在的安全隐患。他希望通过这篇文章，能够帮助Rust开发人员更好地理解 unsafe 关键字的使用场景和潜在风险。原文链接https://geo-ant.github.io/blog/2023/unsafe-rust-exploration/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-25 22:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"从错误中学习 Unsafe Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Lambert"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"以下内容来自reddit 社区（Distributed computing in Rust, https://www.reddit.com/r/rust/comments/155hxlf/distributed_computing_in_rust/），由小编重新整理后发布，读起来也许会更流畅些，因为在整理过程中，会揉一些小遍的思考进去，感兴趣的小伙伴，可以在读完本文后，去读读原文，链接在上方。因为是边看reddit，边译边写边思考，可能行文会有些乱。见谅！小编在逛 reddit 社区的时候，看到一篇帖子Distributed computing in Rust”，就忍不住点进去，才发现是一个长帖，很吸引人。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/155hxlf/distributed_computing_in_rust/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-25 10:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"0x、写在前头"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Lambert"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一名叫 amindiro 的老哥提了一个问题，小编分两段来介绍下：https://www.reddit.com/user/amindiro/他说自己是一名机器学习工程师，最近开始学习 Rust，他很喜欢Rust！ 他认为 Rust 将是一种编写数据处理工具的出色语言，并且可以取代现有的库（通常用 Python 或带有 Python wrapper的 C 语言编写）。大规模数据处理通常意味着分布式并行计算。像 dask 和 ray 这样的库是令人惊叹的库，您可以在其中动态地在正在运行的集群上分派函数。 Dask（注：Dask 是一个灵活的 Python 并行计算库） 完全用 Python 编写，通过序列化 Python 函数并使用 TCP 将它们发送到在本地线程池中运行它们的工作进程来解决这个问题。 Ray （注：Ray 是一个开源统一计算框架，可以轻松扩展 AI 和 Python 工作负载）是用 C++ 编写的并且做了同样的事情。他的问题是，这个叫 amindiro 老哥想使用 Rust 在运行时实现相同的行为，像 serde_closure 这样的包用于序列化闭包（serialize closure）并通过网络发送它们。然后他提到这样做有一个问题，就是客户端进程和工作进程的二进制文件要是相同的（注：对，这是这个方法的限制，因为闭包的序列化和反序列化需要在两端使用相同的闭包类型，不知道这样说对不对）。紧接着，这个叫 amindiro 老哥他说，用这个方法的缺点是不能在集群中生成并发送任意的Rust函数给正在运行的进程（can't spawn a cluster and send arbitrary rust functions to the running processes）。https://www.reddit.com/user/amindiro/小遍尝试去理解他的问题：1. 我有机器学习的基础，对传统（这里定义成使用非Rust工具）大规模数据处理我还比较行；2. 因为这里没有提到会不会C++，假设我不会。3. 我还在学习Rust，假设我Rust学的还行，但不是专家级，能用能写小东西。4. 我想使用Rust实现在运行时动态传递函数的行为，并且我要面向的场景是集群（cluster），我该怎么办？省流版描述：如何使用Rust做分布式计算集群中的大规模数据处理工作？二更问题：如何使用Rust实现一个灵活、高效的分布式计算框架，重点是可以调度任意函数并支持Actor模型，从而可以更方便地进行分布式计算和处理大规模的任务。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-25 10:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一、先说问题"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Lambert"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"第一种讨论是，在分布式节点中，可以考虑让 WASM模块 与本机计算库交互，但是如果需要高性能和高效率，就需要评估Wasm和本机代码之间的差异了。但是这样做有一个问题，WASM 的当前标准是 32 位，64 位版本仍处于提案阶段（注：https://webassembly.github.io/spec/core/bikeshed/，Future versions of WebAssembly might provide memory instructions with 64 bit address ranges. 其实还有一点，wasm貌似不支持cuda，因为不太懂wasm以及wasm是否有gpu提案这样，这里纯属臆想，欢迎评论区吹水）。因此，这对于处理大型数据集，可能是一个问题。第二种方讨论说是，在 noir（分布式流处理框架）中，使用类似 mpirun 的方法，通过使用 SSH 来分发二进制文件并开始计算。可以研究使用 wasm 运行时来生成和编排分布式应用程序，这似乎是可行的 （注：其实关于使用wasm后与原生相比，性能损失有多少，是一个需要研究的话题）。第三种讨论是，关注 Ray C++，成立一个社区，去推Rust 分布式计算这件事（start a community driven Rust distributed computing project）。第四种讨论是，如果集群节点够大，可以尝试使用GNU Parallel和Rust相结合的方法，这可以绕开序列化 Rust 函数（instead of serializing a Rust function），从而实现通过网络发送二进制文件和环境变量。第五种讨论是，有小伙伴提到 Apache Arrow Ballista（https://github.com/apache/arrow-ballista/）， 但是amindiro 老哥更想的是一个更加通用的使用Rust实现的分布式计算框架（a more general distributed computing framework using Rust）。https://www.reddit.com/user/amindiro/第六种讨论是，有小伙伴提到Arroyo (https://github.com/ArroyoSystems/Arroyo)，这是一个分布式流处理引擎，但是amindiro 老哥提到，如果实例超参数调整工作流程或某些 RL 工作流程，Arroyo会很难实现（For instance Hyper parameter tuning workflow or some RL workflows can be tricky to implement this way）。https://www.reddit.com/user/amindiro/第七种讨论是，“我想使用Rust实现在运行时动态传递函数的行为，并且我要面向的场景是集群（cluster），我该怎么办？”，针对这个问题，可以使用使用 Nextflow（https://www.nextflow.io/） 来进行编排计算执行，amindiro 老哥说他想做的是separate running cluster，所以这里也不行（（注：但是，这个方法应该更适用于Batch Job Workflow，针对实时的Separate Running Cluster，这是两种不同的工作流性质和执行方式）。https://www.reddit.com/user/amindiro/第八种讨论是，elixir + rust nifs。（注：字少事大，感觉很硬的技术栈，不懂）第九种讨论是，使用dll，但是做runtime linking很难。（注：这里简译了，因为不太懂，可以看看：https://www.reddit.com/r/rust/comments/155hxlf/comment/jsw1wfq/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button）第九种讨论是，有小伙伴说， 可以使用nvidia 的 NCLL 来做分布式编程。dask 使用自定义 rpc 协议进行分布式计算。至于 GPU 集群，他认为 nvidia 有 NCLL，这是实现分布式编程的两种不同方法。但是amindiro 老哥说，“Dask RPC 协议基本上是调用 cloudpickle 来序列化 python 函数并通过 TCP 发送它们。当使用编译语言时，这是一个棘手的部分，函数序列化在 Rust 中并不那么简单……NCLL 遵循 MPI 接口，使用起来可能很棘手。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-25 10:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"二、再说回答"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Lambert"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"以上回答部分，对原帖对一些回答进行了摘录、整理和注释。看完这个帖子，感觉这真的是一个好问题，欢迎大家在下方留言讨论，或在群内吹水。大家的办法是什么呢？"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-25 10:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"三、写在最后"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"InfluxDB 是一个开源的、分布式的时序数据库，用于存储和分析时间序列数据, 于 2013 年由 Brian Bondy 和 Nicholas Zakhariev 创立。InfluxDB 最初是用 Go 语言编写的。2018 年，InfluxData 决定将 InfluxDB 重写为 Rust 语言。重写 InfluxDB 的主要原因是 Rust 是一种更快、更安全、更可靠的编程语言。重写 InfluxDB 的过程非常成功。InfluxDB 3.0 在性能、可靠性和安全性方面都有显著的改进, 现在是世界上最快、最可靠的时序数据库之一原文链接视频地址https://www.influxdata.com/blog/meet-founders-who-rewrote-in-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-24 17:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Rust 重写的InfluxDB 3.0"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Egregoria 是一个独立的城市建造器，主要受 Cities:Skylines 启发。每个人都有自己的思维模型，这意味着每个行为都很重要并影响环境。 Egregoria 专注于城市的社会经济方面，并带有物流元素。 游戏仍处于早期开发阶段.githhub地址https://github.com/Uriopass/Egregoria"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-24 17:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Egregoria: 无网格3D城市构建游戏"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"kbt是一个命令行键盘测试器, 厌倦了网上各种半瘫痪的键盘测试器, 所以作者自己做了这个命令键盘测试器.github地址https://github.com/bloznelis/kbt--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-24 17:56"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"kbt: 一个命令行键盘测试器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"使用 Rust 语言编写的Modular UI编译器和运行时库。示例：GitHub: https://github.com/concoct-rs/concoct##时区解析库rtzrtz 是一个极快的时区解析引擎。这是一个用Rust语言编写的库、二进制文件和服务器（也可以通过Wasm使用）。你可以使用这个库，运行自己的服务器，或者也可以使用作者在fly.io上设置的免费服务器。使用示例（二进制）：使用示例（Rust）：使用示例（JS）：GitHub: https://github.com/twitchax/rtz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/twitchax/rtz"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-23 21:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"交互式UI框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Demo: https://azriel.im/dot_ix/GitHub: https://github.com/azriel91/dot_ix"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/azriel91/dot_ix"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-23 21:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"交互式dot图"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Trie（字典树）数据结构用于快速访问与单词及其相关数据相关联的内容。基本的 Trie 被实现为一棵树，每个节点包含一个字符，并且可以指向任何其他字符，因此可以插入任意的单词。每个节点还包含与之相关联的数据的向量。GitHub: https://github.com/lukascobbler/basic_trie"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/lukascobbler/basic_trie"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-23 21:29"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Trie实现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我很高兴地宣布 Fyrox 0.31已经发布了！Fyrox 是一个用 Rust 编写的现代游戏引擎，它可以帮助您使用本地编辑器轻松创建2D 和3D 游戏; 它很像 Godot，但是使用了 Rust。此版本包括编辑器改进、文档改进、整体可用性改进、 bug 修复等。文章链接，https://fyrox.rs/blog/post/fyrox-game-engine-0-31/shebling_rewriting_shellcheck_in_rust/Github 链接，https://github.com/FyroxEngine/Fyrox"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/FyroxEngine/Fyrox"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-23 09:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Fyrox Game Engine 0.31"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Talc是一个性能较好和灵活的非标准兼容的内存分配器，适合如操作系统内核这类的项目，或arena allocation（一种GC优化技术）的普通单线程应用程序。文章链接，https://www.reddit.com/r/rust/comments/155x2ew/talloc_a_better_no_std_allocator/Github 链接，https://github.com/SFBdragon/talc"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/SFBdragon/talc"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-23 09:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Talloc一个更好的no_std allocator"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"binarytom"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"嘿，大家好，这是我第二次发布我的sciport-rs。公共 API 没有改变，我只是增加了大量的测试，以确保从 scypy 正确的移植。文章链接，https://www.reddit.com/r/rust/comments/156o3pr/sciportrs_002_just_released_now_with_full_test/Github 链接，https://github.com/ChristianBelloni/sciport-rshttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/ChristianBelloni/sciport-rs"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-23 09:08"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"sciport-rs 0.0.2"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"jtcpp 是一个实验性的 Rust 程序，它可以将 JVM 字节码转换为 C++。这使得像 Java 和 Kotlin 这样的语言编写的程序能够编译成本机指令，在某些情况下提高性能。GitHub- jtcpp ：https://github.com/FractalFir/jtcpp"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/FractalFir/jtcpp"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-21 09:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"jtcpp：Java 转译到 CPP"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"来自 Yoshua Wuyts 的新文章。文章最开始是由作者、Eric Holk 以及 Koka 创始人Daan Leijen 三者的交流引发的，Daan 认为，在 Koka 的程序中：\n\n~70％ 的程序是全函数（即：没有任何副作用）\n\n\n15％的程序必须处理异常或发散（可能出错、可能 panic 或者可能无限循环）\n\n\n~5％的程序需要直接处理IO资源\n\n~70％ 的程序是全函数（即：没有任何副作用）15％的程序必须处理异常或发散（可能出错、可能 panic 或者可能无限循环）~5％的程序需要直接处理IO资源作者认为这个分布非常有趣，并且就如何在 Rust 中实现全函数进行了讨论。Totality — 2023-07-20: https://blog.yoshuawuyts.com/totality/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.yoshuawuyts.com/totality/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-21 09:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"文章：Rust 背景下的全函数、无 panic 和保证终止"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"PsiACE"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 504: https://this-week-in-rust.org/blog/2023/07/19/this-week-in-rust-504/https://github.com/PsiACE"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2023/07/19/this-week-in-rust-504/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-21 09:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"This Week In Rust 504"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Cannonball 是一个用 Rust 构建 QEMU 插件的框架！您可以在 C 语言的 QEMU TCG 插件中执行的任何操作，都可以使用cannonball。编写以最小的开销和尽可能多的功能运行的插件！"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-21 00:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Cannonball Rust 构建的 QEMU 插件的框架"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这里提供了几个例子！\njaivana\n一个简单的跟踪器，将一组可配置的事件记录到文件或标准输出中。\nmons meg\n一个跟踪器，记录与 Jaivana 相同的事件，但使用 Tokio 在异步环境中运行跟踪，通过 UNIX 套接字而不是匿名管道与主机进行通信。看看它们，它们是学习如何使用这个框架的最佳方式。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-21 00:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"例子"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"安装只需将其添加到您的 Cargo.toml：Jaivana 的演示例子https://github.com/novafacing/cannonball/tree/main/examples/jaivana"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-21 00:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"安装"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"整体设计参考LevelDB，旨在作为NewSQL数据库的存储引擎\n支持嵌入式/单机存储/远程调用等多应用场景\n以Kiss作为开发理念，设计以简单而高效为主导\n实现MVCC以支持ACID\n性能，BenchMark 读取吞吐量约为 Sled 的两倍，且大数据量下的读取顺序平均延迟为 1μs 左右\n远程连接使用ProtoBuf实现，支持多语言通信\n极小内存占用（占用/大量冷数据）\n安全读取\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-21 00:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"kiddb 基于 Rust 的嵌入式存储引擎"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-21 00:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"组件引入"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-21 00:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"代码"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-21 00:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Docker镜像编译"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"EAHITechnology"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\nhttps://github.com/KipData/KipDB\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-21 00:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"直接调用（基本使用）"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"有些事情你总是学了又忘记（或者说你从来就没学过？）对我来说，其中之一就是在Rust中 Pin/Unpin 。每次我读到有关固定的解释，我的大脑就像 👍 ，几周后就像 🤔 🤨 。所以，我写这篇文章是为了强迫我的大脑记住这些知识。我们看看效果如何！"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-18 15:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":""},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Pin 是一种指针，可以看作是 &mut T 和 &T 之间的折中。Pin<&mut T> 的重点是说：为什么？因为有些值必须不能移动，或者需要特别小心地去移动。一个典型的例子就是自指数据结构。在使用 async 时，它们会自然地出现，因为未来值往往会在引用自己的本地值。这个看似温和的 Future：需要一个自我引用的结构，因为在底层，futures 是状态机（不像闭包）。请注意， self_ref 在第一个 await 处将控制权传递回调用者。这意味着尽管 v 和 x 看起来像普通的堆栈变量，但在这里可能发生了更复杂的事情。编译器希望生成类似这样的内容：但是！如果你想的话，你可以移动 SelfRefFuture ，这会导致 x 指向无效的内存。怎么回事？就像一位聪明的编译器曾经说过的：futures do nothing unless you .await or poll them#[warn(unused_must_use)] on by default– rustc这是因为调用 self_ref 实际上什么都不做, 我们实际上会得到类似于:那么在这种状态(初始状态)下可以安全地移动。只有当我们开始在 f 上进行轮询时，我们才会遇到自我引用的问题（x 指针被设置），但如果 f 被包裹在 Pin 中，所有这些移动都变成了 unsafe ，这正是我们想要的。由于许多futures 一旦执行就不应该在内存中移动，只有将它们包装在 Pin 中才能安全地使用，因此与异步相关的函数往往接受 Pin<&mut T> （假设它们不需要移动该值）。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-18 15:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Pin"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这里不需要固定：但是如果我们想要多次调用 timeout （例如，因为我们想要重试），我们将不得不使用 &mut f （否则会得到 use of moved value ），这将导致编译器报错为什么？因为在几个层级下， timeout 调用了被定义为 Future::poll 的函数当我们 await f 时，我们放弃了对它的所有权。编译器能够为我们处理固定引用，但如果我们只提供一个 &mut f ，它就无法做到这一点，因为我们很容易破坏 Pin 的不变性：这个时候我们需要给 future 套上一个 pin!这里还需要再做一点额外的工作，我们需要确保 f 在被 pin 包裹之后不再可访问。如果我们看不到它，就无法移动它。事实上我们可以更准确地表达不能移动规则：指向的值在值被丢弃之前不能移动（无论何时丢弃 Pin）。这就是 pin! 宏的作用：它确保原始的 f 对我们的代码不再可见，从而强制执行 Pin 的不变性Tokio’s pin! 是这样实现的:标准库的版本 pin! 有点更酷，但使用的是相同的原理：用新创建的 Pin 来遮蔽原始值，使其无法再被访问和移动。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-18 15:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一个微小的例子"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"所以 Pin 是一个指针（对另一个指针的零大小的包装器），它有点像 &mut T 但有更多的规则。下一个问题将是“归还借用的数据”。我们无法回到以前的固定未来现在应该更清楚为什么了：被固定的 f 现在是一个指针，它指向的数据（异步闭包）在我们从函数返回后将不再存在。因此，我们可以使用 Box::pin但是我们刚刚不是说 Pin<&mut T> 是 &mut T 和 &T 之间的（一个包装器）指针吗？嗯，一个 mut Box<T> 也像一个 &mut T ，但有所有权。所以一个 Pin<Box<T>> 是一个指向可变 Box<T> 和不可变 Box<T> 之间的指针，值可以被修改但不能被移动。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-18 15:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一个 📦"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Unpin 是一种 Trait。它不是 Pin 的\"相反\"，因为 Pin 是指针的一种类型，而特征不能成为指针的相反。Unpin 也是一个自动特性（编译器在可能的情况下会自动实现它），它标记了一种类型，其值在被固定后可以被移动（例如，它不会自我引用）。主要的观点是，如果 T: Unpin ，我们总是可以 Pin::new 和 Pin::{into_inner,get_mut} T 的值，这意味着我们可以轻松地在“常规”的可变值之间进行转换，并忽略直接处理固定值所带来的复杂性。Unpin Trait 是 Pin 的一个重要限制，也是 Box::pin 如此有用的原因之一：当 T: !Unpin 时，“无法移动或替换 Pin<Box<T>> 的内部”，因此 Box::pin（或者更准确地说是 Box::into_pin）可以安全地调用不安全的 Pin::new_unchecked，而得到的 Box 总是 Unpin 的，因为移动它时并不会移动实际的值。这里说的很绕，我们用例子例子解释一下。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-18 15:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Unpin"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"我们可以亲手创造一个美好的 Future：现在，我们可以多次调用它而不需要固定： timeout使用 async fn 或 async {} 语法创建的任何 Future 都被视为 !Unpin ，这意味着一旦我们将其放入 Pin 中，就无法再取出来。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-18 15:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"另一个微小的例子"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Koalr"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\nPin 是对另一个指针的包装，有点像 &mut T ，但额外的规则是在值被丢弃之前，移动它所指向的值是不安全的。\n为了安全地处理自引用结构，我们必须在设置自引用字段后防止其移动(使用 Pin)。\nPin 承诺该值在其生命周期内无法移动，所以我们无法在不放弃创建 &mut T 的能力并破坏 Pin 的不变性的情况下创建它。\n当在拥有所有权的 Future 进行 await Future 时，编译器可以处理固定，因为它知道一旦所有权转移， Future 就不会移动。\n否则，我们需要处理固定（例如使用 pin! 或 Box::pin ）\nUnpin 是一个标记特征，表示一个类型即使在被包装在 Pin 之后仍然可以安全地移动，使一切变得更简单。\n大多数结构是 Unpin ，但 async fn 和 async {} 总是产生 !Unpin 结构。\nReadMore: https://ohadravid.github.io/posts/2023-07-put-a-pin-on-that/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-18 15:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"摘要"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust 和 Julia 都是用于科学计算的编程语言。Rust 和 Julia 的关键区别：\n静态类型 vs 动态类型：Rust 是静态类型语言，这意味着 Rust 编译器可以检查代码的类型安全。Julia 是动态类型语言，这意味着 Julia 编译器不能。\n并发：Rust 和 Julia 都支持并发编程。但是，Rust 的并发模型更安全，因为它不允许发生数据竞争。\n静态分析：Rust 支持静态分析，这意味着 Rust 编译器可以检查代码中可能存在的错误。Julia 不支持静态分析。\n根据这些关键区别，可以得出以下结论：Rust 是用于科学计算的更好的语言。它更安全、更可靠，并且可以编写更高效的代码。\n以下是一些额外的关于 Rust 和 Julia 的比较：\n性能：Rust 通常比 Julia 更快。这是因为 Rust 的并发模型更安全，因此可以编写更高效的代码。\n可维护性：Rust 代码通常比 Julia 代码更可维护。这是因为 Rust 的静态类型系统可以帮助防止错误，并且 Rust 的静态分析可以帮助检查代码中可能存在的错误。\n社区：Rust 社区比 Julia 社区更小，但它也更活跃。这意味着 Rust 开发人员更容易获得帮助和支持。\n总体而言，Rust 是用于科学计算的更好的语言。它更安全、更可靠、更高效，并且更易于维护。\n原文链接https://mo8it.com/blog/rust-vs-julia/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-17 18:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 和 Julia 在科学计算中的比较"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"该库收集了大量的博客文章、视频等资源，用于学习 Rust. 对学习 Rust 感兴趣的小伙伴可以去上面找找相关的资料.github 地址https://github.com/ctjhoa/rust-learning"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-17 18:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rust-learning: Rust学习资源汇总"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"gensmusic"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"与默认的 clap help 信息相比, 该库的特点:\n更易读：clap-help 使用宽度感知布局，使帮助消息在小型终端上更易读。\n更紧凑：clap-help 可以将帮助消息渲染为比原生帮助渲染器少 2 到 3 倍的行数。\n选项以平衡表格显示：clap-help 以平衡表格显示选项，该表格针对终端的宽度进行了优化。\n描述被解释为 Markdown：帮助消息的介绍可以被解释为 Markdown，这允许使用列表、表格、代码块等。\n选项的文档被解释为 Markdown：选项的文档也可以被解释为 Markdown。\n皮肤会自动为明亮或暗色终端选择：clap-help 会自动为帮助消息选择适合终端的明亮或暗色主题的皮肤。\n可定制的 termimad 皮肤：termimad 皮肤可以定制以更改帮助消息的外观。\n可定制的模板：用于渲染帮助消息的模板可以进行有限的定制。\ngithub地址https://github.com/Canop/clap-help--"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-17 18:59"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"clap-help: 以另外一种方式渲染帮助信息"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Charming是一个功能强大且多用途的Rust图表渲染库，利用Apache ECharts的强大功能提供高质量的数据可视化。该库使用Rust编程语言构建，旨在为Rust生态系统提供一种直观有效的生成和可视化图表的方式，采用声明式和用户友好的API。亮点如下：\n易于使用的声明式API。\n丰富且可自定义的图表主题和样式。\n支持多种格式的渲染，包括HTML、SVG、PNG和JPEG。\n丰富的图表类型。\n示例：绘制结果如下：GitHub: https://github.com/yuankunzhang/charming"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/yuankunzhang/charming"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-16 23:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"可视化工具charming"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个简单的、具有多种功能的终端 / 文件日志记录器。这是simplelog的fork版本，作者之所以创建这个日志记录器，是因为对原工具的格式化能力不够满意，而且要对它进行“修复”所需的更改量太大。https://github.com/Drakulix/simplelog.rsGitHub: https://github.com/qarmin/handsome_logger"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/qarmin/handsome_logger"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-16 23:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"日志记录器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是受cryptdb的ope实现启发的保序加密（Order-preserving encryption，OPE）库。可加密的最大值是65532。示例：GitHub: https://github.com/sentclose/ope/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/sentclose/ope/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-16 23:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"OPE加密库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"长琴"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"一个用Rust编写的Intel 8080 CPU仿真器。该库旨在在不同的平台上重用：macOS、iOS、Android 和（如果可能的话）Web。GitHub: https://github.com/k0Iry/8080-Emulator-in-Rust"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/k0Iry/8080-Emulator-in-Rust"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-16 23:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"8080 CPU仿真器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Lambert"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Polars 是基于 Rust 实现的 OLAP 查询引擎之上的 DataFrame 接口，使用 Apache Arrow 列格式作为内存模型。在reddit上，有小伙伴提到，他想使用 Polars 而不是 Pandas，但发现文档很少，希望有人可以制作一些关于用 Polars 替换基本 Python 数据分析工作的教程，那就太棒了。社区的小伙伴可以在该帖下方留言，我们一起寻找优质的教程👀阅读更多：Github：https://github.com/pola-rs/polarsReddit：https://www.reddit.com/r/rust/comments/150cew4/rust_polars_031_release/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://www.reddit.com/r/rust/comments/150cew4/rust_polars_031_release/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-16 08:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Polars 0.31 release"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Lambert"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"微软Windows Blogs发文，称：与用 C/C++ 编写的传统程序相比，Rust 在可靠性和安全性方面具有优势。此预览版附带了 safe Rust 中关键内核功能的早期实现。具体来说，win32kbase_rs.sys 包含  Windows GDI region https://learn.microsoft.com/zh-cn/windows/win32/gdi/regions 的新实现。虽然这是一个小试验，但我们将继续增加 Rust 在内核中的使用。敬请关注！"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://learn.microsoft.com/zh-cn/windows/win32/gdi/regions"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-16 08:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust在Windows 11 Insider Preview Build 25905中的表现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Lambert"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"想要找工程的小伙伴可以关注rustjobs的官推或网站https://rustjobs.dev/Tweetshttps://twitter.com/rustjobs_dev/status/1679070864745062403"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://rustjobs.dev/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-16 08:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"在rustjobs上寻找你心仪的工作吧"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Lambert"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"今年11月中旬，RUSTLAB将在佛罗伦萨举办一场RustConf阅读更多：https://rustlab.it/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://rustlab.it/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-16 08:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"由Rustlab主办的Rustaceans大会预告！"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Lambert"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"图片来自推特：https://twitter.com/SearcherEye/status/1679253723996930048"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-16 08:13"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"今日幽默"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本指南介绍了 WebAssembly 是什么、如何将 Rust 编译为 WebAssembly 以在不同的目标中使用以及这样做的最佳实践。可根据指南的示例代码库轻松开始将 Rust 编译为 Wasm，主要关注目标：Webpack，Node.js 和 Deno。指南原文链接，https://grafbase.com/blog/getting-started-with-rust-and-webassembly示例代码的 GitHub 链接，https://github.com/grafbase/getting-started-with-rust-wasm"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/grafbase/getting-started-with-rust-wasm"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-15 21:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 和 WebAssembly 入门指南"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"RustSmith 是一个为 Rust 语言构建的模糊测试工具，目的是模糊 Rust 编译器 (rustc) 并查找编译器内的编译器崩溃和错误编译。GitHub 链接，https://github.com/rustsmith/rustsmith"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/rustsmith/rustsmith"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-15 21:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RustSmith，Rust 语言的模糊测试工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"洋芋"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Internet Archive 使用 Ruffle 支持 Flash，Ruffle 是个用 Rust 实现的 Flash 模拟器。Ruffle  GitHub 链接，https://ruffle.rs/https://github.com/lesterli"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://ruffle.rs/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-15 21:58"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Internet Archive 支持 Flash"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Rust团队发布了Rust 1.71.0版本。以下是该版本的一些亮点：\nC-unwind ABI：这个版本稳定了C-unwind ABI，使得在跨ABI边界时，异常处理的行为更加安全。\n调试器可视化属性：支持#[debug_visualizer(natvis_file = \"...\")] 和 #[debug_visualizer(gdb_script_file = \"...\")] 属性，帮助库作者为用户提供更好的调试体验。\nraw-dylib链接：在Windows平台，Rust现在支持在编译时无需依赖动态库就能使用它们的功能。\n更新musl版本：Rust 1.71将musl版本升级到1.2.3，大部分用户不会受到影响。\n其他：一些新的API稳定化，以及const上下文中的新稳定API。\n点击这里查看Rust 1.71.0的详细公告 ↗: https://blog.rust-lang.org/2023/07/13/Rust-1.71.0.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blog.rust-lang.org/2023/07/13/Rust-1.71.0.html"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-13 23:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 1.71.0发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"微软发布了 Windows 11 Insider Preview Build 25905，其中引入了 Rust 的早期实现。具体来说，在内核中加入了一个名为 win32kbase_rs.sys 的模块，它包含了 GDI（图形设备接口）区域的新实现。虽然这只是一个小试验，但微软表示他们将继续增加在内核中使用 Rust 的程度，以提高 Windows 内核的可靠性和安全性。相比传统的 C/C++ 程序，Rust 具有更多的可靠性和安全性优势。需要注意的是，该功能目前还处于试验阶段，因此并不是所有的Insiders都能够看到该功能。微软表示他们将根据反馈结果来决定是否向所有用户推出该功能。点击这里查看Windows 11 Insider Preview Build 25905的公告 ↗: https://blogs.windows.com/windows-insider/2023/07/12/announcing-windows-11-insider-preview-build-25905/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://blogs.windows.com/windows-insider/2023/07/12/announcing-windows-11-insider-preview-build-25905/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-13 23:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Windows 11 Insider Preview Build 25905"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"本周Rust速览503中提到了一些Rust的新闻、项目更新、教程和杂项。以下是一些亮点：\n官方公告：发布regex 1.9版本\n项目/工具更新：Bevy 0.11, rustc_codegen_gcc进展报告#24, rust-analyzer更改日志#189等\nRust教程：关于如何使用Rust构建聊天机器人、深入理解Pin智能指针等的教程\n点击这里查看本周Rust速览503的详细内容 ↗: https://this-week-in-rust.org/blog/2023/07/12/this-week-in-rust-503/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://this-week-in-rust.org/blog/2023/07/12/this-week-in-rust-503/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-13 23:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"本周Rust速览503"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"Cupnfish"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Jonathan Becker在他的研究中探讨了如何优化Rust代码以获得更好的性能。这篇文章提供了一些关于内存分配、数据结构和算法选择、以及编译器优化等方面的建议。点击这里阅读关于提高Rust代码性能的文章 ↗: https://jbecker.dev/research/on-writing-performant-rust请关注我们的更新，以便了解更多有关Rust的新闻和动态！"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://jbecker.dev/research/on-writing-performant-rust"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-13 23:48"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"提高Rust代码性能的文章"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Pin是一种介于 &mut T 和 & T 之间的智能指针。重点说的是：Pin<T>ReadMore: https://ohadravid.github.io/posts/2023-07-put-a-pin-on-that/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://ohadravid.github.io/posts/2023-07-put-a-pin-on-that/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-12 23:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用 Pin"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"mook"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\ntiny-std 只支持linux\ntiny-std生成的二进制文件更小\ntiny-std只支持 x86_64 和 aarch64\nReadMore:https://github.com/MarcusGrass/tiny-std"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://github.com/MarcusGrass/tiny-std"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2023-07-12 23:02"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"tiny-std 一个小型的std库"},"type":"text"}],"type":"title"}},]
