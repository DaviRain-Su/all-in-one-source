export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "joshsulin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "像许多从事于JavaScript、Java、Ruby等高级语言编程的人一样，Rust真正吸引我的一件事是能够“更接近于计算机底层”。尽管Rust提供了许多高级抽象，但是它肯定会让您比JavaScript、Java、Ruby多考虑一些诸如内存分配之类的低级问题。但是，当然您可以随时更深入，并且了解有关Rust之下的抽象层的更多信息可能是真正了解Rust产生动因的绝佳方法。我们将从Rust开发人员的角度探索汇编语言的世界。我们将编译器视为黑匣子，看看从标准的常规Rust代码生成什么样的汇编指令。这样做应该使我们更加了解机器上实际发生的情况（当然，堆栈比汇编语言抽象层更深）。强烈推荐: https://blog.ryanlevick.com/down-the-stack-part-1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.ryanlevick.com/down-the-stack-part-1/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-24 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "我很好奇Rust在调试和发布模式下会产生什么汇编代码?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "joshsulin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "当你研究了Rust流, 同时也研究了Futures并发, 是时候该将两者结合在一起了, 仔细研究Rust的并发流.详细资料: https://blog.yoshuawuyts.com/streams-concurrency/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.yoshuawuyts.com/streams-concurrency/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-24 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust的并发流, 你知道多少?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "joshsulin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "It features a lot of improvements, but the main news is that it eliminates a major source of bugs and performance issues in concurrent programs: accidental blocking.Read More: https://async.rs/blog/stop-worrying-about-blocking-the-new-async-std-runtime/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://async.rs/blog/stop-worrying-about-blocking-the-new-async-std-runtime/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-24 21:14" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-std升级了, 让你不再担心阻塞了." }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个完全重写的项目，旧的客户端已经被放弃。MongoDB在Rust方面拥有长时间的研究。早在2013年，两名实习生就针对Rust 0.7的数据库编写了原型Rust驱动程序，但是由于Rust语言发展迅速，并且当时进rust行了重大更改，因此这套代码最终被淘汰。Rust驱动程序支持3.6以上的所有MongoDB服务器版本，并且需要Rust 1.39或更高版本。它使用rustlscrate以及SCRAM-SHA-1和SCRAM-SHA-256身份验证实现本机TLS，完全支持独立实例、副本集和分片群集 。https://github.com/ctz/rustls该驱动程序支持连接到MongoDB Atlas和本地部署。通过bson crate驱动程序支持使用serde对从数据库写入的文档进行序列化和反序列化。https://www.mongodb.com/cloud/atlas更多详细信息和使用方法参见https://www.mongodb.com/blog/post/announcing-the-official-mongodb-rust-driver" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.mongodb.com/blog/post/announcing-the-official-mongodb-rust-driver" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-24 00:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MongoDb团队发布正式Alpha版本的客户端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "异步/等待一直是Rust中一个期待已久的功能。对于这个语言来说，是一个巨大的“革命家”。传统上，低级异步编程始终意味着构建状态机，并抽象化围绕它们的系统。尽管Futures库通过为我们提供针对常见场景的预定义状态机确实起到了很大的帮助作用，但Rust中的Futures的原始版本没有什么不同。从某些代码中可以最容易地看出这是更符合人体工程学的示例，这是先前版本的TrustS-DNS（HTTPS请求处理程序）中的示例：上述示例说明了如何将较早的Future组合器一起使用，但是这使得编写一些复杂的代码成为可能。此async fn版本更加简单：此代码更直接，容易阅读，也会更讨巧。这是异步/等待的最大优势，您可以以更简单的方式编写代码。更多细节前往GitHub博客查看详细内容。https://bluejekyll.github.io/blog/rust/2019/12/21/await-trust-dns.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-24 00:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Trust-DNS 0.18发布，具备异步/等待支持和Tokio 0.2兼容性" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "LacneQin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个工程是以为技术极客所创造，它仍然不及正式版本软件的功能完善，因此除非您愿意做出贡献，否则请不要尝试使用它。thatcord的原型Rust Discord库支持tokio 0.2，futures 0.3和异步/等待。由于过于强调原型，因为它目前只能接收，不能发送。并且仅支同时持两个进程。关于文献资料，目前也十分缺乏。但是，这个examples/目录对于该库的当前完整功能应该足够。更多细节及工程克隆请访问GitHubhttps://github.com/Admicos/thatcord\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-24 00:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "异步/等待WIP Discord API库：thatcord" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #rustc一份早来的圣诞节礼物，rustacean们渴望的rustc并行编译功能来咯！大家可以帮助测试rustc的并行编译能力，虽然rust发布团队会克隆各种项目进行编译测试，但是还有会有特殊的场景，希望开发者们踊跃反馈问题。Read Morehttps://internals.rust-lang.org/t/help-test-parallel-rustc/11503" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-22 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "早来的圣诞节礼物——并行编译的rustc" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #node.jsBenoit Chassignol是一名node.js开发者，他写了自己学习Rust的经历，他没有做很多技术层面的对比，更多是从开发体验上谈了他学习rust后的感受。https://blog.link-value.fr/@benoit.chassignol?source=post_page-----dabee9f9c5e1----------------------Read Morehttps://blog.link-value.fr/my-journey-with-rustlang-dabee9f9c5e1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-22 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Node.js开发者学习Rust后的感受" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rustu/bionicbits在Reddit上发帖，他想教孩子们学习rust作为第一门编程语言，他有三个原因支持他的想法，第一学习rust要比JavaScript、python更能了解计算机工作原理；第二，孩子们可塑性强，作为第一门语言，他们不知道它难不难，也不知道学习曲线；第三，现在可视化工具很丰富，可以通过及时的视觉反馈帮助教学。所以他想寻求社区帮助，包括：https://www.reddit.com/user/bionicbits/Repohttps://www.reddit.com/r/rust/comments/ee3oh1/teaching_kids_rust_as_first_language/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-22 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "让孩子们学习rust作为第一门编程语言？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "bumpalo, 快速的bump arena分配。此版本带来了一系列新的辅助方法，用于在arena上分配切片，分配速度提高了3-19％。Githubhttps://github.com/fitzgen/bumpalo/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-21 21:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "bumpalo v3.0.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "tide, HTTP server框架。Githubhttps://github.com/http-rs/tide" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-21 21:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tide v0.5.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "2020年1月25日至26日，第七届国际计算机科学和信息技术会议，瑞士苏黎世，欢迎大家参与。官网https://cosit2020.org/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-21 21:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "CoSIT 2020" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该补丁增加了future::timeout，提供了与其相对应的函数。Githubhttps://github.com/async-rs/async-std/tree/v1.4.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-21 21:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async-std v1.4.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust开发的Telegram机器人（bots）Gitlabhttps://gitlab.com/SnejUgal/tbot--https://rust.cc/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-21 21:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tbot v0.3" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新增了一些新特性#[non_exhaustive] structs, enums, and variants這表示當前的屬性有缺少，要增加屬性欄位，沒增加是會出現錯誤的。範例看到 beta 依賴 alhpa現在可以這樣寫 expand_to_type 是 procedural macrotype Foo = expand_to_type!(bar);extern 裡面也可以有 macroRust 2015的借用檢查警告會變成錯誤更多 const fn 函數進入標準庫還有其它一些函數跟macro也穩定了Read morehttps://blog.rust-lang.org/2019/12/19/Rust-1.40.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-21 13:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.40.0 了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "至少要使用 rust 1.40.0因為使用了 non_exhaustive 特性與標準庫具有完全的相容性。每種類型都可以執行與標準庫對應的相同算法，反之亦然。類型可以在標準庫之間自由轉換。Read morehttps://docs.rs/time/0.2.0/time/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-21 13:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "time v0.2" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Signal是一個通訊軟體，類似Line, WhatApps, Telegram, QQ本文大部份是講他們遇到的分散式儲存問題，最後他們使用Raft同步。Signal選擇將Rust用於我們的Raft實現，他們選擇的重點是因為正確性，而不是性能，因此即使有機會加快某些操作的速度，我們也不會偏離Raft規範。Read morehttps://signal.org/blog/secure-value-recovery/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-21 13:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Signal 正在使用 rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "這個庫提供了 mitosis::spawn 他很像 thread::spawn但實際上是產生了一個新的 process但是用起來就像 thread::spawn 一樣簡單Read morehttps://github.com/manishearth/mitosis" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-21 13:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "mitosis: thread::spawn" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者原本使用 actix-web但因為好奇心接觸了 Cloudflare WorkersCloudflare Workers是支持Rust和WASM的無服務器平台。使用Cloudflare Workers的主要優勢：地理位置分佈的託管設置（包括Kubernetes集群）是在單個地理位置上設置的。對於並行應用程序，讓代碼在Cloudflare的所有數據中心中一起運行非常棒。比起一般的設置時間成本，Cloudflare Workers可以快速的讓我訪問Kubernetes集群。 但是對於沒有預先在服務器或群集部署服務的用戶而言，建立新的安全，高可用性部署環境的時間以及運行這些計算機的成本可能會很高。 作者目前使用Cloudflare上託管此服務，還沒有到花到錢的流量。易於測試/部署。Cloudflare團隊在Wrangler工具方面做得很好。 部署更新是對 wrangler publish 來說很簡單。 我可以使用wrangler preview --watch進行測試。 而且發布速度很快。主要缺點：WASM庫無法完美運行，因為大多數在WASM的庫都針對瀏覽器。例如，在Cloudflare Worker中，沒有視窗。要訪問程式，會需要一個ServiceWorkerGlobalScope。開發週期很慢，儘管wrangler preview棒極了，但仍然需要很多時間才能看到更改。每次更改代碼都需要重新編譯Rust代碼，打包並將其發送到Cloudflare以及刷新頁面。特別是由於我使用的是經過編譯時檢查的HTML模板，因此速度非常慢。密鑰與Kubernetes不同，Cloudflare Workers中沒有內置的密鑰管理。 Cloudflare小組的某人建議我可以將其密鑰/值存儲成檔案。我選擇了一個傻瓜方式，將機密（加密密鑰和Recaptcha機密密鑰）直接編譯為可執行文件。調試困難 異步代碼，恐慌以及與JavaScript的橋樑的結合導致錯誤消息被完全刪除，這使得調試非常困難。那到底要怎麼使用 Cloudflare Workers 與 rust 結合呢？請看原始文章。Read morehttps://tech.fpcomplete.com/blog/serverless-rust-wasm-cloudflare" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-21 13:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Serverless Rust 使用 WASM 加 Cloudflare" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "這是一個英文音頻節目Read morehttps://rustacean-station.org/episode/007-zola/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-21 13:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "採訪Zola的創建者（前身為Gutenberg），這是一個用Rust開發的靜態網站生成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Includes new APIs, utilities, and fixes. Some highlights:tokio::sync::broadcasttokio::sync::SemaphoreA multi-producer, multi-consumer channel where each sent value is sent to all consumers (fan-out). The channel is bounded and when consumers lag, they will receive an error indicating they have lagged too far behind.example 1:" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-19 21:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio v0.2.5 版本更新" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tokio 0.2 使用 std::future 和 async/await 使得 Tokio 编写异步代码更加符合人体工程学，并且新的调度器使 Tokio 0.2 的线程池快了 10 倍。然而，更新现有的 Tokio 0.1 将是个难题。Tokio Compat 这个库就是为了解决这个问题，它提供与 Tokio 0.1 和 Tokio 0.2 未来兼容的运行时。Spawning both tokio 0.1 and tokio 0.2 futures:查看原文：https://tokio.rs/blog/2019-12-compat/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-19 21:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tokio-compat 0.1.1版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果你做系统编程，你可能最近经常听说BPF。它是一种新的热门 Linux 技术，允许在内核中运行用户提供的程序。Netflix、Facebook、谷歌、Cloudflare 和其他许多公司都在使用它来实现快速的负载平衡、DDoS 缓解和性能监控等功能。原文请看：https://blog.redsift.com/labs/writing-bpf-code-in-rust/reddit 参与讨论：https://www.reddit.com/r/rust/comments/ecspjx/writing_bpf_code_in_rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.redsift.com/labs/writing-bpf-code-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-19 21:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Writing BPF code in Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原图真的不错，reddit 原文：https://www.reddit.com/r/rust/comments/echv8s/my_rust_holiday_wallpaper/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-19 21:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "壁纸来一发" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Jancd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "@NEARProtocol  is looking for a WebAssembly & Compiler Engineerhttps://twitter.com/NEARProtocol🇺🇸 San Francisco / New York🇩🇪 Berlin 🇷🇺 Moscow🌍 Remote allowed!原文链接：https://t.co/iL4s9gAcc8?amp=1\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-19 21:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "招聘信息" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用于关机、重启、登出系统的 Rust 库，详情见 GitHubhttps://github.com/risoflora/system_shutdown" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-18 23:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "system_shutdown" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Mio 是底层级的 I/O 可移植抽象，为 Tokio 和其他的 Rust 项目提供支持。对比 0.6 版本，0.7 简化了 API 以让 Mio 的实践和使用更加简便。详情见官方bloghttps://tokio.rs/blog/2019-12-mio-v0.7-alpha.1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-18 23:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Mio 0.7-alpha.1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "提供在 “build.rs” 运行期间能与 Cargo 交互的宏，详情见 Crate cargo_emithttps://docs.rs/cargo-emit/0.1.1/cargo_emit/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-18 23:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cargo_emit : 在编译期与 Cargo 交互" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该工具包具有以下特性：\n触屏支持\nGPU加速\n高/宽 计算\n多窗口支持\n全扩展性（hidpi）\n等等。详情见GitHubhttps://github.com/dhardy/kas\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-18 23:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "KAS：GUI 工具包" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "joshsulin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有时候你看到一张动态图片(GIF)，感觉其中的一个画面你觉得很不错，想从中提取出来. 这篇文章会教你如何用Rust来完成提取(https://pudymody.netlify.com/blog/2019-12-15-converting-gifs-to-powerpoint-with-rust/).并将图片保存到PowerPoint.现在网上有很多这样的提取图片的网站, 有兴趣的话，用Rust实现一个在线动态图片提出服务吧.Read morehttps://pudymody.netlify.com/blog/2019-12-15-converting-gifs-to-powerpoint-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://pudymody.netlify.com/blog/2019-12-15-converting-gifs-to-powerpoint-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-17 23:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust将GIF里动态图片分解出来，保存到PowerPoint" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "joshsulin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者上次写于10月的文章是关于加速Rust编译器的工作。 随着年底的临近，是时候进行更新了。How to speed up the Rust compiler one last time in 2019https://blog.mozilla.org/nnethercote/2019/12/11/how-to-speed-up-the-rust-compiler-one-last-time-in-2019/How to speed up the Rust compiler some more in 2019https://blog.mozilla.org/nnethercote/2019/10/11/how-to-speed-up-the-rust-compiler-some-more-in-2019/Read morehttps://blog.mozilla.org/nnethercote/2019/12/11/how-to-speed-up-the-rust-compiler-one-last-time-in-2019/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-17 23:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何在2019年最后一次加速Rust编译器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "joshsulin" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "hyper是一个用Rust编写的成熟的HTTP库，已经是其中最快的HTTP库之一，并因其正确性而受到许多人的信任。此版本的亮点：\nFull async/await support.\nTokio v0.2 upgrade.\nAdopting tower::Service.\nRead morehttps://seanmonstar.com/post/189594157852/hyper-v013\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n【Rust日报】 2019-12-17https://rust.cc/article?id=649fdba2-b52d-4249-b3d3-acd6fac32e43" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-17 23:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "经过几个月的开发，hyperv0.13.0的最终版本现已准备就绪！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #codeReddit上的一个讨论，为什么Rust能激发人们的灵感，andymeneely是一个软件工程专业的大学教授，他讲述了Rust在过去几年中是如何让他的学生着迷。大一新生需要掌握至少一门语言，C语言由于它的系统级能力和快速成为很多新生的首选，但是指针和内存是很难掌握的，在经历过熬夜解决bug的过程后，很多学生开始怀疑学习这门语言的必要性。后来有些学生开始自发学习并传播Rust，尽管他们要学习borrow check和lifetime等新的概念，他们依然对这门语言很着迷，并讨论它的文档是如何的优秀。教授表示对Rust的热情是完全正确的，并且这比其他的“新技术”更重要，而且在经过三年的观望后，他也开始学Rust了。Read Morehttps://www.reddit.com/r/rust/comments/eaay3c/why_does_rust_seem_to_inspire_people/fap3ej2/?utm_medium=android_app&utm_source=share" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-15 21:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么Rust能激发人们的灵感？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rustRendology是一个基于Glium并用Rust编写的3D渲染管道。 它具有阴影映射，延迟阴影，发光效果，FXAA和实例渲染的基本实现。在这篇博客文章中，将概述Rendology的一些概念，并描述它们如何成为这种形式。Read Morehttps://leod.github.io/rust/gamedev/rendology/2019/12/13/introduction-to-rendology.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-15 21:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "介绍Rendology" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rustu/re-sheosi:Lily，一个语音助手，使用Rust作为核心，使用Python + Yaml作为“技能”（Python定义了一个动作，比如说些什么，而Yaml用来将每个订单与每个动作关联）。其主要特征是脱机并具有NLU，总体目标是在（遥远的）未来拥有高质量的助手（具有降噪和多麦克风算法等功能）。这仍然处于非常非常早期的阶段，它仍然不能做很多事情，并且代码还存在很多问题。但是我仍然想展示这一点，因为我想知道您的想法，并且因为我想获得几乎所有内容的反馈，尽管有编程经验，但这毕竟是我的第一个个人项目。Repohttps://github.com/sheosi/lily\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-15 21:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust+python实现的语音助手" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "libical是一个用于解析和生成icalendar数据对象（.ical文件）的库。相关Bloghttps://imag-pim.org/blog/2019/12/13/libical-v0.1.0/Githubhttps://github.com/libical/libical" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-14 21:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "LIBICAL V0.1.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Gitlabhttps://gitlab.com/pentagonum/gled" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-14 21:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gled：轻量级动画软件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "详情参见Bloghttp://liuchengxu.org/posts/speed-up-vim-python-plugin-using-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-14 21:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust使Vim Python插件快10倍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Githubhttps://github.com/ankrugold/redismachine--https://rust.cc/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-14 21:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "redismachine，用于状态机的Redis模块" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "quick-xml 是一个用于读写xml的 crate。0.17.1 版初步支持 serde 的(De)Serialize traitshttps://github.com/tafia/quick-xml" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-11 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "quick-xml v0.17.1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "refinery 使不同数据库间的迁移变得更简单。目前支持: Postgress, Rustlite 和 MySQLhttps://github.com/rust-db/refinery" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-11 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "refinery: SQL 迁移工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "hyper 是一个由 rust 编写的成熟 http 库，在速度和准确率上都十分优秀。此版本的新增特性有:https://seanmonstar.com/post/189594157852/hyper-v013\n全面支持 async/await\nTokio v0.2\n采用：tower::Service\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-11 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "hyper v0.13" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "eldruin 给 PCA9685 16位 PWM LED/Servo 控制器写了 Rust版的驱动器。博客介绍https://github.com/eldruin" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-11 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust PCA9685 PWM LED 灯控制驱动器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "nnethercote 从2016年起就一直在写如何加速 Rust 编译器的博客。今天发布了最新博客，以下是性能提升效果的部分截图https://blog.mozilla.org/nnethercote/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-11 20:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "博客：如何加速 Rust 编译器（2019的最后一版）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "今天的日报丰富多彩。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-10 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "支持 IMAP 协议，具有一些有趣的特性。https://meli.delivery/posts/2019-12-09-alpha-release.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://meli.delivery/posts/2019-12-09-alpha-release.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-10 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "meli - Rust实现的终端下的邮件客户端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "极客玩家的文章记录。讲了波表的原理。感兴趣的可以了解。https://cprimozic.net/blog/buliding-a-wavetable-synthesizer-with-rust-wasm-and-webaudio/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://cprimozic.net/blog/buliding-a-wavetable-synthesizer-with-rust-wasm-and-webaudio/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-10 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust, WebAssembly, 和 WebAudio 从头创建一个波表合成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://www.behance.net/gallery/89117181/Ferris-the-professional" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.behance.net/gallery/89117181/Ferris-the-professional" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-10 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 小螃蟹，各式各样的，总有一款击中你" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Voca_rs is the ultimate Rust string library inspired by Voca.js, string.py and Inflector, implemented as independent functions and on Foreign Types (String and str).借鉴自 Voca.js, string.py 和 Inflector。https://github.com/e1r0nd/voca_rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/e1r0nd/voca_rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-10 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "voca_rs - rust 字符串操作的终极武器？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "主要是负责文档相关的事情。https://blog.rust-lang.org/inside-rust/2019/12/09/announcing-the-docsrs-team.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/inside-rust/2019/12/09/announcing-the-docsrs-team.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-10 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "docs.rs 官方组成立了。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者提出了一个严肃的观点，格式化相关功能对于嵌入式Rust来说，太昂贵了。可以去掉。值得一读。https://jamesmunns.com/blog/fmt-unreasonably-expensive/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://jamesmunns.com/blog/fmt-unreasonably-expensive/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-10 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "嵌入式Rust中一点也不需要格式化相关功能！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是湾区的Rust会议的一个talk。Slide在这里：https://docs.google.com/presentation/d/1fasP_7rIFZtThdigGYZfMz-tMKx8q396v-xS4Gg6DeY/mobilepresent#slide=id.g6bc3cfd623_0_5视频在这里。https://watch.cloudflarestream.com/8a4e3eff3f54f1337fbd2328813e8349" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://watch.cloudflarestream.com/8a4e3eff3f54f1337fbd2328813e8349" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-10 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Declarative UI patterns in Rust 视频讲解。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "打开下面链接选一张吧。https://dev.to/robertohuertasm/wallpapers-for-the-rust-of-us-33p4\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://dev.to/robertohuertasm/wallpapers-for-the-rust-of-us-33p4" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-10 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust壁纸来了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "此前，微软表示正探索将 Rust 作为 C 和 C++ 的安全替代方案，并且也对外展示了使用 Rust 重写 Windows 组件的体验，根据微软的说法，Rust 是一种从根本上考虑安全性的编程语言，他们将尝试使用 Rust 重写各种产品，因为在过去的十年里，微软 70% 以上的安全补丁都提供了与内存相关的错误，而 Rust 正是解决这个问题的“良药”。而根据 ZDNet 的报导，近日在一次演讲中，谈到微软为解决相应内存问题所做的工作，微软研究人员 Matthew Parkinson 提到了微软正在开发的基于 Rust 的新编程语言 Verona。演讲中，Matthew 先是分享了微软在 MemGC（Memory Garbage Collector）上所做的工作，MemGC 是指 IE 和  Edge 浏览器上的内存垃圾回收器，它解决了标准浏览器一个特性——文档对象模型（DOM）中的漏洞，DOM 以树结构表述了 HTML 文档内容。之后他由此牵出另一个问题：如何构建最安全的产品？不仅仅丢弃已有的东西，而要考虑可以在更加安全的系统中构建一些什么。他介绍了微软正在使用 Rust 重写某些组件，并提出：“如果我们想要隔离，并精简遗留代码，以使攻击者的利用代码无法逃逸出来，那么如何设计语言呢？”Matthew 提出了微软正在开发的基于 Rust 的新编程语言 Verona，他表示这是首次讨论该项目，Verona 是用于微软“安全基础设施编程（safe infrastructure programming）”的一种新语言。Matthew 介绍，Verona 由 C# 项目经理 Mads Torgensen 与 Microsoft Research Cambridge 研究软件工程师 Juliana Franco 维护。微软面临的挑战是应对宽广的应用领域，范围从 C# 桌面应用到 C 或 C# Exchange、ASP.NET、Azure 与设备驱动程序，再到内存管理和启动加载器等底层 Windows 组件，以及 Windows 内核硬件抽象层（HAL，hardware abstraction layer）。“执行内存管理确实很困难，如果有任意并发突变，则临时内存安全性将非常困难”，Matthew 介绍了 Verona 的设计思路：“Verona 的所有权模型是基于对象组的，而不是像 Rust 那样基于单个对象的所有权模型。在 C++ 中，可以获得指针，并且它是基于对象的。但这与我关于数据和语法的思考不同，我认为数据结构是对象的集合，而对象的集合则是生命周期。 因此，通过在对象的所有权级别获得所有权，我们就可以更接近人们正在使用的抽象级别，它使我们能够构建数据结构而不会超出安全范围。”Read More: https://www.zdnet.com/article/microsoft-were-creating-a-new-rust-based-programming-language-for-secure-coding/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.zdnet.com/article/microsoft-were-creating-a-new-rust-based-programming-language-for-secure-coding/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-09 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "微软正在开发基于 Rust 的安全编程语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Vault客户端是HashiCorp Vault的一个本地客户端库Repo: https://github.com/Metaswitch/vault-client" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Metaswitch/vault-client" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-09 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "vault-client - HashiCorp Vault的Rust客户端库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Enoki是一个C++模板库，它支持数字码的自动转换，例如，创建在CPU或GPU上运行的算法的“宽”矢量化变体，或通过透明的正向/反向模式自动求差来计算梯度。Repo：https://github.com/mitsuba-renderer/enoki" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mitsuba-renderer/enoki" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-09 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "enoki - Enoki:现代处理器架构上的结构化向量化和差异化" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n快速在浏览器地址栏检索 Rust 文档、crate 和错误码的插件，支持 Chrome/Firefox。\n搜索基本类型和模块\n搜索Structs, Traits和Enums\n搜索函数, 方法和宏\n搜索 https://crates.io 上的 crate\n搜索 Compile Error Index 上的错误代码\n支持离线模式，可以搜索本地 Rust 文档(rustup docs --std)\n支持 Chrome 和 Firefox\n使用方式只需要在浏览器地址栏输入关键字 rs 然后敲击 Tab 或者 Space 键就能激活查询功能。Repo：https://github.com/Folyd/rust-search-extension\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Folyd/rust-search-extension" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-09 19:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust search extension - 快速搜索 Rust 文档的浏览器插件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #code@nick_r_cameron正在进行Rust新的编码风格方面的工作，是以开源的形式进行的，大家可以在这里踊跃的发表自己的观点、讨论，或者提交PR。https://www.twitter.com/u/@nick_r_cameronRepohttps://pincap.github.io/style-guide/rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-08 21:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 新的编码风格讨论" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #wasm如题，1Password是一个流行的密码管理工具，1.17版本智能填充功能完全用wasm实现了。点击下面的链接了解更多关于1Password使用wasm的详细信息。Read Morehttps://blog.1password.com/1passwordx-december-2019-release/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-08 21:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "1Password X 1.17 使用WebAssembly" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #algorithm搜索索引包含了“大量”的数据，在其中找到所需要的信息绝非易事，下面文章介绍了如何使用Rust实现算法，在毫秒的时间内查询数十亿个高维向量。Read Morehttps://0x65.dev/blog/2019-12-07/indexing-billions-of-text-vectors.html\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-08 21:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用Rust实现毫秒级别的搜索算法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "OrbTk更新了：\n实现了可以存储和访问自定义服务的全局注册表（registry）\n每个状态都可以访问注册表\n。。。\nOrbTk的主要目标是速度，易用性和跨平台。Githubhttps://github.com/redox-os/orbtk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-07 18:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "OrbTk, Rust UI-Toolkit" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "可以为crate生成各种licenses。Githubhttps://github.com/embarkstudios/cargo-about" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-07 18:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cargo插件：cargo-about" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "主要是bug修复，文档改进，最大的新增功能是读取和写入整数的新helper。Github releasehttps://github.com/tokio-rs/tokio/releases/tag/tokio-0.2.3" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-07 18:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio v0.2.3" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Githubhttps://github.com/yjh0502/rjs--https://rust.cc/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-07 18:47" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rjs，Rust支持的安全快速的Erlang JSON库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\"Slavic Castles\" 是一款用 Rust 制作的卡牌游戏，他的作者是Leinnan。在线玩http://leinnan.ayz.pl/ukw/slavic_castles/index.html看源码https://github.com/Leinnan/slavic_castles" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-04 22:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 卡牌游戏 —— \"Slavic Castles\"" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "nes-rust 是Rust版的任天堂娱乐系统模拟器。支持音频以及WebAssembly。https://github.com/takahirox/nes-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-04 22:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 版任天堂娱乐系统（NES）模拟器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者在想是否有可能不使用 trait 对象就改变一个基于确定类型的泛型函数的行为。该库目前还在实验阶段，期望能实现零开销向下转型。了解更多https://github.com/sagebind/transmogrify" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-04 22:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Transmogrify: Rust 向下转型（downcasting）库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Roperator 是一个可以用 Rust 写 Kubernetes operators 的新框架。Roperator 处理所有与 Kubernetes api 服务器的交互，用户只需要聚焦于应用相关的逻辑。了解更多https://github.com/psFried/roperator\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-04 22:22" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Roperator" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "编译期常量优化是指在编译期就可以对一些常量相关的表达式进行计算，比如：这次更新，是增加了常量传递的检查优化。https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-03 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rustc 编译期常量传递优化已经在 nightly 版本中默认打开" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "支持 no_std!https://github.com/neobirth/micromath" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/neobirth/micromath" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-03 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "micromath - 可嵌入的Rust计算，2D/3D向量，和统计库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Microsoft's Project Verona involves creating a new language for \"safe infrastructure programming\" to be open-sourced soon.Microsoft can't throw away old Windows code, but the company's research under Project Verona is aiming to make Windows 10 more secure with its recent work on integrating Mozilla-developed Rust for low-level Windows components.很多人都在担心MS的新语言（还未命名）可能会分裂Rust社区，我想说，这是杞人忧天。这只会对 Rust 有促进，不会对 Rust 有任何负面效应。理由：https://www.zdnet.com/article/microsoft-were-creating-a-new-rust-based-programming-language-for-secure-coding/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.zdnet.com/article/microsoft-were-creating-a-new-rust-based-programming-language-for-secure-coding/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-03 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Microsoft: We're creating a new Rust-based programming language for secure coding" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "比较新的一个索引（learned index）的一个算法实现。https://github.com/learnedsystems/RMI" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/learnedsystems/RMI" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-03 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RMI - The recursive model index, a learned index structure" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目前支持这两个后端Backend \tCratetokio-postgres \tdeadpool-postgreslapin (AMQP) \tdeadpool-lapinhttps://github.com/bikeshedder/deadpool/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/bikeshedder/deadpool/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-03 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Deadpool - 一个连接异步池的实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "最新UI库有点多，确实也是大家在这方面的呼声比较大吧。可以关注一下。https://blog.anp.lol/rust/moxie-intro/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.anp.lol/rust/moxie-intro/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-03 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "moxie - Rust的增量响应式UI库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章写得真好，图也配得好。赶紧阅读下面原文链接。https://www.lpalmieri.com/posts/2019-12-01-taking-ml-to-production-with-rust-a-25x-speedup/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.lpalmieri.com/posts/2019-12-01-taking-ml-to-production-with-rust-a-25x-speedup/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-03 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "好文推荐！使用Rust进行机器学习，提升 25 倍性能！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Wasmer 的 Rust 2020 畅想。先读为快。https://medium.com/wasmer/rust-2020-rust-at-wasmer-7646646a2024\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://medium.com/wasmer/rust-2020-rust-at-wasmer-7646646a2024" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-03 22:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 2020: Rust at Wasmer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在官方已在Youtube上提供下载Youtube：https://www.youtube.com/watch?v=o01QmYVluSw&list=PL85XCvVPmGQg-dewHRpM08JkGrBPdIVHw&index=2&t=0s" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.youtube.com/watch?v=o01QmYVluSw&list=PL85XCvVPmGQg-dewHRpM08JkGrBPdIVHw&index=2&t=0s" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-02 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustFest Barcelona 2019 所有录像已经可以下载了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Package Repo：https://www.archlinux.org/packages/community/x86_64/diesel-cli/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.archlinux.org/packages/community/x86_64/diesel-cli/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-02 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "diesel-cli、cargo-tree和cargo已经被打包到了Arch Linux中" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "In a previous article we’ve talked about how you can avoid rewriting a library in Rust when you don’t need to. But what about the times when you really do need to?In most languages you’d need to rewrite the entire library from the ground up, waiting until the port is almost finished before you can start seeing results. These sorts of ports tend to be quite expensive and error-prone, and often they’ll fail midway and you’ll have nothing to show for your effort. Joel Spolsky does a much better job of explaining this than I ever could, see his article on why full rewrites are a bad idea for more.However, Rust has a killer feature when it comes to this sort of thing. It can call into C code with no overhead (i.e. the runtime doesn’t need to inject automatic marshalling like C#’s P/Invoke) and it can expose functions which can be consumed by C just like any other C function. This opens the door for an alternative approach:Port the library to Rust one function at a time.Read More：http://adventures.michaelfbryan.com/posts/how-to-riir/index.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "http://adventures.michaelfbryan.com/posts/how-to-riir/index.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-02 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "How to RiiR" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "As everyone knows, Rust recently stabilized the async/await feature. My first attempt to convert a little program I had to use it was a dismal failure, (reasons are at the bottom of this post), so I thought I would step back and write some simple - and I do mean very simple - examples of how to use await. The final step in this post shows how to download multiple URLs, in parallel, which was the business problem I was trying to solve in the first place.I am definitely a learner when it comes to this material, so there may well be better ways to accomplish some of this - if so, please write a comment and I’ll update the post.Read More：https://www.philipdaniels.com/blog/2019/async-std-demo1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.philipdaniels.com/blog/2019/async-std-demo1/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-02 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust async-std的简单例子" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Lately I was porting a software from tokio/futures-1.0 to async-await. I somehow thought async-std was the successor of tokio and ported everything to async-std. 80% in, I noticed that my hyper dependency requires tokio and that it's not possible to replace tokio with async-std without also replacing hyper. Also, tokio and async-std try to solve the same problem. So I started a journey into the inners of the rust async story to find out if it is possible to use both tokio and async-std at the same time. (tl;dr: it is). I had heard of reactors and executors before, but there was much new stuff to discover.I found it interesting, so I decided to write it down. The following is a dive into a mixture of async-std-1.0.1 and async-std-master. I guess that tokio does not differ that much in its architectural design. I will skip async-await sugar, Pin and futures. Disclaimer: There may be misconceptions in here.Read More：https://gist.github.com/Phaiax/dd3476f13b4542492f79e3ab2171eb8c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gist.github.com/Phaiax/dd3476f13b4542492f79e3ab2171eb8c" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-12-02 19:44" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "异步在async-std中是如何工作的" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "根据Redox OS的创建者Jeremy Soller的说法，用Rust编写并正在开发中的Redox OS距离自托管（self-hosting）仅“几个月的时间”，这意味着Rustc编译器将在Redox本身上运行。其它资料https://www.theregister.co.uk/2019/11/29/after_four_years_rusty_os_nearly_selfhosting/更多信息https://www.redox-os.org/news/focusing-on-rustc/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-30 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Redox OS self-hosting" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "iced，是一个受Elm启发的Rust跨平台GUI库。Githubhttps://github.com/hecrj/iced" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-30 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "iced，Github Rust分类趋势排第二" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "由于在v0.2中删除了current_thread::Runtime，初始发行版不提供生成!Send任务的机制。现在Tokio v0.2.2中提供了task::LocalSet来处理这种情况。更多信息https://github.com/tokio-rs/tokio/releases/tag/tokio-0.2.2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-30 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio v0.2.2" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "StaticVec，是使用const泛型实现由数组支持的固定容量堆栈分配Vec替代方案。这是在0.4.0之上的一个重大改进。更多信息https://github.com/slightlyoutofphase/staticvec--https://rust.cc/section?id=ce0fe0fb-1ac6-413a-b535-59e4a8e74b6c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-30 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "StaticVec 0.5.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "cheats.rs —— Rust 备忘录网站用示意图讲解了 Rust 的各种数据类型，非常直观https://cheats.rs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-27 21:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 数据类型示意图" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新版本具有以下特性：\n更佳的 async / await 使用体验\n全新且更快的调度器\n更加轻量的 Tokio 依赖\n例如，从 TcpListener 接收套接字 可以使用 accept 函数：了解更多https://tokio.rs/blog/2019-11-tokio-0-2/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-27 21:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio 0.2 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用 Rust 编写的 WebAssembly 项目：可以根据周围声音实时显示声谱图形。使用了crate：rustfft 和 web-sys。https://timjrd.github.io/wasm-spectrogram/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-27 21:54" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 声谱图" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "A cross-platform GUI library for Rust, inspired by Elm重要的特性：同时支持本地GUI和Web UI。就是一份代码，可以编译到不同平台上运行。然后，今天发布的消息，这个项目已经被 Cryptowatch 赞助了。https://blog.cryptowat.ch/2019/11/25/sponsoring-rust-gui-library-iced/Repo: https://github.com/hecrj/iced" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/hecrj/iced" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-26 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "iced - 跨平台原生Rust GUI库，并且受到赞助了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大意是说gnome-shell之前使用的那些处理css的c语言的库，都已经陈旧且长时间不再维护了，而新的Mozilla/Servo/Rust 相关的Css工作栈的库，更新很快，性能也强。现在gnome官方已经决定全面转向使用 Rust 这套工具包了。Link: https://people.gnome.org/~federico/blog/moving-gnome-shell-styles-to-rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://people.gnome.org/~federico/blog/moving-gnome-shell-styles-to-rust.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-26 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gnome-shell 的css解析栈工具全面转向Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "What exactly happens when you panic!()? I recently spent a lot of time looking at the parts of the standard library concerned with this, and it turns out the answer is quite complicated! I have not been able to find docs explaining the high-level picture of panicking in Rust, so this feels worth writing down.https://www.ralfj.de/blog/2019/11/25/how-to-panic-in-rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.ralfj.de/blog/2019/11/25/how-to-panic-in-rust.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-26 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "How to Panic in Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Scryer Prolog aims to become to ISO Prolog what GHC is to Haskell: an open source industrial strength production environment that is also a testbed for bleeding edge research in logic and constraint programming, which is itself written in a high-level language.https://github.com/mthom/scryer-prolog" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mthom/scryer-prolog" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-26 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "scryer-prolog - 用Rust写的现代prolog编译器实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "One of Rust’s biggest selling points is how well it can interoperate with C. It’s able to call into C libraries and produce APIs that C can call into with very little fuss. However, when dealing with sufficiently complex APIs, mismatches between language concepts can become a problem. In this post we’re going to look at how to handle callback functions when working with C from Rust.https://blog.seantheprogrammer.com/neat-rust-tricks-passing-rust-closures-to-c" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.seantheprogrammer.com/neat-rust-tricks-passing-rust-closures-to-c" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-26 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Neat Rust Tricks: Passing Rust Closures to C" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "同时支持 cli，repl, gtk 哦。https://github.com/In-line/calculator" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/In-line/calculator" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-26 23:24" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "calculator - 用 Nom, Pratt Parser, LLVM, Cranelift and Relm  实现的计算器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个Rust实现的2048游戏，运行在终端。除了标准的用户输入，AI还可以用来执行这些动作。这个人工智能利用expectiminimax算法在每一步中推荐最好的下一步。使用Repo：https://github.com/KappaDistributive/rs2048" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/KappaDistributive/rs2048" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-25 21:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2048-rs - 2048游戏Rust实现版本" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如果您是Vim用户，estream可以帮助您解锁quickfix窗口的强大功能，而无需处理Vim的errorformat带来的痛苦。使用Repo：https://github.com/JoshMcguigan/estream" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/JoshMcguigan/estream" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-25 21:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "estream - 解析文件位置信息" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "yuequan1997" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rPGP是OpenPGP的唯一完全可靠的实现，遵循RFC4880和RFC2440。它提供了一个最低级别的API，并且没有规定信任模式或密钥管理策略。它完全支持Autocrypt 1.1电子邮件加密规范所需的所有功能。Repo：https://github.com/rpgp/rpgp\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rpgp/rpgp" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-25 21:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rpgp - Rust实现的 OpenPGP" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在Rust-Belt-Rust 2019会议上，Nicholas Matsakis做了一个关于Polonius-将来的Rust借用检查器的演讲。https://www.rust-belt-rust.com/演讲PPT，视频后面会更新。https://nikomatsakis.github.io/rust-belt-rust-2019" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-23 16:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Polonius" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "关于响应式UI的一篇博客文章https://raphlinus.github.io/ui/druid/2019/11/22/reactive-ui.html为了找出druid最佳的响应式结构，作者研究各种各样的响应式UI系统。文章试图找到常见的模式，以表征整个设计空间。https://github.com/xi-editor/druid备注：druid是一个数据优先的Rust原生UI设计工具包。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-23 16:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "响应式UI" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "博客信息http://smallcultfollowing.com/babysteps/blog/2019/11/22/announcing-the-async-interviews/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-23 16:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Async一些有趣的采访" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "编译器团队于2019-11-14举行了每周分类会议。更多信息https://blog.rust-lang.org/inside-rust/2019/11/19/compiler-team-meeting.html--https://rust.cc/section?id=ce0fe0fb-1ac6-413a-b535-59e4a8e74b6c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-23 16:34" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust编译器团队会议" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #crateCrates.io于今日切换了DNS服务器，在接下来的几天，这个改动将会影响到所有人，这个过程应该不会有什么问题，如果有问题的话可以Twitter @rustlang。Read Morehttps://twitter.com/rustlang/status/1197168031450972160" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-22 21:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "crates.io 切换了DNS服务器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #androidAndroid 程序员对 Android NDK 并不陌生，它是一套允许您使用 C 和 C++ 等语言，以原生代码实现部分应用的工具集。在开发某些类型的应用时，这有助于重复使用以这些语言编写的代码库。这是一篇使用Rust在Android位图中渲染Fractal图像的示例，如果团队中有Android程序员需要Rust NDK开发，可以看一下这篇入门文章。Read Morehttps://hoangpq.github.io/posts/rust-ndk/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-22 21:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust for NDK development" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust #webRead Morehttps://github.com/actix/actix-web" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-22 21:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "std::future合并到了actix-web" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "makeco" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "#rust作者在开发redismodule-rs时遇到一个问题，他需要创建自定义的内存分配器。我们知道Rust为String和Vec类型分配内存时使用的是Global Allocator，然而redis 模块的是以共享库的形式被编译的，也就是说Rust要使用这个模块就要用到System Allocator，这是系统默认提供的内存分配器，这种行为会导致几个问题：https://github.com/RedisLabsModules/redismodule-rs首先，Redis可能根本不使用系统分配器，而是依靠jemalloc。 jemalloc分配器是系统malloc的替代方案，它除其他功能外还包括许多避免碎片的调整。 如果模块使用系统分配器，而Redis使用jemalloc，则分配行为将不一致。其次，即使Redis始终使用系统分配器，Redis也不会看到模块直接分配的内存：它不会显示在诸如信息内存之类的命令中，也不会受到Redis执行的清除操作（例如逐出键）的影响 。由于这些原因，Redis模块API提供了钩子，例如RedisModule_Alloc和RedisModule_Free。 它们的用法与标准malloc和free调用非常相似，但是除了将调用实际传递给内存分配器之外，还使Redis知道分配的内存。Rust提供了实现自定义内存分配器的能力，可以通过impl GlobalAlloc 实现自己一个RedisAlloc，通过Redis 模块API提供的钩子来实现内存分配和释放。Read Morehttps://engineering.redislabs.com/posts/using-the-redis-allocator-in-rust/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-22 21:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Rust中使用Redis内存分配器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "创意编程（Creative Coding）简单来说就是用代码来搞艺术，如果你对创意编程感兴趣，也想练练 Rust 的话，可以看看这篇 Rust 创意编程入门教程。https://dev.to/deciduously/creative-coding-in-rust-with-nannou-1lbl#challenges" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-20 23:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用Rust进行创意编程（Creative Coding）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "亚马逊云服务的 Rust SDK: Rusoto 发布 0.42.0 版。更多请查看 Githubhttps://github.com/rusoto/rusoto/releases" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-20 23:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rusoto 0.42.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "添加以下功能：\n在 crate 旁展示其最新版本\n悬浮展示 crate 所有可用软件，并且可以点击更改\n点击查看详情https://marketplace.visualstudio.com/items?itemName=serayuzgur.crates" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-20 23:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "vscode 包管理插件 crates 0.4.6 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "挺肥" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Allsorts 是从 Prince 中剥离出来的字体成形（Font Shaping）引擎。https://github.com/yeslogic/allsorts字体成形指的是Unicode码转化成文本，然后再把文本排版成字体的过程。\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-20 23:15" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 字体解析成形引擎 Allsorts" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "其实这算是月经贴，最近 reddit 上又讨论了。答案比较丰富，各位看官自行前往围观：https://www.reddit.com/r/rust/comments/dxbjq2/what_makes_rust_so_fast/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/dxbjq2/what_makes_rust_so_fast/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "是什么让 Rust 这么快" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "讲解得非常详细，区块链初学者可以学习学习。https://blog.knoldus.com/custom-implementation-of-blockchain-in-rustpart-1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.knoldus.com/custom-implementation-of-blockchain-in-rustpart-1/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "自己动手使用 Rust 实现区块链-第一部分" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rabbithole-rs is a nearly well-typed, user-friendly JSON:API type system, with an easy-to-use Macro System to help you modelling the your data.https://github.com/UkonnRa/rabbithole-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/UkonnRa/rabbithole-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rabbithole-rs - 兔子洞 Json API 系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Simulating Turing machines for the Busy Beaver game 。Busy Beaver game 的解释在这里：wikipediahttps://en.wikipedia.org/wiki/Busy_Beaver_gameInformally, in theoretical computer science, the busy beaver game aims at finding a terminating program of a given size that produces the most output possible.[1]https://github.com/LukasKalbertodt/beaver" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/LukasKalbertodt/beaver" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "beaver - Busy Beaver 游戏的模拟图灵机" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/LeakyBucket/filler" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/LeakyBucket/filler" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "filler - 把不同的数据源的内容汇总到一个地方的工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "直接在下面网页中就可以玩儿！！http://klotzandrew.com/blog/rust-wasm-tetris" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "http://klotzandrew.com/blog/rust-wasm-tetris" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust + wasm 开发的俄罗斯方块" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "teensy4 是一款 Armv7 开发板，有兴趣可以用rust玩儿了。https://github.com/mciantyre/teensy4-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mciantyre/teensy4-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "「嵌入式」teensy4 开发板的 Rust 支持包" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "强调使用 Rust 的类型系统来阻止错误。It’s a Rust library for working with colors and color spaces. It uses the type system to prevent mistakes, like mixing incompatible colors or working with non-linear RGB. It encodes the color spaces and their meta data (such as RGB primaries and white point) into the types to help making color processing less error prone and hopefully more accessible to those who don’t want to dive into the rabbit hole that is colors in computing.https://ogeon.github.io/2019/11/17/palette-0-5-0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ogeon.github.io/2019/11/17/palette-0-5-0.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Palette - Rust 实现的色彩和色彩空间库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/Piripant/sudoku" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Piripant/sudoku" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "sudoku - 使用 ggez 实现的独数游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "做基因遗传算法的吗？好像就是面向生物学物种演化的库。https://github.com/pkalivas/radiate" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/pkalivas/radiate" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "radiate - 一个并行基因演化程序引擎" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Windows Open and Save dialogs in Rust using winapihttps://github.com/ben-wallis/wfd" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ben-wallis/wfd" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "wfd - 包装了 windows 的文化对话框" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "会在记录日志时自动做索引，方便搜索。https://github.com/pathivu/pathivu" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/pathivu/pathivu" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pathivu - 可以搜索的日志库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "讲解得很细致，对于学习深入理解 Serde 很有用。https://www.joshmcguigan.com/blog/understanding-serde/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.joshmcguigan.com/blog/understanding-serde/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "博文：理解 Serde" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/PorkSausages/tfex-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/PorkSausages/tfex-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tfex-rs - 一个用 tui 实现的终端下的文件管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/kardeiz/jsonrpc-v2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/kardeiz/jsonrpc-v2" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "jsonrpc-v2 支持 async/await 语法了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "看看大家的讨论：https://www.reddit.com/r/rust/comments/dy79ty/is_learning_rust_as_a_first_systems_programming/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/dy79ty/is_learning_rust_as_a_first_systems_programming/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 适合作为第一门编程语言来学习吗？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "又一个基础轮子被翻了。https://github.com/tarka/xcp" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/tarka/xcp" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "xcp - cp 命令的翻版" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "好文：Rust 无错开发的模式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://dflemstr.io/posts/music-visualization-7/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://dflemstr.io/posts/music-visualization-7/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 进行音乐可视化教程（FFT 傅里叶变换可视化）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/karrq/kyansel" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/karrq/kyansel" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "kyansel - 可以控制取消你的 future 的库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "值得读一读。https://thomashartmann.dev/blog/async-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://thomashartmann.dev/blog/async-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "博文：Rust async 介绍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "基于 ggez 和 ecs 库开发。https://github.com/silentsokolov/tocenter" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/silentsokolov/tocenter" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tocenter - 一个圆圈小游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/kyren/luster" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/kyren/luster" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "luster - 用 Rust 实现的 lua 虚拟机" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对 rust 别名模型的研究提案。全世界有这么多大佬在做研究，看来要设计一个好的语言真不是一件容易的事。https://www.ralfj.de/blog/2019/11/18/stacked-borrows-paper.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.ralfj.de/blog/2019/11/18/stacked-borrows-paper.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Stacked Borrows: An Aliasing Model for Rust (the paper)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Pure Rust Yubikey host-side driver for PIV-based RSA/ECC key storage + signing/encryption support" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-19 22:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "yubikey-piv.rs - 身份验证硬件驱动的 Rust 实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "目前只支援 1.40比如你有貓跟狗都會叫，然後你有個動物enum在上層想要模仿繼承的感覺，那就是他Read morehttps://github.com/hobofan/ambassador" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-17 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ambassador 程序宏實作的委派 trait (Delegation of trait implementations via procedural macros)" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "將 git diff, git add -A, git status, git diff --cached, git commit -m <message>, git push and git shortlog -se用 dp, aa, st, di, cm, pu and le 取代Read morehttps://github.com/ctsrc/repotools" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-17 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "repotools rust縮寫指令小工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "SIMD 加速分形渲染Read morehttps://github.com/termhn/rayn" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-17 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rayn 0.3" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有人使用了rust結合硬體做了 MIDI 播放器對嵌入式有興趣的朋友不要錯過了Read morehttps://blog.eldruin.com/ad983x-waveform-generator-dds-driver-in-rust/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-17 23:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MIDI 實體播放器使用 AD9833與 BluePill版子" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "编程语言的错误处理解决方案在很大程度上影响代码的健壮性，简洁性，可读性，并在一定程度上影响代码的运行时性能。考虑到最近的一些讨论以及越来越多的错误处理包装箱的出现，文章分享了作者对此的一些想法，关键点如下：\n“匿名sum类型”是一个错误处理的好工具。\n我们可能希望明确区分针对应用程序用户的错误和旨在由代码处理的错误。\n我认为，Rust的错误处理很好，但仍可以改进。\n更多信息参见博客https://lukaskalbertodt.github.io/2019/11/14/thoughts-on-error-handling-in-rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-16 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于Rust中错误处理的思考" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Orbital Widget Toolkit是一个多平台（G）UI工具包，用于使用编程语言Rust构建可扩展的用户界面。OrbTk发布了重写的第一版，0.3.1-alpha1，建议新开发者跳过0.2.*的所有版本，并从此alpha版本或即将发布的版本开始。更多信息crates.iohttps://crates.io/crates/orbtk/0.3.1-alpha1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-16 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "OrbTk 0.3.1-alpha1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Lopdf，用于PDF文件操作的纯Rust库。更多信息Githubhttps://github.com/J-F-Liu/lopdf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-16 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Lopdf" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "faster-utf8-validator，一种SSE/AVX-2加速的UTF-8验证算法。更多信息Githubhttps://github.com/zwegner/faster-utf8-validator" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-16 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "faster-utf8-validator" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "hilbert，希尔伯特曲线转换更多信息Githubhttps://github.com/paulchernoch/hilbert--https://rust.cc/section?id=ce0fe0fb-1ac6-413a-b535-59e4a8e74b6c\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-16 22:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "hilbert" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "真的是很猛busybox是linux開發者最常用的一套cmd使用rust增加穩定性是很多網路設備開發工程師樂見的?Read morehttps://github.com/samuela/rustybox" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-15 16:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustyBox 一個完全用rust重寫的 BusyBox" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一個簡單高效的 http serverRead morehttps://github.com/brson/basic-http-server" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-15 16:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一個使用 async/await 跟 tokio 0.2 and hyper 0.13 的範例" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者手把手的教你怎麼做很詳細的教學Read morehttps://dev.to/robertohuertasm/rust-once-and-share-it-with-android-ios-and-flutter-286o" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-15 16:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "寫一次Rust就可應用在 Android, iOS, Flutter" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者講解了他實作這個庫中遇到的種種困難以及解決辨法建議想用到泛型特性的朋友，可以來了解Read morehttp://adventures.michaelfbryan.com/posts/const-arrayvec/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-15 16:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "實作泛型的固定大小陣列 arrayvec" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "damody" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Read morehttps://mun-lang.org/blog/2019/11/14/rust-2020-scalability/\nTelgram Channel\n阿里云语雀订阅\nSteemit\nGitHub\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2019-11-15 16:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RUST 2020 目標：可擴展性" }, "type": "text" }], "type": "title" } },]
