export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "12-11.md" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-11 23:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个模板允许您生成一个“ Hello World”的web扩展，运行一个编译到 WASM的程序。该程序将作为内容脚本执行，不需要被注入到页面中。Gitlab 链接，https://github.com/Mubelotix/wasm-extension-template文章链接，https://www.reddit.com/r/rust/comments/rdxnl8/i_made_a_template_for_web_extensions_in_rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Mubelotix/wasm-extension-template" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-11 23:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "用rust做了一个web扩展的模板" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们发布了Hurl 1.5.0，一个简单的HTTP命令行工具，建立在libcurl和Rust之上。Hurl允许运行以纯文本格式定义的HTTP请求。它可以用来获取数据，或者模拟一个场景(请求序列)，并在过程中对响应断言。它的文本格式既适合devops，也适合开发人员。一个Hurl的样例Gitlab 链接，https://github.com/Orange-OpenSource/hurl文章链接，https://www.reddit.com/r/rust/comments/rde935/hurl_150_a_command_line_to_run_and_test_http/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/Orange-OpenSource/hurl" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-11 23:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Hurl 1.5.0：一个运行和测试HTTP请求的命令行工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是X Window System xclock程序的一个版本，已通过“cat模式”进行了增强。最初是由Tony Della Fera（麻省理工学院雅典娜分校，12月）、Dave Mankins（麻省理工学院雅典娜分校，BBN分校）和Ed Moy（加州大学伯克利分校）、Deanna Hohn和我（数字设备公司）在20世纪80年代末自己自娱自乐制作的X10程序。这些图形的灵感来自于著名的、标志性的Kit Cat（R）时钟，其中一个仍然挂在我的厨房里。我把它放在github上是为了纪念今年X10推出30周年，因为它是一款有趣的桌面玩具。Gitlab 链接，https://github.com/epilys/kitkathttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/epilys/kitkat" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-11 23:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust做的kitcat时钟" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Monoio 是字节跳动服务框架组开源的基于 io-uring 的 thread-per-core 模型高性能 Rust Runtime，旨在为高性能网络中间件等场景提供必要的运行时。与 Golang 不同，Rust 语言中标准库并没有提供异步运行时(Runtime)，只提供了必要的结构抽象。Runtime 负责与操作系统打交道，并对齐标准库的 Future 和 Waker 等定义，用户可以自主选择 Runtime。当前被广泛使用的 Runtime 是 Tokio，它提供了类似 Golang 调度器的实现，用户的 Task 可以在多个线程之间被调度，较为有效地利用了多核心的性能。但问题也随之而来：在部分强依赖高性能低延迟的场景下，调度带来的开销反而是用户不希望看到的。在核心数较多的情况下，调度开销反而会抵消调度带来的好处。Nginx 和 Envoy 这类组件往往使用 thread-per-core 模型，即多少核心就运行多少线程，一个任务一旦被一个线程所接收，它后续的处理则都在该线程上。这种做法下几乎没有跨线程的开销，提升了 CPU 利用率，可以较好地保持系统的线性扩展性。此外，由于没有跨线程，处理逻辑也可以尽可能地利用 thread local 的便利，多数时候无需加锁便可操作共享数据。面向这类场景，Monoio 基于 io-uring 致力于提供最佳的性能；另外，我们还定义了一个更适合 io-uring 的 IO trait。Github: https://github.com/bytedance/monoio/blob/master/README-zh.md微信公众号文章: https://mp.weixin.qq.com/s/4zuM0DTDh4tztkcm7mHAVQ" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://mp.weixin.qq.com/s/4zuM0DTDh4tztkcm7mHAVQ" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-09 22:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "monoio - 字节基于 io_uring 的异步 Runtime" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "该工具是使用Rust写的，目前属于早期预览阶段，有兴趣的伙伴可以自行在下面地址预申请体验。Read More: https://github.blog/2021-12-08-improving-github-code-search/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.blog/2021-12-08-improving-github-code-search/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-09 22:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Github 发布代码搜索工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "又到了这个时候! 是时候让我们看看谁是Rust社区的成员，Rust项目的情况如何，以及我们如何改善Rust的编程体验。Rust社区团队很高兴地宣布我们的2021年Rust状态调查 无论你今天是否使用Rust，我们都想知道你的意见。你的回答将帮助项目了解其优势和劣势，并确定未来的发展重点。Read More: https://blog.rust-lang.org/2021/12/08/survey-launch.html中文调查问卷: https://surveyhero.com/c/7rnfv4cf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://surveyhero.com/c/7rnfv4cf" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-09 22:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "2021年Rust状态调查已发起" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\"在Linux内核中增加对Rust作为第二语言的支持 \"的补丁系列的v2版发表在了LKML[...] 。自RFC和链接邮件中描述的v2版以来，对Rust的整体支持有了一些改进。\nThorsten Leemhuis 在其 twitter 谈到\nRead More: https://this-week-in-rust.org/blog/2021/12/08/this-week-in-rust-420/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/12/08/this-week-in-rust-420/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-09 22:07" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周周报" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "关于Rust的两本新书Black Hat RustRed Hat Rust地址：https://kerkour.com/black-hat-rust-week-2021/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-09 11:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "黑帽Rust和红帽Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Opensource programmatic video framework.https://fframes.studio/fframes_announce.mp4直接操作SVG实现。Site: https://fframes.studio/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://fframes.studio/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-09 11:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "第一个完全使用Rust制作的Video" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者最近在做Rust的借用检查器的形式化（formalisation），目的是让人们更加清晰地理解借用检查器是如何工作的。然后写了这篇文章解释初步的东西，推荐。Modelling Borrow Checking in Rusthttps://whileydave.com/2021/12/06/modelling-borrow-checking-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-09 11:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "模型化Rust中的借用检查器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "不过现在还在预览阶段，希望大家来提意见。Improving GitHub code searchhttps://github.blog/2021-12-08-improving-github-code-search/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-09 11:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Github新开发了代码搜索引擎，使用Rust实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Cranelift 是字节码联盟的本地代码（JIT）编译器，是wasmtime和lucet等的后端，目前也在尝试成为Rust后端的替代。2021年总结：Cranelift Progress Report: A Look Back at 2021https://bytecodealliance.org/articles/cranelift-progress-2021" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-09 11:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Cranelift 2021年年度总结" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Neovim 是 vim 的一个分支，它专注于可扩展性和可用性。比如，能够使用 Lua 以及各种脚本来编写插件，并为扩展编辑器提供更大的灵活性。在 Neovim 0.5 版本中，开发者引入了语言服务器协议 (LSP) 客户端框架 (:help lsp)这意味着，Neovim 可以充当 LSP 服务器（如 rust-analyzer）的客户端，并协助构建增强的 LSP 工具。下面这篇文章就详细说明了 如何为 Neovim 配置 Rust 插件，可以省去很多自己折腾的时间。文章地址https://sharksforarms.dev/posts/neovim-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-07 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Vim 中写 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "2022 年，我们很可能会看到 Linux 内核中的实验性 Rust 编程语言支持成为主流。最近又发布了最新的补丁，介绍了在内核中处理 Rust 的初始支持和基础设施。目前 Rust 支持在 Linux 中编写最简单的 driver，虽然还没有落地，但是距离完善的开发支持，也仅仅是一个时间问题，无需顾虑可行性。Rust-For-Linux-v2https://www.phoronix.com/scan.php?page=news_item&px=Rust-For-Linux-v2Rust-Linux-Kernel-2021https://www.phoronix.com/scan.php?page=news_item&px=Rust-Linux-Kernel-Linaro-2021" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-07 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust for Linux 补丁发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这来自 Reddit 上的一个热门讨论，题主问题如下：显然，要学习 C 就应该学习 C，要学习 rust 就应该学习 rust但我很好奇，在第一次学习其他语言时，是否存在不对称性。 主要是我听说严格的 rust 编译器会让你成为一个更好的低级程序员，因为它迫使你养成可以扩展到 C 的良好编码习惯，但这是真的还是假的？热门回帖如下：我想说，了解两种语言非常有用，但一般来说，它们本质上是完全不同的，恕我直言，很难将知识从一种语言移植到另一种语言。也就是说：如果您非常了解 C，并且如果您在实际使用该语言时遇到了一些问题，您肯定会轻松理解 Rust 中大多数安全机制的基本原理，如果 Rust 是您的第一语言，您可能会不清楚这些原理。如果您可以在不与 rust 中的借用检查器进行斗争的情况下进行编码，然后切换到 C，那么您在编写代码时大概率会自动开始在 C 中应用相同的模式。但是，Rust 为您进行内存管理，从 Rust 切换到 C 后，释放分配的内存仍然是一件头大的事情。并不是说编写 C 的人不会像你说的那样考虑生命周期，而是他们经常使用临时的心理模型来考虑它。 Rust 形式化了一个你可以带回 C 的模型。Rust 之所以影响你在 C 中的编码习惯，并不是使用 C 或其他语言编写脱糖的 Rust 那么简单，而是可以避免过于复杂的所有权模型，更多地考虑指针失效，避免可能移动的自引用结构，避免修改 for 循环条件中使用的变量，避免可变全局变量，正确使用同步原语等。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-07 12:59" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "讨论：学习 Rust 让我更擅长 C  VS  学习 C 让我更擅长 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者萌生了一个用 Rust 编写 GUI 程序的想法,由于时间不多,所以作者想法设法加快 GUI 程序的开发. 整个过程的思考值得借鉴.原文链接https://aaronerhardt.github.io/blog/posts/gui_speedrun/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-06 19:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Rust 中加速GUI开发" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust CUDA 项目是一个旨在使Rust成为使用CUDA工具包进行极其快速的GPU计算的一级语言的项目。它提供了将Rust编译为极其快速的 PTX 代码的工具，以及使用现有CUDA库的库。目前发布了 0.2 版本.原文链接https://github.com/Rust-GPU/Rust-CUDA/releases/tag/0.2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-06 19:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust Cuda: 0.2 版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "seorm是一个关系型ORM:\n异步. 依靠 SQLx, SeaORM 是一个从第一天起就提供异步支持的库。\n动态. 基于SeaQuery, SeaORM允许您构建复杂的查询，而不需要“对抗ORM”。\n可测试的. 使用模拟连接为逻辑编写单元测试。\n面向服务的. 在api中快速构建连接、过滤、排序和分页数据的服务。\n原文链接https://www.sea-ql.org/SeaORM/blog/2021-11-19-whats-new-in-0.4.0/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-06 19:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SeaOrm: 0.4 版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Toql 是一个异步数据库的 ORM，目前只支持 MySQL。安装使用Github 链接，https://github.com/roy-ganz/toql" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/roy-ganz/toql" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-05 10:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Toql，异步数据库 ORM" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rg3d, Rust Game engine 3D and 2D, 一个用 Rust 编写的功能丰富、生产环境就绪、通用的 2D/3D 游戏引擎，并带有场景编辑器。rg3d Github 链接，https://github.com/rg3dengine/rg3d直播 Youtube 链接，https://youtu.be/TQaCyC_tGko" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://youtu.be/TQaCyC_tGko" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-05 10:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 rg3d 游戏引擎进行游戏开发 - 直播 #2" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Hubris 是一个用于深度嵌入计算机系统的小型开源操作系统，例如：我们的服务器替代基板管理控制器（BMC，Baseboard Management Controller）。本次演讲将概述 Hubris 的设计、Hubris 应用程序的结构以及我们在此过程中学到的一些亮点。视频链接，https://talks.osfc.io/osfc2021/talk/JTWYEH/https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://talks.osfc.io/osfc2021/talk/JTWYEH/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-05 10:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【视频】Hubris：为健壮性开发操作系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者结合 webrtc，WebAssembly，Rust 编程语言，开发了 WRaft ！并在 https://wraft0.eevans.co/ 上进行动态展示 raft 的效果\nhttps://eevans.co/blog/wraft/\ncargo-udeps 是一个了不起的项目，可帮助您分析 Rust 代码库上未使用的依赖项。您可以简单cargo install cargo-udeps地安装它。1、安装2、使用3、忽略依赖项要忽略某些依赖项，请添加package.metadata.cargo-udeps.ignore到Cargo.toml.\nhttps://erayerdin.com/checking-unused-dependencies-in-a-rust-project-with-github-actions-ckwm3yov901cwlvs1h48z54xi\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-04 00:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "时隔 6 周，Rust 1.57.0 stable 正式发布了，一起看看有哪些值得关注的新特性吧。\n为 const 上下文添加 panic! 支持\nCargo 现在可以自定义 profile 配置\n稳定的 try_reserve API\nAnnouncing Rust 1.57.0: https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-02 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.57.0 stable 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "经过几个月的工作，WASMER 发布了 2.1 版本。包含一些新功能和错误修复，包括：\nWasmer Js.\n虚拟文件系统\niOS 支持\nWindows 下支持 Singlepass 编译\nLLVM ARM64 支持 & LLVM 13\n更快的 Singlepass 编译\n可重复和确定性构建\n新语言集成：LISP 和 Crystal\nWasmer 2.1: https://wasmer.io/posts/wasmer-2.1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://wasmer.io/posts/wasmer-2.1" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-02 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Wasmer 2.1.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者试图对比 Rust 和 C++ 中 Mutex 的性能，结果发现 Rust 中的 Mutex 比 C++ 慢了大概 30 倍。经过讨论，现阶段的结论是：C++ 可能存在一些作弊现象。在将所有东西包装在一个线程中后，Rust 与 C++ 在 Mutex 上具有相当的性能。Reddit - Why is std::sync::Mutex 60-70x time slower than C++'s std::mutex?: https://www.reddit.com/r/rust/comments/r75wm6/why_is_stdsyncmutex_6070x_time_slower_than_cs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/r75wm6/why_is_stdsyncmutex_6070x_time_slower_than_cs/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-02 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 的 Mutex 真的比 C++ 慢吗？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 419: https://this-week-in-rust.org/blog/2021/12/01/this-week-in-rust-419/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/12/01/this-week-in-rust-419/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-02 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 419" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Hubris 是由Oxide Computer Company开发的用于微控制器的操作系统。Hubris 提供抢占式多任务处理、单独编译的组件之间内存隔离、崩溃的驱动程序可以在不影响系统情况下重新启动，以及灵活的组件间消息传递，减少了系统调用,——大约 2000 行 Rust没有运行时创建或销毁任务的操作，没有动态资源分配，没有特权模式运行的驱动程序代码，系统中没有C代码。这通过构造消除了许多存在于类似系统中的攻击面。ReadMore:https://hubris.oxide.computer/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://hubris.oxide.computer/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-01 23:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Hubris - 一个用于嵌入计算机系统的小型开源操作系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一名在Mixxx工作6.5 年的工程师,打算用 Rust 重写 Mixxx。ReadMore:https://rust-audio.discourse.group/t/a-new-dj-application-in-rust/484" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust-audio.discourse.group/t/a-new-dj-application-in-rust/484" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-01 23:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个新的 DJ 应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "实现trait将struct转换为 Vec 并返回。默认情况下，转换为大端序。ReadMore:https://github.com/breuHQ/byteme" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/breuHQ/byteme" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-12-01 23:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "byteme" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "JetBrains Fleet: Next generation JetBrains IDE with built-in Rust supporthttps://www.reddit.com/r/rust/comments/r4r9fz/jetbrains_fleet_next_generation_jetbrains_ide/Fleet是JetBrains创建的一个功能齐全的轻量级编辑器，同时也是一个功能齐全的IDE：具有智能补全、重构、导航、调试以及 IDE 中一直存在的所有功能。参考资料：\n下一代 IDE 来了？有请 「Fleet」登场！\nFleet Architecture overview\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-30 20:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "JetBrains Fleet: 具有内置Rust支持的下一代JetBrains IDE" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://plv.mpi-sws.org/rustbelt/popl18/Rust是一种新的系统编程语言，它有望克服高级别安全保证和低级别资源管理控制之间看似不可能的权衡。不幸的是，Rust的所有安全声明都没有得到正式证明，因此有充分的理由质疑它们是否真的有效。具体来说，Rust使用了一个强大的、基于所有权的类型系统，但随后通过内部使用不安全特性的库扩展了这个核心类型系统的表达能力。在本文中，我们给出了一种语言的第一个形式化（和机器检查的）安全证明，该语言表示一个真实的Rust子集。我们的证明是可扩展的，因为对于每个使用不安全特性的新Rust库，我们可以说它必须满足什么样的验证条件才能被视为语言的安全扩展。我们对Rust生态系统中使用的一些最重要的库进行了验证。论文地址：RustBelt: Securing the Foundations of the RustProgramming Languagehttps://plv.mpi-sws.org/rustbelt/popl18/paper.pdf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://plv.mpi-sws.org/rustbelt/popl18/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-30 20:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustBelt: 保护Rust编程语言的基础" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Learn Rust with gitoxide in 17 episodeshttps://www.youtube.com/playlist?list=PLMHbQxe1e9Mk5kOHrm9v20-umkE2ck_gEgitoxide是一个纯Rust实现的惯用、精简、快速和安全的的Git，如果你对Rust和Git两者中任意一个主题感兴趣，那么可以跟着gitoxide的作者Byron 在youtube上学习只有17集的系列课程《Learn Rust with Gitoxide》。https://www.youtube.com/playlist?list=PLMHbQxe1e9Mk5kOHrm9v20-umkE2ck_gERust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-30 20:40" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "LRG系列课程：使用Gitoxide学习Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "PyO3 使从 Python 调用Rust 代码变得很容易。您可以编写一个Rust库，并依赖PyO3和 maturin (PyO3生态系统的一个支持工具)的组合来编译Rust库，并将其直接作为Python模块安装。除此之外，PyO3可以在Python和Rust之间转换类型，还可以通过一组宏方便地将Rust函数导出到Python。原文链接http://saidvandeklundert.net/learn/2021-11-18-calling-rust-from-python-using-pyo3/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-29 20:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Python中调用 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust有一个关键属性，使其成为内核中的第二语言变得非常有趣:它保证不会发生未定义的行为(只要不安全的代码是合理的)。这包括没有 内存释放后内存使用， double free， 数据竞争等等。原文链接https://linuxfoundation.org/webinars/rust-for-linux-writing-abstractions-and-drivers/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-29 20:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust for linux: 编写安全的抽象和驱动" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Poem OpenAPI是一个基于 Poem 的 OpenAPI 服务器端框架。如果你用过FastAPI，它们在使用上是非常相似的。1.0版简化了一些宏属性，使用起来更加方便。原文链接https://crates.io/crates/poem-openapi" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-29 20:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Poem-openapi 1.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Life simulation, 一个 Rust 编写的 模拟器.生物可以通过突变和自然选择进化。生物有一个简单的基因组，赋予它们独特的特征.demo地址https://joelthelion.github.io/life_web/demo/github地址https://github.com/joelthelion/life_web" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-29 20:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Life simulation" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "lib.rs 索引了 Rust的 72,419 个应用。快速，轻量级，可以作为 crates.io 的一个替代品.lib.rshttps://lib.rs/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-29 20:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "lib.rs: 一个 crates.io的替代品" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "@anastaopara 用了过去几周将 prodecural 移植到 OpenGL。https://twitter.com/anastasiaopara\n阅读原文 https://twitter.com/anastasiaopara/status/1464304076074672144\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-28 17:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "procedural 移植到 OpenGL" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "想写出更多 idiomatic Rust 吗？@matthiasendler 维护了一个经过同行评审的项目，他包括文章、演讲、repos，它们都使用了 Rust。https://twitter.com/matthiasendler\nRepo https://github.com/mre/idiomatic-rust\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-28 17:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "How to write idiomatic Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "@wwojtekk 用egui开发了一个管理Docker的GIU应用，作者知道目前有一个适用于 macOS 和 Windows 的 Docker 桌面应用程序，但在涉及小型 QOL 功能以及更高级的高级用户功能和元数据时，它的功能有些欠缺，它还缺少 Linux 版本。目前这个项目实现的功能包括：https://www.reddit.com/user/wwojtekk/\nrepo https://github.com/vv9k/dockeye\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-28 17:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Dockeye 一个用来管理 Docker 的 GUI 应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n阅读原文 https://matklad.github.io//2021/11/27/notes-on-module-system.html\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-28 17:13" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于 Module system 的一些笔记" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rena是我在Rust中实现的Lox语言的树遍历解释器。我用rust重写它，以熟悉rust的borrow checker和提供的各种工具链。在这篇文章中，我将解释我如何为解释器实现一个简单的环境。Gitlab 链接，https://github.com/veera-sivarajan/rena文章链接，https://veera.app/rena's_memory_model.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://veera.app/rena's_memory_model.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-27 19:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rena的内存模型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Yap是一个小型的、零依赖的解释器库，灵感来自于parser-combinator。我试图以简洁性换取简单性，并以迭代器接口的灵活性为基础。它的目标是使解析字符串和切片变得容易，并且易于使用。在过去的几个星期里，我一直在构建和使用它，我认为它已经准备好向其他可能有兴趣使用它的人发布了!下面是它的用法:Gitlab 链接，https://github.com/jsdw/yap文章链接，https://www.reddit.com/r/rust/comments/r3blx1/announcing_yap_a_small_iterator_based_zero/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/r3blx1/announcing_yap_a_small_iterator_based_zero/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-27 19:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "yap：一个小型的、基于迭代器的、零依赖的解析库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "今天我发布了新版本的AMD显卡冷却和电压守护程序。当前版本包括：\n非常简单的电压管理\n有关如何启用电压管理的信息\n...\nGitlab 链接，https://github.com/Eraden/amdgpud文章链接，https://www.reddit.com/r/rust/comments/r1wyu7/release_amdfand_v106/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/r1wyu7/release_amdfand_v106/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-27 19:41" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "amdfand v1.0.6发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "PyO3 让 Python 调用 Rust 代码变得容易。用户可以编写 Rust 库，并依靠 PyO3 和生态系统中maturin的支持工具的组合 PyO3 来编译 Rust 库并将其作为 Python 模块直接安装。其中 PyO3 可以在 Python 和 Rust 之间转换类型，并且可以通过一组宏轻松地将 Rust 函数导出到 Python。\nhttps://saidvandeklundert.net/learn/2021-11-18-calling-rust-from-python-using-pyo3/\n文章作者用无人机拍了一张防水布的照片。使用基本的摄影测量法估计了图片的面积，使用机器学习对图像中的防水布进行了分割，得到的防水布面积为 3.86 m2，而实际面积为 3.96 m2（误差约为 4%）整个预估算法由 Rust 实现。\nhttp://cmoran.xyz/writing/adventures_in_photogrammetry\n合并队列是一个与您的版本控制系统（本文将重点关注git和 GitHub）集成的应用程序，它要求以原子方式合并代码更改，从而确保主分支始终包含经过全面测试的代码版本。许多工程团队和开源项目正在引入合并队列作为其工作流程的一部分。这篇文章探讨了使用合并队列的几个原因，并描述了如何设置 Bors，Rust 语言项目使用的合并队列实现。\nhttps://kflansburg.com/posts/merge-queues/\n来自每日 侯盛鑫，坏姐姐\nRustcc 论坛：支持 rss\n微信语言中文社区号：Rust\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-27 00:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "来自高级语言的我们，在创建和使用Rust中的函数时，常常会错过灵活性。Rust函数默认不具备以下功能。\n\n函数重载（通常出现在C++/Java/JS/C#中）\n\n\n可选参数（Python中的基本功能）\n\n\n命名参数（Python中的基本功能）\n很多人说，Rust已经可以通过trait、泛型和struct来提供这些功能。但是，我还没有找到任何关于这方面的具体例子或者彻底的教程，特别是关于实现的利弊分析。\n因此，我试图自己实现这些功能。结果发现，它们并不复杂，只需要trait、泛型和struct，没有宏，也没有nightly版本功能。下面是我的实现。\n\n函数重载（通常出现在C++/Java/JS/C#中）可选参数（Python中的基本功能）命名参数（Python中的基本功能）很多人说，Rust已经可以通过trait、泛型和struct来提供这些功能。但是，我还没有找到任何关于这方面的具体例子或者彻底的教程，特别是关于实现的利弊分析。因此，我试图自己实现这些功能。结果发现，它们并不复杂，只需要trait、泛型和struct，没有宏，也没有nightly版本功能。下面是我的实现。Github: https://github.com/tidunguyen/flexible-fn-rs我很愿意分享我的实现。\n\n它作为参考，以便其他人可以在此基础上提供更复杂、更灵活的API\n\n\n我希望得到大家的反馈，因为我对Rust还不是很精通，特别是对于那些我怀疑在使用时会带来副作用的东西，比如泛型里的Sized约束。\n\n\n同时我也希望我的分享能作为证明Rust也可以有灵活的函数\n\n它作为参考，以便其他人可以在此基础上提供更复杂、更灵活的API我希望得到大家的反馈，因为我对Rust还不是很精通，特别是对于那些我怀疑在使用时会带来副作用的东西，比如泛型里的Sized约束。同时我也希望我的分享能作为证明Rust也可以有灵活的函数以上是Reddit上原帖内容，代码示例在Github上，README就写的有，感兴趣的可以看一下。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/tidunguyen/flexible-fn-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-25 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust中的函数重载和可选参数事例" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "关于重构UB的话题，我想起了一篇关于历史文化中誓言和誓约的机制的文章。https://acoup.blog/2019/06/28/collections-oaths-how-do-they-work/当程序员编写get_unchecked时，我们可以想象他们想向编译器承诺他们坚持其前提条件。但是，由于编译器通常对未经证实的断言不那么信任，程序员发誓说他们的论证是在边界内的。编译器看到这样一个庄严的承诺，就把程序员的话当作真的，并相应地进行优化。编译器是如此彻底地相信，以至于它甚至从未考虑过怀疑程序员誓言的可能性。但是，如果程序员发了假誓，那么他们很可能会受到神的报应，以鼻腔恶魔的形式出现--或者更糟糕的是，程序的行为也会变得微妙莫测。\n/u/scook0 在 /r/rust 谈到\n这段话是这篇Blog的热评：https://blog.sigplan.org/2021/11/18/undefined-behavior-deserves-a-better-reputation/这篇Blog讨论的是在Rust中的UB（undefined behavior）应该拥有更好的名声，举了几个例子说明编程语言里拥有UB能带来的好处。Read More: https://this-week-in-rust.org/blog/2021/11/24/this-week-in-rust-418/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/11/24/this-week-in-rust-418/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-25 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周周报" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "中文社区征集各位的Rust相关的创作，直接发送到对应公众号就可以，链接和全文都OK，不然大部分时候日报内容都是英文社区搬运过来的，还是希望中文社区能更活跃一些。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-25 22:45" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "最后" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "现在是使用Rust的好时机了吗？Convex的创始团队（从DropBox分离出来的）有使用Rust开发Magic Pocket（Dropbox的地理分布式数据存储系统），Nucleus（重写的Dropbox的同步引擎），Convex（0配置，无限扩容的为响应式应用开发需求设计的后端）。它们是目前世界上负载最大的基于Rust语言的系统之一。Convex的创始团队分享了使用Rust的好处和一些取舍心得体会。十分推荐。https://blog.convex.dev/a-tale-of-three-codebases/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.convex.dev/a-tale-of-three-codebases/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-24 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "三个Rust代码库的故事" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "LibertyOS完全从头开发，具体面向桌面还是IoT目前并不清楚，项目还在早期，感兴趣可参与。https://github.com/LibertyOS-Development/kernel" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/LibertyOS-Development/kernel" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-24 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "LibertyOS - 使用Rust语言从头开发的操作系统" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Persy完全由Rust开发，目前已发布1.1版本。在性能上有一些改进。https://persy.rs/posts/persy-1.1.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://persy.rs/posts/persy-1.1.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-24 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Persy - 一个单文件数据库存储，类似于 sqlite" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇文章作者研究了如何使用Rust实现依赖注入模式，非常清晰明了，看完又长姿势了。强烈推荐，人人可读。https://www.bumbar.blog/tech/dependency-injection-with-rust/讨论 也可以看看。https://www.reddit.com/r/rust/comments/r0ipfu/explain_to_me_like_im_5_dependency_injection/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.bumbar.blog/tech/dependency-injection-with-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-24 23:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust中的依赖注入设计模式" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "经过半年多的工作，作者终于发布了他一直致力于的 Rust-CUDA 的一个非常早期的版本，目标是使 Rust 成为用于快速 GPU 计算的 Tier-1 语言。它提供了将 Rust 编译为极快的 PTX 代码的工具，以及使用现有 CUDA 库的 crate。该项目仍处于早期开发阶段，可能存在一些问题，不过是 rust 在 CUDA 上的一次非常有意义的探索。github 地址https://github.com/RDambrosio016/Rust-CUDA" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-23 10:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust CUDA 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "游戏服务器大多将可靠 UDP 作为传输协议，在 rust 中有很多对应的实现，如果你对这方面感兴趣，可以查收下面这份清单。https://arewegameyet.rs/ecosystem/networking/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-23 10:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust 游戏服务器开发" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "rust 日报 babpstep" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这篇 blog 演示了如何使用（误用）Rust 的生成器，将任何递归函数转换为几乎零代码更改的迭代函数。你可以将其称为 fearless recursion!文章链接https://hurryabit.github.io/blog/stack-safety-for-free/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-23 10:16" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Stack-safety for free ？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "oreboot是类似于coreboot的引导程序项目，而RustSBI是适用于RISC-V的引导程序环境，这两者都是纯粹由rust编写的嵌入式应用程序。经过社区成员@OrangeCMS和贡献者们的进一步适配，RustSBI-Nezha现在能在oreboot引导链中能正常运行。图片的控制台输出显示，引导链在初始化DDR内存后，能够做到M态的陷入处理，随后进入下一步的系统启动过程。这项适配工作意味着，oreboot和RustSBI-Nezha提供了一种启动Linux系统可用的新引导途径。RustSBI-Nezha项目是湖南农业大学的杨云枫同学、天津科技大学的王涛同学和队友们在暑假的“2021年开源操作系统夏令营”活动中发起的开源项目。项目分支地址https://github.com/orangecms/rustsbi-nezha/tree/rustsbi-nezha推文链接https://twitter.com/OrangeCMS/status/1462197961606246403?t=_n8beWS2OFhygZ9CWdrwiA&s=19" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-22 21:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustSBI-Nezha项目已经可以在oreboot引导链中使用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我们日常中享用着各种 IDE 的便利性，但是很少人会去实现相关的功能。在本文中，我们将讨论语言服务器在支持宏时所面临的挑战。这很有趣，因为对于Rust 的 analyzer 来说，宏是最难破解的。原文链接https://rust-analyzer.github.io/blog/2021/11/21/ides-and-macros.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-22 21:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "IDE 和 宏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文介绍了 SymSpell这个难以置信的算法, 以及大致了解我们如何在lnx中实现它。原文链接https://chillfish8.ghost.io/fuzzy-searching-5x-faster-with-symspell/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-22 21:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Inx 如何做到使用 SymSpell 使 模糊搜索提速超过5倍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文记录了作者在 Artichoke 贡献 Rust 代码的整个过程。和谐友爱！原文链接https://briankung.dev/2021/11/20/contributing-to-artichoke-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-22 21:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在 Artichoke 中贡献代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个用Rust编写的UEFI应用程序，它解锁一个SED，然后从解锁的驱动启动另一个UEFI应用程序,通常是一些引导加载程序或Linux efirstub。它被设计为一个简单的最低限度的PBA，用于自我加密驱动器，不包括一个完整的另一个小Linux，也不需要暖重启来启动系统解锁后-它只是一个UEFI引导加载程序通过。目前，它只支持NVMe驱动器，SATA支持即将到来。原文链接https://github.com/necauqua/opal-uefi-greeter--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-22 21:23" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "opal-uefi-greeter" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "日程：(https://rustfest.global/schedule/地址：https://watch.rustfest.global/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-21 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustFest Global 2021：Rust In Arts Edition" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Pigeon 是一种命令行工具，用于以廉价且高效的方式自动化电子邮件工作流程。比如，查询时事通讯的订阅者并向他们发送电子邮件：结果如下：Massage 配置文件格式如下：GitHub：https://github.com/quambene/pigeon-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-21 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pigeon-rs：电子邮件自动化工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "链接：https://dev.to/davidadewoyin/top-rust-cargo-commands-2b70" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-21 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Top10 Cargo 命令" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用 Prometheus 和 Grafana 监控 Rust Web 应用程序。链接：https://romankudryashov.com/blog/2021/11/monitoring-rust-web-application/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-21 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust WebAPP 监控" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "也包含了一些 Rust 的学习资源。链接：https://www.embeddedrelated.com/showarticle/1432.php" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-21 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何为嵌入式系统学习 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "oreboot是类似于coreboot的引导程序项目，而RustSBI是适用于RISC-V的引导程序环境，这两者都是纯粹由rust编写的嵌入式应用程序。经过社区成员@OrangeCMS和贡献者们的进一步适配，RustSBI-Nezha现在能在oreboot引导链中能正常运行。图片的控制台输出显示，引导链在初始化DDR内存后，能够做到M态的陷入处理，随后进入下一步的系统启动过程。这项适配工作意味着，oreboot和RustSBI-Nezha提供了一种启动Linux系统可用的新引导途径。RustSBI-Nezha项目是湖南农业大学的杨云枫同学、天津科技大学的王涛同学和队友们在暑假的“2021年开源操作系统夏令营”活动中发起的开源项目。项目分支地址：https://github.com/orangecms/rustsbi-nezha/tree/rustsbi-nezha推文链接：https://twitter.com/OrangeCMS/status/1462197961606246403?t=_n8beWS2OFhygZ9CWdrwiA&s=19" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-21 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustSBI-Nezha项目已经可以在oreboot引导链中使用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n测试 Trait 的多个 implementation：https://eli.thegreenplace.net/2021/testing-multiple-implementations-of-a-trait-in-rust/\n循环引用数据结构：https://eli.thegreenplace.net/2021/rust-data-structures-with-circular-references/\nRust 安全相关：https://kerkour.com/rust-crate-backdoor/\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-21 22:20" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "文章推荐" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有没有想过计算机的能耗与编程语言的选择之间是否存在相关性？葡萄牙大学一组研究人员着手量化它。2017年的研究论文《Energy Efficiency across Programming Languages》对 27 种知名软件语言的运行时、内存使用和能耗进行了研究，使用以每种语言表达的十种不同的编程问题来监控此类语言的性能。https://greenlab.di.uminho.pt/wp-content/uploads/2017/10/sleFinal.pdf文件链接，https://hackaday.com/2021/11/18/c-is-the-greenest-programming-language/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://hackaday.com/2021/11/18/c-is-the-greenest-programming-language/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-20 20:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "最环保编程语言，Rust 仅次于 C 排第二" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "elfshaker，是一个高性能的针对二进制文件进行了优化的版本控制系统。400 GiB -> 100 MiB，访问时间为1s+；当应用于 clang 构建时。Github链接，https://github.com/elfshaker/elfshaker" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/elfshaker/elfshaker" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-20 20:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "elfshaker" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "semver-explain，是一个 CLI 工具，用于解释语义版本控制 （Semantic Versioning）要求，将其转换为仅具有小于、大于或等于比较器的形式，其中主要、次要和补丁版本都是指定的。SemVer 需求的确切含义解释来自于 Cargo。尤其是它不处理连字符范围或来自 JS node-semver 库的 x-ranges。Github链接，https://github.com/alilleybrinker/semver-explain" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/alilleybrinker/semver-explain" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-20 20:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "semver-explain" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这期的 Rust 播客是 Allen Wyma 与 Jane Lusby 的访谈，Jane 是 Rust 错误处理项目组的负责人，也是 Rust 基金会的协作项目主管。这期 Rust 播客主要的时间轴：\n00:57 - Jane 的介绍\n04:10 - Jane 对 Clippy 的贡献\n08:54 - Eyre\n15:49 - Failure & Anyhow\n17:13 - 在 anyhow 和 eyre 之间做出选择\n20:05 - AnyError 和 ThisError\n23:31 - Color-eyre\n26:08 - 其他在 eyre 中的 crates\n28:59 - 错误处理组\n38:12 - 与其他小组的合作\n46:05 - Rust 2021 & 2018\n播客链接，https://rustacean-station.org/episode/047-jane-lusby/https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rustacean-station.org/episode/047-jane-lusby/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-20 20:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 播客  | 与 Jane Lusby 讨论 Rust 中的错误处理" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在本文中，作者将向您展示如何设置 Rust Web 应用程序的监控。该应用程序将公开 Prometheus 指标，这些指标将使用 Grafana 进行可视化。这次实验的监控的应用是 mongodb-redis demo。\nhttps://romankudryashov.com/blog/2021/11/monitoring-rust-web-application/\nhRPC 是一个 RPC 系统，在 Harmony 仓库中，作者们一直在用 hRPC 开发他们的去中心化聊天协议。hRPC 使用 PB 作为协议中间件，并支持流式传输。hRPC 使用 REST 对普通一元请求建模，使用 WebSockets 对流请求建模。因此，为不支持它的语言编写一个库应该很容易。https://github.com/harmony-development\nhttps://dev.to/harmonydevelopment/introducing-hrpc-a-simple-rpc-system-for-user-facing-apis-16ge\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-19 16:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一篇有意思的文章，演示了如何使用 Rust 的生成器将任何递归函数转换为迭代函数，而几乎无需更改代码。Stack-safety for free?: https://hurryabit.github.io/blog/stack-safety-for-free/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://hurryabit.github.io/blog/stack-safety-for-free/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-19 00:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Stack-safety for free?" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Lemmy 是一款 Reddit 替代品，使用 Rust 编写。在刚刚发布的 v0.14.0 中完成了与 Mastodon 和 Pleroma 联合。这意味着，如果你是 Mastodon 和 Pleroma 的用户，那么你也可以：\n查看 Lemmy 社区，用户配置文件，帖子和评论\n关注 Lemmy 社区获取新的帖子和评论\n答复（提及）双向生效，包括通知\nLemmy Online: https://lemmy.mlLemmy (a federated reddit alternative written in Rust) Release v0.14.0: Federation with Mastodon and Pleroma: https://lemmy.ml/post/89740" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://lemmy.ml/post/89740" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-19 00:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Lemmy v0.14.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 417: https://this-week-in-rust.org/blog/2021/11/17/this-week-in-rust-417/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/11/17/this-week-in-rust-417/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-19 00:02" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 417" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Neon除了内存和类型安全之外，应该在 Node.js 中使用 Rust Embedding 的原因还有很多。\n并行编程和线程\n性能更强\n访问操作系统特定的库\n通过 Cargo 访问 Rust 的生态系统\nReadMore:https://levelup.gitconnected.com/create-memory-and-type-safe-node-js-modules-with-rust-2c10bba92013" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://levelup.gitconnected.com/create-memory-and-type-safe-node-js-modules-with-rust-2c10bba92013" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-18 12:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Neon - 使用 Rust 创建内存和类型安全的 Node.js 模块" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nWindows NT 上的 MIPS\n在 QEMU 中运行 Windows NT 4.0 MIPS\n获取在 Windows NT 4.0 上运行的代码\nMIPS NT 4.0 上的 Rust\nrust 奇怪的targets\n....\nReadMore:https://gamozolabs.github.io/fuzzing/2021/11/16/rust_on_nt_mips.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gamozolabs.github.io/fuzzing/2021/11/16/rust_on_nt_mips.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-18 12:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MIPS64 Windows NT 4.0 上的 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n建立在现代图形 API 的基础上wgpu：Vulkan、Metal、DirectX 12、OpenGL ES3。\n\nDirectX 11、WebGL2 和 WebGPU 支持正在进行中。\n\n\n使用您自己的自定义着色器来获得特殊效果。\n完美像素边界上的硬件加速缩放。\n支持非方形像素纵横比。\n\nDirectX 11、WebGL2 和 WebGPU 支持正在进行中。\nReadMore:https://github.com/parasyte/pixels" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/parasyte/pixels" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-18 12:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pixels - 一个微小的硬件加速像素帧缓冲区。 🦀" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Simple Console Input API for Standard Libraryhttps://strawpoll.com/zxds5jye6StrawPoll.com：我们正试图将一个简单的控制台输入API推送到标准库中，以使编写简单的命令行输入变得更容易，我们需要社区决定实现的高级程度。因为这是一个相当有争议的话题（双方的数量非常均匀），所以这次投票就是为了解决这个问题。注意：下面的例子不是最终的，它只是一个用来阐述这个概念的例子。简单输入的例子：高级输入的例子：或者「投票」：\nA. 简单输入系统：一个函数，读取一行、执行错误检查并返回一个字符串；\nB. 高级输入系统：一个或多个宏，提供格式化输入，用于读取多个值和各种类型；\nC. 二者都选择：在需要时提供简单的输入宏和高级宏；\nD. 这些都不是：别的东西。\n如果想参与投票，请访问原文投票。https://strawpoll.com/zxds5jye6" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-16 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【投票】为Rust标准库添加控制台输入API" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Is rust good for mathematical computing?https://www.reddit.com/r/rust/comments/qv5i0n/is_rust_good_for_mathematical_computing/科学计算相关的任务：\n矩阵计算\n数值分析\n对编程语言的要求：\n对lambda的良好支持；\n简单易用的函数组合；\nRust语言本身对lambda(在Rust中称为闭包)、通用组合和函数式编程有很好的支持，但像柯里化(curry)这样的东西看起来并不漂亮。目前Rust语言实现的跟科学计算相关的crate列表，可以在此查看：Scientific Computinghttps://www.arewelearningyet.com/scientific-computing/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-16 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【Reddit讨论帖】Rust适合做科学计算吗？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Testing multiple implementations of a trait in Rusthttps://www.reddit.com/r/rust/comments/qv4awi/testing_multiple_implementations_of_a_trait_in/文中介绍了几种测试trait实现逻辑的实用方法：另外也可以使用test-case 这个crate来进行测试：https://crates.io/crates/test-case/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-16 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Rust中测试trait的多个实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "How variables are saved in Python and Rust. Side by Side 4: str/stringhttps://www.reddit.com/r/rust/comments/quwyds/how_variables_are_saved_in_python_and_rust_side/在Python3中，和str相关的结构体有三个：\nPyASCIIObject：纯ascii字符串；\nPyCompactUnicodeObject：Unicode字符串；\nPyUnicodeObject：兼容历史API的Unicode字符串。\n在Rust中，和string相关的类型有：\n&str：字符串切片；\nString：动态扩容的字符串；\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-16 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "变量是如何在Python和Rust中保存的——对比4: str/string" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Get stats and the energy consumption of your docker containershttps://www.reddit.com/r/rust/comments/qv5uxm/get_stats_and_the_energy_consumption_of_your/Docker activity是一种用于监视Docker容器统计信息并输出其能耗的工具。当前它还处于早期阶段，对于demoing来说，它很快就会变得更好。。。项目地址：Docker Activityhttps://github.com/jdrouet/docker-activityRust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-16 22:12" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Docker Activity：获取docker容器的统计数据和能耗" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "可以移植的 SIMD 模块.该模块提供了一个可移植的不绑定于任何硬件架构的 SIMD 操作的抽象。目前 nightly-only.原文链接https://doc.rust-lang.org/nightly/std/simd/index.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-15 19:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "std::simd nightly 可用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rudra是一个静态分析器，用于检测Rust程序中常见的未定义行为。它能够分析单个Rust的 package 也可以分析crates.io上的 crate。原文链接https://www.infoq.com/news/2021/11/rudra-rust-safety/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-15 19:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "静态分析器 Rudra 在 Rust crates 中找到超过 200 个内存安全问题" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文中介绍了大量的学习资料，对于新手可以少走很多弯路。原文链接https://www.embeddedrelated.com/showarticle/1432.php" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-15 19:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "学习嵌入式系统中使用 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Quinn是IETF QUIC传输协议的纯rust、异步兼容的实现。目前刚发布 0.8.0 版本，正式支持了 QUIC v1标准.原文链接https://github.com/quinn-rs/quinn/releases/tag/0.8.0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-15 19:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Quinn: 0.8.0发布，正式支持 QUIC v1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者做了一个关于如何在 Rust 中使用 opencv 的视频。油管视频https://www.youtube.com/watch?v=zcfixnuJFXg--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-15 19:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 中使用 opencv" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "@annieanqi 开源了一个基于 Rust 和 Flutter 的 Notion 替代产品 appflowy，目前是MVP状态，该项目还处于一个比较早的状态，欢迎各位开发者提出自己的想法。https://twitter.com/annieanqi\n官网\nRepo\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-14 21:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个开源的基于Rust和Flutter的Notion替代产品" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者在 Mozilla 从事 Rust 的兼职工作数年，那段时间里，作者定期总结编译器的性能是如何改进的。 例如：2017-11-12 至 2019-07-24。进行的最后一次比较是在 2020 年 8 月，从 2020 年末开始暂停 Rust 工作，直到本周我成为 Futurewei Technologies 的 Rust 团队的全职成员，作者很想知道那段时间的性能是如何提高的，好消息！从 2020-08-05 到 2021-11-11，编译器基准套件的结果有 459 项改进，只有 18 项回归，如下面（很长）的屏幕截图所示，因为截图过长印象阅读体验，请移步原文查看。\n阅读原文\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-14 21:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rustc 变得更快了！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\nRepo\nDemos\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-14 21:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个基于Rust WebGPU 实现的ECS库的渲染 demo" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Apollo Router 是用 Rust 编写的下一代 Federation 运行时，它比 Apollo Gateway 快 10 倍，运行效率提高 12 倍，目前 Apollo Router alpha 版本现已发布。\n阅读原文\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-14 21:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 实现的 Apollo Router 发布 alpha 版本！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "lidongjies" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "w806是北京联盛德推出的一款IoT嵌入式MCU。嵌入式rust对它的支持项目正在开发中，其中pac库的svd文件编写工作需要更多的贡献者参与。主要工作是，阅读官方文档，把寄存器信息整理到svd文件中，以供后续嵌入式rust使用。欢迎大家关注项目！如果您愿意为w806-pac项目做出贡献，请打开项目主页的issues，来查看详细的信息。感谢各位对项目的支持！\n项目主页\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-14 21:52" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "w806-pac项目正在招募贡献者" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "我只是想写一篇简短的帖子，只是想对大家说声“谢谢”。没有太多细节，我最近经历了很多事情，我觉得我所做的任何事情对除我自己以外的任何人都没有（或将有）价值。我发布了我的爱好操作系统，在两天之内，我的repo收到了20颗星，在crates.io上的下载量达到了200，有很多有用的（有趣的）评论来帮助我改进我的工作。我确信我的工作有点差劲，但我肯定想继续在我发布的操作系统上工作。你们太棒了，让我对自己感觉好多了。让我觉得我可能不是在浪费时间。Gitlab 链接，https://github.com/LibertyOS-Development/kernel文章链接，https://www.reddit.com/r/rust/comments/qsv0ue/thank_you_to_the_rust_community_libertyos_070/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/qsv0ue/thank_you_to_the_rust_community_libertyos_070/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-13 23:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "感谢Rust社区+ LibertyOS 0.7.0" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "大家好，我到现在只学了3天rust，为了练习，我制作了一个小lib，允许您使用unicode字符直接在终端中绘制蜡烛图形：我觉得有些人可能会感兴趣，所以我想分享一下。我很想得到关于它的反馈，或改进/新功能的建议！Gitlab 链接，https://github.com/Julien-R44/cli-candlestick-chart文章链接，https://www.reddit.com/r/rust/comments/qt3k14/draw_candlestick_charts_right_into_your_terminal/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/qt3k14/draw_candlestick_charts_right_into_your_terminal/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-13 23:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在你的终端绘制蜡烛图" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "为了实现其安全保证，Rust编译器在整个程序中仔细跟踪所有权和引用。这使得编写某些类型的数据结构具有挑战性；特别是具有循环引用的数据结构。让我们从一个简单的二叉树开始：因为Rust编译器应该能够在编译时计算结构的大小，所以left和right通常使用Box分配堆内存。这些Box被包装在一个Option中，因为节点的左或右子节点可能为空。文章链接，https://eli.thegreenplace.net/2021/rust-data-structures-with-circular-references/https://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://eli.thegreenplace.net/2021/rust-data-structures-with-circular-references/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-13 23:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "具有循环引用的Rust数据结构" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "今天小编给大家讲一个有关安全边界的漏洞。小编最初关注 RUSTSEC-2020-0159 的原因是因为对练手项目进行审计（ cargo audit ）的时候，审计反馈 chrono 这个的日期时间处理库有脆弱性，于是追究起其发生的原因。首先，最初的问题是来自于 chrono 库发现 localtime_r 在直接使用 libc 提供的 getenv、setenv时可能会引起不安全性(unsound) ,而该问题在使用 std 的时候可以通过上锁来保证安全性（sound）。在这个问题底下有网友指向了 rust-lang 关于 getaddrinfo 是否需要获取 ENV 锁 的讨论，里面 alexcrichton 贴出了 Linux man page 里的描述：https://rustsec.org/advisories/RUSTSEC-2020-0159被多线程安全性（MT-Safety）标记 env 标记的函数在用 getenv 或者类似函数访问环境变量会出问题，如果不使用 guard 来保证在并发修改环境时的安全性。然而我们不把这些函数标记为多线程不安全（MT-Unsafe），因为修改环境的的函数均被用 const:env 标记并且认为是不安全的。因为不安全，所有后者不会在多线程运行或异步信号启用时被调用，所以这些环境变量可以被有效认为在上下文中是常量，因此前者（getenv,小编注)是安全的。也即，在并发场景中，只要不修改环境变量（set_env)就会不会引起读取时安全问题——因为此时环境变量相当于常量（共享不可变原则）。而实际上 并不能阻止编程师在并发场景中调用相关修改环境变量的函数，也即前文描述的安全条件总会有被破坏的时候（尤其是在嵌入式高并发场景），因此这个问题可以认为是一个不合理性。于是，为解决相关不合理性，我们提出了 可选方案：https://github.com/rust-lang/rust/issues/90308然而，在漏洞修复之前，如果不想被提示相关的问题，可以 --ignore参数来忽略：" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-13 00:01" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RUSTSEC-2020-0159 原因浅析" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "众所周知Rust有几种不同的字符串类型。两个主要的竞争者是：\n&str是一个 \"字符串引用\"。它是不可调整大小的，它的可变性是有限的。\nString是一个 “自有（owned）字符串\"。它是可调整大小的，并且可以简单地被改变。\n事实证明，这两个字符串并没有太大区别。str只是一个由[u8]字节片支持的字符串。同样地，String只是一个由Vec<u8>支持的字符串。https://github.com/rust-lang/rust/blob/88e5ae2dd3/library/alloc/src/string.rs#L294-L296那么为什么它们真的是不同的类型呢？理论上我们不能有这样的东西吗：所以，就是这一点。这主要是为了与标准库中的字符串进行功能比对。很多标准trait的实现，这里也实现了。我还实现了用于utf-32应用程序。顺便贴上这个万恶的表情包：Github: https://github.com/conradludgate/generic-str" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/conradludgate/generic-str" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-11 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为Rust有很多字符串类型而烦恼吗？好吧，它没有必要" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "几天前，我问是否有人对C FFI之外的二进制库发行有什么建议，人们不断地给我指出各种 \"hack \"解决方案，对此我非常感激（尽管这些hack的方法在我的特定情况下没有帮助，C FFI看起来仍然是最不坏的解决方案）。然而，有一件事让我很吃惊，那就是动态链接（或者说是可预测的ABI，我认为动态链接需要ABI）的想法（也许只是被认为）受到了反对。还有一个事实是，几乎没有人关心在我看来是系统语言设计中的一个巨大漏洞。TL;DR：这让我想到：Redox OS或类似的项目（比如今天早些时候u/dptzippy发布的项目）打算如何解决这个问题？他们肯定不会期望人们在某个核心库/缓存中的错误修复后重新编译整个操作系统，或者他们会怎样做？还是我错过了什么？https://www.reddit.com/r/rust/comments/qr2kyb/libertyos_another_opensource_operating_system/*我说的是 \"可预测 \"而不是 \"稳定\"，因为我们不需要一个完全稳定的ABI。即使只是保证如果我用同一版本的编译器编译东西，如果公共API保持不变，公共ABI也会有很大的帮助。今日reddit上的Rust板块的热帖，贴一下高赞回复：你好，我是Theseus操作系统的作者。很好的帖子，真的和我心底的想法一致。https://github.com/theseus-os/Theseus缺乏一个稳定的ABI是我们尚未完全解决的一个大障碍。这个问题对于像 Theseus 这样基于安全语言的 SAS/SPL 操作系统来说特别重要，考虑到我们的目标是让编译器对系统各层的所有代码都能可见（visibility）/自我反省（instrospection），没有盲点，就更重要了。我个人认为，对于使用系统调用作为用户应用程序和内核之间的 \"稳定 \"接口的其他操作系统来说，这不是一个问题，或者在更广泛的意义上，作为两个独立编译的代码片断之间的 \"稳定 \"连接层，它们在执行时相互依赖。我记录了我在实现针对现有 Theseus 编译实例为了编译out-of-tree这个crate（以及一个各种启动器 libc 骨架）的工具时所经历的历程和思考过程。这涉及到对cargo的hack式滥用，我没必要推荐其他用例 -- 在我们有限的事例下，它是有效的，因为我们可以控制一切的编译 -- 但相当难以处理。它很可能无法扩展到支持闭源应用程序或库的分发。显然，我意识到，在运行时动态地重新链接单独编译的二进制文件中的符号/依赖关系是非常愚蠢和乏味的，这些符号/依赖关系在构建时是静态链接的，与实际运行的系统实例中存在的这些依赖关系的版本相一致。请注意，我们还没有时间去探索更好的选择。我发这个帖子只是为了说明人们为了解决稳定的ABI问题而可能需要做的事情。最好的 \"替代方案 \"基本上是其他人在你上面链接的u/dptzippy的帖子中所建议的—使用某种bindgen来创建一个薄的FFI层，将稳定的C ABI函数作为Rust函数的存根来暴露。然而，这有一个主要的缺点，那就是到处引入不必要的unsafe因素，这有点违反了我上面提到的Theseus的整个目标，因为unsafe因素是一个盲点。不管怎么说，我只是觉得应该把我的想法说出来，在这里分享我的经验，让对话进行下去，看看其他人有什么意见。Read More: https://www.reddit.com/r/rust/comments/qr5pyo/how_is_redox_os_and_similar_projects_planning_to/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/qr5pyo/how_is_redox_os_and_similar_projects_planning_to/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-11 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Redox OS（以及类似的项目）计划如何处理缺乏动态链接支持的问题？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "有时我们开始做事情，但中途决定宁愿不做这些事情。这个过程有时被称为 \"取消\"。比如我们不小心在浏览器中点击了 \"下载 \"一个大文件。我们应该有办法告诉计算机停止下载它。今年早些时候，当Rust异步工作组在研究用户体验时，异步取消被反复提及。这是一种很重要的东西，但推理起来却很麻烦。我想我可以通过写一篇关于这个主题的深度研究来改变这种状况。在这篇文章中，我们将看一下Async Rust的异步原语，并介绍今天这些原语的取消是如何进行的。然后，我们将继续研究如何确保我们不会出现资源悬空的情况。最后，我们将看看当前Async Rust的方向对Async取消意味着什么。听起来像个计划？很好，让我们开始行动吧技术向博文。Read More: https://blog.yoshuawuyts.com/async-cancellation-1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.yoshuawuyts.com/async-cancellation-1/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-11 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "异步取消（asnyc cancellation）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "要成为一名Linux开发者，你曾经需要C语言作为你的护照。现在Rust也可以让你成为一个操作系统程序员。有这样一个笑话。\"C语言结合了汇编语言的力量和性能以及汇编语言的灵活性和易用性\"。我曾经用C语言和IBM 360汇编语言编程--那是很久以前的事了，好吧--这话是有道理的。由于C语言的功能、性能和可移植性，它成为操作系统语言的首选，当然也包括Linux。一篇博文，介绍Rust在Linux中的应用。Read More: https://www.theregister.com/2021/11/10/where_rust_fits_into_linux/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.theregister.com/2021/11/10/where_rust_fits_into_linux/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-11 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "保持冷静，学习Rust。我们很快就会在Linux中更多的看到这种语言。" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "即使你能修复rustc的所有健全性漏洞，或者以其他方式防止用户代码利用这些漏洞，任何第三方库中的健全性漏洞也会使恶意的crates有可能从安全代码中触发任意行为。[...]这就是为什么我们需要强调，虽然Rust的静态分析在限制非恶意代码的意外漏洞方面非常出色，但它们并不是一个可以对恶意代码进行有意义限制的沙盒系统。\nMatt Brubeck 在 rust-users 谈到\nRead More: https://this-week-in-rust.org/blog/2021/11/10/this-week-in-rust-416/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/11/10/this-week-in-rust-416/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-11 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周周报" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个月的游戏月报，有不少很好的作品，关注Rust游戏开发的小伙伴，别忘了去看月报！Read More: https://gamedev.rs/news/027/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gamedev.rs/news/027/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-11 22:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "最后" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个 crate 原理仍然是将rust编译成 cdylib，然后在 c# 里面调用。不过将这个过程变得更容易了一点。https://docs.rs/rnet/0.1.0/rnet/index.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-10 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rnet - 从 .net 中调用 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-10 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "适合制作鼠标垫：Rust 中的模式匹配" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Spectral 跟 Arm，Toyota 等一批加入了 Rust 基金会。Spectral 是做代码安全的公司，提供一整套服务。https://spectralops.io/在这里 Nahum 讲了为什么 Spectral 爱上了 Rust。https://spectralops.io/blog/spectral-joins-the-rust-foundation/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://spectralops.io/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-10 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Spectral 介绍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "虽然是站在 kotlin 立场上来看的，比较研究也比较有价值。https://www.beust.com/weblog/2021/11/09/what-kotlin-could-learn-from-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.beust.com/weblog/2021/11/09/what-kotlin-could-learn-from-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-10 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "blog: kotlin 可以从 Rust 身上学到哪些？" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "啥也不说了，太酷了。fq看。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-10 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个模拟的 cpu/disk/net 仪表盘" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "跟踪贴在这里：https://github.com/rust-lang/rust/issues/72016#issuecomment-964186287" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-lang/rust/issues/72016#issuecomment-964186287" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-10 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "内联汇编语法快稳定了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Ferrous System 出品。现已迭代到 v0.3 版本。https://ferrous-systems.com/blog/knurling-rs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://ferrous-systems.com/blog/knurling-rs/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-10 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Knurling-rs - 更好的嵌入式 Rust 库和应用开发测试套件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章非常深入地讨论基于 Rust 中的泛型、dyn trait, slice 等设施的更有宽容度的上层设计。属于进阶文章，值得学习。https://blog.logrocket.com/improving-overconstrained-rust-library-apis/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.logrocket.com/improving-overconstrained-rust-library-apis/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-10 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "好文推荐：如何改进限制过多的 Rust 库 API" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://romankudryashov.com/blog/2021/11/monitoring-rust-web-application/主要就是一些配置和对应的代码嵌入，写得非常详细。推荐。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://romankudryashov.com/blog/2021/11/monitoring-rust-web-application/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-10 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Prometheus 和 Grafana 监控 Rust Web 应用程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "属于验证型的项目，做 ios 开发的童鞋可以研究研究。https://github.com/wooden-worm/ios-app-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/wooden-worm/ios-app-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-11-10 21:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用纯 Rust 开发 ios 应用" }, "type": "text" }], "type": "title" } },]
