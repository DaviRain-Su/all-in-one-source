export const propertiesForNewPages = [{ "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "RillRate是一个将实时网络仪表盘嵌入到你的应用程序中的库。RillRate 周一发布了前端的所有资源(由Yew制作)!并将许可完全改为Apache-2.0:前端和后端。你可以在这里看到Yew应用程序的资源:https://github.com/rillrate/rillrate/tree/trunk/pkg-dashboard它包括2个crate:\nrate-ui -小部件基础和连接代理\nrate-app -仪表盘\n原文链接https://github.com/rillrate/rillrate" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-10-04 18:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "大型 Yew 应用揭晓: 所有的 RillRate 资源均可使用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Poem是一个功能齐全且易于使用的web框架，使用Rust编程语言。openapi 例子原文链接https://www.reddit.com/r/rust/comments/q0d588/poem_08_released/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-10-04 18:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Poem 0.8 版本发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Doku是一个框架，可以直接从代码中构建美观的、人类可读的文档;它允许您轻松地为配置文件、HTTP端点等生成文档。告别陈旧的手写文档——使用Doku，代码就是文档!结果github 地址https://github.com/anixe/doku--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-10-04 18:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "doku: 0.10 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Linkerd —— Kubernetes 的服务网格——具有用 Rust 编写的代理（自 2017 年以来），但它的控制平面完全用 Go 实现......一直到现在！在昨天的 2.11.0 版本中，Linkerd 具有一个用 Rust 编写的新策略控制器组件！它使用kube-rs与 Kubernetes API 进行通信，并公开了一个使用Tonic实现的 gRPC API 。文章链接，https://www.reddit.com/r/rust/comments/pzcu62/linkerd_211_now_includes_a_kubernetes_controller/Gitlab 链接，https://github.com/linkerd/linkerd2" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://www.reddit.com/r/rust/comments/pzcu62/linkerd_211_now_includes_a_kubernetes_controller/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-10-02 12:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Linkerd 2.11 现在包含一个用 Rust 编写的 Kubernetes 控制器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Flowistry 是一个 VSCode 扩展，可帮助您理解 Rust 程序。Flowistry 使用数据流分析和指针分析在比类型所能提供的更深层次上分析 Rust 程序（您已经可以在rust-analyzer 中找到）。Flowistry 是 alpha 软件（请参阅限制）。我正在寻找早期采用者来尝试并提供反馈！如果您有疑问或问题，请提交 Github 问题，加入我们的 Discord，或在 Twitter 上 DM @wcrichton。Gitlab 链接，https://github.com/willcrichton/flowistry" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/willcrichton/flowistry" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-10-02 12:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Flowistry：强大的 Rust IDE 工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "worm是一个浮动的、基于标签的 X11 窗口管理器。它是用 Rust 编程语言编写的，使用 X11RB 库。Gitlab 链接，https://github.com/codic12/wormhttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/codic12/worm" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-10-02 12:08" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "worm：Rust 中基于浮动标签的窗口管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Open Source Security, Inc. 开发和维护 grsecurity®，这是 Linux 内核的安全替代品。Facebook 的 Rust 基金会成员总监 Joel Marcey 邀请 Open Source Security 总裁 Brad Spengler 回答了他的一些问题，并回答了一些加入 Rust 基金会的感想。\nhttps://foundation.rust-lang.org/posts/2021-09-21-member-spotlight-open-source-security-software/\n文章带我们了解怎么用 Rust 编写 Cloudflare Workers ServerLess 代码。然后将展示构建一个完整的 ServerLess 功能，并可以使用它来验证带有 hCaptcha 的前端 Web 用户。\nhttps://dev.to/askrodney/using-rust-cloudflare-workers-serverless-hcaptcha-358g\nRustcc论坛: 支持rss微信公众号：Rust语言中文社区https://rustcc.cn/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-10-01 23:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "微软的 Ryan Levick 大神提到，LLVM13 的最新的 pass manager 进展让 Rust 的编译速度整体提高 5~20%。目前 LLVM13 还在 nightly 状态。很快估计能惠及到 Rust 这边来。https://twitter.com/ryan_levick/status/1443202538099073027" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-30 10:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "LLVM13 的最新的 pass manager 进展让 Rust 的编译速度整体提高 5~20%" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Linux Plumbers Conference 是一个面向开源社区的开发者会议，将以下场景的顶级开发者汇聚在一起：内核子系统，核心库， 窗口系统等等。Linux Plumbers Conference 2021 有 9 个 topic 与 Rust 相关它们分别是：https://www.reddit.com/r/rust/comments/pxz7at/rustlinux_plumbers_conference_2021/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-30 10:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Linux Plumbers Conference 2021 有 9 个 topic 与 Rust 相关" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "blog 讲解 使用 serenity 用 20 行代码创建一个 Discord 机器人。https://elijahpotter.medium.com/how-to-write-your-own-discord-bot-in-rust-bf2288d93361" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-30 10:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 写一个 Discord 机器人" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "https://github.com/Lea-fish/Leafish" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-30 10:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "leafish - 一个兼容 Minecraft 游戏的客户端" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "原理很简单，通过解析 markdown 文件，填充一个 html 模板。完成。https://kerkour.com/blog/rust-static-site-generator/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-30 10:53" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 100 行 Rust 代码构建一个静态站点生成器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "真的是一款很有趣的游戏。视频中还未展示很多游戏内容，欢迎大家来游玩。有能力的玩家欢迎提供建模模型，修改源码提供MOD。B站视频https://www.bilibili.com/video/BV1mL411x7rF?p=1&share_medium=android&share_plat=android&share_session_id=1b28a632-f60f-4ee5-9d71-4bcb96a744b1&share_source=WEIXIN&share_tag=s_i&timestamp=1632706296&unique_k=tsDj2D" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-27 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "20W+行 Rust 构建的游戏居然这么好玩！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "russtls 是一个 Rust 编写的现代的 TLS库。它使用ring进行加密，使用libwebpki进行证书验证。目前已发布 0.20 版本.github地址https://github.com/rustls/rustls" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-27 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rustls 0.20 发布了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如下图所示:github 地址https://github.com/adam-mcdaniel/dune" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-27 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "dune: 一个 Rust 写的 shell" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "SeaORM 是一个关系型 ORM,可以帮助你构建轻量的高并发的 web 服务.原文链接https://www.sea-ql.org/SeaORM/blog/2021-09-20-introducing-sea-orm/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-27 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "SeaORM: 异步动态的 ORM" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "如下图效果:github地址https://github.com/multimeric/emoji_pix--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-27 20:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "emoji_pix: 一个可以将图片转换为像素风的工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "以下项目来自 RustConf 2021。移动构造函数：有可能吗？“自引用” 类型是一种对自身引用的类型；异步 Features 是当今 Rust 中最常见的自引用类型。但是，它们不能在不使引用无效的情况下移动，因此常被固定在堆或栈上。你不能返回它们或将之放入 Collection（当然了不用 Boxing）。C++ 通过移动构造函数大量使用可安全移动的自引用类型，将移动构造函数桥接到 Rust 是 C++ FFI 未解决的重大问题之一。使用对 Pin P 保证的新颖解释，我们将所有 C++ 构造函数（而不仅仅是移动构造函数）移植到 Rust，而不影响 Rust 的「使用后移动」保护（C++ 所缺乏的）。今天，稳定的 Rust 完全支持按移动返回和集合，除了零成本的 C++ FFI，Rust 的 “构造函数” 还可用于在纯 Rust 中表达新颖的数据结构。视频：(4) RustConf 2021 - Move Constructors: Is it Possible? by Miguel Young de la Sota - YouTubehttps://www.youtube.com/watch?v=UrDhMWISR3w在 Rust 中不要过度优化的重要性Rust 编程语言具有许多高级功能，可以实现一些出色的优化。对于新的 Rust 开发人员来说，这些既令人兴奋又令人沮丧。因为 Rust 允许我们编写经验丰富的 Rust 开发人员可以理解的高度优化的代码，所以很容易一直这样做。本演讲将展示这些优化通常对于获得优于 Python 等高度动态语言的性能来说是不必要的。对于新的 Rust 开发人员来说，打破过度优化的诱惑可以提高 Rust 的生产力和满意度。视频：(4) RustConf 2021 - The Importance of Not Over-Optimizing in Rust by Lily Mara - YouTubehttps://www.youtube.com/watch?v=CV5CjUlcqsw模糊驱动开发有时候你可以想出一种简单的方法验证正确性，但很难找到单元测试的实际示例。你知道「对于所有 x 都成立」但是无法为 x 想出好的可能性。这就是依靠模糊测试可以通过提供一些代码尚未涵盖的真实示例来快速推动开发的地方。本演讲我们将一起完成使用 cargo fuzz 的过程，以构建一个可以压缩 JSON Patch 操作的快速程序，涉及 Rust 社区的一些实用程序/库（模糊测试工具，serde_json 等），以及学习一些关于在开始模糊测试时你可能会有什么样的误解。视频：(4) RustConf 2021 - Fuzz Driven Development by Midas Lambrichts - YouTubehttps://www.youtube.com/watch?v=qUu1vJNg8yo使用 Rust 写最快的 GBDT 库本演讲将分享作者优化梯度提升决策树机器学习算法的 Rust 实现的经验。 通过代码片段、堆栈跟踪和基准测试，探索如何使用 rayon、perf、cargo-asm、编译器内在函数和 unsafe rust 来编写一个 GBDT 库，该库的训练速度比用 C/C++ 编写的类似库更快。PS：作者是个美女。视频：(4) RustConf 2021 - Writing the Fastest GBDT Library in Rust by Isabella Tromba - YouTubehttps://www.youtube.com/watch?v=D1NAREuicNsTwitter 工程师使用 Rust 重构的故事三名工程师，在不同的方面，各自采用自己的方法将 Rust 添加到 C 代码库中，每个人都越来越雄心勃勃。最初只是想用同样快速的 Rust 实现替换服务器的网络和事件循环。 我们会重用 C 中的许多核心组件，然后从 Rust 中调用它们。肯定不会有那么多代码...... Pelikan 是 Twitter 用于内存缓存的开源和模块化框架，允许我们用单个代码库替换 Memcached 和 Redis 分支并获得更好的性能。在 Twitter，我们运行数百个缓存集群，在内存中存储数百 TB 的小对象。内存缓存至关重要，需要性能、可靠性和效率，本演讲将分享在 Pelikan 工作的冒险经历以及如何用 Rust 重写它。视频：(4) RustConf 2021 - Whoops! I Rewrote It in Rust by Brian Martin - YouTubehttps://www.youtube.com/watch?v=m-Qg3OoPIdc五" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-26 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RustConf 2021 项目精选" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本 Tutorial 是一个简单的全栈 Web 应用，包含具有数据库支持的 REST 后端和基于 Wasm 的单页应用程序前端。具体是构建一个简单的宠物主人应用程序，使用户能够添加主人和他们的宠物。程序需要将所有者和他们的宠物列表提供详细视图，能够根据需要删除和添加宠物。教程涵盖以下内容：\n创建一个全栈的 Rust APP\n常用功能\n构建 REST 后端\n前端实现\n测试\n教程地址：Full-stack Rust: A complete tutorial with examples - LogRocket Bloghttps://blog.logrocket.com/full-stack-rust-a-complete-tutorial-with-examples/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-26 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "全栈 Rust：包含示例的 Tutorial" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "写给 Java 程序员的 Rust 介绍 Tutorial。包括以下内容：\n简介\nRust 构建和运行\nRust 变量\nRust 默认的不可变性\nRust 函数\nRust if/else 和表达式\nRust 字符串\nRust 结构体（Java 类）\nRust 结构体函数（Java 静态函数）\nRust 结构体方法（Java 方法）\nRust Trait（Java 接口）\nRust 数组（Java 数组）\nRust 元组\nRust Vec\nRust 枚举（Java 枚举）\nRust Match\nJava 17 Switch 表达式（Rust Match）\nRest Generics\nRust Option（vs Null/Optional）\nRust Result（Java Exception）\n非常不错的介绍，值得一看看。视频地址：(4) Rust for Java Developers - YouTubehttps://www.youtube.com/playlist?list=PL7r-PXl6ZPcD63DS2djSiz4SlXkaTfobc" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-26 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust For Javaer" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "项目致力于『可学习性和可控制』，目标包括：\n低语法噪声\n对 Python 开发者熟悉\n允许优化内循环\n与 Rust 生态互操作\n设计指南：eztd/CONTRIBUTING.md at main · epage/eztdhttps://github.com/epage/eztd/blob/main/CONTRIBUTING.md#design-guidelinesGitHub：epage/eztd: Source code spell checkerhttps://github.com/epage/eztd#about网址：Learnability of Rusthttps://epage.github.io/blog/2021/09/learning-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-26 23:35" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "eztd：让 Rust 更易学习" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "GitHub Advisory Database（安全咨询数据库）现在已经支持 Rust 了。下一步将支持  dependabot ， dependabot是 GitHub 推出的一个提醒依赖更新机器人，当你项目的依赖有更新的时候就会自动推送一个 Pull requests。GitHub Advisory Database 官方写道：这一覆盖范围确保了Rust社区的任何成员都可以在他们的代码所在的同一个地方检查安全问题：GitHub上。这仅仅是第一步! 请查看我们的公共路线图，我们正在努力实现Rust对依赖关系图和Dependabot警报的支持。谢谢你，RustSec和Rust社区!在我们努力将Rust生态系统加入咨询数据库的过程中，我们得到了RustSec和Rust社区的大量支持。我们非常感谢RustSec，这是一个独立的组织，负责收集、规范和发布与Rust库相关的安全建议。它的免费公共数据库是我们自己的Rust漏洞数据集的起点。我们计划继续与RustSec和更广泛的Rust社区合作，使我们自己的GitHub安全咨询数据可用并易于使用，以进一步补充他们的数据。通过合作，我们可以为减少漏洞的可见性问题做更多的工作，而不是单独行动。原文链接，https://github.blog/2021-09-23-github-advisory-database-now-supports-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.blog/2021-09-23-github-advisory-database-now-supports-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-25 23:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "GitHub Advisory Database 现已支持 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Klask，从 clap v3 apps 自动创建 GUI 应用，将 egui 用于图形。Github 链接，https://github.com/MichalGniadek/klask" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/MichalGniadek/klask" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-25 23:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Klask" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "MiniJinja 是一个强大但最小依赖的 Rust 模板引擎，基于 Python 的 Jinja2 模板引擎的语法和行为。https://jinja.palletsprojects.com/en/3.0.x/Github 链接，https://github.com/mitsuhiko/minijinjahttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mitsuhiko/minijinja" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-25 23:43" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "MiniJinja" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Composing Studio 是一款支持在线实时协作的音乐编辑器，使用 Rust、WebAssembly 和 TypeScript 构建，允许任何人创建简单的音乐作品。Composing Studio 使用一种名为 ABC 的文本格式来完成对音乐的编辑，可以用于转录简单的歌曲 + 吉他和弦，以及其他一些作品，如合唱和民间音乐。同时提供一个友好直观的 Web 界面，具有语法突出显示、实时预览、音频播放和实时协作等功能。GitHub - ekzhang/composing.studio: https://github.com/ekzhang/composing.studioonline demo: https://composing.studio/productive-animal-5688" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://composing.studio/productive-animal-5688" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-23 22:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Composing Studio - 协作编曲工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "termusic 是一款用 Rust 开发的终端音乐播放器，目前支持 mp3, m4a, flac 和 ogg/vorbis 多种格式。作者曾经是 GOMU 的贡献者，由于在开发时遇到像数据竞争这样的严重问题，所以使用 Rust 进行了重写。GitHub - tramhao/termusic: https://github.com/tramhao/termusicCrates.io - termusic: https://crates.io/crates/termusic" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/termusic" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-23 22:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "termusic - 终端音乐播放器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "新一期的 Rust 周报速递发布，快来看看有哪些内容你曾经关注过 :)This Week in Rust 409: https://this-week-in-rust.org/blog/2021/09/22/this-week-in-rust-409/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/09/22/this-week-in-rust-409/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-23 22:50" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Rust 409" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n支持多线程并发任务提交。\n很快。\n实现在 tokio 中引入的 AsyncRead/AsyncWrite trait。\nReadMore:https://github.com/KuiBaDB/kbioBlog:https://blog.hidva.com/2021/09/14/kbio/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.hidva.com/2021/09/14/kbio/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-22 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "kbio基于io_uring的异步 IO 框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "KuiBaDB是另一个用Asynchronous Rust重写的PostgreSQL，KuiBaDB专注于 OLAP 分析。KuiBaDB建立在kbio和tokio之上。只用 tokio 的“rt-multi-thread”、“rt”和“io-util”功能。所有 IO，包括文件 IO 和网络 IO，以及异步系统调用都由kbio提供支持。KuiBaDB使用矢量化引擎，也是目录驱动的。KuiBaDB使用了Hologres 中引入的列式存储。但是我删除了Delete Map并为每行添加了xmin，xmax，xmin/xmax保存在行存储中。ReadMore:https://github.com/KuiBaDB/KuiBaDB" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/KuiBaDB/KuiBaDB" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-22 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "KuiBaDB" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Robyn 是一个由用 Rust 编写的异步 Python 后端HTTP服务运行时。在 Rust 异步运行时之上运行的 Python 服务。ReadMore:https://sansyrox.github.io/robyn" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://sansyrox.github.io/robyn" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-22 23:06" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Robyn" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "所有 Rustaceans，中秋节快乐。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-21 21:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本系列已经更新到第四部分了，也是终结篇。欢迎跟进。https://www.fpcomplete.com/blog/axum-hyper-tonic-tower-part4/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-21 21:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "组合 Axum, Hyper, Tonic 和 Tower 一起，开发一个混合的 web/gRPC 应用：第四部分" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Allen Wyma 与软件工程师 Daniel McKenna，也是 Tarpaulin 覆盖测试工具的作者的访谈节目。欢迎收听。https://rustacean-station.org/episode/037-daniel-mckenna/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-21 21:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【播客】使用 Tarpaulin 进行 Rust 工程测试率覆盖" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Trunk 会打包 WASM，JS 代码片断，静态资源（images, css, scss 等）。它的配置使用 HTML 文件。Trunk 支持所有基于 wasm-bindgen 的框架，包括但不仅限于 Yew 和 Seed。官网：https://trunkrs.dev/代码仓库：https://github.com/thedodd/trunk" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-21 21:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Trunk - 一个 Rust 的 WASM web 应用打包器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "perseus 采用 No-VDOM 技术实现页面渲染。实现纯 Rust 前端 Web UI 开发。\n支持服务端静态页面生成\n支持服务端动态渲染\n支持增量生成\n各种定制渲染策略\n命令行工具\n基于 Fluent 的 i18n 支持\n它基于强大的 sycamore 实现。实际上，Perseus 与 Yew, Seed 等算竞争对手，但是所采用的技术思路实际是不一样的。https://github.com/sycamore-rs/sycamorehttps://github.com/arctic-hen7/perseus--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-21 21:28" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Perseus - 另一个前端集成 Web UI 框架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "和任何其他语言一样, 在我们掌握语法之外, 我们往往还有 CI/CD 的需求:\n需要哪些组件来组成CI管道，以确保我的代码是健康的？\n如何部署？\n我需要编写自定义工具还是有社区资源可用？\n作者会用三篇文章来讲解 Rust在 github 中如何使用 action 来完成 CI/CD.原文链接https://www.homeops.dev/continuous-integration-with-github-actions-and-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-20 20:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust CI/CD: github action 使用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是使用 Axum, Hyper, Tonic, and Tower 来打造 web/gRPC 应用系列的第四部分. 本次主要讲解如何组合  Axum 和 Tonic.原文链接https://www.fpcomplete.com/blog/axum-hyper-tonic-tower-part4/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-20 20:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Axum, Hyper, Tonic, and Tower 打造 web/gRPC 应用" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "CompactStr 是一种内存效率更高的不可变字符串类型，它可以在堆栈上存储较小的字符串，并透明地在堆上存储更长的字符串。它们大多可以用作String的替换，在解析、反序列化或任何其他可能有较小字符串的应用程序中特别有用。github 地址https://github.com/ParkMyCar/compact_str" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-20 20:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "compact_str: 一种内存高效的不可变 string 类型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是一个 Rust 版本的 LRU 实现. golang 的实现: https://github.com/hashicorp/golang-lrugithub 地址 https://github.com/al8n/caches-rs--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-20 20:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Caches: rust版本的 LRU" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rustc_codegen_gcc 是为 Rustc 设计的 GCC 代码生成后端，目前已经加入 rust-lang 官方大家庭。它不仅可以复用现有的 Rustc 前端，还能够获取来自 GCC 的增益，比如支持更多架构以及应用 GCC 的独门优化。尽管该项目采用 libgccjit 进行实现，但其实并不是利用 JIT 技术，而是采用 AOT 方案，可不要被名字迷惑哦。GitHub - rust-lang/rustc_codegen_gcc: https://github.com/rust-lang/rustc_codegen_gcc" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/rust-lang/rustc_codegen_gcc" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-17 23:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "事件 - GCC 代码生成后端现已加入 rust-lang 大家庭" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Kraken 一家总部位于旧金山的公司，是世界上最大的基于欧元交易量和流动性的全球数字资产交易所。Kraken 的后端服务早期是使用 PHP 实现的，在最近两年时间，使用 Rust 改造原有的 PHP 服务并开发新的产品和功能，并使用 Rust 支撑了不断扩大的加密货币交易业务。Kraken 发布了关于使用 Rust 改进基础建设的一篇文章，并希望对于考虑使用 Rust 构建产品的公司和想要投入时间学习该语言的开发人员来说是一个有用的资源。同时，Kraken 还表示，为了感谢 RustAnalyzer 的出色工作，将会向该项目捐赠 50K EUR 。文章 - Oxidizing Kraken: Improving Kraken Infrastructure Using Rust: https://blog.kraken.com/post/7964/oxidizing-kraken-improving-kraken-infrastructure-using-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.kraken.com/post/7964/oxidizing-kraken-improving-kraken-infrastructure-using-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-17 23:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "文章 - Kraken 使用 Rust 改进基础设施" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "三月份的时候，Deno 1.8 就已经使用 wgpu 来提供了初始的 WebGPU 支持。Deno 团队花了更多的时间将一致性测试套件（CTS）连接到 Deno WebGPU 运行，并报告了 wgpu 上第一个 CTS 结果/问题。现在该工作已经与 wgpu CI 集成，作为 wgpu 基础设施和生态系统的一部分。文章 - https://gfx-rs.github.io/2021/09/16/deno-webgpu.html: https://gfx-rs.github.io/2021/09/16/deno-webgpu.htmlhttps://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://gfx-rs.github.io/2021/09/16/deno-webgpu.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-17 23:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "事件 - WGPU 与 Deno 在 CTS 上的成功合作" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Elixir 是一门函数式编程语言，其中有个管道操作符十分好用，可以将上一步操作的结果传入给下一个方法，做链式调用，在某些情况下比嵌套括号好看很多。Pipette 是一个Rust的管道操作包，拥有这个包你也可以在Rust里实现类似的操作：或者这样：其实社区内也有其他实现，但是基本都是用了宏，这个包相较于其他实现而言，就是没有使用宏。Github: https://github.com/jkelleyrtp/pipette" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/jkelleyrtp/pipette" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-16 23:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Pipette: 一个模仿 Elixir 的管道操作的包，没有使用宏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust for Rustaceans 是一本 Rust 新书，目标读者从书的简介里可以知道是针对对于Rust有一定了解，还想要再更近一步深入的读者。作者大家之前应该有接触过： Jon Gjengset，油管上发了很多Rust相关的实战录播，是Crust of Rust系列视频的作者，基本没过段时间都会在其推特上让大家投票选择下一期视频的主讲内容。作者推特: https://twitter.com/jonhoo" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://twitter.com/jonhoo" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-16 23:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "《 Rust for Rustaceans 》 已经在印刷厂了！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是用Rust写的一个能理解语法的比较工具!Difftastic解析源代码（使用树状图），执行结构性差异（基本上是Dijktra的算法），然后试图以一种可理解的方式显示它:)它并不完美：它有时会被混淆，而且它真的不喜欢大文件。这是我在crates.io上的第一个相关工具，而且它真的很有趣，可以修补。https://github.com/Wilfred/difftastic/希望你有任何反馈!" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-16 23:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Difftastic 句法比较工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "对外语播客感兴趣的可以关注一下，基本每过段时间都会邀请社区大佬进行采访。Read More: https://rustacean-station.org/episode/036-luca-palmieri/还有另一个播客节目： Are we podcast yet...令人熟悉的Rust社区Are we体名字 :）恰好这次邀请的作者就是Rust for Rustaceans的作者：https://soundcloud.com/arewepodcastyet/awpy-08-jon-ferdinand-ronge-gjengset" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rustacean-station.org/episode/036-luca-palmieri/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-16 23:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 播客，这次邀请到的是Rust从零到生产的作者" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "第 408 期。Read More: https://this-week-in-rust.org/blog/2021/09/15/this-week-in-rust-408/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/09/15/this-week-in-rust-408/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-16 23:29" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周周报" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "DHCP 用于动态分配 IP 地址。DHCProto 是使用 Rust 实现的基础库。https://leshow.github.io/post/dhcproto/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-15 23:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "DHCProto 发布，支持 DHCPv4 和 DHCPv6" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "shellcode 是啥？黑客攻击壳代码，一般使用汇编语言写。Rust也可以完成此类工作。尝试在这里：https://kerkour.com/blog/shellcode-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-15 23:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 写 shellcode 代码" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本次网络大会的主题：\nProject Update: Lang Team\nProject Update: Libs Team\nMove Constructors: Is it Possible?\nThe Importance of Not Over-Optimizing in Rust\nIdentifying Pokémon Cards\nFuzz Driven Development\nWriting the Fastest GBDT Library in Rust\nWhoops! I Rewrote It in Rust\nHow I Used Rust to Become Extremely Offline\nSupercharging Your Code With Five Little-Known Attributes\nCompile-Time Social Coordination\nHacking rustc: Contributing to the Compiler\nThis Week in Rust: 400 Issues and Counting!\n干货满满哦~https://rustconf.com/schedulehttps://www.youtube.com/watch?v=pLdCcolQsxA" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-15 23:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本年度的全球 Rust 大会网络开幕" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "示例在这里：https://www.youtube.com/watch?v=S1NSsHZs6hI&feature=youtu.be" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-15 23:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust 开发 FLTK GUI程序" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "axum 的一个实战项目示例，是一个真正在跑的服务：https://github.com/sayanarijit/qrcode.show" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-15 23:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个使用 axum 框架开发的二维码生成服务" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "鉴于 Amazon 拥有很多 Rust 核心组的领导及成员，其影响力在 Rust 社区越来越大。steveklabnik（The Rust Book的作者）站出来，挑起一个话题：拒绝让 Amazon 来定义 Rust。可持续关注。关于这个，您怎么看？https://twitter.com/steveklabnik/status/1437441118745071617--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-15 23:49" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "steveklabnik: 拒绝让 Amazon 来定义 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "想象一下：你的坦克都是纸板做的。然后你的飞机也都是用纸做的，你的海军也全都是纸船，那也太惨了吧？虽然很荒唐，但是这就是现在的黑客技术的状态。Imagine: all the tanks of your army are made of cardboard. Now imagine that not only your tanks but also all your airforce is composed of paper planes and your navy of paper vessels. It would be a pretty bad situation, don’t you think?While it sounds absurd, this is the sad state of hacking today." }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-14 22:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Why Rust for offensive security" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "huangjj27" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "文章指出，过去的编程语言（c, Java， python）等都只能局限在一个领域应用，然而现在我们等来了 Rust 救场——不再有奇怪的包管理器、二级制打包工具或者脆弱的网络代码，这些方面的可靠性一旦被黑客们意识到，就可能带来安全攻防的变革。为了安利可靠的 Rust，作者还写了本书 Black Hat Rust, 来总结自己通过 Rust 在黑客技术中的实践，以其让读者少踩坑，更好地理解 Rust 的可靠。https://academy.kerkour.com/black-hat-rust?coupon=BLOG" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-14 22:09" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "TL;DR" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "虽然Rust编程语言在内核中使用的支持还没有登陆到本周末结束的 Linux 5.15 合并窗口，但这项工作仍在进行中。本周，关于Rust在Linux内核中的使用的最新进展被分享了出来。作为Rust for Linux项目的主要开发人员之一，Miguel Ojeda在本周的Linaro Connect虚拟会议上介绍了该项目，他目前正在为谷歌的合同工作。对周五的演讲感兴趣的人可以查看下面的 Presentation。原文链接https://bigthinkbuzz.com/the-latest-progress-on-rust-for-the-linux-kernel/Presentation地址https://static.linaro.org/connect/lvc21f/presentations/LVC21F-317.pdf" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-13 21:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 在 linux 内核中的最新进展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Matchbox 的诞生是因为作者在rust 中制作了一款多人网页游戏，遇到了以下问题:如何使用不可靠的、无序的 p2p connection 连接 N 个web浏览器?原文链接https://johanhelsing.studio/posts/introducing-matchbox" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-13 21:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Matchbox: Rust wasm 中的 p2p 网络解决方案" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "wgrpu 是 WebGPU API spec 的 Rust 实现, 目前这个教程已经更新到了 0.10 版本, 有大量的原理和代码示例讲解.原文链接https://sotrh.github.io/learn-wgpu/beginner/tutorial2-surface/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-13 21:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Learn Wgpu 更新了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Sycamore是一个用 Rust 和 WebAssembly 构建同构web应用程序的库. 目前发布了 0.6.0 版本了.\n静态生成\n服务端渲染\n重验证\n增量构建\n开放构建矩阵\nCLI利用，让您轻松和自信地构建应用程序\n充分利用 Fluent 开箱即用的 i18n 支持\n原文链接https://sycamore-rs.netlify.app/news/announcing-v0.6.0--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-13 21:10" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Sycamore: v0.6.0 版本发布了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "内容整理自 Reddit 的讨论：What is the current recommendation for logging in Rust? : rust。https://www.reddit.com/r/rust/comments/pmdh6a/what_is_the_current_recommendation_for_logging_in/问题简述：除了标准的 log，还有不少选择：env_logger，tracing，slog，simplelog 等等，最佳实践是什么？来自 Koxiaet 的答复：通常有两类与日志相关的 crate：日志接口和日志消费者。接口提供了想要记录某些东西时调用的函数，消费者处理将结构化日志数据格式化到某个地方（stderr 或文件）。两个主要的接口是 log 和 tracing，后者功能更强大因为它支持结构化日志记录，但前者更普遍。还有另一个结构化日志接口 slog，比 tracing 更古老但用的较少。每个日志接口都有自己生态系统，可以根据自己的需要选择。如果在写一个库，log 是个不错的选择，因为所有的日志记录接口都与它兼容。但如果你确实需要结构化日志记录，则可以改用 tracing，这取决于你的需求，比如你是需要写到文件还是只是终端。https://www.reddit.com/user/Koxiaet/其他网友的推荐：\nFile Logging：emabee/flexi_logger: A flexible logger for rust programs that can write to stderr or to log files。（来自 cfsamson）\ntracing 的接口：tracing_log - Rust，有多个同时操作交错日志消息时特别方便，可以按某些属性对它们进行分组并单独查看它们。（来自 class_two_perversion）\nestk/log4rs: A highly configurable logging framework for Rust，log4rs 是一个高度可配置的日志框架，以 Java 的 Logback 和 log4j 库为模型。通过 Yaml 配置，到 sdout 和文件，带有文件大小限制选项，还可以配置不同级别的日志。（来自 tms102）\ntracing-appender - crates.io: Rust Package Registry，推荐者所知道的唯一线程外日志记录解决方案，不仅适用于异步应用程序。（来自 Pand9）\ndaboross/fern: Simple, efficient logging for Rust，像 Python 的 logging 和 JS 的 Winston。（来自 RapBeautician）\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-12 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 的 Logging 推荐" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "本文是一篇博客翻译，来自：Full Stack Rust - Blog。https://www.justinm.one/blog/2021/09/11/fullstackrust/一年前，我的首选语言如下：\nPython 用于高级代码快速原型设计，或用于需要第三方功能的代码\nC/C++ 用于长期的 low-level 项目\n当时只听过 Rust 并简单使用过，我的经验来自用 Rust 写了一个处理大文件（>4GB）的事务并从中挖掘一些统计信息的小工具。我用了一个库将文件映射到内存，缤瑞按照顺序对其进行分析。有一些很酷的概念，比如编译器静态地强制内存映射在它被取消映射后无法访问——如果你不小心，C++ 中可能就会发生这种错误。不过当时并没有真正吸引我，因为那只是一个小新奇。当我向 pdblister 添加新功能以并行获取数千个 PDB 文件时诀窍来了。由于 GIL，在 CPython 中几乎不可能，而在 C/C++ 中做到不面临并行错误是极其困难的。然而 Rust 让这变得容易。我添加了 tokio 驱动的异步，使用 tokio::spawn 生成新任务来下载 PDB，并修复了编译器报的错误，它可以正常工作了。Rust 编译器输出一个二进制文件，它可以在任何地方运行，没有运行时依赖。https://github.com/DrChat/pdblister取代 Python这是第一点，Rust 是 Python 作为中长期工具语言的绝佳替代品。Python 的好处是庞大的库和生态系统，通过 pip 可以直接拿到，想要快速制作与 API 交互的原型，可以使用 requests，只要 import requests 就可以使用了。Rust 的 reqwest\t 也是如此，只要输入 cargo add reqwest 就可以在代码中使用它。然而当进入更长期的生命周期时，Python 就显示出劣势，requests 是程序的依赖，用户需要后去后才能使用。此外，由于弱类型和错误处理能力（与 Rust 比），Python 变得更加劣势。这一点上，我可以使用 Rust 比使用 Python 更快地编写原型工具，并且我可以自信地知道我的工具比等效的 Python 更易于维护且寿命更长。但是，对于短期工具，Python 可能仍然更好，因为它不需要启动项目即可在 VSCode 中获得智能感知支持。 Rust 的 cargo-script 接近将 Rust 推入脚本语言的领域，但不幸的是，我还没有在 VSCode 中找到与之集成的插件。取代 CRust 也是 C 的直接替代品，它在各方面都更好，并且可以与遗留 C 代码原生互操作以进行增量替换。Rust 最大的改进是生态系统：如上所述，利用 Rust 生态中已有的库是很容易的。如果你从未使用过 C，那很幸运，实际上 C 中使用高级功能的最佳方法是自己写。C 生态系统是支离破碎的，而且很脆弱。ABI 或构建系统没有一致的标准：\n由于缺乏 ABI 一致性，你不能跨平台或操作系统使用相同的二进制文件。  所以你必须从源代码构建。\n由于缺乏一致的构建系统，你不能简单地和应用程序一起构建 C 库，必须修补或重写要使其与你的库兼容的库的构建系统。\nC 库很少跨平台兼容，因为它们缺乏可以依赖的共享抽象。\n然后还有 Rust 最特色的安全改进——我就不展开了。但根据我的经验 - 安全性在很大程度上是一种工具，可以让第三方库开发人员更容易强迫我正确使用他们的库，这是 C 库不能做的事情。全栈 Rust总而言之，在过去的一年中，我一直在堆栈的所有部分使用 Rust，而我之前使用过其他语言。我已经使用 Rust 来实现引导加载程序：xenia-project/xell-rs: Xell Bootloader, rewritten in Rust because ¯_(ツ)_/¯，我已经使用它通过 pdblister 和 panamax 中的高级 HTTP/HTTPS 和其他技术来镜像文件。我利用并贡献了优秀的 gdbstub 库，用于控制由自定义 VMM 运行的 VM。这些项目都是在堆栈的不同级别完成的，而 Rust 非常适合所有级别。  我已经开始在我的个人项目中专门使用 Rust，并在适合的时候推动它在我的工作中使用。https://github.com/xenia-project/xell-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-12 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 全栈" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "通过 TaggedCell 和 Tag 类型实现，为了安全操作，TaggedCell 的每个实例都必须是唯一的。然后必须通过 TaggedCell::init () 初始化 TaggedCell，它使用用户提供的函数或闭包初始化底层数据，然后返回一个特殊的零大小的 Init<Tag> 用于访问 Cell 的数据。为了确保每个单元格使用唯一的标签类型，tagged_cell! 提供宏。该宏根据变量的名称创建一个新的标记类型，并将其应用到声明中。为了允许跨线程使用，只有第一次调用 TaggedCell::init 才会初始化 Cell 的数据。所有未来的 TaggedCell::init 调用都将返回一个新标签。未确定哪个线程将初始化 Cell 的数据。GitHub：Dasch0/tagged_cell: Fast, initializable, and thread safe static variableshttps://github.com/Dasch0/tagged_cell" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-12 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tagged_cell：快速、可初始化和线程安全的静态变量" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "µKanren 是一种轻量级关系编程语言\n原始的 Schema 实现在这里：jasonhemann/microKanren: The implementation of microKanren, a featherweight relational programming language\n相关参考：miniKanren.org\nGitHub：ekzhang/ukanren-rs: Rust implementation of µKanren, a featherweight relational programming language.https://github.com/ekzhang/ukanren-rs" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-12 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ukanren-rs：µKanren 的 Rust 实现" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "字符串中的每个星号都出现在由紧接前面的数字指定的位置。因此，29 后面的星号是该字符串中的第 29 个字符。可以在任何地方砍掉字符串的末尾，并且确切地知道它在哪里被剪掉了。比如不用数就知道字符串 2*4*6*8*11*14*17*2 正好有 18 个字符。当处理 50 万个字符时会比较省事。这就是个小工具，代码也只有几十行。GitHub：thomaschaplin/rust-counter-strings: 🧵 Generate self-describing strings of a given length to help aid software testinghttps://github.com/thomaschaplin/rust-counter-strings" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-12 22:30" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rust-counter-strings：快速定位字符串位置" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Tabled 是一个易于使用的库，用于美化 Rust 结构和枚举的输出。Github链接，https://github.com/zhiburt/tabled" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/zhiburt/tabled" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-11 23:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tabled 发布v0.3" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "使用 bma_benchmark使用宏 benchmark!Crate 链接，https://crates.io/crates/bma-benchmark" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/bma-benchmark" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-11 23:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "bma-benchmark 一个友好的基准测试工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "seL4 是一个用于构建操作系统和嵌入式程序的工具包，这个开源项目是使 Rust 中的 seL4 编程变得更好。以下代码演练假定使用示例 sel4_start 库执行 selfe，并介绍了 ferros 的某些方面。Github链接，https://github.com/auxoncorp/ferros" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/auxoncorp/ferros" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-11 23:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ferros" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "今天，Veloren 发布了 0.11。 这个版本已经制作了 3 个月，其一大重点是让世界各地的战斗更具活力。这是以新的地点系统的形式出现，以及 NPC 和生物如何与世界互动。要了解还有哪些新功能！请继续阅读 V0.11 变更日志链接，https://veloren.net/release-0-11/https://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://veloren.net/release-0-11/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-11 23:33" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Veloren发布v0.11" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rust 1.55 是 2021 Edition 正式发布之前的倒数第二个版本，此版本主要更新如下：\nrange 操作符支持半开语法\n\n极大的提高浮点数的解析速度\n采用新的 Eisel-Lemire 算法解析浮点数，不仅在速度上有很大提升，之前一些解析失败的边缘 case 也全都修复了\n\ncargo 构建的时候不再重复报 Error\n\n\n细化 io::ErrorKind\n\ncargo 构建的时候不再重复报 Error细化 io::ErrorKind使用 ErrorKind::Other 来区分标准库之外产生的 io Error，标准库之内不会再产生 ErrorKind::Other 的 Error。标准库未来暂未分类的 Error 类型，统一使用 Uncategorized。\n数组增加 map() 方法\n数组的 map() 方法返回的依然是数组，对数组来说更方便！\n稳定 ops::ControlFlow\n这是未来要稳定的 try trait v2 的一部分。标准库里面很多地方都用到了这个类型，很有用。\ncargo clippy --fix 可以自动帮你修复 clippy 的警告\n这个非常赞！链接：https://blog.rust-lang.org/2021/09/09/Rust-1.55.0.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.rust-lang.org/2021/09/09/Rust-1.55.0.html" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-10 20:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.55 稳定版发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Anna Harren 是第一个将 Rust 的 ::<> 语法命名为 Turbofish 的人。Rust 官方发布 1.55 的时候在博客里还特意纪念了最近刚去世的 Anna Harren。链接：https://twitter.com/garblefart/status/627886036211900416" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://twitter.com/garblefart/status/627886036211900416" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-10 20:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "纪念 Anna Harren" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Folyd" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Niko 发布了一篇博客，总结出 Rustaceans 的准则，比如其中提到：Rust empowers by being…\n⚙️ Reliable: “if it compiles, it works”\n🐎 Performant: “idiomatic code runs efficiently”\n🥰 Supportive: “the language, tools, and community are here to help”\n🧩 Productive: “a little effort does a lot of work”\n🔧 Transparent: “you can predict and control low-level details”\n🤸 Versatile: “you can do anything with Rust”\nHow to Rustacean\n💖 Be kind and considerate\n✨ Bring joy to the user\n👋 Show up\n🔭 Recognize others’ knowledge\n🔁 Start somewhere\n✅ Follow through\n🤝 Pay it forward\n🎁 Trust and delegate\n链接：https://smallcultfollowing.com/babysteps//blog/2021/09/08/rustacean-principles/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://smallcultfollowing.com/babysteps//blog/2021/09/08/rustacean-principles/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-10 20:38" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rustaceans 准则" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "你现在可以用rustup安装2021测试版了。使用rustup default beta切换到最新的测试版，然后你可以将你的toml文件迁移到 edition=\"2021\" 或者用cargo new启动一个使用21版的新项目。关于现有项目的迁移过程的一些信息:https://doc.rust-lang.org/cargo/commands/cargo-fix.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-09 21:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 1.56 beta1 (2021版)现已发布！!" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "陈渝老师的rcore系列操作系统课程更新了:rCore-Tutorial-Book 在暑假期间又进行了一轮修改，算是从0.35版进化到0.50版了。请对学习用Rust写OS感兴趣的朋友看看。如果有问题、建议，发现了bug，请直接在每节下方的交互窗口留言。如果想一起来参与写作，请直接联系 陈渝或吴一凡。谢谢！ 本书定位是以尽量简单的编程和尽量少的OS/CPU知识来逐步设计实现一个一个的小OS，让学生知道操作系统的概念的实际体现和操作系统的全貌。经过我们讨论，虽然这本书是基于单处理器讲解的，但觉得还是要加入OS的同步互斥支持，与传统方式不同，这一章主要讲解操作系统如何支持用户态线程的同步互斥操作。所以，目前还缺的是关于同步互斥的一章，各种图，相关OS历史的介绍，相关知识点的进一步补充。争取本月完成。Read More: https://rcore-os.github.io/rCore-Tutorial-Book-v3/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rcore-os.github.io/rCore-Tutorial-Book-v3/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-09 21:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rcore tutorial book 更新了" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "9.13 分享：Bento 是  Safe Rust 实现的 linux 内核 文件系统。 通过实现安全的 API 并使用安全的内核函数包装器，文件系统是用安全的 Rust 编写的。 这些安全接口尽可能接近现有的用户空间（主要是标准库）接口，因此只需将 Bento 包含更改为用户空间 Rust 库和/或 bento_utils 包含，就可以将文件系统重新编译为 FUSE 文件系统。更多信息：https://github.com/smiller123/bento这次分享主要讨论 Bento ，用于加速 Linux 内核开发的框架。目前已经为文件系统模块实现了Bento框架，并利用它实现了一个性能类似于ext4的文件系统，可以在不卸载的情况下进行升级，而且只需要15ms的停机时间。我们目前正在努力扩展Bento，以支持自定义的TCP/IP堆栈。在Linux中使用Rust的目的是创建更稳固、更安全的代码：通过利用Rust的语言特性和设计一个安全的API供驱动程序使用，避免内存安全问题和并发问题。该分享研究了我们如何/是否可以利用自动形式验证工具走得更远。9.14 分享：介绍   在 Linux  内核领域应用 Rust 的一些关键概念，第一部分内核线程是内核中最重要的组件之一，它也是实现内核中其他核心子系统的必要环节。本专题将分享如何在Linux内核中实现Rust类线程的封装器的学习过程，以及目前的状况和未来的工作。内核中的seq_file接口允许通过实现一个迭代可以打印的值的接口来轻松创建虚拟文件。这似乎应该直接转化为Rust的Iterator特性，其中Item实现了Display，但当然，魔鬼在细节中。该分享将展示如何为Rust代码提供seq_file的接口。9.15 分享介绍在 Linux 内核领域应用 Rust 的一些关键概念，第二部分虽然Linux主要不是一个以嵌入式为重点的操作系统，但它仍然被用于诸如Raspberry Pi这样的平台。在这些平台上，内核模块提供了一种有用的方式，可以在内核层面与各种设备进行交互，这些设备通常使用低级协议进行通信，如SPI或I2C。在这种工作负载中使用Rust有很多优势，虽然这些协议的内核API已经被尝试和测试了很长时间，但目前还没有Rust的抽象。在该分享中，将谈论在ARM64平台上为Linux带来一个安全的Rust的SPI协议的抽象，以及如何使用它来实现一个简单的设备驱动程序。该分享将与C语言的原始实现进行比较，后者提供了同样多的功能。最后，将深入探讨所使用的技术和他们使用Rust-for-Linux的经验。以上三天的研讨会，应该是线下的，因为并没有提供线上参与链接。对此话题感兴趣的可以关注：https://github.com/Rust-for-Linux/linux，也可以登记参加在线讨论： https://rust-for-linux.zulipchat.com研讨会官网： https://kangrejos.com/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-09 21:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust for Linux 研讨会 9.13 ～ 9.15" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "谷歌发布了一篇名为在Chrome中更安全地使用C++，它有一些关于这些安全问题如何困扰Chrome和Android代码库的安全报告的链接，这部分链接内提到了Rust。Read More: https://docs.google.com/document/d/e/2PACX-1vRZr-HJcYmf2Y76DhewaiJOhRNpjGHCxliAQTBhFxzv1QTae9o8mhBmDl32CRIuaWZLt5kVeH9e9jXv/pub" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://docs.google.com/document/d/e/2PACX-1vRZr-HJcYmf2Y76DhewaiJOhRNpjGHCxliAQTBhFxzv1QTae9o8mhBmDl32CRIuaWZLt5kVeH9e9jXv/pub" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-09 21:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "在Chrome中更安全地使用C++" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "自从几个月前开始制作 Tokio Console 原型以来，我们一直在努力工作，把它变成一个很棒的异步任务调试器。我们想围绕它的进展情况提供一些集中的更新。Read More: https://tokio.rs/blog/2021-09-console-dev-diary-1" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://tokio.rs/blog/2021-09-console-dev-diary-1" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-09 21:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tokio Cosole 开发日记#1" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "最值得激动的新功能当然是：simd和simd-nightly特性使得支持稳定和不稳定的SIMDRead More: https://docs.rs/zerocopy/0.6.0/zerocopy/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://docs.rs/zerocopy/0.6.0/zerocopy/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-09 21:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "zerocopy 0.6.0刚刚发布，带来了很多新的功能!" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "rpg-cli是一个用Rust编写的极简主义computer RPG。它的命令行界面可以作为CD的替代品，当你改变目录时，你会随机遇到敌人。https://en.wikipedia.org/wiki/Role-playing_video_gameGithub: https://github.com/facundoolano/rpg-cli/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/facundoolano/rpg-cli/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-09 21:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "rpg-cli发布1.0版本！" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Cupnfish" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "第 407 期。Read More: https://this-week-in-rust.org/blog/2021/09/08/this-week-in-rust-407/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://this-week-in-rust.org/blog/2021/09/08/this-week-in-rust-407/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-09 21:04" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本周周报" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n\nacpi - 包含用于解析 ACPI 表的 crate - 现代计算机的固件用于将有关硬件的信息传递给操作系统的数据结构。\n已将处理器 UID 和本地 APIC ID 的表示更改 acpi::platform::Processor为u32，以支持 X2APIC 用于支持更多处理器的更广泛的 ID。\n\n\nuefi-rs - 该uefi箱提供了安全，高性能包装UEFI。\n\n\nx86_64  - 提供了用于各种抽象x86_64系统，包括包装为CPU指令，访问处理器的专用寄存器，和抽象类型体系结构的特定结构，如页表和描述符表。\n\n\nbootloader - 实现了64位ELF可执行文件便于装载基于rust定制引导程序。\n\n\nmultboot2 - 提供一个抽象类型multiboot2引导程序的引导信息。\n\n\npic_8259 - 提供了用于8259个8259A可编程中断控制器（PICS）的抽象。\n\nacpi - 包含用于解析 ACPI 表的 crate - 现代计算机的固件用于将有关硬件的信息传递给操作系统的数据结构。已将处理器 UID 和本地 APIC ID 的表示更改 acpi::platform::Processor为u32，以支持 X2APIC 用于支持更多处理器的更广泛的 ID。uefi-rs - 该uefi箱提供了安全，高性能包装UEFI。x86_64  - 提供了用于各种抽象x86_64系统，包括包装为CPU指令，访问处理器的专用寄存器，和抽象类型体系结构的特定结构，如页表和描述符表。bootloader - 实现了64位ELF可执行文件便于装载基于rust定制引导程序。multboot2 - 提供一个抽象类型multiboot2引导程序的引导信息。pic_8259 - 提供了用于8259个8259A可编程中断控制器（PICS）的抽象。ReadMore:https://rust-osdev.com/this-month/2021-08/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rust-osdev.com/this-month/2021-08/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-08 23:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "本月 Rust OSDev（2021 年 8 月）" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n什么是Futures\n什么是自引用类型\n为什么他们不安全\nPin/Unpin 如何使它们安全\n使用 Pin/Unpin 编写复杂的futures\nReadMore:https://blog.cloudflare.com/pin-and-unpin-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://blog.cloudflare.com/pin-and-unpin-in-rust/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-08 23:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "为什么 Rust 需要 Pin 和 unpin" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "mook" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "像 jq，但用于 HTML。使用 CSS 选择器从 HTML 文件中提取部分内容。例子:ReadMore:https://github.com/mgdm/htmlq" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mgdm/htmlq" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-08 23:57" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "htmlq" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Poem-openapi 0.2.1 released!https://www.reddit.com/r/rust/comments/pjhoiu/poemopenapi_021_released/Poem-openapi:Poem-openapi 使你能够方便快捷的构建符合 OpenAPIv3标准的应用程序接口; 通过使用过程宏来生成大量样板代码，你将有更多时间和精力来专注于实现更重要的业务逻辑。功能特性:\n完全支持 async/await;\n类型安全;\n对Rustfmt用户友好 （过程宏）;\n最小开销;\n示例:代码：运行：更多信息：\n项目地址：https://github.com/poem-web/poem-openapi\n开源声明：Poem-openapi开源了!\n作者信息：油条哥主页\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-07 18:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "【大家的项目】 Poem-openapi v0.2.1 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Announcing Relm4 v0.1https://aaronerhardt.github.io/blog/posts/announcing_relm4/在第一个测试版发布大约一个月后，经过无数个小时的工作，作者高兴地宣布Relm4的第一个稳定版本正式发布！关于Relm4：Relm4是一个受Elm启发并基于gtk4-rs的惯用GUI库。它是一个从头开始构建的relm的新版本，并且兼容gtk4和libadwaita。Relm4的主要目标是生产效率、灵活性、简单性和可维护性。功能特性\n支持libadwaita;\n配套书籍GUI development with Relm4 已完结;\n新增支持非阻塞IO的消息句柄;\n更多的可复用组件;\n许多其他的改进和修复;\n完整的ChangeLog可以参见：https://github.com/AaronErhardt/relm4/blob/main/CHANGES.md更多信息：\n项目地址：https://github.com/AaronErhardt/relm4\n项目文档：https://aaronerhardt.github.io/docs/relm4/relm4/\n参考书籍：GUI development with Relm4\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/AaronErhardt/relm4/blob/main/CHANGES.md" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-07 18:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Relm4 v0.1 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Build a secure access tunnel to a service in a remote private networkhttps://github.com/ockam-network/ockam/tree/develop/documentation/use-cases/secure-remote-access-tunnels#readmeOckam是一个支持端到端加密、双向认证、网络安全的Rust和Elixir语言通信库。在本篇博文中，作者详细的介绍了如何使用Ockam在Rust中通过约20行代码来构建一个可以安全访问远程私有网络中设备的通道。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-07 18:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Ockam示例: 构建一个可以安全访问远程私有网络的通道" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "odd-cat" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Introducing Skiff, a gradually typed functional language written in Rusthttps://www.reddit.com/r/ProgrammingLanguages/comments/pjcewi/introducing_skiff_a_gradually_typed_functional/Skiff，是一门用Rust编写的逐渐类型化的函数式编程语言。所谓逐渐类型化是指作者计划下一步通过添加类型化关键字来区分完全类型函数和部分类型函数。Skiff受Elm/Pyret/Python语言启发，并受Rust/Javascript/Typescript/Haskell/OCaml/Lua等语言影响，当前语言功能还在持续完善中，作者提供了一个由wasm!驱动的网页编辑器可供读者学习使用，更多信息请访问项目主页的Readme。https://skiff.paulbiberstein.me/更多信息：\n项目地址：https://github.com/P-bibs/skiff/\n网页编辑器：https://skiff.paulbiberstein.me/\nRust.cc 论坛: 支持 rsshttps://rustcc.cn/微信公众号：Rust 语言中文社区https://rustcc.cn/article?id=ed7c9379-d681-47cb-9532-0db97d883f62" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-07 18:05" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Skiff: 一门用Rust编写的逐渐类型化的函数式编程语言" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "众所周知，Rust代码编译起来很慢。但我有一种强烈的直觉，大多数Rust代码的编译速度比它本可以的要慢得多。例如, Rust 的 rust-analyzer CI 在 GitHub 上操作需要8分钟。这是一个相当大和复杂的项目，有20万行自己的代码和100万行依赖。跟随作者, 让我们进一步了解如何使编译时间保持在合理的范围内!原文链接https://matklad.github.io/2021/09/04/fast-rust-builds.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-06 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "加快 Rust 的编译" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者对于 async的语法方案提出了完整的自己的解决方案, 非常有趣.原文链接https://ibraheem.ca/writings/an-alternative-async-fn-syntax/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-06 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "async 的另外一个语法方案" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这是作者的第二篇关于 Rust插件的文章!在这里，作者将尝试编写一些 PDK (Plugin Development Kit, 插件开发工具包) 可能是什么样子的简单代码，并对在编写过程中出现的问题做一些研究。原文链接https://nullderef.com/blog/plugin-start/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-06 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 插件" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Sentinel 是一个面向分布式服务架构的高可用流量控制组件. 现在 Rust 版本已加入github 地址https://github.com/sentinel-group/sentinel-rust" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-06 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "sentinel-rust: Rust 版本的 sentinel" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "<<Programming Rust>> 第二版的在线电子书现已上架.原文链接https://www.lunaticai.com/2021/09/programming-rust-2nd-edition-pdf-github.html--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-06 20:00" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "<<Programming Rust>> 第二版电子书已上架" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Allen Wyma 与 cURL 的原作者 Daniel 谈论在 cURL 中使用 Rust。\ncURL 是一个命令行工具和库，用于通过 URL 传输数据。\ncURL 及其数据传输核心 libcurl 都是用 C 编写的，众所周知，这不是内存安全的。\n虽然几乎不可能将其重写为另一种语言，但提供一个用 Rust 编写的第三方库可能会更进一步。\n文章链接，https://rustacean-station.org/episode/035-daniel-stenberg/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://rustacean-station.org/episode/035-daniel-stenberg/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-04 20:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "cURL 中的 Rust" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "\n\n轻量\n\n零依赖\n支持no_std，WASM\n最紧凑的非编译存储格式\n\n\n\n稳定...\n\n轻量\n零依赖\n支持no_std，WASM\n最紧凑的非编译存储格式\n稳定...Gitlab 链接，https://github.com/only-cliches/NoProto" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/only-cliches/NoProto" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-04 20:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "NoProto：灵活、快速和紧凑的序列化和rpc" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "binarytom" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "用于玩颜色渐变的命令行工具Features:\n许多预设渐变。\n自定义渐变。\n从 SVG 和 GIMP 渐变 (ggr) 文件中读取渐变\n...\nGitlab 链接，https://github.com/mazznoer/gradient-rshttps://rustcc.cn/blog_with_author?author_id=dd4a77ca-2042-459e-901a-b8f9bfeb7db0" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/mazznoer/gradient-rs" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-04 20:51" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "gradient介绍" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Pilka是一种用于创建着色器（shader）演示的跨平台实时编码工具，类似于 Bonzomatic 或 KodeLife 。支持热重载，能够在后台检查和更新资源。GitHub: https://github.com/pudnax/pilka" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/pudnax/pilka" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-02 23:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pilka - 用 Rust 写成跨平台实时编码工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "ritecache 是在流行的 sccache/lru_disk_cache 基础上派生出的内存/磁盘缓存。默认提供 LruCache 和 LruDiskCache，也支持开发者通过实现 Cache 特质来支持基于其他策略的内存/磁盘缓存。同时，得益于 ritelinked 的支持，性能优于基于 linked-hash-map 的版本。GitHub: https://github.com/ritelabs/ritecacheCrates.io: https://crates.io/crates/ritecache" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/ritecache" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-02 23:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "ritecahce - 简单易用的 memory/disk cache" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "hebi 是一个高度可定制的贪吃蛇游戏复刻，使用 Rust 写就，由 Bevy 引擎驱动，命名源于日语中的“蛇”。GitHub: https://github.com/ElnuDev/hebi" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/ElnuDev/hebi" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-02 23:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "hebi - 由 Bevy 引擎驱动的贪吃蛇游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "pixels 是用于简单软件侧光栅化的板条箱。它可以提供一个像素缓冲区，用于插入颜色（在 CPU 端完成）。缓冲区作为纹理上载到GPU，所有缩放和剪裁都由默认着色器处理。对于其他控件，可以添加自己的自定义着色器以进行预处理和后处理。GitHub: https://github.com/parasyte/pixelsCrates.io: https://crates.io/crates/pixels" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.io/crates/pixels" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-02 23:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "pixels 0.6.0 发布" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "PsiACE" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Datafuse 发布了第 5 期周报，感兴趣的朋友们可以关注 Datafuse 的最新进展。Datafuse 是一个开源、易用、便于扩展的云数仓，查询速度极快，并结合云的弹性、简单性和低成本，帮助用户轻松享受下一代数据云。Datafuse: https://github.com/datafuselabs/datafuseThis Week in Datafuse 5: https://datafuselabs.github.io/weekly/2021-09-01-datafuse-weekly/https://github.com/PsiACE" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://datafuselabs.github.io/weekly/2021-09-01-datafuse-weekly/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-02 23:31" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "This Week in Datafuse 5" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作为深度学习研究员，处于深度学习领域的最前沿，自然用 py 和现成的框架是不够的。而 Rust 是一个非常好的替代 c++ 的底层算法实现选择。https://www.reddit.com/r/rust/comments/pft9n9/i_wanted_to_share_my_experience_of_rust_as_a_deep/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-01 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个深度学习研究员学习Rust的经验" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这里有非常详实的讨论：https://www.reddit.com/r/rust/comments/2mwpie/what_are_the_advantages_of_rust_over_modern_c/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-01 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Rust 比现代 C++ 的优势在哪些地方" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "性能比 Chocolatey 高 3~10倍。https://github.com/novus-package-manager/novus" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-01 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Novus - 一个rust实现的 Windows 包管理器" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "作者记录了自己学习 Rust 的心路历程，很详细，文笔不错。https://thespblog.net/a-gophers-foray-into-rust/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-01 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "一个 Gopher 的 Rust 冒险" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "代码一行行讲解的一个 tutorial。值得学习。https://www.fpcomplete.com/blog/axum-hyper-tonic-tower-part1/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-01 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "组合使用 Axum, Hyper, Tonic, Tower 开发 Web/gRPC 混合接口的 app：第一部分" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "列举了几个简单的操作就能达到很好的效果，非常实用。https://deterministic.space/high-performance-rust.html" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-01 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "关于高性能 Rust 代码的几个简单的调优方法" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "Mike Tang" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "tac 是一个命令行工具，用于翻转一个文件的内容。被收录于 GNU core-utils。而 Rust 结合 SIMD，达到了最快的速度。https://neosmart.net/blog/2021/using-simd-acceleration-in-rust-to-create-the-worlds-fastest-tac/--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-09-01 22:32" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "使用 Rust + SIMD 开发世界上最快的 tac" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "unwrap 方法可能会让新手感到困惑。一些建议:\n可以使用 Expect (&str) 而不是 unwrap() 为 panic 提供上下文。\n使用 unwrap 和 expect 类似于断言。如果他们 panic，那只有在不可挽回的情况下才会发生。\n避免在库代码中使用。\n原文链接https://owengage.com/writing/2021-08-30-how-to-think-of-unwrap/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-30 20:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "如何来看待 unwrap" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "这个库提供了一个安全的、零开销的接口，用于通过访问另一个单例令牌来保护对共享数据的访问。它是 GhostCell的扩展，除了品牌令牌外，它还允许更多普通的单例，使数据成为“静态的”这个库本身也提供了两个单例实现:\n通过with_token将限定范围的标记令牌作为 GhostCell\n通过new_singleton简单地创建一次单例结构\ncrate 地址https://crates.io/crates/singleton-cell" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-30 20:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "singleton-cell: 一个更强大的 ghost cell 扩展" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "通过本文学习如何使用 Rust 调用 C 方法以及如何在 C 中调用 Rust 方法.原文链接https://piware.de/post/2021-08-27-rust-and-c/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-30 20:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Learning Rust: Interfacing with C" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "gensmusic" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "运行在任何事务性 键值存储上的 强类型 文档数据库。目前支持的 backends 有:\nFoundationDB\n单机部署的 SQLite。\n一个简单的内存键值存储。\ngithub 地址https://github.com/losfair/RefineDB--" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-30 20:46" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "RefineDB: Rust编写的强类型文档数据库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "内容整理自 robyoung (Rob Young) 的文章：First steps with Embedded Rust: Selecting a boardhttps://github.com/robyoung有这么多令人眼花缭乱的微控制器和项目，对于嵌入式经验很少的人来说应该从哪里开始？我们在开发板中想要什么？\n良好的架构支持\n良好的芯片支持\n活跃的社区\n内置调试器\n我们需要什么架构？拥有最完整库、最详尽指南和最大社区的架构是 ARM Cortex-M。 ARM Cortex-M 是面向微控制器应用的低功耗、低成本处理器。 查看 crates.io 上的下载量虽说不是一个完美的指标，但可以让我们了解规模上的差异。在过去的 90 天内，cortex-m 的下载量超过 250k。 RISC-V、AVR 或 Xtensa 最多有 3k 次下载，cortex-a 有大约 18k 次下载。ARM Cortex-M 独树一帜。\nAVR：AVR 是用于嵌入式系统的 8 位微控制器系列。在 Rust 生态系统中，它们并没有得到很好的支持。直到最近，还需要使用 rustc 的一个分支来构建 AVR。 现在有几个不同的选择，awesome-avr-rust 是一个很好的起点。\nARM Cortex-A：更强大的多核 ARM 处理器，专为运行更大的东西而设计。 通常会在它们上运行完整的操作系统。  例如这是大多数智能手机和掌上游戏机中使用的架构。查看 cortex-a - crates.io: Rust Package Registry 了解更多。\nRISC-V：似乎是机器架构的新热点，它是一种免费且开放的指令集架构 (ISA)。  它也从一开始就被设计成模块化的，这意味着芯片设计人员可以创建各种各样的专用芯片，虽然目前开发板的范围很小。有一个活跃的 Rust RISC-V 社区，SiFive 或 www.riscv.org 都是不错的起点，Rust 方面，可以查看 riscv crate。\nXtensa：最受欢迎的主板组是来自 Espressif 的 ESP32 系列芯片。它们是小型、廉价、支持 WiFi 的电路板。  需要注意的是，并非所有 ESP32 开发板都使用 Xtensa 芯片，新的 ESP32-C3 是基于 RISC-V 的。在 Xtensa 芯片上使用 Rust 的最大障碍可能是 llvm 不支持它，因此需要构建 Rust 的 fork：esp-rs/rust。\n我们需要什么芯片？因此，我们将使用 ARM Cortex-M。  这缩小了搜索范围，但仍有很多选择。如果我们查看 cortex-m crate 的依赖项，我们会看到有两组芯片比其他任何一组都使用得更多； STM32 系列芯片和 nRF5 系列，这是我们要重点搜索的地方。https://crates.io/crates/cortex-m/reverse_dependencies\nSTM32：STM32 系列芯片可能是应用最广泛的嵌入式 Rust ARM Cortex-M 芯片。两种最受欢迎的 STM32 板是 Blue Pill 和 Black Pill。主要的缺点是没有板载调试器。如果想要带有调试器的基于 STM32 的电路板，那么获得 STMicroelectronics 官方套件是一个不错的选择（STM32F3 或 STM32F4 是不错的选择）。Rust Embedded Discovery 书的原始版本是针对 STM32F3 板编写的，因此有非常高质量的初学者文档，可以从那里开始。\nnRF5：用于嵌入式 Rust 的第二个最广泛使用的 ARM Cortex-M 芯片系列是 Nordic Semiconductor 的 nRF5 系列。官方开发套件 (DK) 是很棒的入门板。 Ferrous Systems 的 Knurling-rs 会议使用 nRF52840 开发套件。Knurling 课程质量非常高，手把手指导，通过有趣好玩的项目教授嵌入 Rust，是使用 Rust 进行嵌入式开发的最佳切入点。另一个很棒的基于 nRF 的开发板是 BBC micro:bit。它配备了板载调试器和一系列有趣的板载外围设备，如板上的 LED 显示屏、按钮和传感器。BBC micro:bit 被设计为一个教育平台，因此硬件在他们的开发者社区中以非常适合初学者的方式进行记录，并且互联网上有大量项目创意。\nRP2040：RP2040 于 2020 年底发布，是 Raspberry Pi 基金会首次尝试设计自己的芯片。由于如此新，Rust 对它的支持仍在开发中。与 BBC micro:bit 一样，RP2040 旨在成为一个教育平台，因此硬件文档是一流的，并且有大" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-29 20:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Embedded Rust 第一步：选择一块板子" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "一个机器学习套件，使用方法如下：推理支持多种语言：Elixir, Go, JavaScript, Python, Ruby 和 Rust，以 Rust 为例：https://hex.pm/packages/tangram很好奇训练的时候居然没有要指定模型，发现其将模型共分为三类：回归、二分类和多分类，训练时会根据数据自动选择合适（使用评估方法）的模型，每种模型又有两种不同的训练方法：线性方法和树方法。自带的监控功能看起来还不错，比如下面这张可以展示特征对输出的贡献：项目理论上可以用在简单机器学习场景下，尤其是那些还没有支持机器学习的语言，不过推理并没有 Benchmark，生产中使用需要做好性能测试。GitHub：tangramdotdev/tangram: Tangram makes it easy for programmers to train, deploy, and monitor machine learning models.https://github.com/tangramdotdev/tangram文档：Tangramhttps://www.tangram.dev/docs/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-29 20:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Tangram：训练、部署和监控机器学习模型" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "在本地执行：可以根据自己的情况调整 Makefile 第一行 Bash 的配置。执行后如果有安装 QEMU 的话会自动加载：每个组件都建立在窗口管理器之上，而不是像大多数操作系统那样建立在终端之上。GitHub：carterisonline/lateral: A clean, custom-built modular kernel ready to boot on x86_64.https://github.com/carterisonline/lateral" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-29 20:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "lateral：一个在 x86_64 上启动的模块化内核" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "就是把 json 或 csv 显示成表格，看起来很不错：Mac 用户 brew 安装：GitHub：uzimaru0000/tv: CLI tool for displaying tablehttps://github.com/uzimaru0000/tv" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-29 20:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "tv：显示表格的 cli 工具" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "界面长这样：是很好的学习资料。在这里玩儿：Minesweeperhttps://karthiknedunchezhiyan.me/minesweeper/GitHub：KarthikNedunchezhiyan/minesweeper: Minesweeper game developed with Rust, WebAssembly (Wasm), and Canvashttps://github.com/karthikNedunchezhiyan/minesweeper" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-29 20:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "minesweeper：使用 Rust，WebAssembly 和 Canvas 的扫雷游戏" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "复制后翻译，使用 DeepL 的 API，不过目前只有 Local 版本好用：当然，也可以使用 Eudic（欧路词典）。GitHub：zu1k/copy-translator: Copy Translator, using DeepL apihttps://github.com/zu1k/copy-translator" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-29 20:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "copy-translator：划词翻译" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "长琴" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "项目受 p5.Vector 启发，使用方法如下：https://p5js.org/reference/#/p5.VectorGitHub：micouy/veccentric: Tiny 2D vector library. Inspired by p5.js's p5.Vector.https://github.com/micouy/veccentric" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-29 20:17" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "veccentric：小巧的 2-D 向量 Library" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "会议主题：开源操作系统夏令营最终报告会会议时间：2021/08/29 09:00-11:30 (GMT+08:00) 中国标准时间 - 北京点击链接入会，或添加至会议列表： https://meeting.tencent.com/dm/Mp7T1h5zeQOk?rs=25会议 ID：635 194 989下面是9位全程参与夏令营活动同学的报告顺序。每人报告时间最长15分钟。" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-28 23:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "开源操作系统夏令营最终报告会安排" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "crates.live 是来自 crates.io 的 Rust crates 的依赖可视化工具。 它显示了 Rust crates（包）的依赖树。功能包括：\n依赖解析， crates.live 引擎通过匹配依赖版本来完成完整的依赖解析。\n交互式图表，带有标记的板条箱的可缩放交互式图表。\n图像导出， 将图形导出为 PNG。\n开放 API：（即将推出）GraphQL API。\ncrates.live 使用了一堆技术框架，技术栈包括：\nRust， crates.live 后端和爬虫是用 Rust 和开源 Rust 库开发的。\nGraphQl， WASM 驱动的 GraphQL 服务器。\nReact/Bulma， 前端库。\nTerraform， 帮助启动和维护我们的基础设施。\nCloudflare， Cloudflare 工作人员运行 WASM 后端。\n如果在使用此应用程序时有任何疑问、建议或问题； 可以通过 contact@crates.live 联系。 crates.live 由 Abid Omar 开发，可通过 contact@omarabid.com 联系。链接：https://crates.live/" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://crates.live/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-28 23:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "crates.live：可视化 Rust crates 依赖项" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Obake 是一个用于声明和维护版本化数据结构的过程宏。 “obake”这个名字取自日语“お化け（おばけ）”，这是日本民间传说中一类会变形的超自然生物。在开发应用程序时，配置格式和内部数据结构通常会在版本之间演变。 然而，保持这些版本之间的向后兼容性需要声明和维护遗留格式的数据结构和用于在它们之间迁移的代码。 Obake 的目标是让这个过程变得轻松。Github链接：https://github.com/doctorn/obake" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/doctorn/obake" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-28 23:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "Obake，版本化数据结构" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "洋芋" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "iced，Rust 的跨平台 GUI 库，专注于简单性和类型安全。 灵感来自Elm。https://elm-lang.org/Github链接：https://github.com/hecrj/iced/示例：https://github.com/hecrj/iced/tree/master/exampleshttps://rustcc.cn/blog_with_author?author_id=207704d2-4f5e-4219-a631-6ab4ab4d8929" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "https://github.com/hecrj/iced/" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-28 23:42" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "iced，跨平台 GUI 库" }, "type": "text" }], "type": "title" } }, { "Author": { "rich_text": [{ "text": { "content": "EAHITechnology" }, "type": "text" }], "type": "rich_text" }, "Intro": { "rich_text": [{ "text": { "content": "Rudra 是一个静态分析器，用于检测 Rust 程序中常见的未定义行为。它能够分析单个 Rust 包以及 crates.io 上的所有包。Rudra 及其相关论文将在 Proceedings of the 28th ACM Symposium on Operating Systems Principles 2021 (SOSP '21) 上发表。\nhttps://github.com/sslab-gatech/Rudra#readme\nnom 是一个用 Rust 编写的解析器组合库。它的目标是提供工具来构建安全的解析器，而不会影响速度或内存消耗。为此，它广泛使用 Rust 的强类型和内存安全来生成快速且正确的解析器，并提供函数、宏和特征来抽象大部分容易出错的管道。目前7.0已经发布\nhttps://crates.io/crates/nom\negui 是一个易于使用的纯 Rust 图形用户界面。egui 可以在 Web 上、本机上以及您最喜欢的游戏引擎中运行。egui 旨在成为最容易使用的 Rust GUI 库，以及在 Rust 中制作 Web 应用程序的最简单方法，它可以在任何可以绘制纹理三角形的地方使用，这意味着您可以轻松地将其集成到您选择的游戏引擎中。\n演示文档：https://emilk.github.io/egui/\nhttps://github.com/emilk/egui\n" }, "type": "text" }], "type": "rich_text" }, "Link": { "rich_text": [{ "text": { "content": "" }, "type": "text" }], "type": "rich_text" }, "Time": { "rich_text": [{ "text": { "content": "2021-08-27 22:27" }, "type": "text" }], "type": "rich_text" }, "Title": { "title": [{ "text": { "content": "" }, "type": "text" }], "type": "title" } },]
