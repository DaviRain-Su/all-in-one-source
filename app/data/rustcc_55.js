export const propertiesForNewPages = [{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"\n中文\n英文\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-28 13:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」Rust 2018年度调查报告"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#ckb #ckbvm #riscvNervos CKB是一个公共授权区块链，是Nervos网络的共识层。CKB的VM是基于RISC-V指令集实现的。\nckb\nckb-vm\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-28 13:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"秘猿开源CKB和CKB-VM"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#RustBeltRust2018视频合集https://www.youtube.com/playlist?list=PLgC1L0fKd7UlpVTHVfLYVtudVx8CzbSxW"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-28 13:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Belt Rust 2018 大会 视频合集"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#cheatsheetCheats.rshttps://cheats.rs/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-28 13:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust语言CheatSheet"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#ratel_core #js #compiler #wasm基于Rust和Wasm实现ratel-corehttps://github.com/ratel-rust/ratel-core"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-28 13:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"高性能JavaScript到JavaScript编译器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tide #middleware在上篇文章里说到，Tide借鉴了actix-web中before/after风格的中间件。然而@tirr-c基于此又发现了更好的抽象方式。新的trait使用一个方便的RequestContext，封装了中间件可用的所有上下文信息。在这种方法中，每个中间件都可以完全控制剩余的请求处理管道。在此接口上构建before/after的中间件构造函数很简单。但使用这种around中间件作为核心接口有一些关键的优势：\n在before/after发生的步骤之间传递数据要更简单。\n之前的方法强制为每个请求分配FutureObj，但是现在的around风格中间件只需要在执行异步工作或管道其余部分需要的时候再分配新的FutureObj\n新的接口可以说更简单、更整洁。Tide也新增了带有自定义中间件的嵌套路由。现在使用nest方法可以将中间件应用于具有公共路由的子路由里。nest方法实现：另外还增加了一个使用计算值的示例：computed_valueshttps://github.com/rust-net-web/tide/blob/master/examples/computed_values.rs原文中列出了还待解决的一些问题列表，你也可以来参与。Read Morehttps://rust-lang-nursery.github.io/wg-net/2018/11/27/tide-middleware-evolution.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-28 13:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」演变中的Tide中间件"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Firecracker是一种开源虚拟化技术，专门用于创建和管理安全，多租户容器和基于功能的服务，提供无服务器操作模型。 Firecracker在轻量级虚拟机中运行工作负载，称为microVM，它将硬件虚拟化技术提供的安全性和隔离性与容器的速度和灵活性相结合。看上去应该是兼容docker生态链，倾向于Serverless。\nfirecracker\nRead More\nMore Read More\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-28 13:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"AWS 出品 :  Firecracker"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#blockchain本月，Bitfury®工程师Yury Yanovich，Ivan Prokhorov，Darya Korepanova和Sergey Vorobyov与Skolkovo科学技术研究所（Skoltech）的计算和数据密集型科学与工程中心一起在科学研究期刊Informatics上发表; 信息传输问题研究所数据挖掘和预测建模实验室; 罗蒙诺索夫莫斯科国立大学世界经济地理系; 和高等经济学院的工作是设计一个基于区块链的供应链，以防止印章伪造。\n论文\n代码原型\n每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-28 13:09"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」Bitfury公司的工程师为俄罗斯邮政服务设计区块链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust_2018Rust 2018已经进入了最终的倒计时，官方刚刚发布了一个最新测试版。新的测试版包含了一些最近新稳定的功能和一些Bug修复。还包含一些工具的改进：\nRustfmt 1.0\nRLS和Clpippy可以直接安装，不再是“preview”组件了。\n来帮助检测是否存在Bug。Read Morehttps://internals.rust-lang.org/t/announcing-rust-2018-beta-release/8901"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-27 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「通告」Rust 2018 新的Beta版发布！"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await本文介绍了async/await，并且介绍了如何在最新的生态系统中使用老的futures 0.1。Read Morehttps://jsdw.me/posts/rust-asyncawait-preview/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-27 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」在Nightly版下使用async/await"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#audio包含了演讲视频、代码和Slides。\n视频\nCode\nSlides\n也可以多关注下后续，会有详细的博文放出。Read Morehttps://synthesize.rs/nov-2018-talk/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-27 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「演讲」低延迟音频合成"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Read Morehttps://i.redd.it/y75oir0xun021.png"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-27 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"一个新的Rust壁纸"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#amethyst #game视频演讲中以一个开源的消除游戏everpuzzle为示例进行介绍。 [大约1小时]everpuzzle Codehttps://github.com/Skytrias/everpuzzleRead Morehttps://www.youtube.com/watch?v=P_9A7P0uNpY"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-27 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「视频」使用Rust和Amethyst引擎进行游戏开发"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#dojoRust Coding Dojo 旨在唤醒人们对Rust语言的兴趣，并提供了开启Rust之旅的工具。该仓库是2018年11月26日在Infi举行的Rust Coding Dojo活动的部分代码。代码很简单，对Rust感兴趣还迟迟没有下手的朋友可以来看看。coding-dojo-rust-2018https://github.com/infi-nl/coding-dojo-rust-2018"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-27 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「新手向」Rust编程道场(Rust coding dojo)代码"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#embedded作者尝试玩嵌入式，选择了以自定义一个ErgoDox键盘作为尝试。本教程介绍了相关的开发环境准备。Read Morehttps://josh.robsonchase.com/embedded-bootstrapping/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-27 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「嵌入式Rust」嵌入式开发环境"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#openpgp #rustfestromaRustFest Roma上的演讲https://media.ccc.de/v/rustfest-rome-6-sequoia关于Sequoia：Sequoia由三位前GnuPG开发商Neal H. Walfield，Justus Winter和Kai Michaelis开发。为了缓解许多常见的安全问题，Sequoia是用强类型语言Rust编写的，它提供了时间和空间内存安全性。 Rust还为将库嵌入其他语言提供了出色的支持。 Sequoia已经提供了C绑定，并且正在积极开发Python绑定。sequoiahttps://gitlab.com/sequoia-pgp/sequoia"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-27 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Sequoia: OpenPGP的一个Rust实现"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#android #jni国内社区小伙伴写的文章，介绍如何在Android中使用Rust。基于 jni-rshttp://github.com/jni-rs/jni-rsRead Morehttps://zhuanlan.zhihu.com/p/50123055每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-27 11:46"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"在Android开发中使用Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#learn #rust为你精心打造Rust必学第一课。知乎Live (已完结，可回看，9.9¥)https://www.zhihu.com/lives/1043463438202249216"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-26 10:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「付费」《如何系统地学习Rust》"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#wasm #sudoku作者想用一个数独谜题生成器来检测WebAssembly的性能，他写了一系列文章，本文是第三篇，用Rust的wasm-bindgen工具来创建数独生成器的wasm模块。Read Morehttps://medium.com/@rossharrison/generating-sudoku-boards-pt-3-rust-for-webassembly-85bd7294c34a"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-26 10:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「系列文章」数独谜题生成器 pt.3: 使用WebAssembly"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustfest #parity「\"We don’t do scrum, agile, standups, or meetings. We use @github, and @RiotChat for communication because privacy matters (no Slack), and we adhere to \"programmer anarchy,\" where people take the tasks they want to work on.”   —@MaciejHirsz」「我们不做Scrum、敏捷、站立会议。我们使用GitHub和RiotChat进行沟通，因为我们认为隐私很重要（没有用Slack）。我们坚持“程序员自管理”，各自完成的想做的任务即可。—— @MaciejHirsz」Read Morehttps://twitter.com/ParityTech/status/1066335406378180615"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-26 10:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「RustFest」Parity工程师在RustFest大会谈论工程师文化"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#sd #mmc #no_stdRead Morehttps://www.reddit.com/r/rust/comments/a07k6e/wip_a_no_std_rust_crate_for_reading_sdmmc_cards/embedded-sdmmc-rshttps://github.com/thejpster/embedded-sdmmc-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-26 10:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「嵌入式」WIP：用于读取SD/MMC卡的no_std crate"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#future #tokio #async_read #async_write\nAsyncRead to Future, 一次性读\nAsyncRead to Stream, 持续读\nAsyncWrite to Sink, 持续写\nAsyncWrite to Future, 一次性写\nRead Morehttps://jsdw.me/posts/rust-futures-tokio/Sample Codehttps://github.com/jsdw/jsdw.me/blob/master/content/posts/rust-futures-tokio/src/main.rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-26 10:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」如何将Tokio的AsyncRead和AsyncWrite转换为Futures, Sinks和Streams"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#gnome #hackfestRead Morehttp://antoyo.ml/rust-gnome-hackfest-thessaloniki"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-26 10:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「系列」Rust+GNOME Hackfest 记录 #4"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#i18n #tr刚发布，现在找人使用，并且想得到更多反馈。Read Morehttps://www.reddit.com/r/rust/comments/a09b0n/tr_a_crate_for_internationalizationof_rust_code/每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-26 10:44"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"tr: 国际化（i18n）库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是今天会知乎Live中谈到的一个问题，当我们用Rust编程的时候，该用什么编程范式？这个问题在我学习Rust之初产生过这个问题，但是，后来随着我对Rust的学习越来越深入之后，再回过神来才发现自己已经不关注用什么编程范式的问题了。趁着今天做Live，我又重新反思了这个问题，得到了一个结论。截图分享一下。一元查看https://t.zsxq.com/2jIy3Fq"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-25 18:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「付费阅读」Rust混合范式到底是什么？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#unit_test #xunit灵感来自于xUnit的一个Rust测试库。看上去更像是一种BDD测试框架。Read Morehttps://gitlab.com/Boiethios/fluid-rs/wikis/home"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-25 18:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"fluid: 让测试更容易"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#amethyst #game好消息。Amethyst是一款免费的开源游戏引擎。它是用Rust编写的，其核心是ECS架构。现在成立了基金会是为了组建一个官方的非盈利组织。这对于Amethyst的发展应该是非常有好处的了。当然，现在的状态只是提交了文件，还在等待最后的审批。Read Morehttps://www.amethyst.rs/blog/non-profit-announce/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-25 18:15"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「游戏」Amethyst基金会成立了"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#trending #twitter_bot关注@RustTrending，就可以在twitter上收到GitHub中Rust趋势榜里的项目推送。rust-trendinghttps://github.com/pbzweihander/rust-trending"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-23 10:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust实现的Twitter Bot"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#byteorder在byteorder的基础上包装了API，可以指定读写数据的字节序。byteorderedhttps://github.com/Enet4/byteordered"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-23 10:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"byteordered: 为读写数据指定字节序"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#redox #widget #orbtk #sdl2Orbital Widget Toolkit是一个多平台（G）UI工具包，用于使用编程语言Rust构建可扩展的用户界面。 基于 Entity Component System Pattern (ECS)上，提供函数响应式API。OrbTk的主要目标是高性能，易于使用和平台独立性。redox-os/orbtkhttps://gitlab.redox-os.org/redox-os/orbtkRedox里提供的一个轻量级零依赖的ECS库：dceshttps://gitlab.redox-os.org/redox-os/dces-rust"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-23 10:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"OrbTk：Widget工具包，兼容ReDox和SDL2"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#miniprogram群友@JiaYe 使用Rust和WASM实现了Gif图片制作的小程序。让小程序加载wasm模块，还需要做一些针对性修改，可以在该源码里看到。感兴趣的可以看看。miniprogram-gifmakerhttps://github.com/planet0104/miniprogram-gifmaker/blob/master/README.md"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-23 10:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust+WASM实现的小程序"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#amp #vim这个库最近在GitHub趋势榜上升很快，最近几天发布了0.5.2版本。使用Vim的核心的交互模型，但是对其做了简化。其内部结构（工具集）已经独立为scribe库，包含数据结构、语法高亮、工作空间管理等功能。\namp\nscribe\n每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-23 10:31"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"amp: 类Vim的终端文本编辑器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#mobile #iOS #Android #gfx作者是国内Rust社区的 @熊皮皮。 目录：\nRust 2018开发环境配置与开发效率工具集\nC++与Rust变量声明的比较\nC++与Rust引用外部符号的比较\nC++与Rust数据类型对应关系\nC++与Rust操作裸指针的比较\nRust日志输出实践总结\n点击链接还有很多内容，还在不断更新。对移动端Rust应用和图形渲染感兴趣的朋友可以看看。另外，他们还在招聘。Read Morehttps://juejin.im/post/5bea5c2af265da613a538fb5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust 移动端跨平台复杂图形渲染项目开发系列总结"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这哥们从2012年就开始看Rust了，和Rust经历了这么多年风风雨雨，风云变幻，今天依旧还爱着Rust。可以看看此文，你也像他这样深爱Rust吗？Read Morehttps://dpc.pw/still-in-love-with-rust"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"给Rust的一封「情书」"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"之前因为Rust 2018生成fail的文档都可以看了"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"发现docs.rs支持Rust 2018了"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#js_stateWith projects like Web Assembly arriving on the scene, writing code directly in JavaScript might soon seem quaint as developers embrace languages like Rust instead.Read Morehttps://2018.stateofjs.com/javascript-flavors/conclusion"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"2018 JS状态报告里提到了Rust"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#pest #xml作者在实现一个XML解析器，这篇文章记录了使用Pest来实现使用EBNF-esque形式的词法分析器。\nxml-grimoire\nRead More\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用Pest实现EBNF语法"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#exonum #actix_web本文是Exonum工程师记录了使用泛型编程将Iron迁移到Actix-Web框架的过程。由于平台自身的增长需求，需要从同步迁移到异步，Iron是同步框架，已经无法满足需求，所以选择了actix-web。他们不仅仅是迁移Web框架，更重要的是，重新设计新的API体系。本文较长，其中详细给出了如何利用泛型编程对API进行设计的思考，感兴趣的可以看看。Read Morehttps://medium.com/meetbitfury/generic-methods-in-rust-how-exonum-shifted-from-iron-to-actix-web-7a2752171388"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust中的泛型方法：Exonum如何从Iron迁移到Actix-Web"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust_clock纯Rust打造的DIY液晶闹钟，很酷。rusty-clockhttps://github.com/TeXitoi/rusty-clock"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「嵌入式」 Rust实现的闹钟"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#serde #postgresserde_postgreshttps://github.com/1aim/serde_postgres"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"serde_postgres: 方便反序列化Postgres的行数据"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#fp感兴趣的可以看看maroon-langhttps://github.com/adam-mcdaniel/maroon-lang"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust实现的纯函数式编程语言"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#AudioRead Morehttps://www.reddit.com/r/rust/comments/9z4z9o/adc18_introduction_to_rust_for_audio_programming/freeverb-rshttps://github.com/irh/freeverb-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「演讲」ADC'18大会:  Rust音频编程"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#version_control #gitpijul是基于Rust实现的类Git版本控制工具，用法介绍https://jneem.github.io/pijul/Read Morehttps://pijul.org/posts/2018-11-20-pijul-0.11/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"pijul 0.11发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#ndarray为ndarray实现了一些统计方法ndarray-statshttps://github.com/jturner314/ndarray-stats/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"ndarray-stats 发布 0.1"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#parser #lexerlogoshttps://github.com/maciejhirsz/logos"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"logos: Rust实现的一个词法分析器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#modulatorAndrea Pessino是曾开发 《战神：奥林匹斯之链》 和《 战神：斯巴达之魂》 的业界大厂 Ready at Dawn Studios 的CTO。这个包，就是他亲自上阵开发的。（Rust竟然有如此魅力，让一个CTO又找回了写代码的乐趣？）modulator_playhttps://github.com/apessino/modulator_playmodulatorhttps://crates.io/crates/modulator视频https://www.youtube.com/watch?feature=player_embedded&v=n-txrCMvdms"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"modulator_play: 一个用于测试2D渲染的Playground"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rustyline: Rust实现的Readline"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"rustylinehttps://github.com/kkawakam/rustyline每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-22 18:22"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"readline"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tikvTiKV Rust Client 的RFC马上完工，现在呼吁社区开发者为其做贡献。也是一次最佳练手的机会。当然，如果你对去PingCAP工作感兴趣的话，也许也是一次绝佳的机会。如何参与？开发环境配置：\n最简单的就是本机启动一个pd（Placement Driver ），然后启动一个 Tikv，都用默认的配置应该就能跑起来。\n部署TiKVhttps://github.com/tikv/tikv/blob/master/docs/op-guide/deploy-tikv-using-binary.mdRFC-7https://github.com/tikv/rfcs/pull/7然后提交PR或Issues就可以了。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-21 11:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"TiKV Rust Client呼吁社区开发者参与"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#swc发现作者是韩国人。\nswc\nswc_ecma_parser\nRead More\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-21 11:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"用Rust实现ecmascript 2019 parser和ast visitor"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#curl #httpie #rust_client一个Rust实现的类crul命令行http客户端，灵感来自于Python的HTTPierust_clienthttps://gitlab.com/rakenodiax/rust-client"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-21 11:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"命令行HTTP客户端"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#wasm #ide这是集成了https://webassembly.studio/吗?但是操作起来不如WebAssembly Studios润滑呢？wasm.fastlylabs.comhttps://wasm.fastlylabs.com/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":"https://webassembly.studio/"},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-21 11:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Fastlylabs继承了WebAssembly在线IDE"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#readhatRedHat对Rust1.29、Go1.10和Clang/LLVM6.0的可用性评估之后，现在已经将它们提升到了完全支持状态。在完全支持阶段，一些合格的重要的勘误表（RHSA）和一些选定的高优先级的错误修复表（RHBA）将会在可用时及时发布。由于这些包正在快速发展阶段，RedHat将对它们提供特别的更新支持。Rust每个季度会有更新，对于LLVM和Go，则是半年一次。Read Morehttps://developers.redhat.com/blog/2018/11/20/support-lifecycle-for-clang-llvm-go-and-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-21 11:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"RedHat发布对Rust、Go、Clang/LLVM6.0的支持计划"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#wasm #jit基于Cranelift 代码生成引擎实现的。wasmerhttps://github.com/WAFoundation/wasmer"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-21 11:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"wasmer: 高性能WASM JIT解释器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#http3 #quic也就是HTTP3，这两天火了呢。注意看项目Readme，有相关演讲。quinnhttps://github.com/djc/quinn每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-21 11:39"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"quinn : Rust实现的QUIC协议"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustworld今天看到Reddit有人在r/rust频道下贴出Rust游戏的广告宣传片《The Rust World》，想到社区里经常有来自于Rust游戏的人乱入，也有人好奇这个Rust游戏到底是个什么游戏？可以去看看这个宣传视频了。Read Morehttps://www.reddit.com/r/rust/comments/9ymioh/therustworld/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-20 11:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「乱入」Rust到底是个什么游戏？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-20 11:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」crates.io帐号审核措施"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"从2019-02-28开始，需要经过验证电子邮件地址的帐号才能往crates.io发布crate。所以，之前注册帐号的，2019-02-28之前，可能会收到警告，要求你去验证注册的email地址。如果不验证，2019-02-28之后就会收到发布错误了。 crates.io承诺将保护好你的隐私。Read Morehttps://users.rust-lang.org/t/a-verified-email-address-will-be-required-to-publish-to-crates-io-starting-on-2019-02-28/22425"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-20 11:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"crates.io"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#typed_html #jsx这个库上次（前几天）介绍还是100左右的star，现在已经上升到800多star了。也增加了Readme说明。typed-htmlhttps://github.com/bodil/typed-html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-20 11:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"TypedHtml: 带类型检查的JSX模板"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vulkanVulkan是由Khronos Group组织（知道OpenGL的话应该都听过这个组织）提供的一个新型的图形接口，它对现代图形显卡做了一个更好的抽象。跟现有的图形接口例如OpenGL和DirectX相比，Vulkan的性能更加强劲，驱动表现更加符合预期行为。Vulkan背后的设计思路跟 Direct3D 12 和 Metal 类似，但它具有跨平台的优势，可以让你同时在windows，linux和android上进行开发。 来源https://zhuanlan.zhihu.com/p/26938967vulkano教程http://vulkano.rs/guide/acquire-presentvulkano.rshttps://vulkano.rs/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-20 11:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Vulkano：Vulkan API的Rust安全绑定"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vim #fzf #deviconRead Morehttps://coreyja.com/blog/2018/11/17/vim-fzf-with-devicons.html每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-20 11:57"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「vim」使用FZF加速DevIcon文件预览"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#gnome #hackfestRead Morehttps://blog.guillaume-gomez.fr/articles/2018-11-19+GNOME%2BRust+Hackfest+in+Thessaloniki"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-19 12:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"塞萨洛尼基（希腊古城） GNOME+Rust Hackfest 活动记录"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"用C语言编写的PHP扩展，通过FFI调用Rust lib，用wasmi来执行wasm。 只是一个POC版本！\nwasmi\nphp-ext-wasm\nRead More\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-19 12:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"PHP中运行WASM"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"Features Flag用于启用或禁用features的配置。本文讲解了如何在项目里使用它。Read Morehttps://www.worthe-it.co.za/programming/2018/11/18/compile-time-feature-flags-in-rust.html这篇文章是作者参加一个2018 塔防游戏机器人大赛过程中总结出来的。也是用Rust实现，源码： entelect-challenge-tower-defencehttps://github.com/JWorthe/entelect-challenge-tower-defence游戏官网： challenge.entelect.co.za/ ，好像挺好玩。https://challenge.entelect.co.za/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-19 12:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「教程」Rust中的编译时Features Flag"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#mongodb #rustwither是为Mongodb编写的Rust驱动。可以参考宣传文章，有更多介绍。\nwither\nRead More\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-19 12:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Wither 0.6发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#mio #sonr #network相比于Tokio来说，更加轻量。但不晓得是不是玩票之作，至少可以满足学习的需求。sonrhttps://github.com/hagsteel/sonr"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-19 12:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"建立在mio之上的网络库：Sonr"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#postgresql作者提供了一个库pgxr，可以方便地使用该库提供的宏来编写postgresql的扩展函数pgxrhttps://github.com/clia/pgxrRead Morehttps://www.reddit.com/r/rust/comments/9y2yjq/write_postgresql_extension_functions_as_stored/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-19 12:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"使用Rust为PostgreSQL编写扩展函数"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#magic_square #linear_solvermagic_squarehttps://github.com/advancedresearch/linear_solver/blob/master/examples/magic_square.rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-19 12:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"利用线性求解器证明3x3的幻方"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#wait_free #thread_local_storage本文介绍了一种无等待线程本地存储。Read Morehttps://bzim.gitlab.io/blog/posts/wait-free-per-object-thread-local-storage.html每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-19 12:19"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"无等待线程本地存储"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#gutenberg #zolaRust实现的静态网站生成工具Gutenberg改成了Zola（之前的名字确实太长）。改名的原因是和Wrodpress的某个工具重名了。新名字Zola来源于 Emile Zola • 【埃米尔·左拉（法国作家）。Zola名言：「生活的道路一旦选定了，就要勇敢的走下去，绝不走回头路。」Read Morehttps://www.vincentprouillet.com/blog/releasing-zola-0-5-0/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-18 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Gutenberg改名为Zola并发布0.5版"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#futures #async_awati该视频长约4小时，详细介绍了Future和async/await，包括tokio等内容。Read Morehttps://www.youtube.com/watch?v=9_3krAQtD2k"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-18 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「油管」Rust中的Futures和async/await"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#cache #proc_macrolru-cache-macrohttps://github.com/tylerreisinger/lru-cache-macro"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-18 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"lru-cache-macro: 提供自动缓存函数调用结果的过程宏"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#3d #mesh #rust #immense灵感来自于structure SynthRead Morehttps://www.reddit.com/r/rust/comments/9y1efh/generate_3d_meshes_in_rust/[使用指南](Synthesizing Structures with immense)"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-18 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust实现可生成3D网格的库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#pest #nom #glsl该作者正在编写glsl方面的库，他之前使用了nom，现在又引入了pest。然后通过写这一系列文章，来比较这两者在实践应用中的区别和定位。Pest:Pest在编译时使用一个文件，其中包含定义要解析的输入格式的PEG语法。PEG, 表示解析表达式语法，是一种形式语言，使你能够用规则描述自己的语言。这些规则是用一些属于语言理论的基本块编写的。如果你曾经听说过Stephen Kleene及其着名的Kleene star，你就会对PEG感到熟悉。作者喜欢PEG的是，通过一组非常有限的结构，可以描述很多决定论语言。在GLSL450的情况下 - 这是glsl crate可以解析的语言 - 它是一种无上下文和确定性的语言。因此，整个语言可以根据（递归）PEG规则来定义。Pest不是解析器，它应该是一种词法分析器。AST解析还需要自己来弄。也有人推荐用pest-ast来处理AST。https://github.com/pest-parser/astNom：nom是一个解析器组合器。这意味着您可以通过组合小解析器来构建更大的解析器。关于nom的正确术语是它是一个无扫描器解析器：它不需要在解析之前生成令牌，并且更喜欢同时执行两者。 nom解析器通常使用像preceded！，delimited！，take_until！，tag！，value!和do_parse!等宏，允许匹配（lexing）切片的字节/字符，并使用你选择的类型将它们解析为实际值。然而，Pest依赖于PEG文件，表示要标记的语言的正式语法。该词法分析器阶段发生并且必须能够在返回之前对整个输入进行标记。我不确定我什么时候说这个（但我很有说服力就是这种情况）：Pest不支持流输入，因为它需要吃特殊规则EOI（End Of Input ）， 或者在返回之前吃规则错误（使用先前的规则成功或向上传播错误）。但是，nom可以用来吃掉字节流。Part IPart IIhttps://phaazon.net/blog/glsl-pest-part-1"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-18 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「系列文章」Pest vs Nom"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#cranelift #llvm #compiler_backend当前还属于实验阶段。cranelifthttps://github.com/bjorn3/rustc_codegen_cranelift"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-18 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Cranelift： 一个rustc的新编译后端"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"这是Bryan Cantrill（云计算平台joyent的CTO ）在最近某次Scala大会上的分享。选择一门编程语言，一个平台，一个操作系统，是一个重大且最重要的决定，具有持久的影响。因为你不仅仅是选择一个工具，更多的是选择它所代表的意义。比如，C的平台价值观：\nInteroperability「互操性」\nPerformance「性能」\nPortability「可移植性」\nSimplicity「简单性」\nC++的平台价值观：\nExpressiveness 「表达能力」\nPerformance 「性能」\nPortability 「可移植性」\nScala的平台价值观：\nComposability「可组合性」\nExpressiveness「表达能力」\nInteroperability「互操性」\nIntegrity「完整性」\nRobustness「健壮性」\n近十年来，系统软件编程语言所拥有的价值观和软件本身必须保持的价值观之间存在巨大差异。现在的系统软件已经能够提供相对安全和可靠的系统，但这一切是因为编程语言吗？不是！我们是否可以做的更好？来看看Rust吧！Rust的平台价值观：\nComposability 「可组合性」\nExpressiveness 「表达能力」\nExtensibility 「可扩展性」\nInteroperability 「互操性」\nIntegrity 「完整性」\nPerformance 「性能」\nRigor 「严谨性」\nRobustness 「健壮性」\nSafety 「安全性」\nSecurity 「安全保障」\n在此演讲中，作者还提供了三种使用Rust进行混合系统开发的方法：\nRust子系统。不要用Rust重写旧系统，Rust适合新的开发。这方面在FreeBSD里有一个示例应用。\nRust组件系统。传统的系统软件应用很广，而且都以组件方式发布，这里面有很多组件有问题，这正是Rust的应用之地。\nRust固件。操作系统之下，硬件之上的固件。可能更适合Rust。\nRust告诉我们：我们可以拥有更美好的东西。Slideshttps://www.slideshare.net/bcantrill/platform-values-rust-and-the-implications-for-system-software?from_action=save"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-18 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「演讲」平台价值观、Rust以及对系统软件的启示"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#shellRead Morehttps://www.joshmcguigan.com/blog/build-your-own-shell-rust/每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-18 11:51"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「教程」使用Rust构建你自己的Shell"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#miri #unsafe_ub_check #stack_borrowralfj比较高产，他负责Unsafe下内存模型相关的工作，目的是用miri来检测unsafe中的UB行为。该模型用于定义在unsafe内存模型中允许哪种别名。建立合理的别名规则，才能基于miri来检查unsafe下的UB行为。该模型的核心思想是： 对于一个内存位置，逐步建立可跟踪的引用，形成一个栈结构。比如有一个&mut i32，可以对其重新借用获得一个新引用。这个新引用是必须用于此位置的引用，建立在旧引用之上。当新引用过期的时候，旧引用会被激活，就好像是栈结构push和pop。在今天这篇文章中，ralfj写了实现上述模型的进展。在Safe Rust中，通常有借用检查来保护内存。但是在编写Unsafe代码的时候，借用检查就无法提供帮助了。所以，Rust核心团队就必须要定义一组规则，即使对于Unsafe代码来说也是非常有意义的。在本篇文章中，ralfj会再次解释这些规则，但是和上次的有所不同，因为ralfj在这三个月对栈式借用实现的过程中，对这些规则理解更深了\n前篇：栈式借用模型\n关于别名规则issues\nRead More\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-17 18:54"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」如何检测Unsafe代码中的UB"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustacean #podcast #rust2018Read Morehttps://www.reddit.com/r/rust/comments/9xmnze/new_rustacean_news_rust_129_and_130_procedural/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-17 18:54"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Podcast」关于Rust 1.29和1.30中过程宏等特性讨论"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#elm #wasm #willowElm生态系统有一个架构，叫做TEA，The Elm Architecture。然后该文作者将TEA引入了Rust和WASM体系里。并且通过此实验，了解Rust和WASM在web开发方面能走多远。结论是：他想在日程工作中都能用Rust编写webapp。代码实现： willowhttps://github.com/sindreij/willow其中还包含了两个demo。Read Morehttps://sindrejohansen.no/blog/willow/rust/elm/2018/11/16/willow-elm-in-rust.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-17 18:54"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"将Elm架构引入Rust和WebAssembly"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#pbrt #pbrtrs_pbrt是对《Physically Based Rendering,PBRT(光线跟踪：基于物理的渲染) 》这本书中代码的Rust实现。这篇文章是一个使用rs_pbrt的简单教程。Read Morehttps://www.rs-pbrt.org/blog/2018-11-16-getting-started/rs_pbrthttps://github.com/wahn/rs_pbrt每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-17 18:54"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"开始使用rs-pbrt"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#synthesis该文作者受程序合成是可能的这篇文章影响，实现了一个Rust版本。https://www.cs.cornell.edu/%7Easampson/blog/minisynth.html程序合成是指按特定的规则自动生成程序。有一个设想，就是在未来没有程序员这一行业，有的只是设计师。设计师设计好功能，交给电脑，自动合成程序。 本文就是一种尝试。现在有基于机器学习人工智能的程序合成引擎，但大家放心，还没到足以能让程序员失业的那一天。Read Morehttp://fitzgeraldnick.com/2018/11/15/program-synthesis-is-possible-in-rust.html相关论文https://people.csail.mit.edu/asolar/manual.pdf代码实现https://github.com/fitzgen/minisynth-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-16 13:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"探索用Rust实现程序合成的可能性"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#jdbi #dbi #java基于mysql_asyncmysql异步驱动库。https://github.com/blackbeam/mysql_asyncdbihttps://github.com/kardeiz/dbi"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-16 13:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「库」Java JDBI的SQL Object API的Rust接口"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#javascript #parser #espritesprithttps://github.com/dherman/esprit"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-16 13:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"又一个JavaScript解释器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#debian #librsvg在LWN社区发布的一篇新闻。Debian支持许多（CPU）架构，即使对于那些没有正式支持的架构，也有Debian Port试图填补空白。对于大多数应用程序来说，主要是为相关架构启动并运行GCC，然后构建Debian提供的所有不同软件包。但是对于需要使用Rust构建的LLVM应用程序或库构建的软件包，则变得更加复杂。最近librsvg就引起一场风波。Read Morehttps://lwn.net/SubscriberLink/771355/1c4ca5254f22dbdf/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-16 13:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「撕逼贴」Rust、Debian和librsvg"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#game #game_wg该文作者通过这篇文章阐述了当前游戏开发中存在的一些问题，并且建议Rust官方团队启动建立「游戏工作组」来进一步完善以Rust作为游戏开发首选语言的生态系统。当前比较知名的游戏开发商， Chucklefish, Embark Studios, Ready at Dawn，都宣布使用Rust作为游戏开发的主要语言。https://www.rust-lang.org/pdfs/Rust-Chucklefish-Whitepaper.pdf什么是游戏开发？游戏由复杂的系统组成。游戏对性能的要求很高，即使忽略渲染，还需要做物理、动画、各种游戏系统、AI、寻路等，这些事情都需要在一瞬间完成。这也是C++成为游戏引擎开发语言首选的原因。存在的问题？主要有两大类问题：目前市面上的引擎，由Ubisoft，DICE，Epic，Unity，Lumberyard等公司创建了各种重量级的引擎。大多数是C++编写的，并且都不太关心ABI的兼容性。所以，这就导致这些引擎和Rust的通信不太理想。并不是说，需要解决Rust和C++的绑定问题。重量级引擎也关心性能，玩家希望在AAA游戏世界中能做更多的事情。为了满足这种期望，很多优化的工作就被放到数据结构布局、SIMD、自定义内存分配器等等当中。这些优化其实在Rust中已经支持的相当好，当然也有一些还需要完善。所以，需要考虑，现有引擎如何与Rust系统共存的问题。像Chucklefish，Killhouse和其他很多公司，都没有使用现成的重量级引擎。很多时候，这些中小公司中的游戏引擎，实际上就是一个游戏。虽然Rust成熟度很高，但是当前用Rust开发游戏，还是面临很多阻碍。在这个领域，也有Rust游戏引擎，但是和Unity相比，入门门槛比较高。比如Amethist引擎，一个简单的Pong游戏开局就是这样的代码：'a和'b都是什么？你可能会哭。虽然生命周期参数有存在的必要，但是你说，写一个Pong游戏示例还要来这个生命周期参数干嘛？作者拿他近十年的游戏开发生涯打赌：即便你写更复杂的游戏，也不一定需要用到生命周期参数。当然，作者也承认Amethist引擎很不错，但是当做一些简单的游戏，可能使用一些更简单的抽象比较好。当然，在未来可能会有更多的引擎来满足开发者的各种问题。解决方案？作者建议成立一个游戏开发工作组来解决这些问题。有人建议把Amethist引擎作为游戏开发的首选引擎来建立生态系统，但是作者认为，需要多元化。并非所有的游戏都有相同的要求，并非所有游戏都需要引擎，因此开放很重要。结论：Rust官方核心团队ms答应了要在2019年启动游戏开发工作组。想用Rust制作游戏的开发者们拭目以待吧。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-16 13:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust与游戏开发"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#Heartbleed #WannaCry #security心脏滴血(heartbleed)、欲哭无泪(wannacry)、价值百万美刀的iPhone漏洞(FBI支付90万美刀给黑客，只为了破解一台iphone/ 安全机构悬赏100w刀找iOS漏洞)，它们之间有什么共同之处？该文作者是Mozilla的软件安全工程师Alex，曾经担任过美国数字服务的软件工程师。同时也是Python和Django软件基金会董事会成员。一个Bug影响iPhone、windows（wanncry）和Linux服务器（heartbleed），看似没什么关联，实际上，这些漏洞的产生，都是同一个原因：内存不安全。而当今互联网上，造成内存不安全的主要语言是C/C++。缓冲区溢出漏洞、类型混淆、使用释放内存、使用未初始化内存等问题，共同构成了当今互联网基础设施（Windows、Android、iOS、Chrome、Firefox等）中漏洞的温床。作者花费大约一年多时间来跟踪这些项目的安全，发现这些产品中几乎超过一半的漏洞都是内存不安全引起的。更令人不安的是，高危的漏洞（导致远程执行代码的漏洞）几乎总是因为内存不安全。比如被广泛使用的图片处理库ImageMagick和GraphicsMagic，作者就发现了400个内存不安全漏洞。当然，造成这些主要是因为历史原因。很多重要的互联网安全软件都是老产品。但是作者为了改善这种现状也提出了以下一些建议：\n在选择语言的时候，首要标准应该考虑「这种选择将如何影响软件的安全性？」\nRust、Swift等现代语言都是内存安全的，可供选择。但是选择Rust的公司比较多，Google、Dropbox、Facebook等都在用Rust。\n需要量化内存安全造成的损害程度。可以参考CVE数据库。\n需要投入资源研究如何更好地将大型软件项目迁移到内存安全的语言。\n将软件工程文化的重心向安全性转移。比如从大学教学、培训机构教学，应该让学生认识到安全的重要性。\n内存不安全是目前互联网最大的祸害。还需要投入工程研究，以便作出更好的工具来改善计算机安全性。\nRead Morehttps://motherboard.vice.com/en_us/article/a3mgxb/the-internet-has-a-huge-cc-problem-and-developers-dont-want-to-deal-with-it?utm_source=reddit.com每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-16 13:37"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「安全呼吁」互联网存在一个巨大的C/C++安全隐患，但是开发人员不愿意处理它们"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rand\nchangelog\nupdate guide\nrand book\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-15 14:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"rand库 0.6版发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#embedded #2018今年嵌入式工作组开始构建Rust生态系统茁壮成长需要的坚实基础。这篇文章回顾当前进展并分享了今年所取得的成就。嵌入式Rust稳定性：稳定性：2018年嵌入式路线规划的一个最基本功能是：我的crate在升级到最新工具链时不应该被破坏。嵌入式开发从一开始就紧密和nightly相连，在一定时间内大家经历了很多重大变化。幸运的是，随着Rust 1.30的发布，这些痛苦都结束了。 Rust 1.30标志着嵌入式Rust开发迎来的第一个稳定版本。你可以在不依赖unstable功能的情况下构建出完整可用的嵌入式程序。此外，还在编译器测试套件中提供了一些单元测试来检测嵌入式代码，因此，在Nightly之下也能检测到一些意外的break。一个平稳的起点：「我如何开始使用嵌入式Rust？」，这是长期存在于IRC的一个问题。但是想回答这个问题并不容易，因为维护长期依赖于unstable功能的文档是一场艰苦的战斗。所以，新手会经常看到过时的文档。但是现在，稳定的嵌入式Rust已经准备好了。官方整合了一个权威稳定的文档给大家：《嵌入式之书(Embedded Rust Book)》。在一些模板和工具的帮助下，尽量使得第一次使用嵌入式Rust的开发者感受到丝般顺滑的体验。https://docs.rust-embedded.org/book《嵌入式之书》不仅仅是一本入门指南，它也包含着如何使用Rust编写正确的嵌入式软件。目前官方正在积极往里面添加更多的模式和开发技巧。面向所有人群的学习资源《嵌入式之书》是面向有嵌入式开发经验的人，但官方也意识到，Rust是有很大潜力可以成为任何开发者尝试嵌入式开发的首选语言。所以，官方还在继续努力研究提供相关的资源，比如面向人群的 《探索之书(Discovery)》。https://docs.rust-embedded.org/discovery/另外，官方也知道嵌入式Rust目标受众对嵌入式系统领域的兴趣点和专业度都不太相同，所以官方推出了《嵌入式黑魔法(embedonomicon)》，并收集更多针对性的资源，比如各种awesome的第三方库列表。https://docs.rust-embedded.org/embedonomicon/当然，上面列出的资源，都可以在嵌入式文档站点找到。https://docs.rust-embedded.org/有组织的社区成就所有这一切都是通过很多志愿者、工作组成员和其他社区成员辛勤工作完成的。特别是工作组成员致力于维护生态系统所依赖的核心crate和文档。所有的这一切都是在Rust嵌入式工作组的庇护下进行的。WG团队嵌入式领域非常庞大： 在这个领域中存在多种架构体系。许多应用领域和嵌入式开发者使用不同的约束(constraint)集：实时约束(real-time constraints)、内存约束(memory constraints)、能量/功率约束(energy/power constraints)等。出于这个原因，官方嵌入式WG团队通过增加不同专业领域的成员，并在工作组内发展和创建相关领域的专业团队。这保证了核心库中API设计在决策时，以及将嵌入式社区的需求传达给其他Rust工作组时可以产生不同的观点。拥有专业的团队也意味着在组织开发crate时，可以分配给具有适合相关技术背景的人。即将迎来的Rust 2018在Rust 2018即将发布的最后期限内，嵌入式工作组的重点是「文档」。这也需要大家的帮助。一个重要的事项：文档使用了2018版本，所以建议大家使用Rust beta版来测试文档。超越2018Rust 2018只是嵌入式Rust开发的一个起点。当前，嵌入式Rust支持的最成熟的的目标架构是「ARM Cortex-M」，crates.io上面大多数crate都是针对此架构。但也已经为支持其他目标架构奠定了很好的基础。比如如裸机ARM Cortex-A、ARM Cortex-R、MSP430和RISCV。明年会继续在这些目标上努力。此外，嵌入式工作组还在收集「愿望清单」，如果你希望2019年嵌入式Rust支持一些你想要的功能，现在是时候提交了。https://github.com/rust-embedded/wg/issues/256Read Morehttps://rust-embedded.github.io/blog/2018-11-14-this-year-in-embedded-rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-15 14:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「嵌入式工作组」嵌入式Rust年度回顾"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#static_file #compress #static_server #http使用cargo doc的时候会产生很多小的html文件（大约10w个，每个10kb），这些文件其实并不常用，所以作者提供了这样一个工具，帮助你压缩这些文件，并且通过该工具提供的http server来在需要的时候查看这些文件。这样就可以省空间。而且也可以加速一些备份或杀毒软件扫描。static-filezhttps://github.com/killercup/static-filez这篇文章记录了关于该crate实现的一些细节。Read Morehttps://deterministic.space/serve-archived-static-files-over-http.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-15 14:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」static-filez: 可以帮助你压缩静态文件并允许通过http server访问它们"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#shipping_puzzle在这系列文章里，作者探索了一道算法题：航线谜题（shipping puzzle）第二篇是Rust实现方案。航线谜题：给定一组航段（leg）集合，每条航段分别对应于一周内的一天，包括起点和终点：如何将以上航段划分为单个飞机的航线，受以下条件限制：\n一条航段的目的地必须与下一条航段的起点相匹配\n飞机必须持续航行（比如，一条航线不能包括：星期一 西雅图 -> 波特兰，然后是星期三 波特兰 -> 塔科马，此航线飞机在周二是闲置的。）\n满足这些限制的简单方案是，将每条航段看作是一条单独的航线，但是需要多架飞机，但是一架飞机可以连续飞行的航段也可以看作是一条航线。现在问题是，如何找到最少的路线，也就是找到最少的飞机数。在此例中，我们最少需要两条航线。一种可能的解决方案是：让一架飞机飞行PDX、SEA、DEN、PDX、DEN、JFK航线，并且第二架飞机只在周二从PDX飞到SFO。这里有一个1w条航段的数据集。可以开干了。https://gist.github.com/lynaghk/0c75252b455e744ed3a8a0d09b493223\npart 1\npart 2\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-15 14:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「算法」探索航线谜题"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#object_poollifeguard是Rust实现的一个对象池管理库，用来创建可重用的值，避免不断分配新值造成的开销。lifeguardhttps://github.com/zslayton/lifeguard"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-15 14:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"lifeguard 0.6 发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#static_assertions该库可以实现编译时断言。static-assertions-rshttps://github.com/nvzqz/static-assertions-rs"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-15 14:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"static-assertions 0.3发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#bulletproofs #blockchain #zero_knowledge_proof预发布版本号称性能大幅提升：\n比libsecp实现快1.83倍（使用endomorphisms）;\n比libsecp实现快2.00倍（没有endomorphisms）;\n比Monero实施快4.63倍。\n并且还提供了干净、安全可扩展的API。Bulletproofs是由斯坦福大学应用加密学小组最近发表的一篇有关于保密交易的有效范围证明的研究论文，文中提出了一种可以大幅降低区块链存储数据大小（约为十倍）的方法。基于Bulletproofs 论文https://crypto.stanford.edu/bulletproofs/Bulletproofshttps://github.com/dalek-cryptography/bulletproofs/是之前这个库ristretto-bulletproofs迁移到了新的仓库里。https://github.com/chain/ristretto-bulletproofs/Read Morehttps://medium.com/interstellar/bulletproofs-pre-release-fcb1feb36d4b每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-15 14:06"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「区块链」零知识证明库Bulletproofs ：pre-release版本发布"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"从今天起开始尝试添加「付费阅读」的文章，你可以选择花一元查看，也可以选择不看，看个人兴趣。文章是通过知识星球(魅力Rust)分享出来的，暂时不要申请进入，以后有文章我也会以这种方式分享出来。准备陆续在里面创作一些Rust相关的内容。\n关于翻译外文版权的说明：翻译国外的内容，我会尽量取得原作者的同意，并且附上原文地址。联系不上的也没办法了。\n对于付费的说明： 1元购买的是我的劳动，不是内容。\n"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-14 12:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「付费阅读」 Rust实现用户态网络驱动"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"找到了修改颜色的PR，作者给出了修改的理由：The Rust color on GitHub doesn't look much like rust, and I don't see where it could have come from (not on the website or part of the logo). In fact, it looks rather pale and sickly, rather than vibrant and robust.#a62c00 is much nicer. It resembles the red paints that have traditionally been made with iron oxide.作者认为，新颜色是正宗氧化铁的颜色，应该改成这个。其实我比较喜欢新颜色，像「血液」的颜色，也可以赋予其象征意义：「热血」、「新鲜血液」肇事者PRhttps://github.com/github/linguist/pull/4319如果你不喜欢，可以去肇事者PR里面发表意见，发现楼层里面有人反应过于强烈，建议大家不要太激动。Reddit 讨论： Read Morehttps://www.reddit.com/r/rust/comments/9wsas2/github_changed_the_language_color_for_rust/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-14 12:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「讨论」你是否喜欢GitHub新换的Rust语言颜色？"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#typed_html  #wasm #virtualdomTypedHtml是一个带类型检查的HTML模板，现在支持了纯wasm实现的虚拟dom渲染HTMLtyped-htmlhttps://github.com/bodil/typed-html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-14 12:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「库」typed-html： Rust模板库"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #reddit这篇reddit帖子评论区罗列出了async/await相关的issues、pr等，可以关注async/await的进展Reddit讨论https://www.reddit.com/r/rust/comments/9wrtgs/asyncawait_status_and_tracking/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-14 12:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「讨论」如何跟踪async/await进展状态"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#stnford #pl #cs242 #wasm斯坦福CS242编程语言课程升级到V2版，增加了新的内容。除了Rust，还涵盖了WebAssembly。在官网中有详细的课程表和slides、笔记下载。Read Morehttp://cs242.stanford.edu/Reddithttps://www.reddit.com/r/rust/comments/9wlcis/rust_in_stanfords_pl_course_v2_webassembly/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-14 12:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「大学课程CS242」斯坦福的Rust课程: V2版"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#cpp #lifetime对CPP熟悉的朋友可以关注下，也许通过该视频可以对Rust的生命周期有更深入的理解。youtubehttps://www.youtube.com/watch?v=sjnp3P9x5jA"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-14 12:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「Cpp 2018」在Clang中实现C++ Core Guidelines生命周期安全"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#mundane #google #boringssl #cryptoMundane 基于BoringSSL的Rust加密库。BoringSSL 是由谷歌从 OpenSSL 中抽出来后独立发展的作品。之前新闻中介绍过该库。今天是相关开发者写博文详细介绍了Mundane的起源和实现。why mundane?Mundane存在的理由是提供一种难以滥用的API。经验表明，密码学中最常见的失败模式之一就是不正确的实现，并且，通常失败都发生在应用程序和加密库之间。鉴于此原因，Mundane采取的方法是为开发者提供尽可能少的自由度。做正确的事，很容易，但是想做错事，则会很困难，理想情况下完全不可能。（和Rust的理念相似，这也是他们使用Rust开发的理由）。Mundane也是Google Fuchsia操作系统的主要加密库。Mundane完全依赖BoringSSL，是因为信任BoringSSL。BoringSSL团队都是密码学专家。mundanehttps://github.com/google/mundaneRead Morehttps://joshlf.com/post/2018/11/06/introducing-mundane/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-14 12:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「博文」介绍Mundane"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#sublime #pest期待vscodepest-sublimehttps://github.com/dten/pest-sublime每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-14 12:05"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Sublime： Pest语法支持"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#cargo #no_stdcargo-nonohttps://github.com/hobofan/cargo-nono"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-13 11:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小工具」检测no_std兼容性"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#jsc #es5 #nodejschttps://github.com/eatonphil/jsc"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-13 11:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」jsc：Rust实现的js编译器"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rustrush看来战斗民族也挺喜欢Rust。最近国际上的其他Rust大会：\nRome at @RustFest Nov 23-28\nCologne at @RustCologne Dec 5\nrustrushhttps://www.papercall.io/rustrushRead Morehttps://www.reddit.com/r/rust/comments/9we3oe/rustrush_2018_the_rust_conference_in_moscow/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-13 11:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「RustRush 2018」莫斯科举办的国际Rust大会"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#mut #guard该库实现了相关的Guard trait和方法（MutGuard::new和MutGuard::wrap），允许对可变借用指定函数，在可变借用的值发生改变之后，执行该函数。为开发的时候提供方便。详情可看项目Readme文档示例。mutguardhttps://github.com/geal/mutguardReddit讨论https://www.reddit.com/r/rust/comments/9wcujb/mutguard_run_code_every_time_data_is_mutably/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-13 11:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「库」mutguard: 在可变变量被修改之后调用指定的函数"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#aws #lambdaRead Morehttps://medium.com/@bernardo.belchior1/running-rust-natively-in-aws-lambda-and-testing-it-locally-57080421426d"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-13 11:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「教程」如何使用Rust编写AWS Lambda函数"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#asteroids #amethyst #ecs #rust2018基于Rust 2018 版本asteroids-amethysthttps://github.com/udoprog/asteroids-amethyst"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-13 11:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「小游戏」 使用Amethyst引擎实现的经典游戏Asteroids"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#youtube #rust #microserviceyoutubehttps://www.youtube.com/watch?v=B4ccsfJ_IK8每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-13 11:47"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「油管视频」devopsdays Edinburgh 2018大会：Rust与微服务"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#zerocost #arc_swap作者在实现一个库arc-swap，允许存储[Arc]，并且可以原子性地交换它。类似于RwLock<Arc>，但要更快且永远不会阻塞。此库被应用于作者的另外一个信号处理的库中signal-hook。https://github.com/vorner/arc-swap作者在实现这些库的过程中，仔细查看了Rust编译器生成的汇编代码，发现编译器做了很多额外的工作来展开抽象，但最终那些多余的操作都被抛弃了，只剩下最关键的一两条汇编指令。Read Morehttps://vorner.github.io/2018/11/11/truly-zero-cost.html"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"零成本名符其实"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#kentik #hooray美国的网络大数据分析公司Kentik使用Rust优化了网络分析平台的性能。该公司软件工程师声称：Rust是Kentik每秒摄取来自互联网百万分之一的流量（十亿比特(Gigabits)/千万亿(Petabit/s)）的重要部分，并且每天存储100TB的网络流数据。我们平台的性能和可靠性依赖于Rust编写的软件，我们受益于crates.io上可用的强大的开源库生态系统。在网络数据解析方面，使用nom，实现了高性能的零Copy解析器，对DHCP、DNS和HTTP等数据进行了高性能的解码。在数据存储方面，使用Rust编写了新的后端磁盘存储格式，可提供更高的性能和存储密度。在查询层也使用Rust编写的HyperLogLog扩展。Rust的性能和低内存使用是这里的一个关键。这些组件和C-API一起分发，并链接到了分布式存储引擎的各个部分。Kentik大多数后端都是用Go来编写，但是Go写的共享库很大，包含了完整运行时和GC等。而且Go在运行时初始化会产生很多线程，在链接到静态二进制文件还会导致运行时的段错误。所以他们也为此增加了很多补丁，但这并不是对Go的攻击，反而，他们对Go还算满意。相比于Go，Rust更容易动态和静态链接，因为没有运行时和GC，也没有从C调用Rust函数的开销。所以，你如果对Rust感兴趣，赶紧试试吧。Read Morehttps://www.kentik.com/blog/under-the-hood-how-rust-helps-keep-kentik's-performance-on-high/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust如何帮助Kentik提升性能"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #lifetime #borrow #mutable本文罗列了Rust中可变系统和借用检查不允许开发者做的事情，并讨论了当前行为的理由，以及可能的解决方法。文章较长，还需要耐心阅读。我有时间会翻译，也招募志愿者来翻译此文，可以一起协作。Read Morehttps://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「长文」那些Rust不允许你干的事"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#vm #register_based #jazz大多数语言vm都是栈式VM，之前介绍的一些VM实现也都是栈式。今天第一次见寄存器式VM的Rust实现。Android虚拟机Dalvik就是寄存器式VM，可以参考Dalvik的相关资料来了解寄存器式VM的工作机制。感兴趣的可以关注下。Jazzhttps://github.com/playXE/Jazz"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「项目」Rust实现的寄存器式虚拟机"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#tail #tztail #timezonetztailhttps://github.com/thecasualcoder/tztail"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「工具」 按时区查看日志的工具"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#async #await #rust官方核心成员withoutboat的新博文。截止目前，await语法有一个未解决的问题是await的最终语法。当前的实现是await!宏。 无船同志在这篇文章里建议在不久的将来引入await关键字。目前使用await!宏是因为await和?操作之间有一个优先级的问题。考虑下面代码：http::get函数的返回类型基本等价于impl Future<Output = io::Result<Response>>，也就是说，该函数会返回一个成功或失败的Future。这意味着你想要的行为是这样的：\n首先，await那个Future，计算其输出io::Result<Response>。\n其次，使用?来对result解包，如果没有成功则提前返回错误。\n但事实上，当你看到这段代码的时候，你的直觉是?操作比await优先，因为它离http::get函数更近。这个例子很常见，在I/O操作中经常经常可能需要返回错误。这里就存在着优先顺序的冲突。优先问题有以下几种潜在的解决方案：\nawait!宏是一种既定方案。\n默认await优先。用户可以使用括号来改变优先级，比如await (function()?)。但是这种默认的优先级语法会让开发者违反直觉。\n默认?优先，倒是符合直觉。但是用户需要为await返回错误则需要写成(await function())?。但是用户在异步开发的时候可能会经常写这种带括号的代码。\n引入某种后缀语法，比如await? function()，但这个很怪。\n总是使用分隔符号。比如await {}，类似于 unsafe {}。\n无船同志认为上面最靠谱的，还是最后一种方案，使用分隔符。这样也有利用兼容之前的宏写法。他也建议稳定这种await语法。并且文章中也透露，将在2019年3月初的1.33版本稳定future-rs 0.3。Read Morehttps://boats.gitlab.io/blog/post/await-syntax/"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"「官方」await语法方面的进展"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #flow本文探讨了Rust对实现方法调用链的支持。观点：Rust强烈建议使用方法链来简明地表达意图和程序流，提供了能够通过使用方法调用而不是分支和循环结构来产生控制流效果的类型和方法，这些可以用来使代码更易于阅读和修改。Read Morehttps://myrrlyn.net/blog/misc/rust-flow"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"Rust Flow: 数据流与Rust中方法调用链"},"type":"text"}],"type":"title"}},{"Author":{"rich_text":[{"text":{"content":"ChaosBot"},"type":"text"}],"type":"rich_text"},"Intro":{"rich_text":[{"text":{"content":"#rust #type_size在编译时使用-Zprint-type-sizes可以得到比std::mem::size_of方法更加详细的信息。命令：输出：但只能在Rust Nightly版本下使用。每日新闻订阅地址：\nTelgram Channel\n阿里云语雀订阅\nStemmit\nRust.cc论坛\nGitHub\n欢迎通过GitHub issues投稿。"},"type":"text"}],"type":"rich_text"},"Link":{"rich_text":[{"text":{"content":""},"type":"text"}],"type":"rich_text"},"Time":{"rich_text":[{"text":{"content":"2018-11-12 13:40"},"type":"text"}],"type":"rich_text"},"Title":{"title":[{"text":{"content":"如何使用-Zprint-type-sizes获取Rust类型大小"},"type":"text"}],"type":"title"}},]
